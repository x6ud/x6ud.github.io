var FM=Object.defineProperty;var QN=(n,e,t)=>e in n?FM(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var u=(n,e)=>FM(n,"name",{value:e,configurable:!0});var T=(n,e,t)=>(QN(n,typeof e!="symbol"?e+"":e,t),t);const JN=u(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerpolicy&&(r.referrerPolicy=s.referrerpolicy),s.crossorigin==="use-credentials"?r.credentials="include":s.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}u(t,"getFetchOpts");function i(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}u(i,"processPreload")},"polyfill");JN();function u_(n,e){const t=Object.create(null),i=n.split(",");for(let s=0;s<i.length;s++)t[i[s]]=!0;return e?s=>!!t[s.toLowerCase()]:s=>!!t[s]}u(u_,"makeMap");function ci(n){if(ct(n)){const e={};for(let t=0;t<n.length;t++){const i=n[t],s=Xn(i)?ik(i):ci(i);if(s)for(const r in s)e[r]=s[r]}return e}else{if(Xn(n))return n;if(_n(n))return n}}u(ci,"normalizeStyle");const ek=/;(?![^(]*\))/g,tk=/:([^]+)/,nk=/\/\*.*?\*\//gs;function ik(n){const e={};return n.replace(nk,"").split(ek).forEach(t=>{if(t){const i=t.split(tk);i.length>1&&(e[i[0].trim()]=i[1].trim())}}),e}u(ik,"parseStringStyle");function Mn(n){let e="";if(Xn(n))e=n;else if(ct(n))for(let t=0;t<n.length;t++){const i=Mn(n[t]);i&&(e+=i+" ")}else if(_n(n))for(const t in n)n[t]&&(e+=t+" ");return e.trim()}u(Mn,"normalizeClass");const sk="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",rk=u_(sk);function NP(n){return!!n||n===""}u(NP,"includeBooleanAttr");const On=u(n=>Xn(n)?n:n==null?"":ct(n)||_n(n)&&(n.toString===UP||!pt(n.toString))?JSON.stringify(n,kP,2):String(n),"toDisplayString"),kP=u((n,e)=>e&&e.__v_isRef?kP(n,e.value):Uu(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[i,s])=>(t[`${i} =>`]=s,t),{})}:zP(e)?{[`Set(${e.size})`]:[...e.values()]}:_n(e)&&!ct(e)&&!$P(e)?String(e):e,"replacer"),pn={},Bu=[],_r=u(()=>{},"NOOP"),ok=u(()=>!1,"NO"),ak=/^on[^a-z]/,u1=u(n=>ak.test(n),"isOn"),h_=u(n=>n.startsWith("onUpdate:"),"isModelListener"),ss=Object.assign,f_=u((n,e)=>{const t=n.indexOf(e);t>-1&&n.splice(t,1)},"remove"),lk=Object.prototype.hasOwnProperty,Nt=u((n,e)=>lk.call(n,e),"hasOwn"),ct=Array.isArray,Uu=u(n=>h1(n)==="[object Map]","isMap"),zP=u(n=>h1(n)==="[object Set]","isSet"),pt=u(n=>typeof n=="function","isFunction"),Xn=u(n=>typeof n=="string","isString"),d_=u(n=>typeof n=="symbol","isSymbol"),_n=u(n=>n!==null&&typeof n=="object","isObject"),BP=u(n=>_n(n)&&pt(n.then)&&pt(n.catch),"isPromise"),UP=Object.prototype.toString,h1=u(n=>UP.call(n),"toTypeString"),ck=u(n=>h1(n).slice(8,-1),"toRawType"),$P=u(n=>h1(n)==="[object Object]","isPlainObject"),p_=u(n=>Xn(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,"isIntegerKey"),g0=u_(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),f1=u(n=>{const e=Object.create(null);return t=>e[t]||(e[t]=n(t))},"cacheStringFunction"),uk=/-(\w)/g,Jr=f1(n=>n.replace(uk,(e,t)=>t?t.toUpperCase():"")),hk=/\B([A-Z])/g,Ac=f1(n=>n.replace(hk,"-$1").toLowerCase()),d1=f1(n=>n.charAt(0).toUpperCase()+n.slice(1)),Ev=f1(n=>n?`on${d1(n)}`:""),Xd=u((n,e)=>!Object.is(n,e),"hasChanged"),v0=u((n,e)=>{for(let t=0;t<n.length;t++)n[t](e)},"invokeArrayFns"),O0=u((n,e,t)=>{Object.defineProperty(n,e,{configurable:!0,enumerable:!1,value:t})},"def"),F0=u(n=>{const e=parseFloat(n);return isNaN(e)?n:e},"toNumber");let NM;const fk=u(()=>NM||(NM=typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof global!="undefined"?global:{}),"getGlobalThis");let Ur;class VP{constructor(e=!1){this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ur,!e&&Ur&&(this.index=(Ur.scopes||(Ur.scopes=[])).push(this)-1)}run(e){if(this.active){const t=Ur;try{return Ur=this,e()}finally{Ur=t}}}on(){Ur=this}off(){Ur=this.parent}stop(e){if(this.active){let t,i;for(t=0,i=this.effects.length;t<i;t++)this.effects[t].stop();for(t=0,i=this.cleanups.length;t<i;t++)this.cleanups[t]();if(this.scopes)for(t=0,i=this.scopes.length;t<i;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){const s=this.parent.scopes.pop();s&&s!==this&&(this.parent.scopes[this.index]=s,s.index=this.index)}this.parent=void 0,this.active=!1}}}u(VP,"EffectScope");function dk(n,e=Ur){e&&e.active&&e.effects.push(n)}u(dk,"recordEffectScope");const m_=u(n=>{const e=new Set(n);return e.w=0,e.n=0,e},"createDep"),HP=u(n=>(n.w&Ya)>0,"wasTracked"),GP=u(n=>(n.n&Ya)>0,"newTracked"),pk=u(({deps:n})=>{if(n.length)for(let e=0;e<n.length;e++)n[e].w|=Ya},"initDepMarkers"),mk=u(n=>{const{deps:e}=n;if(e.length){let t=0;for(let i=0;i<e.length;i++){const s=e[i];HP(s)&&!GP(s)?s.delete(n):e[t++]=s,s.w&=~Ya,s.n&=~Ya}e.length=t}},"finalizeDepMarkers"),ix=new WeakMap;let vd=0,Ya=1;const sx=30;let vr;const ec=Symbol(""),rx=Symbol("");class p1{constructor(e,t=null,i){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,dk(this,i)}run(){if(!this.active)return this.fn();let e=vr,t=Va;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=vr,vr=this,Va=!0,Ya=1<<++vd,vd<=sx?pk(this):kM(this),this.fn()}finally{vd<=sx&&mk(this),Ya=1<<--vd,vr=this.parent,Va=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){vr===this?this.deferStop=!0:this.active&&(kM(this),this.onStop&&this.onStop(),this.active=!1)}}u(p1,"ReactiveEffect");function kM(n){const{deps:e}=n;if(e.length){for(let t=0;t<e.length;t++)e[t].delete(n);e.length=0}}u(kM,"cleanupEffect");let Va=!0;const WP=[];function Fh(){WP.push(Va),Va=!1}u(Fh,"pauseTracking");function Nh(){const n=WP.pop();Va=n===void 0?!0:n}u(Nh,"resetTracking");function ks(n,e,t){if(Va&&vr){let i=ix.get(n);i||ix.set(n,i=new Map);let s=i.get(t);s||i.set(t,s=m_()),jP(s)}}u(ks,"track");function jP(n,e){let t=!1;vd<=sx?GP(n)||(n.n|=Ya,t=!HP(n)):t=!n.has(vr),t&&(n.add(vr),vr.deps.push(n))}u(jP,"trackEffects");function jo(n,e,t,i,s,r){const o=ix.get(n);if(!o)return;let a=[];if(e==="clear")a=[...o.values()];else if(t==="length"&&ct(n)){const l=F0(i);o.forEach((c,h)=>{(h==="length"||h>=l)&&a.push(c)})}else switch(t!==void 0&&a.push(o.get(t)),e){case"add":ct(n)?p_(t)&&a.push(o.get("length")):(a.push(o.get(ec)),Uu(n)&&a.push(o.get(rx)));break;case"delete":ct(n)||(a.push(o.get(ec)),Uu(n)&&a.push(o.get(rx)));break;case"set":Uu(n)&&a.push(o.get(ec));break}if(a.length===1)a[0]&&ox(a[0]);else{const l=[];for(const c of a)c&&l.push(...c);ox(m_(l))}}u(jo,"trigger");function ox(n,e){const t=ct(n)?n:[...n];for(const i of t)i.computed&&zM(i);for(const i of t)i.computed||zM(i)}u(ox,"triggerEffects");function zM(n,e){(n!==vr||n.allowRecurse)&&(n.scheduler?n.scheduler():n.run())}u(zM,"triggerEffect");const gk=u_("__proto__,__v_isRef,__isVue"),XP=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(d_)),vk=g_(),yk=g_(!1,!0),bk=g_(!0),BM=xk();function xk(){const n={};return["includes","indexOf","lastIndexOf"].forEach(e=>{n[e]=function(...t){const i=it(this);for(let r=0,o=this.length;r<o;r++)ks(i,"get",r+"");const s=i[e](...t);return s===-1||s===!1?i[e](...t.map(it)):s}}),["push","pop","shift","unshift","splice"].forEach(e=>{n[e]=function(...t){Fh();const i=it(this)[e].apply(this,t);return Nh(),i}}),n}u(xk,"createArrayInstrumentations");function g_(n=!1,e=!1){return u(function(i,s,r){if(s==="__v_isReactive")return!n;if(s==="__v_isReadonly")return n;if(s==="__v_isShallow")return e;if(s==="__v_raw"&&r===(n?e?Nk:QP:e?KP:ZP).get(i))return i;const o=ct(i);if(!n&&o&&Nt(BM,s))return Reflect.get(BM,s,r);const a=Reflect.get(i,s,r);return(d_(s)?XP.has(s):gk(s))||(n||ks(i,"get",s),e)?a:Fi(a)?o&&p_(s)?a:a.value:_n(a)?n?JP(a):Ho(a):a},"get")}u(g_,"createGetter");const _k=qP(),wk=qP(!0);function qP(n=!1){return u(function(t,i,s,r){let o=t[i];if(Yu(o)&&Fi(o)&&!Fi(s))return!1;if(!n&&(!N0(s)&&!Yu(s)&&(o=it(o),s=it(s)),!ct(t)&&Fi(o)&&!Fi(s)))return o.value=s,!0;const a=ct(t)&&p_(i)?Number(i)<t.length:Nt(t,i),l=Reflect.set(t,i,s,r);return t===it(r)&&(a?Xd(s,o)&&jo(t,"set",i,s):jo(t,"add",i,s)),l},"set")}u(qP,"createSetter");function Ak(n,e){const t=Nt(n,e);n[e];const i=Reflect.deleteProperty(n,e);return i&&t&&jo(n,"delete",e,void 0),i}u(Ak,"deleteProperty");function Mk(n,e){const t=Reflect.has(n,e);return(!d_(e)||!XP.has(e))&&ks(n,"has",e),t}u(Mk,"has");function Sk(n){return ks(n,"iterate",ct(n)?"length":ec),Reflect.ownKeys(n)}u(Sk,"ownKeys");const YP={get:vk,set:_k,deleteProperty:Ak,has:Mk,ownKeys:Sk},Tk={get:bk,set(n,e){return!0},deleteProperty(n,e){return!0}},Ck=ss({},YP,{get:yk,set:wk}),v_=u(n=>n,"toShallow"),m1=u(n=>Reflect.getPrototypeOf(n),"getProto");function Qp(n,e,t=!1,i=!1){n=n.__v_raw;const s=it(n),r=it(e);t||(e!==r&&ks(s,"get",e),ks(s,"get",r));const{has:o}=m1(s),a=i?v_:t?x_:qd;if(o.call(s,e))return a(n.get(e));if(o.call(s,r))return a(n.get(r));n!==s&&n.get(e)}u(Qp,"get$1");function Jp(n,e=!1){const t=this.__v_raw,i=it(t),s=it(n);return e||(n!==s&&ks(i,"has",n),ks(i,"has",s)),n===s?t.has(n):t.has(n)||t.has(s)}u(Jp,"has$1");function em(n,e=!1){return n=n.__v_raw,!e&&ks(it(n),"iterate",ec),Reflect.get(n,"size",n)}u(em,"size");function UM(n){n=it(n);const e=it(this);return m1(e).has.call(e,n)||(e.add(n),jo(e,"add",n,n)),this}u(UM,"add$4");function $M(n,e){e=it(e);const t=it(this),{has:i,get:s}=m1(t);let r=i.call(t,n);r||(n=it(n),r=i.call(t,n));const o=s.call(t,n);return t.set(n,e),r?Xd(e,o)&&jo(t,"set",n,e):jo(t,"add",n,e),this}u($M,"set$1");function VM(n){const e=it(this),{has:t,get:i}=m1(e);let s=t.call(e,n);s||(n=it(n),s=t.call(e,n)),i&&i.call(e,n);const r=e.delete(n);return s&&jo(e,"delete",n,void 0),r}u(VM,"deleteEntry");function HM(){const n=it(this),e=n.size!==0,t=n.clear();return e&&jo(n,"clear",void 0,void 0),t}u(HM,"clear");function tm(n,e){return u(function(i,s){const r=this,o=r.__v_raw,a=it(o),l=e?v_:n?x_:qd;return!n&&ks(a,"iterate",ec),o.forEach((c,h)=>i.call(s,l(c),l(h),r))},"forEach")}u(tm,"createForEach");function nm(n,e,t){return function(...i){const s=this.__v_raw,r=it(s),o=Uu(r),a=n==="entries"||n===Symbol.iterator&&o,l=n==="keys"&&o,c=s[n](...i),h=t?v_:e?x_:qd;return!e&&ks(r,"iterate",l?rx:ec),{next(){const{value:f,done:d}=c.next();return d?{value:f,done:d}:{value:a?[h(f[0]),h(f[1])]:h(f),done:d}},[Symbol.iterator](){return this}}}}u(nm,"createIterableMethod");function la(n){return function(...e){return n==="delete"?!1:this}}u(la,"createReadonlyMethod");function Ek(){const n={get(r){return Qp(this,r)},get size(){return em(this)},has:Jp,add:UM,set:$M,delete:VM,clear:HM,forEach:tm(!1,!1)},e={get(r){return Qp(this,r,!1,!0)},get size(){return em(this)},has:Jp,add:UM,set:$M,delete:VM,clear:HM,forEach:tm(!1,!0)},t={get(r){return Qp(this,r,!0)},get size(){return em(this,!0)},has(r){return Jp.call(this,r,!0)},add:la("add"),set:la("set"),delete:la("delete"),clear:la("clear"),forEach:tm(!0,!1)},i={get(r){return Qp(this,r,!0,!0)},get size(){return em(this,!0)},has(r){return Jp.call(this,r,!0)},add:la("add"),set:la("set"),delete:la("delete"),clear:la("clear"),forEach:tm(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=nm(r,!1,!1),t[r]=nm(r,!0,!1),e[r]=nm(r,!1,!0),i[r]=nm(r,!0,!0)}),[n,t,e,i]}u(Ek,"createInstrumentations");const[Pk,Rk,Ik,Dk]=Ek();function y_(n,e){const t=e?n?Dk:Ik:n?Rk:Pk;return(i,s,r)=>s==="__v_isReactive"?!n:s==="__v_isReadonly"?n:s==="__v_raw"?i:Reflect.get(Nt(t,s)&&s in i?t:i,s,r)}u(y_,"createInstrumentationGetter");const Lk={get:y_(!1,!1)},Ok={get:y_(!1,!0)},Fk={get:y_(!0,!1)},ZP=new WeakMap,KP=new WeakMap,QP=new WeakMap,Nk=new WeakMap;function kk(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}u(kk,"targetTypeMap");function zk(n){return n.__v_skip||!Object.isExtensible(n)?0:kk(ck(n))}u(zk,"getTargetType");function Ho(n){return Yu(n)?n:b_(n,!1,YP,Lk,ZP)}u(Ho,"reactive");function Bk(n){return b_(n,!1,Ck,Ok,KP)}u(Bk,"shallowReactive");function JP(n){return b_(n,!0,Tk,Fk,QP)}u(JP,"readonly");function b_(n,e,t,i,s){if(!_n(n)||n.__v_raw&&!(e&&n.__v_isReactive))return n;const r=s.get(n);if(r)return r;const o=zk(n);if(o===0)return n;const a=new Proxy(n,o===2?i:t);return s.set(n,a),a}u(b_,"createReactiveObject");function $u(n){return Yu(n)?$u(n.__v_raw):!!(n&&n.__v_isReactive)}u($u,"isReactive");function Yu(n){return!!(n&&n.__v_isReadonly)}u(Yu,"isReadonly");function N0(n){return!!(n&&n.__v_isShallow)}u(N0,"isShallow");function eR(n){return $u(n)||Yu(n)}u(eR,"isProxy");function it(n){const e=n&&n.__v_raw;return e?it(e):n}u(it,"toRaw");function tR(n){return O0(n,"__v_skip",!0),n}u(tR,"markRaw");const qd=u(n=>_n(n)?Ho(n):n,"toReactive"),x_=u(n=>_n(n)?JP(n):n,"toReadonly");function nR(n){Va&&vr&&(n=it(n),jP(n.dep||(n.dep=m_())))}u(nR,"trackRefValue");function iR(n,e){n=it(n),n.dep&&ox(n.dep)}u(iR,"triggerRefValue");function Fi(n){return!!(n&&n.__v_isRef===!0)}u(Fi,"isRef");function He(n){return sR(n,!1)}u(He,"ref");function Uk(n){return sR(n,!0)}u(Uk,"shallowRef");function sR(n,e){return Fi(n)?n:new rR(n,e)}u(sR,"createRef");class rR{constructor(e,t){this.__v_isShallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:it(e),this._value=t?e:qd(e)}get value(){return nR(this),this._value}set value(e){const t=this.__v_isShallow||N0(e)||Yu(e);e=t?e:it(e),Xd(e,this._rawValue)&&(this._rawValue=e,this._value=t?e:qd(e),iR(this))}}u(rR,"RefImpl");function Vu(n){return Fi(n)?n.value:n}u(Vu,"unref");const $k={get:(n,e,t)=>Vu(Reflect.get(n,e,t)),set:(n,e,t,i)=>{const s=n[e];return Fi(s)&&!Fi(t)?(s.value=t,!0):Reflect.set(n,e,t,i)}};function oR(n){return $u(n)?n:new Proxy(n,$k)}u(oR,"proxyRefs");var aR;class lR{constructor(e,t,i,s){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this[aR]=!1,this._dirty=!0,this.effect=new p1(e,()=>{this._dirty||(this._dirty=!0,iR(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!s,this.__v_isReadonly=i}get value(){const e=it(this);return nR(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}u(lR,"ComputedRefImpl");aR="__v_isReadonly";function Vk(n,e,t=!1){let i,s;const r=pt(n);return r?(i=n,s=_r):(i=n.get,s=n.set),new lR(i,s,r||!s,t)}u(Vk,"computed$1");function Ha(n,e,t,i){let s;try{s=i?n(...i):n()}catch(r){g1(r,e,t)}return s}u(Ha,"callWithErrorHandling");function wr(n,e,t,i){if(pt(n)){const r=Ha(n,e,t,i);return r&&BP(r)&&r.catch(o=>{g1(o,e,t)}),r}const s=[];for(let r=0;r<n.length;r++)s.push(wr(n[r],e,t,i));return s}u(wr,"callWithAsyncErrorHandling");function g1(n,e,t,i=!0){const s=e?e.vnode:null;if(e){let r=e.parent;const o=e.proxy,a=t;for(;r;){const c=r.ec;if(c){for(let h=0;h<c.length;h++)if(c[h](n,o,a)===!1)return}r=r.parent}const l=e.appContext.config.errorHandler;if(l){Ha(l,null,10,[n,o,a]);return}}Hk(n,t,s,i)}u(g1,"handleError");function Hk(n,e,t,i=!0){console.error(n)}u(Hk,"logError");let Yd=!1,ax=!1;const Oi=[];let Wr=0;const Hu=[];let Oo=null,Wl=0;const cR=Promise.resolve();let __=null;function qs(n){const e=__||cR;return n?e.then(this?n.bind(this):n):e}u(qs,"nextTick");function Gk(n){let e=Wr+1,t=Oi.length;for(;e<t;){const i=e+t>>>1;Zd(Oi[i])<n?e=i+1:t=i}return e}u(Gk,"findInsertionIndex");function w_(n){(!Oi.length||!Oi.includes(n,Yd&&n.allowRecurse?Wr+1:Wr))&&(n.id==null?Oi.push(n):Oi.splice(Gk(n.id),0,n),uR())}u(w_,"queueJob");function uR(){!Yd&&!ax&&(ax=!0,__=cR.then(fR))}u(uR,"queueFlush");function Wk(n){const e=Oi.indexOf(n);e>Wr&&Oi.splice(e,1)}u(Wk,"invalidateJob");function jk(n){ct(n)?Hu.push(...n):(!Oo||!Oo.includes(n,n.allowRecurse?Wl+1:Wl))&&Hu.push(n),uR()}u(jk,"queuePostFlushCb");function GM(n,e=Yd?Wr+1:0){for(;e<Oi.length;e++){const t=Oi[e];t&&t.pre&&(Oi.splice(e,1),e--,t())}}u(GM,"flushPreFlushCbs");function hR(n){if(Hu.length){const e=[...new Set(Hu)];if(Hu.length=0,Oo){Oo.push(...e);return}for(Oo=e,Oo.sort((t,i)=>Zd(t)-Zd(i)),Wl=0;Wl<Oo.length;Wl++)Oo[Wl]();Oo=null,Wl=0}}u(hR,"flushPostFlushCbs");const Zd=u(n=>n.id==null?1/0:n.id,"getId"),Xk=u((n,e)=>{const t=Zd(n)-Zd(e);if(t===0){if(n.pre&&!e.pre)return-1;if(e.pre&&!n.pre)return 1}return t},"comparator");function fR(n){ax=!1,Yd=!0,Oi.sort(Xk);const e=_r;try{for(Wr=0;Wr<Oi.length;Wr++){const t=Oi[Wr];t&&t.active!==!1&&Ha(t,null,14)}}finally{Wr=0,Oi.length=0,hR(),Yd=!1,__=null,(Oi.length||Hu.length)&&fR()}}u(fR,"flushJobs");function qk(n,e,...t){if(n.isUnmounted)return;const i=n.vnode.props||pn;let s=t;const r=e.startsWith("update:"),o=r&&e.slice(7);if(o&&o in i){const h=`${o==="modelValue"?"model":o}Modifiers`,{number:f,trim:d}=i[h]||pn;d&&(s=t.map(p=>Xn(p)?p.trim():p)),f&&(s=t.map(F0))}let a,l=i[a=Ev(e)]||i[a=Ev(Jr(e))];!l&&r&&(l=i[a=Ev(Ac(e))]),l&&wr(l,n,6,s);const c=i[a+"Once"];if(c){if(!n.emitted)n.emitted={};else if(n.emitted[a])return;n.emitted[a]=!0,wr(c,n,6,s)}}u(qk,"emit$1");function dR(n,e,t=!1){const i=e.emitsCache,s=i.get(n);if(s!==void 0)return s;const r=n.emits;let o={},a=!1;if(!pt(n)){const l=u(c=>{const h=dR(c,e,!0);h&&(a=!0,ss(o,h))},"extendEmits");!t&&e.mixins.length&&e.mixins.forEach(l),n.extends&&l(n.extends),n.mixins&&n.mixins.forEach(l)}return!r&&!a?(_n(n)&&i.set(n,null),null):(ct(r)?r.forEach(l=>o[l]=null):ss(o,r),_n(n)&&i.set(n,o),o)}u(dR,"normalizeEmitsOptions");function v1(n,e){return!n||!u1(e)?!1:(e=e.slice(2).replace(/Once$/,""),Nt(n,e[0].toLowerCase()+e.slice(1))||Nt(n,Ac(e))||Nt(n,e))}u(v1,"isEmitListener");let Ni=null,y1=null;function k0(n){const e=Ni;return Ni=n,y1=n&&n.type.__scopeId||null,e}u(k0,"setCurrentRenderingInstance");function tl(n){y1=n}u(tl,"pushScopeId");function nl(){y1=null}u(nl,"popScopeId");function dn(n,e=Ni,t){if(!e||n._n)return n;const i=u((...s)=>{i._d&&e2(-1);const r=k0(e);let o;try{o=n(...s)}finally{k0(r),i._d&&e2(1)}return o},"renderFnWithContext");return i._n=!0,i._c=!0,i._d=!0,i}u(dn,"withCtx");function Pv(n){const{type:e,vnode:t,proxy:i,withProxy:s,props:r,propsOptions:[o],slots:a,attrs:l,emit:c,render:h,renderCache:f,data:d,setupState:p,ctx:g,inheritAttrs:m}=n;let v,y;const b=k0(n);try{if(t.shapeFlag&4){const w=s||i;v=Vr(h.call(w,w,f,r,p,d,g)),y=l}else{const w=e;v=Vr(w.length>1?w(r,{attrs:l,slots:a,emit:c}):w(r,null)),y=e.props?l:Yk(l)}}catch(w){Fd.length=0,g1(w,n,1),v=Pe(Za)}let x=v;if(y&&m!==!1){const w=Object.keys(y),{shapeFlag:_}=x;w.length&&_&7&&(o&&w.some(h_)&&(y=Zk(y,o)),x=Zu(x,y))}return t.dirs&&(x=Zu(x),x.dirs=x.dirs?x.dirs.concat(t.dirs):t.dirs),t.transition&&(x.transition=t.transition),v=x,k0(b),v}u(Pv,"renderComponentRoot");const Yk=u(n=>{let e;for(const t in n)(t==="class"||t==="style"||u1(t))&&((e||(e={}))[t]=n[t]);return e},"getFunctionalFallthrough"),Zk=u((n,e)=>{const t={};for(const i in n)(!h_(i)||!(i.slice(9)in e))&&(t[i]=n[i]);return t},"filterModelListeners");function Kk(n,e,t){const{props:i,children:s,component:r}=n,{props:o,children:a,patchFlag:l}=e,c=r.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&l>=0){if(l&1024)return!0;if(l&16)return i?WM(i,o,c):!!o;if(l&8){const h=e.dynamicProps;for(let f=0;f<h.length;f++){const d=h[f];if(o[d]!==i[d]&&!v1(c,d))return!0}}}else return(s||a)&&(!a||!a.$stable)?!0:i===o?!1:i?o?WM(i,o,c):!0:!!o;return!1}u(Kk,"shouldUpdateComponent");function WM(n,e,t){const i=Object.keys(e);if(i.length!==Object.keys(n).length)return!0;for(let s=0;s<i.length;s++){const r=i[s];if(e[r]!==n[r]&&!v1(t,r))return!0}return!1}u(WM,"hasPropsChanged");function Qk({vnode:n,parent:e},t){for(;e&&e.subTree===n;)(n=e.vnode).el=t,e=e.parent}u(Qk,"updateHOCHostEl");const Jk=u(n=>n.__isSuspense,"isSuspense");function ez(n,e){e&&e.pendingBranch?ct(n)?e.effects.push(...n):e.effects.push(n):jk(n)}u(ez,"queueEffectWithSuspense");function Gu(n,e){if(Ti){let t=Ti.provides;const i=Ti.parent&&Ti.parent.provides;i===t&&(t=Ti.provides=Object.create(i)),t[n]=e}}u(Gu,"provide");function zi(n,e,t=!1){const i=Ti||Ni;if(i){const s=i.parent==null?i.vnode.appContext&&i.vnode.appContext.provides:i.parent.provides;if(s&&n in s)return s[n];if(arguments.length>1)return t&&pt(e)?e.call(i.proxy):e}}u(zi,"inject$1");const im={};function ts(n,e,t){return pR(n,e,t)}u(ts,"watch$1");function pR(n,e,{immediate:t,deep:i,flush:s,onTrack:r,onTrigger:o}=pn){const a=Ti;let l,c=!1,h=!1;if(Fi(n)?(l=u(()=>n.value,"getter"),c=N0(n)):$u(n)?(l=u(()=>n,"getter"),i=!0):ct(n)?(h=!0,c=n.some(x=>$u(x)||N0(x)),l=u(()=>n.map(x=>{if(Fi(x))return x.value;if($u(x))return Zl(x);if(pt(x))return Ha(x,a,2)}),"getter")):pt(n)?e?l=u(()=>Ha(n,a,2),"getter"):l=u(()=>{if(!(a&&a.isUnmounted))return f&&f(),wr(n,a,3,[d])},"getter"):l=_r,e&&i){const x=l;l=u(()=>Zl(x()),"getter")}let f,d=u(x=>{f=y.onStop=()=>{Ha(x,a,4)}},"onCleanup"),p;if(Jd)if(d=_r,e?t&&wr(e,a,3,[l(),h?[]:void 0,d]):l(),s==="sync"){const x=Wz();p=x.__watcherHandles||(x.__watcherHandles=[])}else return _r;let g=h?new Array(n.length).fill(im):im;const m=u(()=>{if(!!y.active)if(e){const x=y.run();(i||c||(h?x.some((w,_)=>Xd(w,g[_])):Xd(x,g)))&&(f&&f(),wr(e,a,3,[x,g===im?void 0:h&&g[0]===im?[]:g,d]),g=x)}else y.run()},"job");m.allowRecurse=!!e;let v;s==="sync"?v=m:s==="post"?v=u(()=>fs(m,a&&a.suspense),"scheduler"):(m.pre=!0,a&&(m.id=a.uid),v=u(()=>w_(m),"scheduler"));const y=new p1(l,v);e?t?m():g=y.run():s==="post"?fs(y.run.bind(y),a&&a.suspense):y.run();const b=u(()=>{y.stop(),a&&a.scope&&f_(a.scope.effects,y)},"unwatch");return p&&p.push(b),b}u(pR,"doWatch");function tz(n,e,t){const i=this.proxy,s=Xn(n)?n.includes(".")?mR(i,n):()=>i[n]:n.bind(i,i);let r;pt(e)?r=e:(r=e.handler,t=e);const o=Ti;Ku(this);const a=pR(s,r.bind(i),t);return o?Ku(o):tc(),a}u(tz,"instanceWatch");function mR(n,e){const t=e.split(".");return()=>{let i=n;for(let s=0;s<t.length&&i;s++)i=i[t[s]];return i}}u(mR,"createPathGetter");function Zl(n,e){if(!_n(n)||n.__v_skip||(e=e||new Set,e.has(n)))return n;if(e.add(n),Fi(n))Zl(n.value,e);else if(ct(n))for(let t=0;t<n.length;t++)Zl(n[t],e);else if(zP(n)||Uu(n))n.forEach(t=>{Zl(t,e)});else if($P(n))for(const t in n)Zl(n[t],e);return n}u(Zl,"traverse");function zt(n){return pt(n)?{setup:n,name:n.name}:n}u(zt,"defineComponent");const Dd=u(n=>!!n.type.__asyncLoader,"isAsyncWrapper"),gR=u(n=>n.type.__isKeepAlive,"isKeepAlive");function nz(n,e){vR(n,"a",e)}u(nz,"onActivated");function iz(n,e){vR(n,"da",e)}u(iz,"onDeactivated");function vR(n,e,t=Ti){const i=n.__wdc||(n.__wdc=()=>{let s=t;for(;s;){if(s.isDeactivated)return;s=s.parent}return n()});if(b1(e,i,t),t){let s=t.parent;for(;s&&s.parent;)gR(s.parent.vnode)&&sz(i,e,t,s),s=s.parent}}u(vR,"registerKeepAliveHook");function sz(n,e,t,i){const s=b1(e,n,i,!0);_1(()=>{f_(i[e],s)},t)}u(sz,"injectToKeepAliveRoot");function b1(n,e,t=Ti,i=!1){if(t){const s=t[n]||(t[n]=[]),r=e.__weh||(e.__weh=(...o)=>{if(t.isUnmounted)return;Fh(),Ku(t);const a=wr(e,t,n,o);return tc(),Nh(),a});return i?s.unshift(r):s.push(r),r}}u(b1,"injectHook");const ta=u(n=>(e,t=Ti)=>(!Jd||n==="sp")&&b1(n,(...i)=>e(...i),t),"createHook"),rz=ta("bm"),x1=ta("m"),oz=ta("bu"),az=ta("u"),il=ta("bum"),_1=ta("um"),lz=ta("sp"),cz=ta("rtg"),uz=ta("rtc");function hz(n,e=Ti){b1("ec",n,e)}u(hz,"onErrorCaptured");function Iu(n,e){const t=Ni;if(t===null)return n;const i=M1(t)||t.proxy,s=n.dirs||(n.dirs=[]);for(let r=0;r<e.length;r++){let[o,a,l,c=pn]=e[r];o&&(pt(o)&&(o={mounted:o,updated:o}),o.deep&&Zl(a),s.push({dir:o,instance:i,value:a,oldValue:void 0,arg:l,modifiers:c}))}return n}u(Iu,"withDirectives");function dl(n,e,t,i){const s=n.dirs,r=e&&e.dirs;for(let o=0;o<s.length;o++){const a=s[o];r&&(a.oldValue=r[o].value);let l=a.dir[i];l&&(Fh(),wr(l,t,8,[n.el,a,n,e]),Nh())}}u(dl,"invokeDirectiveHook");const A_="components";function xn(n,e){return bR(A_,n,!0,e)||n}u(xn,"resolveComponent");const yR=Symbol();function fz(n){return Xn(n)?bR(A_,n,!1)||n:n||yR}u(fz,"resolveDynamicComponent");function bR(n,e,t=!0,i=!1){const s=Ni||Ti;if(s){const r=s.type;if(n===A_){const a=Vz(r,!1);if(a&&(a===e||a===Jr(e)||a===d1(Jr(e))))return r}const o=jM(s[n]||r[n],e)||jM(s.appContext[n],e);return!o&&i?r:o}}u(bR,"resolveAsset");function jM(n,e){return n&&(n[e]||n[Jr(e)]||n[d1(Jr(e))])}u(jM,"resolve");function Ga(n,e,t,i){let s;const r=t&&t[i];if(ct(n)||Xn(n)){s=new Array(n.length);for(let o=0,a=n.length;o<a;o++)s[o]=e(n[o],o,void 0,r&&r[o])}else if(typeof n=="number"){s=new Array(n);for(let o=0;o<n;o++)s[o]=e(o+1,o,void 0,r&&r[o])}else if(_n(n))if(n[Symbol.iterator])s=Array.from(n,(o,a)=>e(o,a,void 0,r&&r[a]));else{const o=Object.keys(n);s=new Array(o.length);for(let a=0,l=o.length;a<l;a++){const c=o[a];s[a]=e(n[c],c,a,r&&r[a])}}else s=[];return t&&(t[i]=s),s}u(Ga,"renderList");function Kd(n,e,t={},i,s){if(Ni.isCE||Ni.parent&&Dd(Ni.parent)&&Ni.parent.isCE)return e!=="default"&&(t.name=e),Pe("slot",t,i&&i());let r=n[e];r&&r._c&&(r._d=!1),Te();const o=r&&xR(r(t)),a=cn(kt,{key:t.key||o&&o.key||`_${e}`},o||(i?i():[]),o&&n._===1?64:-2);return!s&&a.scopeId&&(a.slotScopeIds=[a.scopeId+"-s"]),r&&r._c&&(r._d=!0),a}u(Kd,"renderSlot");function xR(n){return n.some(e=>B0(e)?!(e.type===Za||e.type===kt&&!xR(e.children)):!0)?n:null}u(xR,"ensureValidVNode");const lx=u(n=>n?DR(n)?M1(n)||n.proxy:lx(n.parent):null,"getPublicInstance"),Ld=ss(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>lx(n.parent),$root:n=>lx(n.root),$emit:n=>n.emit,$options:n=>M_(n),$forceUpdate:n=>n.f||(n.f=()=>w_(n.update)),$nextTick:n=>n.n||(n.n=qs.bind(n.proxy)),$watch:n=>tz.bind(n)}),Rv=u((n,e)=>n!==pn&&!n.__isScriptSetup&&Nt(n,e),"hasSetupBinding"),dz={get({_:n},e){const{ctx:t,setupState:i,data:s,props:r,accessCache:o,type:a,appContext:l}=n;let c;if(e[0]!=="$"){const p=o[e];if(p!==void 0)switch(p){case 1:return i[e];case 2:return s[e];case 4:return t[e];case 3:return r[e]}else{if(Rv(i,e))return o[e]=1,i[e];if(s!==pn&&Nt(s,e))return o[e]=2,s[e];if((c=n.propsOptions[0])&&Nt(c,e))return o[e]=3,r[e];if(t!==pn&&Nt(t,e))return o[e]=4,t[e];cx&&(o[e]=0)}}const h=Ld[e];let f,d;if(h)return e==="$attrs"&&ks(n,"get",e),h(n);if((f=a.__cssModules)&&(f=f[e]))return f;if(t!==pn&&Nt(t,e))return o[e]=4,t[e];if(d=l.config.globalProperties,Nt(d,e))return d[e]},set({_:n},e,t){const{data:i,setupState:s,ctx:r}=n;return Rv(s,e)?(s[e]=t,!0):i!==pn&&Nt(i,e)?(i[e]=t,!0):Nt(n.props,e)||e[0]==="$"&&e.slice(1)in n?!1:(r[e]=t,!0)},has({_:{data:n,setupState:e,accessCache:t,ctx:i,appContext:s,propsOptions:r}},o){let a;return!!t[o]||n!==pn&&Nt(n,o)||Rv(e,o)||(a=r[0])&&Nt(a,o)||Nt(i,o)||Nt(Ld,o)||Nt(s.config.globalProperties,o)},defineProperty(n,e,t){return t.get!=null?n._.accessCache[e]=0:Nt(t,"value")&&this.set(n,e,t.value,null),Reflect.defineProperty(n,e,t)}};let cx=!0;function pz(n){const e=M_(n),t=n.proxy,i=n.ctx;cx=!1,e.beforeCreate&&XM(e.beforeCreate,n,"bc");const{data:s,computed:r,methods:o,watch:a,provide:l,inject:c,created:h,beforeMount:f,mounted:d,beforeUpdate:p,updated:g,activated:m,deactivated:v,beforeDestroy:y,beforeUnmount:b,destroyed:x,unmounted:w,render:_,renderTracked:A,renderTriggered:S,errorCaptured:M,serverPrefetch:C,expose:I,inheritAttrs:F,components:O,directives:N,filters:E}=e;if(c&&mz(c,i,null,n.appContext.config.unwrapInjectedRef),o)for(const X in o){const te=o[X];pt(te)&&(i[X]=te.bind(t))}if(s){const X=s.call(t,t);_n(X)&&(n.data=Ho(X))}if(cx=!0,r)for(const X in r){const te=r[X],j=pt(te)?te.bind(t,t):pt(te.get)?te.get.bind(t,t):_r,ie=!pt(te)&&pt(te.set)?te.set.bind(t):_r,K=st({get:j,set:ie});Object.defineProperty(i,X,{enumerable:!0,configurable:!0,get:()=>K.value,set:$=>K.value=$})}if(a)for(const X in a)_R(a[X],i,t,X);if(l){const X=pt(l)?l.call(t):l;Reflect.ownKeys(X).forEach(te=>{Gu(te,X[te])})}h&&XM(h,n,"c");function G(X,te){ct(te)?te.forEach(j=>X(j.bind(t))):te&&X(te.bind(t))}if(u(G,"registerLifecycleHook"),G(rz,f),G(x1,d),G(oz,p),G(az,g),G(nz,m),G(iz,v),G(hz,M),G(uz,A),G(cz,S),G(il,b),G(_1,w),G(lz,C),ct(I))if(I.length){const X=n.exposed||(n.exposed={});I.forEach(te=>{Object.defineProperty(X,te,{get:()=>t[te],set:j=>t[te]=j})})}else n.exposed||(n.exposed={});_&&n.render===_r&&(n.render=_),F!=null&&(n.inheritAttrs=F),O&&(n.components=O),N&&(n.directives=N)}u(pz,"applyOptions");function mz(n,e,t=_r,i=!1){ct(n)&&(n=ux(n));for(const s in n){const r=n[s];let o;_n(r)?"default"in r?o=zi(r.from||s,r.default,!0):o=zi(r.from||s):o=zi(r),Fi(o)&&i?Object.defineProperty(e,s,{enumerable:!0,configurable:!0,get:()=>o.value,set:a=>o.value=a}):e[s]=o}}u(mz,"resolveInjections");function XM(n,e,t){wr(ct(n)?n.map(i=>i.bind(e.proxy)):n.bind(e.proxy),e,t)}u(XM,"callHook");function _R(n,e,t,i){const s=i.includes(".")?mR(t,i):()=>t[i];if(Xn(n)){const r=e[n];pt(r)&&ts(s,r)}else if(pt(n))ts(s,n.bind(t));else if(_n(n))if(ct(n))n.forEach(r=>_R(r,e,t,i));else{const r=pt(n.handler)?n.handler.bind(t):e[n.handler];pt(r)&&ts(s,r,n)}}u(_R,"createWatcher");function M_(n){const e=n.type,{mixins:t,extends:i}=e,{mixins:s,optionsCache:r,config:{optionMergeStrategies:o}}=n.appContext,a=r.get(e);let l;return a?l=a:!s.length&&!t&&!i?l=e:(l={},s.length&&s.forEach(c=>z0(l,c,o,!0)),z0(l,e,o)),_n(e)&&r.set(e,l),l}u(M_,"resolveMergedOptions");function z0(n,e,t,i=!1){const{mixins:s,extends:r}=e;r&&z0(n,r,t,!0),s&&s.forEach(o=>z0(n,o,t,!0));for(const o in e)if(!(i&&o==="expose")){const a=gz[o]||t&&t[o];n[o]=a?a(n[o],e[o]):e[o]}return n}u(z0,"mergeOptions$1");const gz={data:qM,props:Vl,emits:Vl,methods:Vl,computed:Vl,beforeCreate:Wi,created:Wi,beforeMount:Wi,mounted:Wi,beforeUpdate:Wi,updated:Wi,beforeDestroy:Wi,beforeUnmount:Wi,destroyed:Wi,unmounted:Wi,activated:Wi,deactivated:Wi,errorCaptured:Wi,serverPrefetch:Wi,components:Vl,directives:Vl,watch:yz,provide:qM,inject:vz};function qM(n,e){return e?n?u(function(){return ss(pt(n)?n.call(this,this):n,pt(e)?e.call(this,this):e)},"mergedDataFn"):e:n}u(qM,"mergeDataFn");function vz(n,e){return Vl(ux(n),ux(e))}u(vz,"mergeInject");function ux(n){if(ct(n)){const e={};for(let t=0;t<n.length;t++)e[n[t]]=n[t];return e}return n}u(ux,"normalizeInject");function Wi(n,e){return n?[...new Set([].concat(n,e))]:e}u(Wi,"mergeAsArray");function Vl(n,e){return n?ss(ss(Object.create(null),n),e):e}u(Vl,"mergeObjectOptions");function yz(n,e){if(!n)return e;if(!e)return n;const t=ss(Object.create(null),n);for(const i in e)t[i]=Wi(n[i],e[i]);return t}u(yz,"mergeWatchOptions");function bz(n,e,t,i=!1){const s={},r={};O0(r,A1,1),n.propsDefaults=Object.create(null),wR(n,e,s,r);for(const o in n.propsOptions[0])o in s||(s[o]=void 0);t?n.props=i?s:Bk(s):n.type.props?n.props=s:n.props=r,n.attrs=r}u(bz,"initProps");function xz(n,e,t,i){const{props:s,attrs:r,vnode:{patchFlag:o}}=n,a=it(s),[l]=n.propsOptions;let c=!1;if((i||o>0)&&!(o&16)){if(o&8){const h=n.vnode.dynamicProps;for(let f=0;f<h.length;f++){let d=h[f];if(v1(n.emitsOptions,d))continue;const p=e[d];if(l)if(Nt(r,d))p!==r[d]&&(r[d]=p,c=!0);else{const g=Jr(d);s[g]=hx(l,a,g,p,n,!1)}else p!==r[d]&&(r[d]=p,c=!0)}}}else{wR(n,e,s,r)&&(c=!0);let h;for(const f in a)(!e||!Nt(e,f)&&((h=Ac(f))===f||!Nt(e,h)))&&(l?t&&(t[f]!==void 0||t[h]!==void 0)&&(s[f]=hx(l,a,f,void 0,n,!0)):delete s[f]);if(r!==a)for(const f in r)(!e||!Nt(e,f)&&!0)&&(delete r[f],c=!0)}c&&jo(n,"set","$attrs")}u(xz,"updateProps");function wR(n,e,t,i){const[s,r]=n.propsOptions;let o=!1,a;if(e)for(let l in e){if(g0(l))continue;const c=e[l];let h;s&&Nt(s,h=Jr(l))?!r||!r.includes(h)?t[h]=c:(a||(a={}))[h]=c:v1(n.emitsOptions,l)||(!(l in i)||c!==i[l])&&(i[l]=c,o=!0)}if(r){const l=it(t),c=a||pn;for(let h=0;h<r.length;h++){const f=r[h];t[f]=hx(s,l,f,c[f],n,!Nt(c,f))}}return o}u(wR,"setFullProps");function hx(n,e,t,i,s,r){const o=n[t];if(o!=null){const a=Nt(o,"default");if(a&&i===void 0){const l=o.default;if(o.type!==Function&&pt(l)){const{propsDefaults:c}=s;t in c?i=c[t]:(Ku(s),i=c[t]=l.call(null,e),tc())}else i=l}o[0]&&(r&&!a?i=!1:o[1]&&(i===""||i===Ac(t))&&(i=!0))}return i}u(hx,"resolvePropValue");function AR(n,e,t=!1){const i=e.propsCache,s=i.get(n);if(s)return s;const r=n.props,o={},a=[];let l=!1;if(!pt(n)){const h=u(f=>{l=!0;const[d,p]=AR(f,e,!0);ss(o,d),p&&a.push(...p)},"extendProps");!t&&e.mixins.length&&e.mixins.forEach(h),n.extends&&h(n.extends),n.mixins&&n.mixins.forEach(h)}if(!r&&!l)return _n(n)&&i.set(n,Bu),Bu;if(ct(r))for(let h=0;h<r.length;h++){const f=Jr(r[h]);YM(f)&&(o[f]=pn)}else if(r)for(const h in r){const f=Jr(h);if(YM(f)){const d=r[h],p=o[f]=ct(d)||pt(d)?{type:d}:Object.assign({},d);if(p){const g=QM(Boolean,p.type),m=QM(String,p.type);p[0]=g>-1,p[1]=m<0||g<m,(g>-1||Nt(p,"default"))&&a.push(f)}}}const c=[o,a];return _n(n)&&i.set(n,c),c}u(AR,"normalizePropsOptions");function YM(n){return n[0]!=="$"}u(YM,"validatePropName");function ZM(n){const e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:n===null?"null":""}u(ZM,"getType");function KM(n,e){return ZM(n)===ZM(e)}u(KM,"isSameType");function QM(n,e){return ct(e)?e.findIndex(t=>KM(t,n)):pt(e)&&KM(e,n)?0:-1}u(QM,"getTypeIndex");const MR=u(n=>n[0]==="_"||n==="$stable","isInternalKey"),S_=u(n=>ct(n)?n.map(Vr):[Vr(n)],"normalizeSlotValue"),_z=u((n,e,t)=>{if(e._n)return e;const i=dn((...s)=>S_(e(...s)),t);return i._c=!1,i},"normalizeSlot$1"),SR=u((n,e,t)=>{const i=n._ctx;for(const s in n){if(MR(s))continue;const r=n[s];if(pt(r))e[s]=_z(s,r,i);else if(r!=null){const o=S_(r);e[s]=()=>o}}},"normalizeObjectSlots"),TR=u((n,e)=>{const t=S_(e);n.slots.default=()=>t},"normalizeVNodeSlots"),wz=u((n,e)=>{if(n.vnode.shapeFlag&32){const t=e._;t?(n.slots=it(e),O0(e,"_",t)):SR(e,n.slots={})}else n.slots={},e&&TR(n,e);O0(n.slots,A1,1)},"initSlots"),Az=u((n,e,t)=>{const{vnode:i,slots:s}=n;let r=!0,o=pn;if(i.shapeFlag&32){const a=e._;a?t&&a===1?r=!1:(ss(s,e),!t&&a===1&&delete s._):(r=!e.$stable,SR(e,s)),o=e}else e&&(TR(n,e),o={default:1});if(r)for(const a in s)!MR(a)&&!(a in o)&&delete s[a]},"updateSlots");function CR(){return{app:null,config:{isNativeTag:ok,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}u(CR,"createAppContext");let Mz=0;function Sz(n,e){return u(function(i,s=null){pt(i)||(i=Object.assign({},i)),s!=null&&!_n(s)&&(s=null);const r=CR(),o=new Set;let a=!1;const l=r.app={_uid:Mz++,_component:i,_props:s,_container:null,_context:r,_instance:null,version:jz,get config(){return r.config},set config(c){},use(c,...h){return o.has(c)||(c&&pt(c.install)?(o.add(c),c.install(l,...h)):pt(c)&&(o.add(c),c(l,...h))),l},mixin(c){return r.mixins.includes(c)||r.mixins.push(c),l},component(c,h){return h?(r.components[c]=h,l):r.components[c]},directive(c,h){return h?(r.directives[c]=h,l):r.directives[c]},mount(c,h,f){if(!a){const d=Pe(i,s);return d.appContext=r,h&&e?e(d,c):n(d,c,f),a=!0,l._container=c,c.__vue_app__=l,M1(d.component)||d.component.proxy}},unmount(){a&&(n(null,l._container),delete l._container.__vue_app__)},provide(c,h){return r.provides[c]=h,l}};return l},"createApp")}u(Sz,"createAppAPI");function fx(n,e,t,i,s=!1){if(ct(n)){n.forEach((d,p)=>fx(d,e&&(ct(e)?e[p]:e),t,i,s));return}if(Dd(i)&&!s)return;const r=i.shapeFlag&4?M1(i.component)||i.component.proxy:i.el,o=s?null:r,{i:a,r:l}=n,c=e&&e.r,h=a.refs===pn?a.refs={}:a.refs,f=a.setupState;if(c!=null&&c!==l&&(Xn(c)?(h[c]=null,Nt(f,c)&&(f[c]=null)):Fi(c)&&(c.value=null)),pt(l))Ha(l,a,12,[o,h]);else{const d=Xn(l),p=Fi(l);if(d||p){const g=u(()=>{if(n.f){const m=d?Nt(f,l)?f[l]:h[l]:l.value;s?ct(m)&&f_(m,r):ct(m)?m.includes(r)||m.push(r):d?(h[l]=[r],Nt(f,l)&&(f[l]=h[l])):(l.value=[r],n.k&&(h[n.k]=l.value))}else d?(h[l]=o,Nt(f,l)&&(f[l]=o)):p&&(l.value=o,n.k&&(h[n.k]=o))},"doSet");o?(g.id=-1,fs(g,t)):g()}}}u(fx,"setRef");const fs=ez;function Tz(n){return Cz(n)}u(Tz,"createRenderer");function Cz(n,e){const t=fk();t.__VUE__=!0;const{insert:i,remove:s,patchProp:r,createElement:o,createText:a,createComment:l,setText:c,setElementText:h,parentNode:f,nextSibling:d,setScopeId:p=_r,insertStaticContent:g}=n,m=u((V,Y,R,ee=null,Q=null,U=null,z=!1,W=null,re=!!Y.dynamicChildren)=>{if(V===Y)return;V&&!sf(V,Y)&&(ee=ve(V),$(V,Q,U,!0),V=null),Y.patchFlag===-2&&(re=!1,Y.dynamicChildren=null);const{type:B,ref:D,shapeFlag:L}=Y;switch(B){case w1:v(V,Y,R,ee);break;case Za:y(V,Y,R,ee);break;case Iv:V==null&&b(Y,R,ee,z);break;case kt:O(V,Y,R,ee,Q,U,z,W,re);break;default:L&1?_(V,Y,R,ee,Q,U,z,W,re):L&6?N(V,Y,R,ee,Q,U,z,W,re):(L&64||L&128)&&B.process(V,Y,R,ee,Q,U,z,W,re,_e)}D!=null&&Q&&fx(D,V&&V.ref,U,Y||V,!Y)},"patch"),v=u((V,Y,R,ee)=>{if(V==null)i(Y.el=a(Y.children),R,ee);else{const Q=Y.el=V.el;Y.children!==V.children&&c(Q,Y.children)}},"processText"),y=u((V,Y,R,ee)=>{V==null?i(Y.el=l(Y.children||""),R,ee):Y.el=V.el},"processCommentNode"),b=u((V,Y,R,ee)=>{[V.el,V.anchor]=g(V.children,Y,R,ee,V.el,V.anchor)},"mountStaticNode"),x=u(({el:V,anchor:Y},R,ee)=>{let Q;for(;V&&V!==Y;)Q=d(V),i(V,R,ee),V=Q;i(Y,R,ee)},"moveStaticNode"),w=u(({el:V,anchor:Y})=>{let R;for(;V&&V!==Y;)R=d(V),s(V),V=R;s(Y)},"removeStaticNode"),_=u((V,Y,R,ee,Q,U,z,W,re)=>{z=z||Y.type==="svg",V==null?A(Y,R,ee,Q,U,z,W,re):C(V,Y,Q,U,z,W,re)},"processElement"),A=u((V,Y,R,ee,Q,U,z,W)=>{let re,B;const{type:D,props:L,shapeFlag:H,transition:q,dirs:se}=V;if(re=V.el=o(V.type,U,L&&L.is,L),H&8?h(re,V.children):H&16&&M(V.children,re,null,ee,Q,U&&D!=="foreignObject",z,W),se&&dl(V,null,ee,"created"),L){for(const ge in L)ge!=="value"&&!g0(ge)&&r(re,ge,null,L[ge],U,V.children,ee,Q,ne);"value"in L&&r(re,"value",null,L.value),(B=L.onVnodeBeforeMount)&&Lr(B,ee,V)}S(re,V,V.scopeId,z,ee),se&&dl(V,null,ee,"beforeMount");const de=(!Q||Q&&!Q.pendingBranch)&&q&&!q.persisted;de&&q.beforeEnter(re),i(re,Y,R),((B=L&&L.onVnodeMounted)||de||se)&&fs(()=>{B&&Lr(B,ee,V),de&&q.enter(re),se&&dl(V,null,ee,"mounted")},Q)},"mountElement"),S=u((V,Y,R,ee,Q)=>{if(R&&p(V,R),ee)for(let U=0;U<ee.length;U++)p(V,ee[U]);if(Q){let U=Q.subTree;if(Y===U){const z=Q.vnode;S(V,z,z.scopeId,z.slotScopeIds,Q.parent)}}},"setScopeId"),M=u((V,Y,R,ee,Q,U,z,W,re=0)=>{for(let B=re;B<V.length;B++){const D=V[B]=W?za(V[B]):Vr(V[B]);m(null,D,Y,R,ee,Q,U,z,W)}},"mountChildren"),C=u((V,Y,R,ee,Q,U,z)=>{const W=Y.el=V.el;let{patchFlag:re,dynamicChildren:B,dirs:D}=Y;re|=V.patchFlag&16;const L=V.props||pn,H=Y.props||pn;let q;R&&pl(R,!1),(q=H.onVnodeBeforeUpdate)&&Lr(q,R,Y,V),D&&dl(Y,V,R,"beforeUpdate"),R&&pl(R,!0);const se=Q&&Y.type!=="foreignObject";if(B?I(V.dynamicChildren,B,W,R,ee,se,U):z||te(V,Y,W,null,R,ee,se,U,!1),re>0){if(re&16)F(W,Y,L,H,R,ee,Q);else if(re&2&&L.class!==H.class&&r(W,"class",null,H.class,Q),re&4&&r(W,"style",L.style,H.style,Q),re&8){const de=Y.dynamicProps;for(let ge=0;ge<de.length;ge++){const ye=de[ge],pe=L[ye],Ne=H[ye];(Ne!==pe||ye==="value")&&r(W,ye,pe,Ne,Q,V.children,R,ee,ne)}}re&1&&V.children!==Y.children&&h(W,Y.children)}else!z&&B==null&&F(W,Y,L,H,R,ee,Q);((q=H.onVnodeUpdated)||D)&&fs(()=>{q&&Lr(q,R,Y,V),D&&dl(Y,V,R,"updated")},ee)},"patchElement"),I=u((V,Y,R,ee,Q,U,z)=>{for(let W=0;W<Y.length;W++){const re=V[W],B=Y[W],D=re.el&&(re.type===kt||!sf(re,B)||re.shapeFlag&70)?f(re.el):R;m(re,B,D,null,ee,Q,U,z,!0)}},"patchBlockChildren"),F=u((V,Y,R,ee,Q,U,z)=>{if(R!==ee){if(R!==pn)for(const W in R)!g0(W)&&!(W in ee)&&r(V,W,R[W],null,z,Y.children,Q,U,ne);for(const W in ee){if(g0(W))continue;const re=ee[W],B=R[W];re!==B&&W!=="value"&&r(V,W,B,re,z,Y.children,Q,U,ne)}"value"in ee&&r(V,"value",R.value,ee.value)}},"patchProps"),O=u((V,Y,R,ee,Q,U,z,W,re)=>{const B=Y.el=V?V.el:a(""),D=Y.anchor=V?V.anchor:a("");let{patchFlag:L,dynamicChildren:H,slotScopeIds:q}=Y;q&&(W=W?W.concat(q):q),V==null?(i(B,R,ee),i(D,R,ee),M(Y.children,R,D,Q,U,z,W,re)):L>0&&L&64&&H&&V.dynamicChildren?(I(V.dynamicChildren,H,R,Q,U,z,W),(Y.key!=null||Q&&Y===Q.subTree)&&T_(V,Y,!0)):te(V,Y,R,D,Q,U,z,W,re)},"processFragment"),N=u((V,Y,R,ee,Q,U,z,W,re)=>{Y.slotScopeIds=W,V==null?Y.shapeFlag&512?Q.ctx.activate(Y,R,ee,z,re):E(Y,R,ee,Q,U,z,re):k(V,Y,re)},"processComponent"),E=u((V,Y,R,ee,Q,U,z)=>{const W=V.component=kz(V,ee,Q);if(gR(V)&&(W.ctx.renderer=_e),zz(W),W.asyncDep){if(Q&&Q.registerDep(W,G),!V.el){const re=W.subTree=Pe(Za);y(null,re,Y,R)}return}G(W,V,Y,R,Q,U,z)},"mountComponent"),k=u((V,Y,R)=>{const ee=Y.component=V.component;if(Kk(V,Y,R))if(ee.asyncDep&&!ee.asyncResolved){X(ee,Y,R);return}else ee.next=Y,Wk(ee.update),ee.update();else Y.el=V.el,ee.vnode=Y},"updateComponent"),G=u((V,Y,R,ee,Q,U,z)=>{const W=u(()=>{if(V.isMounted){let{next:D,bu:L,u:H,parent:q,vnode:se}=V,de=D,ge;pl(V,!1),D?(D.el=se.el,X(V,D,z)):D=se,L&&v0(L),(ge=D.props&&D.props.onVnodeBeforeUpdate)&&Lr(ge,q,D,se),pl(V,!0);const ye=Pv(V),pe=V.subTree;V.subTree=ye,m(pe,ye,f(pe.el),ve(pe),V,Q,U),D.el=ye.el,de===null&&Qk(V,ye.el),H&&fs(H,Q),(ge=D.props&&D.props.onVnodeUpdated)&&fs(()=>Lr(ge,q,D,se),Q)}else{let D;const{el:L,props:H}=Y,{bm:q,m:se,parent:de}=V,ge=Dd(Y);if(pl(V,!1),q&&v0(q),!ge&&(D=H&&H.onVnodeBeforeMount)&&Lr(D,de,Y),pl(V,!0),L&&Se){const ye=u(()=>{V.subTree=Pv(V),Se(L,V.subTree,V,Q,null)},"hydrateSubTree");ge?Y.type.__asyncLoader().then(()=>!V.isUnmounted&&ye()):ye()}else{const ye=V.subTree=Pv(V);m(null,ye,R,ee,V,Q,U),Y.el=ye.el}if(se&&fs(se,Q),!ge&&(D=H&&H.onVnodeMounted)){const ye=Y;fs(()=>Lr(D,de,ye),Q)}(Y.shapeFlag&256||de&&Dd(de.vnode)&&de.vnode.shapeFlag&256)&&V.a&&fs(V.a,Q),V.isMounted=!0,Y=R=ee=null}},"componentUpdateFn"),re=V.effect=new p1(W,()=>w_(B),V.scope),B=V.update=()=>re.run();B.id=V.uid,pl(V,!0),B()},"setupRenderEffect"),X=u((V,Y,R)=>{Y.component=V;const ee=V.vnode.props;V.vnode=Y,V.next=null,xz(V,Y.props,ee,R),Az(V,Y.children,R),Fh(),GM(),Nh()},"updateComponentPreRender"),te=u((V,Y,R,ee,Q,U,z,W,re=!1)=>{const B=V&&V.children,D=V?V.shapeFlag:0,L=Y.children,{patchFlag:H,shapeFlag:q}=Y;if(H>0){if(H&128){ie(B,L,R,ee,Q,U,z,W,re);return}else if(H&256){j(B,L,R,ee,Q,U,z,W,re);return}}q&8?(D&16&&ne(B,Q,U),L!==B&&h(R,L)):D&16?q&16?ie(B,L,R,ee,Q,U,z,W,re):ne(B,Q,U,!0):(D&8&&h(R,""),q&16&&M(L,R,ee,Q,U,z,W,re))},"patchChildren"),j=u((V,Y,R,ee,Q,U,z,W,re)=>{V=V||Bu,Y=Y||Bu;const B=V.length,D=Y.length,L=Math.min(B,D);let H;for(H=0;H<L;H++){const q=Y[H]=re?za(Y[H]):Vr(Y[H]);m(V[H],q,R,null,Q,U,z,W,re)}B>D?ne(V,Q,U,!0,!1,L):M(Y,R,ee,Q,U,z,W,re,L)},"patchUnkeyedChildren"),ie=u((V,Y,R,ee,Q,U,z,W,re)=>{let B=0;const D=Y.length;let L=V.length-1,H=D-1;for(;B<=L&&B<=H;){const q=V[B],se=Y[B]=re?za(Y[B]):Vr(Y[B]);if(sf(q,se))m(q,se,R,null,Q,U,z,W,re);else break;B++}for(;B<=L&&B<=H;){const q=V[L],se=Y[H]=re?za(Y[H]):Vr(Y[H]);if(sf(q,se))m(q,se,R,null,Q,U,z,W,re);else break;L--,H--}if(B>L){if(B<=H){const q=H+1,se=q<D?Y[q].el:ee;for(;B<=H;)m(null,Y[B]=re?za(Y[B]):Vr(Y[B]),R,se,Q,U,z,W,re),B++}}else if(B>H)for(;B<=L;)$(V[B],Q,U,!0),B++;else{const q=B,se=B,de=new Map;for(B=se;B<=H;B++){const $e=Y[B]=re?za(Y[B]):Vr(Y[B]);$e.key!=null&&de.set($e.key,B)}let ge,ye=0;const pe=H-se+1;let Ne=!1,Ye=0;const Re=new Array(pe);for(B=0;B<pe;B++)Re[B]=0;for(B=q;B<=L;B++){const $e=V[B];if(ye>=pe){$($e,Q,U,!0);continue}let Qe;if($e.key!=null)Qe=de.get($e.key);else for(ge=se;ge<=H;ge++)if(Re[ge-se]===0&&sf($e,Y[ge])){Qe=ge;break}Qe===void 0?$($e,Q,U,!0):(Re[Qe-se]=B+1,Qe>=Ye?Ye=Qe:Ne=!0,m($e,Y[Qe],R,null,Q,U,z,W,re),ye++)}const Ke=Ne?Ez(Re):Bu;for(ge=Ke.length-1,B=pe-1;B>=0;B--){const $e=se+B,Qe=Y[$e],Bt=$e+1<D?Y[$e+1].el:ee;Re[B]===0?m(null,Qe,R,Bt,Q,U,z,W,re):Ne&&(ge<0||B!==Ke[ge]?K(Qe,R,Bt,2):ge--)}}},"patchKeyedChildren"),K=u((V,Y,R,ee,Q=null)=>{const{el:U,type:z,transition:W,children:re,shapeFlag:B}=V;if(B&6){K(V.component.subTree,Y,R,ee);return}if(B&128){V.suspense.move(Y,R,ee);return}if(B&64){z.move(V,Y,R,_e);return}if(z===kt){i(U,Y,R);for(let L=0;L<re.length;L++)K(re[L],Y,R,ee);i(V.anchor,Y,R);return}if(z===Iv){x(V,Y,R);return}if(ee!==2&&B&1&&W)if(ee===0)W.beforeEnter(U),i(U,Y,R),fs(()=>W.enter(U),Q);else{const{leave:L,delayLeave:H,afterLeave:q}=W,se=u(()=>i(U,Y,R),"remove"),de=u(()=>{L(U,()=>{se(),q&&q()})},"performLeave");H?H(U,se,de):de()}else i(U,Y,R)},"move"),$=u((V,Y,R,ee=!1,Q=!1)=>{const{type:U,props:z,ref:W,children:re,dynamicChildren:B,shapeFlag:D,patchFlag:L,dirs:H}=V;if(W!=null&&fx(W,null,R,V,!0),D&256){Y.ctx.deactivate(V);return}const q=D&1&&H,se=!Dd(V);let de;if(se&&(de=z&&z.onVnodeBeforeUnmount)&&Lr(de,Y,V),D&6)J(V.component,R,ee);else{if(D&128){V.suspense.unmount(R,ee);return}q&&dl(V,null,Y,"beforeUnmount"),D&64?V.type.remove(V,Y,R,Q,_e,ee):B&&(U!==kt||L>0&&L&64)?ne(B,Y,R,!1,!0):(U===kt&&L&384||!Q&&D&16)&&ne(re,Y,R),ee&&le(V)}(se&&(de=z&&z.onVnodeUnmounted)||q)&&fs(()=>{de&&Lr(de,Y,V),q&&dl(V,null,Y,"unmounted")},R)},"unmount"),le=u(V=>{const{type:Y,el:R,anchor:ee,transition:Q}=V;if(Y===kt){ae(R,ee);return}if(Y===Iv){w(V);return}const U=u(()=>{s(R),Q&&!Q.persisted&&Q.afterLeave&&Q.afterLeave()},"performRemove");if(V.shapeFlag&1&&Q&&!Q.persisted){const{leave:z,delayLeave:W}=Q,re=u(()=>z(R,U),"performLeave");W?W(V.el,U,re):re()}else U()},"remove"),ae=u((V,Y)=>{let R;for(;V!==Y;)R=d(V),s(V),V=R;s(Y)},"removeFragment"),J=u((V,Y,R)=>{const{bum:ee,scope:Q,update:U,subTree:z,um:W}=V;ee&&v0(ee),Q.stop(),U&&(U.active=!1,$(z,V,Y,R)),W&&fs(W,Y),fs(()=>{V.isUnmounted=!0},Y),Y&&Y.pendingBranch&&!Y.isUnmounted&&V.asyncDep&&!V.asyncResolved&&V.suspenseId===Y.pendingId&&(Y.deps--,Y.deps===0&&Y.resolve())},"unmountComponent"),ne=u((V,Y,R,ee=!1,Q=!1,U=0)=>{for(let z=U;z<V.length;z++)$(V[z],Y,R,ee,Q)},"unmountChildren"),ve=u(V=>V.shapeFlag&6?ve(V.component.subTree):V.shapeFlag&128?V.suspense.next():d(V.anchor||V.el),"getNextHostNode"),he=u((V,Y,R)=>{V==null?Y._vnode&&$(Y._vnode,null,null,!0):m(Y._vnode||null,V,Y,null,null,null,R),GM(),hR(),Y._vnode=V},"render"),_e={p:m,um:$,m:K,r:le,mt:E,mc:M,pc:te,pbc:I,n:ve,o:n};let we,Se;return e&&([we,Se]=e(_e)),{render:he,hydrate:we,createApp:Sz(he,we)}}u(Cz,"baseCreateRenderer");function pl({effect:n,update:e},t){n.allowRecurse=e.allowRecurse=t}u(pl,"toggleRecurse");function T_(n,e,t=!1){const i=n.children,s=e.children;if(ct(i)&&ct(s))for(let r=0;r<i.length;r++){const o=i[r];let a=s[r];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=s[r]=za(s[r]),a.el=o.el),t||T_(o,a)),a.type===w1&&(a.el=o.el)}}u(T_,"traverseStaticChildren");function Ez(n){const e=n.slice(),t=[0];let i,s,r,o,a;const l=n.length;for(i=0;i<l;i++){const c=n[i];if(c!==0){if(s=t[t.length-1],n[s]<c){e[i]=s,t.push(i);continue}for(r=0,o=t.length-1;r<o;)a=r+o>>1,n[t[a]]<c?r=a+1:o=a;c<n[t[r]]&&(r>0&&(e[i]=t[r-1]),t[r]=i)}}for(r=t.length,o=t[r-1];r-- >0;)t[r]=o,o=e[o];return t}u(Ez,"getSequence");const Pz=u(n=>n.__isTeleport,"isTeleport"),Od=u(n=>n&&(n.disabled||n.disabled===""),"isTeleportDisabled"),JM=u(n=>typeof SVGElement!="undefined"&&n instanceof SVGElement,"isTargetSVG"),dx=u((n,e)=>{const t=n&&n.to;return Xn(t)?e?e(t):null:t},"resolveTarget"),Rz={__isTeleport:!0,process(n,e,t,i,s,r,o,a,l,c){const{mc:h,pc:f,pbc:d,o:{insert:p,querySelector:g,createText:m,createComment:v}}=c,y=Od(e.props);let{shapeFlag:b,children:x,dynamicChildren:w}=e;if(n==null){const _=e.el=m(""),A=e.anchor=m("");p(_,t,i),p(A,t,i);const S=e.target=dx(e.props,g),M=e.targetAnchor=m("");S&&(p(M,S),o=o||JM(S));const C=u((I,F)=>{b&16&&h(x,I,F,s,r,o,a,l)},"mount");y?C(t,A):S&&C(S,M)}else{e.el=n.el;const _=e.anchor=n.anchor,A=e.target=n.target,S=e.targetAnchor=n.targetAnchor,M=Od(n.props),C=M?t:A,I=M?_:S;if(o=o||JM(A),w?(d(n.dynamicChildren,w,C,s,r,o,a),T_(n,e,!0)):l||f(n,e,C,I,s,r,o,a,!1),y)M||sm(e,t,_,c,1);else if((e.props&&e.props.to)!==(n.props&&n.props.to)){const F=e.target=dx(e.props,g);F&&sm(e,F,null,c,0)}else M&&sm(e,A,S,c,1)}ER(e)},remove(n,e,t,i,{um:s,o:{remove:r}},o){const{shapeFlag:a,children:l,anchor:c,targetAnchor:h,target:f,props:d}=n;if(f&&r(h),(o||!Od(d))&&(r(c),a&16))for(let p=0;p<l.length;p++){const g=l[p];s(g,e,t,!0,!!g.dynamicChildren)}},move:sm,hydrate:Iz};function sm(n,e,t,{o:{insert:i},m:s},r=2){r===0&&i(n.targetAnchor,e,t);const{el:o,anchor:a,shapeFlag:l,children:c,props:h}=n,f=r===2;if(f&&i(o,e,t),(!f||Od(h))&&l&16)for(let d=0;d<c.length;d++)s(c[d],e,t,2);f&&i(a,e,t)}u(sm,"moveTeleport");function Iz(n,e,t,i,s,r,{o:{nextSibling:o,parentNode:a,querySelector:l}},c){const h=e.target=dx(e.props,l);if(h){const f=h._lpa||h.firstChild;if(e.shapeFlag&16)if(Od(e.props))e.anchor=c(o(n),e,a(n),t,i,s,r),e.targetAnchor=f;else{e.anchor=o(n);let d=f;for(;d;)if(d=o(d),d&&d.nodeType===8&&d.data==="teleport anchor"){e.targetAnchor=d,h._lpa=e.targetAnchor&&o(e.targetAnchor);break}c(f,e,h,t,i,s,r)}ER(e)}return e.anchor&&o(e.anchor)}u(Iz,"hydrateTeleport");const C_=Rz;function ER(n){const e=n.ctx;if(e&&e.ut){let t=n.children[0].el;for(;t!==n.targetAnchor;)t.nodeType===1&&t.setAttribute("data-v-owner",e.uid),t=t.nextSibling;e.ut()}}u(ER,"updateCssVars");const kt=Symbol(void 0),w1=Symbol(void 0),Za=Symbol(void 0),Iv=Symbol(void 0),Fd=[];let yr=null;function Te(n=!1){Fd.push(yr=n?null:[])}u(Te,"openBlock");function Dz(){Fd.pop(),yr=Fd[Fd.length-1]||null}u(Dz,"closeBlock");let Qd=1;function e2(n){Qd+=n}u(e2,"setBlockTracking");function PR(n){return n.dynamicChildren=Qd>0?yr||Bu:null,Dz(),Qd>0&&yr&&yr.push(n),n}u(PR,"setupBlock");function Be(n,e,t,i,s,r){return PR(ue(n,e,t,i,s,r,!0))}u(Be,"createElementBlock");function cn(n,e,t,i,s){return PR(Pe(n,e,t,i,s,!0))}u(cn,"createBlock");function B0(n){return n?n.__v_isVNode===!0:!1}u(B0,"isVNode");function sf(n,e){return n.type===e.type&&n.key===e.key}u(sf,"isSameVNodeType");const A1="__vInternal",RR=u(({key:n})=>n!=null?n:null,"normalizeKey"),y0=u(({ref:n,ref_key:e,ref_for:t})=>n!=null?Xn(n)||Fi(n)||pt(n)?{i:Ni,r:n,k:e,f:!!t}:n:null,"normalizeRef");function ue(n,e=null,t=null,i=0,s=null,r=n===kt?0:1,o=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:n,props:e,key:e&&RR(e),ref:e&&y0(e),scopeId:y1,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:r,patchFlag:i,dynamicProps:s,dynamicChildren:null,appContext:null,ctx:Ni};return a?(E_(l,t),r&128&&n.normalize(l)):t&&(l.shapeFlag|=Xn(t)?8:16),Qd>0&&!o&&yr&&(l.patchFlag>0||r&6)&&l.patchFlag!==32&&yr.push(l),l}u(ue,"createBaseVNode");const Pe=Lz;function Lz(n,e=null,t=null,i=0,s=null,r=!1){if((!n||n===yR)&&(n=Za),B0(n)){const a=Zu(n,e,!0);return t&&E_(a,t),Qd>0&&!r&&yr&&(a.shapeFlag&6?yr[yr.indexOf(n)]=a:yr.push(a)),a.patchFlag|=-2,a}if(Hz(n)&&(n=n.__vccOpts),e){e=Oz(e);let{class:a,style:l}=e;a&&!Xn(a)&&(e.class=Mn(a)),_n(l)&&(eR(l)&&!ct(l)&&(l=ss({},l)),e.style=ci(l))}const o=Xn(n)?1:Jk(n)?128:Pz(n)?64:_n(n)?4:pt(n)?2:0;return ue(n,e,t,i,s,o,r,!0)}u(Lz,"_createVNode");function Oz(n){return n?eR(n)||A1 in n?ss({},n):n:null}u(Oz,"guardReactiveProps");function Zu(n,e,t=!1){const{props:i,ref:s,patchFlag:r,children:o}=n,a=e?IR(i||{},e):i;return{__v_isVNode:!0,__v_skip:!0,type:n.type,props:a,key:a&&RR(a),ref:e&&e.ref?t&&s?ct(s)?s.concat(y0(e)):[s,y0(e)]:y0(e):s,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:o,target:n.target,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:e&&n.type!==kt?r===-1?16:r|16:r,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:n.transition,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&Zu(n.ssContent),ssFallback:n.ssFallback&&Zu(n.ssFallback),el:n.el,anchor:n.anchor,ctx:n.ctx}}u(Zu,"cloneVNode");function Bo(n=" ",e=0){return Pe(w1,null,n,e)}u(Bo,"createTextVNode");function nt(n="",e=!1){return e?(Te(),cn(Za,null,n)):Pe(Za,null,n)}u(nt,"createCommentVNode");function Vr(n){return n==null||typeof n=="boolean"?Pe(Za):ct(n)?Pe(kt,null,n.slice()):typeof n=="object"?za(n):Pe(w1,null,String(n))}u(Vr,"normalizeVNode");function za(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:Zu(n)}u(za,"cloneIfMounted");function E_(n,e){let t=0;const{shapeFlag:i}=n;if(e==null)e=null;else if(ct(e))t=16;else if(typeof e=="object")if(i&65){const s=e.default;s&&(s._c&&(s._d=!1),E_(n,s()),s._c&&(s._d=!0));return}else{t=32;const s=e._;!s&&!(A1 in e)?e._ctx=Ni:s===3&&Ni&&(Ni.slots._===1?e._=1:(e._=2,n.patchFlag|=1024))}else pt(e)?(e={default:e,_ctx:Ni},t=32):(e=String(e),i&64?(t=16,e=[Bo(e)]):t=8);n.children=e,n.shapeFlag|=t}u(E_,"normalizeChildren");function IR(...n){const e={};for(let t=0;t<n.length;t++){const i=n[t];for(const s in i)if(s==="class")e.class!==i.class&&(e.class=Mn([e.class,i.class]));else if(s==="style")e.style=ci([e.style,i.style]);else if(u1(s)){const r=e[s],o=i[s];o&&r!==o&&!(ct(r)&&r.includes(o))&&(e[s]=r?[].concat(r,o):o)}else s!==""&&(e[s]=i[s])}return e}u(IR,"mergeProps");function Lr(n,e,t,i=null){wr(n,e,7,[t,i])}u(Lr,"invokeVNodeHook");const Fz=CR();let Nz=0;function kz(n,e,t){const i=n.type,s=(e?e.appContext:n.appContext)||Fz,r={uid:Nz++,vnode:n,type:i,parent:e,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,scope:new VP(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(s.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:AR(i,s),emitsOptions:dR(i,s),emit:null,emitted:null,propsDefaults:pn,inheritAttrs:i.inheritAttrs,ctx:pn,data:pn,props:pn,attrs:pn,slots:pn,refs:pn,setupState:pn,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return r.ctx={_:r},r.root=e?e.root:r,r.emit=qk.bind(null,r),n.ce&&n.ce(r),r}u(kz,"createComponentInstance$1");let Ti=null;const Ku=u(n=>{Ti=n,n.scope.on()},"setCurrentInstance"),tc=u(()=>{Ti&&Ti.scope.off(),Ti=null},"unsetCurrentInstance");function DR(n){return n.vnode.shapeFlag&4}u(DR,"isStatefulComponent");let Jd=!1;function zz(n,e=!1){Jd=e;const{props:t,children:i}=n.vnode,s=DR(n);bz(n,t,s,e),wz(n,i);const r=s?Bz(n,e):void 0;return Jd=!1,r}u(zz,"setupComponent");function Bz(n,e){const t=n.type;n.accessCache=Object.create(null),n.proxy=tR(new Proxy(n.ctx,dz));const{setup:i}=t;if(i){const s=n.setupContext=i.length>1?$z(n):null;Ku(n),Fh();const r=Ha(i,n,0,[n.props,s]);if(Nh(),tc(),BP(r)){if(r.then(tc,tc),e)return r.then(o=>{t2(n,o,e)}).catch(o=>{g1(o,n,0)});n.asyncDep=r}else t2(n,r,e)}else LR(n,e)}u(Bz,"setupStatefulComponent");function t2(n,e,t){pt(e)?n.type.__ssrInlineRender?n.ssrRender=e:n.render=e:_n(e)&&(n.setupState=oR(e)),LR(n,t)}u(t2,"handleSetupResult");let n2;function LR(n,e,t){const i=n.type;if(!n.render){if(!e&&n2&&!i.render){const s=i.template||M_(n).template;if(s){const{isCustomElement:r,compilerOptions:o}=n.appContext.config,{delimiters:a,compilerOptions:l}=i,c=ss(ss({isCustomElement:r,delimiters:a},o),l);i.render=n2(s,c)}}n.render=i.render||_r}Ku(n),Fh(),pz(n),Nh(),tc()}u(LR,"finishComponentSetup");function Uz(n){return new Proxy(n.attrs,{get(e,t){return ks(n,"get","$attrs"),e[t]}})}u(Uz,"createAttrsProxy");function $z(n){const e=u(i=>{n.exposed=i||{}},"expose");let t;return{get attrs(){return t||(t=Uz(n))},slots:n.slots,emit:n.emit,expose:e}}u($z,"createSetupContext");function M1(n){if(n.exposed)return n.exposeProxy||(n.exposeProxy=new Proxy(oR(tR(n.exposed)),{get(e,t){if(t in e)return e[t];if(t in Ld)return Ld[t](n)},has(e,t){return t in e||t in Ld}}))}u(M1,"getExposeProxy");function Vz(n,e=!0){return pt(n)?n.displayName||n.name:n.name||e&&n.__name}u(Vz,"getComponentName");function Hz(n){return pt(n)&&"__vccOpts"in n}u(Hz,"isClassComponent");const st=u((n,e)=>Vk(n,e,Jd),"computed");function OR(n,e,t){const i=arguments.length;return i===2?_n(e)&&!ct(e)?B0(e)?Pe(n,null,[e]):Pe(n,e):Pe(n,null,e):(i>3?t=Array.prototype.slice.call(arguments,2):i===3&&B0(t)&&(t=[t]),Pe(n,e,t))}u(OR,"h");const Gz=Symbol(""),Wz=u(()=>zi(Gz),"useSSRContext"),jz="3.2.45",Xz="http://www.w3.org/2000/svg",jl=typeof document!="undefined"?document:null,i2=jl&&jl.createElement("template"),qz={insert:(n,e,t)=>{e.insertBefore(n,t||null)},remove:n=>{const e=n.parentNode;e&&e.removeChild(n)},createElement:(n,e,t,i)=>{const s=e?jl.createElementNS(Xz,n):jl.createElement(n,t?{is:t}:void 0);return n==="select"&&i&&i.multiple!=null&&s.setAttribute("multiple",i.multiple),s},createText:n=>jl.createTextNode(n),createComment:n=>jl.createComment(n),setText:(n,e)=>{n.nodeValue=e},setElementText:(n,e)=>{n.textContent=e},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>jl.querySelector(n),setScopeId(n,e){n.setAttribute(e,"")},insertStaticContent(n,e,t,i,s,r){const o=t?t.previousSibling:e.lastChild;if(s&&(s===r||s.nextSibling))for(;e.insertBefore(s.cloneNode(!0),t),!(s===r||!(s=s.nextSibling)););else{i2.innerHTML=i?`<svg>${n}</svg>`:n;const a=i2.content;if(i){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}e.insertBefore(a,t)}return[o?o.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}};function Yz(n,e,t){const i=n._vtc;i&&(e=(e?[e,...i]:[...i]).join(" ")),e==null?n.removeAttribute("class"):t?n.setAttribute("class",e):n.className=e}u(Yz,"patchClass");function Zz(n,e,t){const i=n.style,s=Xn(t);if(t&&!s){for(const r in t)px(i,r,t[r]);if(e&&!Xn(e))for(const r in e)t[r]==null&&px(i,r,"")}else{const r=i.display;s?e!==t&&(i.cssText=t):e&&n.removeAttribute("style"),"_vod"in n&&(i.display=r)}}u(Zz,"patchStyle");const s2=/\s*!important$/;function px(n,e,t){if(ct(t))t.forEach(i=>px(n,e,i));else if(t==null&&(t=""),e.startsWith("--"))n.setProperty(e,t);else{const i=Kz(n,e);s2.test(t)?n.setProperty(Ac(i),t.replace(s2,""),"important"):n[i]=t}}u(px,"setStyle");const r2=["Webkit","Moz","ms"],Dv={};function Kz(n,e){const t=Dv[e];if(t)return t;let i=Jr(e);if(i!=="filter"&&i in n)return Dv[e]=i;i=d1(i);for(let s=0;s<r2.length;s++){const r=r2[s]+i;if(r in n)return Dv[e]=r}return e}u(Kz,"autoPrefix");const o2="http://www.w3.org/1999/xlink";function Qz(n,e,t,i,s){if(i&&e.startsWith("xlink:"))t==null?n.removeAttributeNS(o2,e.slice(6,e.length)):n.setAttributeNS(o2,e,t);else{const r=rk(e);t==null||r&&!NP(t)?n.removeAttribute(e):n.setAttribute(e,r?"":t)}}u(Qz,"patchAttr");function Jz(n,e,t,i,s,r,o){if(e==="innerHTML"||e==="textContent"){i&&o(i,s,r),n[e]=t==null?"":t;return}if(e==="value"&&n.tagName!=="PROGRESS"&&!n.tagName.includes("-")){n._value=t;const l=t==null?"":t;(n.value!==l||n.tagName==="OPTION")&&(n.value=l),t==null&&n.removeAttribute(e);return}let a=!1;if(t===""||t==null){const l=typeof n[e];l==="boolean"?t=NP(t):t==null&&l==="string"?(t="",a=!0):l==="number"&&(t=0,a=!0)}try{n[e]=t}catch{}a&&n.removeAttribute(e)}u(Jz,"patchDOMProp");function Au(n,e,t,i){n.addEventListener(e,t,i)}u(Au,"addEventListener");function e5(n,e,t,i){n.removeEventListener(e,t,i)}u(e5,"removeEventListener");function t5(n,e,t,i,s=null){const r=n._vei||(n._vei={}),o=r[e];if(i&&o)o.value=i;else{const[a,l]=n5(e);if(i){const c=r[e]=r5(i,s);Au(n,a,c,l)}else o&&(e5(n,a,o,l),r[e]=void 0)}}u(t5,"patchEvent");const a2=/(?:Once|Passive|Capture)$/;function n5(n){let e;if(a2.test(n)){e={};let i;for(;i=n.match(a2);)n=n.slice(0,n.length-i[0].length),e[i[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):Ac(n.slice(2)),e]}u(n5,"parseName");let Lv=0;const i5=Promise.resolve(),s5=u(()=>Lv||(i5.then(()=>Lv=0),Lv=Date.now()),"getNow");function r5(n,e){const t=u(i=>{if(!i._vts)i._vts=Date.now();else if(i._vts<=t.attached)return;wr(o5(i,t.value),e,5,[i])},"invoker");return t.value=n,t.attached=s5(),t}u(r5,"createInvoker");function o5(n,e){if(ct(e)){const t=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{t.call(n),n._stopped=!0},e.map(i=>s=>!s._stopped&&i&&i(s))}else return e}u(o5,"patchStopImmediatePropagation");const l2=/^on[a-z]/,a5=u((n,e,t,i,s=!1,r,o,a,l)=>{e==="class"?Yz(n,i,s):e==="style"?Zz(n,t,i):u1(e)?h_(e)||t5(n,e,t,i,o):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):l5(n,e,i,s))?Jz(n,e,i,r,o,a,l):(e==="true-value"?n._trueValue=i:e==="false-value"&&(n._falseValue=i),Qz(n,e,i,s))},"patchProp");function l5(n,e,t,i){return i?!!(e==="innerHTML"||e==="textContent"||e in n&&l2.test(e)&&pt(t)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&n.tagName==="INPUT"||e==="type"&&n.tagName==="TEXTAREA"||l2.test(e)&&Xn(t)?!1:e in n}u(l5,"shouldSetAsProp");const c2=u(n=>{const e=n.props["onUpdate:modelValue"]||!1;return ct(e)?t=>v0(e,t):e},"getModelAssigner");function c5(n){n.target.composing=!0}u(c5,"onCompositionStart");function u2(n){const e=n.target;e.composing&&(e.composing=!1,e.dispatchEvent(new Event("input")))}u(u2,"onCompositionEnd");const FR={created(n,{modifiers:{lazy:e,trim:t,number:i}},s){n._assign=c2(s);const r=i||s.props&&s.props.type==="number";Au(n,e?"change":"input",o=>{if(o.target.composing)return;let a=n.value;t&&(a=a.trim()),r&&(a=F0(a)),n._assign(a)}),t&&Au(n,"change",()=>{n.value=n.value.trim()}),e||(Au(n,"compositionstart",c5),Au(n,"compositionend",u2),Au(n,"change",u2))},mounted(n,{value:e}){n.value=e==null?"":e},beforeUpdate(n,{value:e,modifiers:{lazy:t,trim:i,number:s}},r){if(n._assign=c2(r),n.composing||document.activeElement===n&&n.type!=="range"&&(t||i&&n.value.trim()===e||(s||n.type==="number")&&F0(n.value)===e))return;const o=e==null?"":e;n.value!==o&&(n.value=o)}},u5=["ctrl","shift","alt","meta"],h5={stop:n=>n.stopPropagation(),prevent:n=>n.preventDefault(),self:n=>n.target!==n.currentTarget,ctrl:n=>!n.ctrlKey,shift:n=>!n.shiftKey,alt:n=>!n.altKey,meta:n=>!n.metaKey,left:n=>"button"in n&&n.button!==0,middle:n=>"button"in n&&n.button!==1,right:n=>"button"in n&&n.button!==2,exact:(n,e)=>u5.some(t=>n[`${t}Key`]&&!e.includes(t))},Hn=u((n,e)=>(t,...i)=>{for(let s=0;s<e.length;s++){const r=h5[e[s]];if(r&&r(t,e))return}return n(t,...i)},"withModifiers"),f5={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},Dn=u((n,e)=>t=>{if(!("key"in t))return;const i=Ac(t.key);if(e.some(s=>s===i||f5[s]===i))return n(t)},"withKeys"),rm={beforeMount(n,{value:e},{transition:t}){n._vod=n.style.display==="none"?"":n.style.display,t&&e?t.beforeEnter(n):rf(n,e)},mounted(n,{value:e},{transition:t}){t&&e&&t.enter(n)},updated(n,{value:e,oldValue:t},{transition:i}){!e!=!t&&(i?e?(i.beforeEnter(n),rf(n,!0),i.enter(n)):i.leave(n,()=>{rf(n,!1)}):rf(n,e))},beforeUnmount(n,{value:e}){rf(n,e)}};function rf(n,e){n.style.display=e?n._vod:"none"}u(rf,"setDisplay");const d5=ss({patchProp:a5},qz);let h2;function p5(){return h2||(h2=Tz(d5))}u(p5,"ensureRenderer");const NR=u((...n)=>{const e=p5().createApp(...n),{mount:t}=e;return e.mount=i=>{const s=m5(i);if(!s)return;const r=e._component;!pt(r)&&!r.render&&!r.template&&(r.template=s.innerHTML),s.innerHTML="";const o=t(s,!1,s instanceof SVGElement);return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),o},e},"createApp");function m5(n){return Xn(n)?document.querySelector(n):n}u(m5,"normalizeContainer");var g5=Object.defineProperty,Ov=u((n,e)=>g5(n,"name",{value:e,configurable:!0}),"__name$3n"),v5=zt({setup(){const n=zi("errorSignal"),e=He(""),t=He(!1),i=Ov(o=>{console.error(o),o instanceof Error?e.value=o.stack+"":e.value=o+"",t.value=!0},"showErrorMessageWindow"),s=Ov(o=>{i(o.error)},"onError"),r=Ov(o=>{i(o.reason)},"onUnhandledRejection");return n.addListener(i),window.addEventListener("error",s),window.addEventListener("unhandledrejection",r),_1(()=>{n.removeListener(i),window.removeEventListener("error",s),window.removeEventListener("unhandledrejection",r)}),{errorMessage:e,errorMessageWindowVisible:t}}});var jt=u((n,e)=>{const t=n.__vccOpts||n;for(const[i,s]of e)t[i]=s;return t},"_export_sfc");const y5=u(n=>(tl("data-v-18bfa632"),n=n(),nl(),n),"_withScopeId$7"),b5={key:0,class:"dialog-mask"},x5={class:"dialog"},_5=y5(()=>ue("div",{style:{"margin-bottom":".25em"}},"An error occurred.",-1)),w5={readonly:""},A5={style:{"text-align":"right"}};function M5(n,e,t,i,s,r){const o=xn("router-view");return Te(),Be(kt,null,[Pe(o),n.errorMessageWindowVisible?(Te(),Be("div",b5,[ue("div",x5,[_5,ue("textarea",w5,On(n.errorMessage),1),ue("div",A5,[ue("button",{onClick:e[0]||(e[0]=a=>n.errorMessageWindowVisible=!1)},"Close")])])])):nt("",!0)],64)}u(M5,"_sfc_render$t");var S5=jt(v5,[["render",M5],["__scopeId","data-v-18bfa632"]]),T5=Object.defineProperty,C5=u((n,e)=>T5(n,"name",{value:e,configurable:!0}),"__name$3m");class P_{constructor(){T(this,"listeners",[])}addListener(e){this.listeners.push(e)}removeListener(e){const t=this.listeners.findIndex(i=>i===e);t>=0&&this.listeners.splice(t,1)}dispatch(e){this.listeners.forEach(t=>t(e))}}u(P_,"Signal");C5(P_,"Signal");/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */const Mu=typeof window!="undefined";function E5(n){return n.__esModule||n[Symbol.toStringTag]==="Module"}u(E5,"isESModule");const qt=Object.assign;function Fv(n,e){const t={};for(const i in e){const s=e[i];t[i]=Sr(s)?s.map(n):n(s)}return t}u(Fv,"applyToParams");const Nd=u(()=>{},"noop"),Sr=Array.isArray,P5=/\/$/,R5=u(n=>n.replace(P5,""),"removeTrailingSlash");function Nv(n,e,t="/"){let i,s={},r="",o="";const a=e.indexOf("#");let l=e.indexOf("?");return a<l&&a>=0&&(l=-1),l>-1&&(i=e.slice(0,l),r=e.slice(l+1,a>-1?a:e.length),s=n(r)),a>-1&&(i=i||e.slice(0,a),o=e.slice(a,e.length)),i=O5(i!=null?i:e,t),{fullPath:i+(r&&"?")+r+o,path:i,query:s,hash:o}}u(Nv,"parseURL");function I5(n,e){const t=e.query?n(e.query):"";return e.path+(t&&"?")+t+(e.hash||"")}u(I5,"stringifyURL");function f2(n,e){return!e||!n.toLowerCase().startsWith(e.toLowerCase())?n:n.slice(e.length)||"/"}u(f2,"stripBase");function D5(n,e,t){const i=e.matched.length-1,s=t.matched.length-1;return i>-1&&i===s&&Qu(e.matched[i],t.matched[s])&&kR(e.params,t.params)&&n(e.query)===n(t.query)&&e.hash===t.hash}u(D5,"isSameRouteLocation");function Qu(n,e){return(n.aliasOf||n)===(e.aliasOf||e)}u(Qu,"isSameRouteRecord");function kR(n,e){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(const t in n)if(!L5(n[t],e[t]))return!1;return!0}u(kR,"isSameRouteLocationParams");function L5(n,e){return Sr(n)?d2(n,e):Sr(e)?d2(e,n):n===e}u(L5,"isSameRouteLocationParamsValue");function d2(n,e){return Sr(e)?n.length===e.length&&n.every((t,i)=>t===e[i]):n.length===1&&n[0]===e}u(d2,"isEquivalentArray");function O5(n,e){if(n.startsWith("/"))return n;if(!n)return e;const t=e.split("/"),i=n.split("/");let s=t.length-1,r,o;for(r=0;r<i.length;r++)if(o=i[r],o!==".")if(o==="..")s>1&&s--;else break;return t.slice(0,s).join("/")+"/"+i.slice(r-(r===i.length?1:0)).join("/")}u(O5,"resolveRelativePath");var ep;(function(n){n.pop="pop",n.push="push"})(ep||(ep={}));var kd;(function(n){n.back="back",n.forward="forward",n.unknown=""})(kd||(kd={}));function F5(n){if(!n)if(Mu){const e=document.querySelector("base");n=e&&e.getAttribute("href")||"/",n=n.replace(/^\w+:\/\/[^\/]+/,"")}else n="/";return n[0]!=="/"&&n[0]!=="#"&&(n="/"+n),R5(n)}u(F5,"normalizeBase");const N5=/^[^#]+#/;function k5(n,e){return n.replace(N5,"#")+e}u(k5,"createHref");function z5(n,e){const t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{behavior:e.behavior,left:i.left-t.left-(e.left||0),top:i.top-t.top-(e.top||0)}}u(z5,"getElementPosition");const S1=u(()=>({left:window.pageXOffset,top:window.pageYOffset}),"computeScrollPosition");function B5(n){let e;if("el"in n){const t=n.el,i=typeof t=="string"&&t.startsWith("#"),s=typeof t=="string"?i?document.getElementById(t.slice(1)):document.querySelector(t):t;if(!s)return;e=z5(s,n)}else e=n;"scrollBehavior"in document.documentElement.style?window.scrollTo(e):window.scrollTo(e.left!=null?e.left:window.pageXOffset,e.top!=null?e.top:window.pageYOffset)}u(B5,"scrollToPosition");function p2(n,e){return(history.state?history.state.position-e:-1)+n}u(p2,"getScrollKey");const mx=new Map;function U5(n,e){mx.set(n,e)}u(U5,"saveScrollPosition");function $5(n){const e=mx.get(n);return mx.delete(n),e}u($5,"getSavedScrollPosition");let V5=u(()=>location.protocol+"//"+location.host,"createBaseLocation");function zR(n,e){const{pathname:t,search:i,hash:s}=e,r=n.indexOf("#");if(r>-1){let a=s.includes(n.slice(r))?n.slice(r).length:1,l=s.slice(a);return l[0]!=="/"&&(l="/"+l),f2(l,"")}return f2(t,n)+i+s}u(zR,"createCurrentLocation");function H5(n,e,t,i){let s=[],r=[],o=null;const a=u(({state:d})=>{const p=zR(n,location),g=t.value,m=e.value;let v=0;if(d){if(t.value=p,e.value=d,o&&o===g){o=null;return}v=m?d.position-m.position:0}else i(p);s.forEach(y=>{y(t.value,g,{delta:v,type:ep.pop,direction:v?v>0?kd.forward:kd.back:kd.unknown})})},"popStateHandler");function l(){o=t.value}u(l,"pauseListeners");function c(d){s.push(d);const p=u(()=>{const g=s.indexOf(d);g>-1&&s.splice(g,1)},"teardown");return r.push(p),p}u(c,"listen");function h(){const{history:d}=window;!d.state||d.replaceState(qt({},d.state,{scroll:S1()}),"")}u(h,"beforeUnloadListener");function f(){for(const d of r)d();r=[],window.removeEventListener("popstate",a),window.removeEventListener("beforeunload",h)}return u(f,"destroy"),window.addEventListener("popstate",a),window.addEventListener("beforeunload",h),{pauseListeners:l,listen:c,destroy:f}}u(H5,"useHistoryListeners");function m2(n,e,t,i=!1,s=!1){return{back:n,current:e,forward:t,replaced:i,position:window.history.length,scroll:s?S1():null}}u(m2,"buildState");function G5(n){const{history:e,location:t}=window,i={value:zR(n,t)},s={value:e.state};s.value||r(i.value,{back:null,current:i.value,forward:null,position:e.length-1,replaced:!0,scroll:null},!0);function r(l,c,h){const f=n.indexOf("#"),d=f>-1?(t.host&&document.querySelector("base")?n:n.slice(f))+l:V5()+n+l;try{e[h?"replaceState":"pushState"](c,"",d),s.value=c}catch(p){console.error(p),t[h?"replace":"assign"](d)}}u(r,"changeLocation");function o(l,c){const h=qt({},e.state,m2(s.value.back,l,s.value.forward,!0),c,{position:s.value.position});r(l,h,!0),i.value=l}u(o,"replace");function a(l,c){const h=qt({},s.value,e.state,{forward:l,scroll:S1()});r(h.current,h,!0);const f=qt({},m2(i.value,l,null),{position:h.position+1},c);r(l,f,!1),i.value=l}return u(a,"push"),{location:i,state:s,push:a,replace:o}}u(G5,"useHistoryStateNavigation");function W5(n){n=F5(n);const e=G5(n),t=H5(n,e.state,e.location,e.replace);function i(r,o=!0){o||t.pauseListeners(),history.go(r)}u(i,"go");const s=qt({location:"",base:n,go:i,createHref:k5.bind(null,n)},e,t);return Object.defineProperty(s,"location",{enumerable:!0,get:()=>e.location.value}),Object.defineProperty(s,"state",{enumerable:!0,get:()=>e.state.value}),s}u(W5,"createWebHistory");function j5(n){return n=location.host?n||location.pathname+location.search:"",n.includes("#")||(n+="#"),W5(n)}u(j5,"createWebHashHistory");function X5(n){return typeof n=="string"||n&&typeof n=="object"}u(X5,"isRouteLocation");function BR(n){return typeof n=="string"||typeof n=="symbol"}u(BR,"isRouteName");const ca={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},UR=Symbol("");var g2;(function(n){n[n.aborted=4]="aborted",n[n.cancelled=8]="cancelled",n[n.duplicated=16]="duplicated"})(g2||(g2={}));function Ju(n,e){return qt(new Error,{type:n,[UR]:!0},e)}u(Ju,"createRouterError");function oo(n,e){return n instanceof Error&&UR in n&&(e==null||!!(n.type&e))}u(oo,"isNavigationFailure");const v2="[^/]+?",q5={sensitive:!1,strict:!1,start:!0,end:!0},Y5=/[.+*?^${}()[\]/\\]/g;function Z5(n,e){const t=qt({},q5,e),i=[];let s=t.start?"^":"";const r=[];for(const c of n){const h=c.length?[]:[90];t.strict&&!c.length&&(s+="/");for(let f=0;f<c.length;f++){const d=c[f];let p=40+(t.sensitive?.25:0);if(d.type===0)f||(s+="/"),s+=d.value.replace(Y5,"\\$&"),p+=40;else if(d.type===1){const{value:g,repeatable:m,optional:v,regexp:y}=d;r.push({name:g,repeatable:m,optional:v});const b=y||v2;if(b!==v2){p+=10;try{new RegExp(`(${b})`)}catch(w){throw new Error(`Invalid custom RegExp for param "${g}" (${b}): `+w.message)}}let x=m?`((?:${b})(?:/(?:${b}))*)`:`(${b})`;f||(x=v&&c.length<2?`(?:/${x})`:"/"+x),v&&(x+="?"),s+=x,p+=20,v&&(p+=-8),m&&(p+=-20),b===".*"&&(p+=-50)}h.push(p)}i.push(h)}if(t.strict&&t.end){const c=i.length-1;i[c][i[c].length-1]+=.7000000000000001}t.strict||(s+="/?"),t.end?s+="$":t.strict&&(s+="(?:/|$)");const o=new RegExp(s,t.sensitive?"":"i");function a(c){const h=c.match(o),f={};if(!h)return null;for(let d=1;d<h.length;d++){const p=h[d]||"",g=r[d-1];f[g.name]=p&&g.repeatable?p.split("/"):p}return f}u(a,"parse");function l(c){let h="",f=!1;for(const d of n){(!f||!h.endsWith("/"))&&(h+="/"),f=!1;for(const p of d)if(p.type===0)h+=p.value;else if(p.type===1){const{value:g,repeatable:m,optional:v}=p,y=g in c?c[g]:"";if(Sr(y)&&!m)throw new Error(`Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`);const b=Sr(y)?y.join("/"):y;if(!b)if(v)d.length<2&&(h.endsWith("/")?h=h.slice(0,-1):f=!0);else throw new Error(`Missing required param "${g}"`);h+=b}}return h||"/"}return u(l,"stringify"),{re:o,score:i,keys:r,parse:a,stringify:l}}u(Z5,"tokensToParser");function K5(n,e){let t=0;for(;t<n.length&&t<e.length;){const i=e[t]-n[t];if(i)return i;t++}return n.length<e.length?n.length===1&&n[0]===40+40?-1:1:n.length>e.length?e.length===1&&e[0]===40+40?1:-1:0}u(K5,"compareScoreArray");function Q5(n,e){let t=0;const i=n.score,s=e.score;for(;t<i.length&&t<s.length;){const r=K5(i[t],s[t]);if(r)return r;t++}if(Math.abs(s.length-i.length)===1){if(y2(i))return 1;if(y2(s))return-1}return s.length-i.length}u(Q5,"comparePathParserScore");function y2(n){const e=n[n.length-1];return n.length>0&&e[e.length-1]<0}u(y2,"isLastScoreNegative");const J5={type:0,value:""},eB=/[a-zA-Z0-9_]/;function tB(n){if(!n)return[[]];if(n==="/")return[[J5]];if(!n.startsWith("/"))throw new Error(`Invalid path "${n}"`);function e(p){throw new Error(`ERR (${t})/"${c}": ${p}`)}u(e,"crash");let t=0,i=t;const s=[];let r;function o(){r&&s.push(r),r=[]}u(o,"finalizeSegment");let a=0,l,c="",h="";function f(){!c||(t===0?r.push({type:0,value:c}):t===1||t===2||t===3?(r.length>1&&(l==="*"||l==="+")&&e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),r.push({type:1,value:c,regexp:h,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):e("Invalid state to consume buffer"),c="")}u(f,"consumeBuffer");function d(){c+=l}for(u(d,"addCharToBuffer");a<n.length;){if(l=n[a++],l==="\\"&&t!==2){i=t,t=4;continue}switch(t){case 0:l==="/"?(c&&f(),o()):l===":"?(f(),t=1):d();break;case 4:d(),t=i;break;case 1:l==="("?t=2:eB.test(l)?d():(f(),t=0,l!=="*"&&l!=="?"&&l!=="+"&&a--);break;case 2:l===")"?h[h.length-1]=="\\"?h=h.slice(0,-1)+l:t=3:h+=l;break;case 3:f(),t=0,l!=="*"&&l!=="?"&&l!=="+"&&a--,h="";break;default:e("Unknown state");break}}return t===2&&e(`Unfinished custom RegExp for param "${c}"`),f(),o(),s}u(tB,"tokenizePath");function nB(n,e,t){const i=Z5(tB(n.path),t),s=qt(i,{record:n,parent:e,children:[],alias:[]});return e&&!s.record.aliasOf==!e.record.aliasOf&&e.children.push(s),s}u(nB,"createRouteRecordMatcher");function iB(n,e){const t=[],i=new Map;e=_2({strict:!1,end:!0,sensitive:!1},e);function s(h){return i.get(h)}u(s,"getRecordMatcher");function r(h,f,d){const p=!d,g=sB(h);g.aliasOf=d&&d.record;const m=_2(e,h),v=[g];if("alias"in h){const x=typeof h.alias=="string"?[h.alias]:h.alias;for(const w of x)v.push(qt({},g,{components:d?d.record.components:g.components,path:w,aliasOf:d?d.record:g}))}let y,b;for(const x of v){const{path:w}=x;if(f&&w[0]!=="/"){const _=f.record.path,A=_[_.length-1]==="/"?"":"/";x.path=f.record.path+(w&&A+w)}if(y=nB(x,f,m),d?d.alias.push(y):(b=b||y,b!==y&&b.alias.push(y),p&&h.name&&!x2(y)&&o(h.name)),g.children){const _=g.children;for(let A=0;A<_.length;A++)r(_[A],y,d&&d.children[A])}d=d||y,(y.record.components&&Object.keys(y.record.components).length||y.record.name||y.record.redirect)&&l(y)}return b?()=>{o(b)}:Nd}u(r,"addRoute");function o(h){if(BR(h)){const f=i.get(h);f&&(i.delete(h),t.splice(t.indexOf(f),1),f.children.forEach(o),f.alias.forEach(o))}else{const f=t.indexOf(h);f>-1&&(t.splice(f,1),h.record.name&&i.delete(h.record.name),h.children.forEach(o),h.alias.forEach(o))}}u(o,"removeRoute");function a(){return t}u(a,"getRoutes");function l(h){let f=0;for(;f<t.length&&Q5(h,t[f])>=0&&(h.record.path!==t[f].record.path||!$R(h,t[f]));)f++;t.splice(f,0,h),h.record.name&&!x2(h)&&i.set(h.record.name,h)}u(l,"insertMatcher");function c(h,f){let d,p={},g,m;if("name"in h&&h.name){if(d=i.get(h.name),!d)throw Ju(1,{location:h});m=d.record.name,p=qt(b2(f.params,d.keys.filter(b=>!b.optional).map(b=>b.name)),h.params&&b2(h.params,d.keys.map(b=>b.name))),g=d.stringify(p)}else if("path"in h)g=h.path,d=t.find(b=>b.re.test(g)),d&&(p=d.parse(g),m=d.record.name);else{if(d=f.name?i.get(f.name):t.find(b=>b.re.test(f.path)),!d)throw Ju(1,{location:h,currentLocation:f});m=d.record.name,p=qt({},f.params,h.params),g=d.stringify(p)}const v=[];let y=d;for(;y;)v.unshift(y.record),y=y.parent;return{name:m,path:g,params:p,matched:v,meta:oB(v)}}return u(c,"resolve"),n.forEach(h=>r(h)),{addRoute:r,resolve:c,removeRoute:o,getRoutes:a,getRecordMatcher:s}}u(iB,"createRouterMatcher");function b2(n,e){const t={};for(const i of e)i in n&&(t[i]=n[i]);return t}u(b2,"paramsFromLocation");function sB(n){return{path:n.path,redirect:n.redirect,name:n.name,meta:n.meta||{},aliasOf:void 0,beforeEnter:n.beforeEnter,props:rB(n),children:n.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in n?n.components||null:n.component&&{default:n.component}}}u(sB,"normalizeRouteRecord");function rB(n){const e={},t=n.props||!1;if("component"in n)e.default=t;else for(const i in n.components)e[i]=typeof t=="boolean"?t:t[i];return e}u(rB,"normalizeRecordProps");function x2(n){for(;n;){if(n.record.aliasOf)return!0;n=n.parent}return!1}u(x2,"isAliasRecord");function oB(n){return n.reduce((e,t)=>qt(e,t.meta),{})}u(oB,"mergeMetaFields");function _2(n,e){const t={};for(const i in n)t[i]=i in e?e[i]:n[i];return t}u(_2,"mergeOptions");function $R(n,e){return e.children.some(t=>t===n||$R(n,t))}u($R,"isRecordChildOf");const VR=/#/g,aB=/&/g,lB=/\//g,cB=/=/g,uB=/\?/g,HR=/\+/g,hB=/%5B/g,fB=/%5D/g,GR=/%5E/g,dB=/%60/g,WR=/%7B/g,pB=/%7C/g,jR=/%7D/g,mB=/%20/g;function R_(n){return encodeURI(""+n).replace(pB,"|").replace(hB,"[").replace(fB,"]")}u(R_,"commonEncode");function gB(n){return R_(n).replace(WR,"{").replace(jR,"}").replace(GR,"^")}u(gB,"encodeHash");function gx(n){return R_(n).replace(HR,"%2B").replace(mB,"+").replace(VR,"%23").replace(aB,"%26").replace(dB,"`").replace(WR,"{").replace(jR,"}").replace(GR,"^")}u(gx,"encodeQueryValue");function vB(n){return gx(n).replace(cB,"%3D")}u(vB,"encodeQueryKey");function yB(n){return R_(n).replace(VR,"%23").replace(uB,"%3F")}u(yB,"encodePath");function bB(n){return n==null?"":yB(n).replace(lB,"%2F")}u(bB,"encodeParam");function U0(n){try{return decodeURIComponent(""+n)}catch{}return""+n}u(U0,"decode");function xB(n){const e={};if(n===""||n==="?")return e;const i=(n[0]==="?"?n.slice(1):n).split("&");for(let s=0;s<i.length;++s){const r=i[s].replace(HR," "),o=r.indexOf("="),a=U0(o<0?r:r.slice(0,o)),l=o<0?null:U0(r.slice(o+1));if(a in e){let c=e[a];Sr(c)||(c=e[a]=[c]),c.push(l)}else e[a]=l}return e}u(xB,"parseQuery");function w2(n){let e="";for(let t in n){const i=n[t];if(t=vB(t),i==null){i!==void 0&&(e+=(e.length?"&":"")+t);continue}(Sr(i)?i.map(r=>r&&gx(r)):[i&&gx(i)]).forEach(r=>{r!==void 0&&(e+=(e.length?"&":"")+t,r!=null&&(e+="="+r))})}return e}u(w2,"stringifyQuery");function _B(n){const e={};for(const t in n){const i=n[t];i!==void 0&&(e[t]=Sr(i)?i.map(s=>s==null?null:""+s):i==null?i:""+i)}return e}u(_B,"normalizeQuery");const wB=Symbol(""),A2=Symbol(""),T1=Symbol(""),XR=Symbol(""),vx=Symbol("");function of(){let n=[];function e(i){return n.push(i),()=>{const s=n.indexOf(i);s>-1&&n.splice(s,1)}}u(e,"add");function t(){n=[]}return u(t,"reset"),{add:e,list:()=>n,reset:t}}u(of,"useCallbacks");function Ba(n,e,t,i,s){const r=i&&(i.enterCallbacks[s]=i.enterCallbacks[s]||[]);return()=>new Promise((o,a)=>{const l=u(f=>{f===!1?a(Ju(4,{from:t,to:e})):f instanceof Error?a(f):X5(f)?a(Ju(2,{from:e,to:f})):(r&&i.enterCallbacks[s]===r&&typeof f=="function"&&r.push(f),o())},"next"),c=n.call(i&&i.instances[s],e,t,l);let h=Promise.resolve(c);n.length<3&&(h=h.then(l)),h.catch(f=>a(f))})}u(Ba,"guardToPromiseFn");function kv(n,e,t,i){const s=[];for(const r of n)for(const o in r.components){let a=r.components[o];if(!(e!=="beforeRouteEnter"&&!r.instances[o]))if(AB(a)){const c=(a.__vccOpts||a)[e];c&&s.push(Ba(c,t,i,r,o))}else{let l=a();s.push(()=>l.then(c=>{if(!c)return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${r.path}"`));const h=E5(c)?c.default:c;r.components[o]=h;const d=(h.__vccOpts||h)[e];return d&&Ba(d,t,i,r,o)()}))}}return s}u(kv,"extractComponentsGuards");function AB(n){return typeof n=="object"||"displayName"in n||"props"in n||"__vccOpts"in n}u(AB,"isRouteComponent");function M2(n){const e=zi(T1),t=zi(XR),i=st(()=>e.resolve(Vu(n.to))),s=st(()=>{const{matched:l}=i.value,{length:c}=l,h=l[c-1],f=t.matched;if(!h||!f.length)return-1;const d=f.findIndex(Qu.bind(null,h));if(d>-1)return d;const p=S2(l[c-2]);return c>1&&S2(h)===p&&f[f.length-1].path!==p?f.findIndex(Qu.bind(null,l[c-2])):d}),r=st(()=>s.value>-1&&CB(t.params,i.value.params)),o=st(()=>s.value>-1&&s.value===t.matched.length-1&&kR(t.params,i.value.params));function a(l={}){return TB(l)?e[Vu(n.replace)?"replace":"push"](Vu(n.to)).catch(Nd):Promise.resolve()}return u(a,"navigate"),{route:i,href:st(()=>i.value.href),isActive:r,isExactActive:o,navigate:a}}u(M2,"useLink");const MB=zt({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:M2,setup(n,{slots:e}){const t=Ho(M2(n)),{options:i}=zi(T1),s=st(()=>({[T2(n.activeClass,i.linkActiveClass,"router-link-active")]:t.isActive,[T2(n.exactActiveClass,i.linkExactActiveClass,"router-link-exact-active")]:t.isExactActive}));return()=>{const r=e.default&&e.default(t);return n.custom?r:OR("a",{"aria-current":t.isExactActive?n.ariaCurrentValue:null,href:t.href,onClick:t.navigate,class:s.value},r)}}}),SB=MB;function TB(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)&&!n.defaultPrevented&&!(n.button!==void 0&&n.button!==0)){if(n.currentTarget&&n.currentTarget.getAttribute){const e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}u(TB,"guardEvent");function CB(n,e){for(const t in e){const i=e[t],s=n[t];if(typeof i=="string"){if(i!==s)return!1}else if(!Sr(s)||s.length!==i.length||i.some((r,o)=>r!==s[o]))return!1}return!0}u(CB,"includesParams");function S2(n){return n?n.aliasOf?n.aliasOf.path:n.path:""}u(S2,"getOriginalPath");const T2=u((n,e,t)=>n!=null?n:e!=null?e:t,"getLinkClass"),EB=zt({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(n,{attrs:e,slots:t}){const i=zi(vx),s=st(()=>n.route||i.value),r=zi(A2,0),o=st(()=>{let c=Vu(r);const{matched:h}=s.value;let f;for(;(f=h[c])&&!f.components;)c++;return c}),a=st(()=>s.value.matched[o.value]);Gu(A2,st(()=>o.value+1)),Gu(wB,a),Gu(vx,s);const l=He();return ts(()=>[l.value,a.value,n.name],([c,h,f],[d,p,g])=>{h&&(h.instances[f]=c,p&&p!==h&&c&&c===d&&(h.leaveGuards.size||(h.leaveGuards=p.leaveGuards),h.updateGuards.size||(h.updateGuards=p.updateGuards))),c&&h&&(!p||!Qu(h,p)||!d)&&(h.enterCallbacks[f]||[]).forEach(m=>m(c))},{flush:"post"}),()=>{const c=s.value,h=n.name,f=a.value,d=f&&f.components[h];if(!d)return C2(t.default,{Component:d,route:c});const p=f.props[h],g=p?p===!0?c.params:typeof p=="function"?p(c):p:null,v=OR(d,qt({},g,e,{onVnodeUnmounted:u(y=>{y.component.isUnmounted&&(f.instances[h]=null)},"onVnodeUnmounted"),ref:l}));return C2(t.default,{Component:v,route:c})||v}}});function C2(n,e){if(!n)return null;const t=n(e);return t.length===1?t[0]:t}u(C2,"normalizeSlot");const PB=EB;function RB(n){const e=iB(n.routes,n),t=n.parseQuery||xB,i=n.stringifyQuery||w2,s=n.history,r=of(),o=of(),a=of(),l=Uk(ca);let c=ca;Mu&&n.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const h=Fv.bind(null,J=>""+J),f=Fv.bind(null,bB),d=Fv.bind(null,U0);function p(J,ne){let ve,he;return BR(J)?(ve=e.getRecordMatcher(J),he=ne):he=J,e.addRoute(he,ve)}u(p,"addRoute");function g(J){const ne=e.getRecordMatcher(J);ne&&e.removeRoute(ne)}u(g,"removeRoute");function m(){return e.getRoutes().map(J=>J.record)}u(m,"getRoutes");function v(J){return!!e.getRecordMatcher(J)}u(v,"hasRoute");function y(J,ne){if(ne=qt({},ne||l.value),typeof J=="string"){const V=Nv(t,J,ne.path),Y=e.resolve({path:V.path},ne),R=s.createHref(V.fullPath);return qt(V,Y,{params:d(Y.params),hash:U0(V.hash),redirectedFrom:void 0,href:R})}let ve;if("path"in J)ve=qt({},J,{path:Nv(t,J.path,ne.path).path});else{const V=qt({},J.params);for(const Y in V)V[Y]==null&&delete V[Y];ve=qt({},J,{params:f(J.params)}),ne.params=f(ne.params)}const he=e.resolve(ve,ne),_e=J.hash||"";he.params=h(d(he.params));const we=I5(i,qt({},J,{hash:gB(_e),path:he.path})),Se=s.createHref(we);return qt({fullPath:we,hash:_e,query:i===w2?_B(J.query):J.query||{}},he,{redirectedFrom:void 0,href:Se})}u(y,"resolve");function b(J){return typeof J=="string"?Nv(t,J,l.value.path):qt({},J)}u(b,"locationAsObject");function x(J,ne){if(c!==J)return Ju(8,{from:ne,to:J})}u(x,"checkCanceledNavigation");function w(J){return S(J)}u(w,"push");function _(J){return w(qt(b(J),{replace:!0}))}u(_,"replace");function A(J){const ne=J.matched[J.matched.length-1];if(ne&&ne.redirect){const{redirect:ve}=ne;let he=typeof ve=="function"?ve(J):ve;return typeof he=="string"&&(he=he.includes("?")||he.includes("#")?he=b(he):{path:he},he.params={}),qt({query:J.query,hash:J.hash,params:"path"in he?{}:J.params},he)}}u(A,"handleRedirectRecord");function S(J,ne){const ve=c=y(J),he=l.value,_e=J.state,we=J.force,Se=J.replace===!0,V=A(ve);if(V)return S(qt(b(V),{state:typeof V=="object"?qt({},_e,V.state):_e,force:we,replace:Se}),ne||ve);const Y=ve;Y.redirectedFrom=ne;let R;return!we&&D5(i,he,ve)&&(R=Ju(16,{to:Y,from:he}),ie(he,he,!0,!1)),(R?Promise.resolve(R):C(Y,he)).catch(ee=>oo(ee)?oo(ee,2)?ee:j(ee):X(ee,Y,he)).then(ee=>{if(ee){if(oo(ee,2))return S(qt({replace:Se},b(ee.to),{state:typeof ee.to=="object"?qt({},_e,ee.to.state):_e,force:we}),ne||Y)}else ee=F(Y,he,!0,Se,_e);return I(Y,he,ee),ee})}u(S,"pushWithRedirect");function M(J,ne){const ve=x(J,ne);return ve?Promise.reject(ve):Promise.resolve()}u(M,"checkCanceledNavigationAndReject");function C(J,ne){let ve;const[he,_e,we]=IB(J,ne);ve=kv(he.reverse(),"beforeRouteLeave",J,ne);for(const V of he)V.leaveGuards.forEach(Y=>{ve.push(Ba(Y,J,ne))});const Se=M.bind(null,J,ne);return ve.push(Se),Oc(ve).then(()=>{ve=[];for(const V of r.list())ve.push(Ba(V,J,ne));return ve.push(Se),Oc(ve)}).then(()=>{ve=kv(_e,"beforeRouteUpdate",J,ne);for(const V of _e)V.updateGuards.forEach(Y=>{ve.push(Ba(Y,J,ne))});return ve.push(Se),Oc(ve)}).then(()=>{ve=[];for(const V of J.matched)if(V.beforeEnter&&!ne.matched.includes(V))if(Sr(V.beforeEnter))for(const Y of V.beforeEnter)ve.push(Ba(Y,J,ne));else ve.push(Ba(V.beforeEnter,J,ne));return ve.push(Se),Oc(ve)}).then(()=>(J.matched.forEach(V=>V.enterCallbacks={}),ve=kv(we,"beforeRouteEnter",J,ne),ve.push(Se),Oc(ve))).then(()=>{ve=[];for(const V of o.list())ve.push(Ba(V,J,ne));return ve.push(Se),Oc(ve)}).catch(V=>oo(V,8)?V:Promise.reject(V))}u(C,"navigate");function I(J,ne,ve){for(const he of a.list())he(J,ne,ve)}u(I,"triggerAfterEach");function F(J,ne,ve,he,_e){const we=x(J,ne);if(we)return we;const Se=ne===ca,V=Mu?history.state:{};ve&&(he||Se?s.replace(J.fullPath,qt({scroll:Se&&V&&V.scroll},_e)):s.push(J.fullPath,_e)),l.value=J,ie(J,ne,ve,Se),j()}u(F,"finalizeNavigation");let O;function N(){O||(O=s.listen((J,ne,ve)=>{if(!ae.listening)return;const he=y(J),_e=A(he);if(_e){S(qt(_e,{replace:!0}),he).catch(Nd);return}c=he;const we=l.value;Mu&&U5(p2(we.fullPath,ve.delta),S1()),C(he,we).catch(Se=>oo(Se,12)?Se:oo(Se,2)?(S(Se.to,he).then(V=>{oo(V,20)&&!ve.delta&&ve.type===ep.pop&&s.go(-1,!1)}).catch(Nd),Promise.reject()):(ve.delta&&s.go(-ve.delta,!1),X(Se,he,we))).then(Se=>{Se=Se||F(he,we,!1),Se&&(ve.delta&&!oo(Se,8)?s.go(-ve.delta,!1):ve.type===ep.pop&&oo(Se,20)&&s.go(-1,!1)),I(he,we,Se)}).catch(Nd)}))}u(N,"setupListeners");let E=of(),k=of(),G;function X(J,ne,ve){j(J);const he=k.list();return he.length?he.forEach(_e=>_e(J,ne,ve)):console.error(J),Promise.reject(J)}u(X,"triggerError");function te(){return G&&l.value!==ca?Promise.resolve():new Promise((J,ne)=>{E.add([J,ne])})}u(te,"isReady");function j(J){return G||(G=!J,N(),E.list().forEach(([ne,ve])=>J?ve(J):ne()),E.reset()),J}u(j,"markAsReady");function ie(J,ne,ve,he){const{scrollBehavior:_e}=n;if(!Mu||!_e)return Promise.resolve();const we=!ve&&$5(p2(J.fullPath,0))||(he||!ve)&&history.state&&history.state.scroll||null;return qs().then(()=>_e(J,ne,we)).then(Se=>Se&&B5(Se)).catch(Se=>X(Se,J,ne))}u(ie,"handleScroll");const K=u(J=>s.go(J),"go");let $;const le=new Set,ae={currentRoute:l,listening:!0,addRoute:p,removeRoute:g,hasRoute:v,getRoutes:m,resolve:y,options:n,push:w,replace:_,go:K,back:()=>K(-1),forward:()=>K(1),beforeEach:r.add,beforeResolve:o.add,afterEach:a.add,onError:k.add,isReady:te,install(J){const ne=this;J.component("RouterLink",SB),J.component("RouterView",PB),J.config.globalProperties.$router=ne,Object.defineProperty(J.config.globalProperties,"$route",{enumerable:!0,get:()=>Vu(l)}),Mu&&!$&&l.value===ca&&($=!0,w(s.location).catch(_e=>{}));const ve={};for(const _e in ca)ve[_e]=st(()=>l.value[_e]);J.provide(T1,ne),J.provide(XR,Ho(ve)),J.provide(vx,l);const he=J.unmount;le.add(J),J.unmount=function(){le.delete(J),le.size<1&&(c=ca,O&&O(),O=null,l.value=ca,$=!1,G=!1),he()}}};return ae}u(RB,"createRouter");function Oc(n){return n.reduce((e,t)=>e.then(()=>t()),Promise.resolve())}u(Oc,"runGuardQueue");function IB(n,e){const t=[],i=[],s=[],r=Math.max(e.matched.length,n.matched.length);for(let o=0;o<r;o++){const a=e.matched[o];a&&(n.matched.find(c=>Qu(c,a))?i.push(a):t.push(a));const l=n.matched[o];l&&(e.matched.find(c=>Qu(c,l))||s.push(l))}return[t,i,s]}u(IB,"extractChangingRecords");function DB(){return zi(T1)}u(DB,"useRouter");/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const I_="146",LB=0,E2=1,OB=2,qR=1,YR=2,yd=3,eo=0,ms=1,Ki=2,Ns=0,nc=1,yx=2,P2=3,R2=4,ZR=5,Su=100,FB=101,NB=102,I2=103,D2=104,kB=200,zB=201,BB=202,UB=203,KR=204,QR=205,$B=206,VB=207,HB=208,GB=209,WB=210,jB=0,XB=1,qB=2,bx=3,YB=4,ZB=5,KB=6,QB=7,C1=0,JB=1,eU=2,Qs=0,tU=1,nU=2,iU=3,sU=4,rU=5,JR=300,eh=301,th=302,$0=303,xx=304,E1=306,Qi=1e3,Wn=1001,tp=1002,Yt=1003,V0=1004,H0=1005,Zt=1006,D_=1007,Mc=1008,to=1009,_x=1010,eI=1011,L_=1012,b0=1013,Ys=1014,on=1015,cc=1016,oU=1017,aU=1018,Wu=1020,lU=1021,cU=1022,rn=1023,uU=1024,hU=1025,ic=1026,nh=1027,ih=1028,tI=1029,nI=1030,O_=1031,G0=1033,zv=33776,Bv=33777,Uv=33778,$v=33779,L2=35840,O2=35841,F2=35842,N2=35843,fU=36196,k2=37492,z2=37496,B2=37808,U2=37809,$2=37810,V2=37811,H2=37812,G2=37813,W2=37814,j2=37815,X2=37816,q2=37817,Y2=37818,Z2=37819,K2=37820,Q2=37821,J2=36492,sh=2300,uc=2301,Vv=2302,eS=2400,tS=2401,nS=2402,dU=2500,pU=1,iI=2,Xo=3e3,Lt=3001,mU=3200,sI=3201,Pp=0,gU=1,Fo="srgb",Kl="srgb-linear",Hv=7680,vU=519,wx=35044,iS="300 es",Ax=1035;class Sc{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const s=this._listeners[e];if(s!==void 0){const r=s.indexOf(t);r!==-1&&s.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const s=i.slice(0);for(let r=0,o=s.length;r<o;r++)s[r].call(this,e);e.target=null}}}u(Sc,"EventDispatcher");const Ri=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let sS=1234567;const zd=Math.PI/180,np=180/Math.PI;function Ar(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Ri[n&255]+Ri[n>>8&255]+Ri[n>>16&255]+Ri[n>>24&255]+"-"+Ri[e&255]+Ri[e>>8&255]+"-"+Ri[e>>16&15|64]+Ri[e>>24&255]+"-"+Ri[t&63|128]+Ri[t>>8&255]+"-"+Ri[t>>16&255]+Ri[t>>24&255]+Ri[i&255]+Ri[i>>8&255]+Ri[i>>16&255]+Ri[i>>24&255]).toLowerCase()}u(Ar,"generateUUID");function ai(n,e,t){return Math.max(e,Math.min(t,n))}u(ai,"clamp");function F_(n,e){return(n%e+e)%e}u(F_,"euclideanModulo");function yU(n,e,t,i,s){return i+(n-e)*(s-i)/(t-e)}u(yU,"mapLinear");function bU(n,e,t){return n!==e?(t-n)/(e-n):0}u(bU,"inverseLerp");function Bd(n,e,t){return(1-t)*n+t*e}u(Bd,"lerp$2");function xU(n,e,t,i){return Bd(n,e,1-Math.exp(-t*i))}u(xU,"damp");function _U(n,e=1){return e-Math.abs(F_(n,e*2)-e)}u(_U,"pingpong");function wU(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}u(wU,"smoothstep");function AU(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}u(AU,"smootherstep");function MU(n,e){return n+Math.floor(Math.random()*(e-n+1))}u(MU,"randInt");function SU(n,e){return n+Math.random()*(e-n)}u(SU,"randFloat");function TU(n){return n*(.5-Math.random())}u(TU,"randFloatSpread");function CU(n){n!==void 0&&(sS=n);let e=sS+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}u(CU,"seededRandom");function EU(n){return n*zd}u(EU,"degToRad$1");function PU(n){return n*np}u(PU,"radToDeg$1");function Mx(n){return(n&n-1)===0&&n!==0}u(Mx,"isPowerOfTwo");function rI(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}u(rI,"ceilPowerOfTwo");function W0(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}u(W0,"floorPowerOfTwo");function RU(n,e,t,i,s){const r=Math.cos,o=Math.sin,a=r(t/2),l=o(t/2),c=r((e+i)/2),h=o((e+i)/2),f=r((e-i)/2),d=o((e-i)/2),p=r((i-e)/2),g=o((i-e)/2);switch(s){case"XYX":n.set(a*h,l*f,l*d,a*c);break;case"YZY":n.set(l*d,a*h,l*f,a*c);break;case"ZXZ":n.set(l*f,l*d,a*h,a*c);break;case"XZX":n.set(a*h,l*g,l*p,a*c);break;case"YXY":n.set(l*p,a*h,l*g,a*c);break;case"ZYZ":n.set(l*g,l*p,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}u(RU,"setQuaternionFromProperEuler");function Uo(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}u(Uo,"denormalize");function sn(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}u(sn,"normalize$4");var Yi=Object.freeze({__proto__:null,DEG2RAD:zd,RAD2DEG:np,generateUUID:Ar,clamp:ai,euclideanModulo:F_,mapLinear:yU,inverseLerp:bU,lerp:Bd,damp:xU,pingpong:_U,smoothstep:wU,smootherstep:AU,randInt:MU,randFloat:SU,randFloatSpread:TU,seededRandom:CU,degToRad:EU,radToDeg:PU,isPowerOfTwo:Mx,ceilPowerOfTwo:rI,floorPowerOfTwo:W0,setQuaternionFromProperEuler:RU,normalize:sn,denormalize:Uo});class Ie{constructor(e=0,t=0){Ie.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6],this.y=s[1]*t+s[4]*i+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),s=Math.sin(t),r=this.x-e.x,o=this.y-e.y;return this.x=r*i-o*s+e.x,this.y=r*s+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}u(Ie,"Vector2");class ki{constructor(){ki.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,i,s,r,o,a,l,c){const h=this.elements;return h[0]=e,h[1]=s,h[2]=a,h[3]=t,h[4]=r,h[5]=l,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,s=t.elements,r=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],h=i[4],f=i[7],d=i[2],p=i[5],g=i[8],m=s[0],v=s[3],y=s[6],b=s[1],x=s[4],w=s[7],_=s[2],A=s[5],S=s[8];return r[0]=o*m+a*b+l*_,r[3]=o*v+a*x+l*A,r[6]=o*y+a*w+l*S,r[1]=c*m+h*b+f*_,r[4]=c*v+h*x+f*A,r[7]=c*y+h*w+f*S,r[2]=d*m+p*b+g*_,r[5]=d*v+p*x+g*A,r[8]=d*y+p*w+g*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8];return t*o*h-t*a*c-i*r*h+i*a*l+s*r*c-s*o*l}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],f=h*o-a*c,d=a*l-h*r,p=c*r-o*l,g=t*f+i*d+s*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/g;return e[0]=f*m,e[1]=(s*c-h*i)*m,e[2]=(a*i-s*o)*m,e[3]=d*m,e[4]=(h*t-s*l)*m,e[5]=(s*r-a*t)*m,e[6]=p*m,e[7]=(i*l-c*t)*m,e[8]=(o*t-i*r)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,s,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-s*c,s*l,-s*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),s=this.elements,r=s[0],o=s[3],a=s[6],l=s[1],c=s[4],h=s[7];return s[0]=t*r+i*l,s[3]=t*o+i*c,s[6]=t*a+i*h,s[1]=-i*r+t*l,s[4]=-i*o+t*c,s[7]=-i*a+t*h,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let s=0;s<9;s++)if(t[s]!==i[s])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}u(ki,"Matrix3");function oI(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}u(oI,"arrayNeedsUint32");function ip(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}u(ip,"createElementNS");function sc(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}u(sc,"SRGBToLinear");function x0(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}u(x0,"LinearToSRGB");const Gv={[Fo]:{[Kl]:sc},[Kl]:{[Fo]:x0}},or={legacyMode:!0,get workingColorSpace(){return Kl},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(Gv[e]&&Gv[e][t]!==void 0){const i=Gv[e][t];return n.r=i(n.r),n.g=i(n.g),n.b=i(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},aI={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},oi={r:0,g:0,b:0},ar={h:0,s:0,l:0},om={h:0,s:0,l:0};function Wv(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}u(Wv,"hue2rgb");function am(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}u(am,"toComponents");class Ce{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Fo){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,or.toWorkingColorSpace(this,t),this}setRGB(e,t,i,s=Kl){return this.r=e,this.g=t,this.b=i,or.toWorkingColorSpace(this,s),this}setHSL(e,t,i,s=Kl){if(e=F_(e,1),t=ai(t,0,1),i=ai(i,0,1),t===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+t):i+t-i*t,o=2*i-r;this.r=Wv(o,r,e+1/3),this.g=Wv(o,r,e),this.b=Wv(o,r,e-1/3)}return or.toWorkingColorSpace(this,s),this}setStyle(e,t=Fo){function i(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}u(i,"handleAlpha");let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const o=s[1],a=s[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,or.toWorkingColorSpace(this,t),i(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,or.toWorkingColorSpace(this,t),i(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(r[1])/360,c=parseFloat(r[2])/100,h=parseFloat(r[3])/100;return i(r[4]),this.setHSL(l,c,h,t)}break}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=s[1],o=r.length;if(o===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,or.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,or.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=Fo){const i=aI[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=sc(e.r),this.g=sc(e.g),this.b=sc(e.b),this}copyLinearToSRGB(e){return this.r=x0(e.r),this.g=x0(e.g),this.b=x0(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Fo){return or.fromWorkingColorSpace(am(this,oi),e),ai(oi.r*255,0,255)<<16^ai(oi.g*255,0,255)<<8^ai(oi.b*255,0,255)<<0}getHexString(e=Fo){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Kl){or.fromWorkingColorSpace(am(this,oi),t);const i=oi.r,s=oi.g,r=oi.b,o=Math.max(i,s,r),a=Math.min(i,s,r);let l,c;const h=(a+o)/2;if(a===o)l=0,c=0;else{const f=o-a;switch(c=h<=.5?f/(o+a):f/(2-o-a),o){case i:l=(s-r)/f+(s<r?6:0);break;case s:l=(r-i)/f+2;break;case r:l=(i-s)/f+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=Kl){return or.fromWorkingColorSpace(am(this,oi),t),e.r=oi.r,e.g=oi.g,e.b=oi.b,e}getStyle(e=Fo){return or.fromWorkingColorSpace(am(this,oi),e),e!==Fo?`color(${e} ${oi.r} ${oi.g} ${oi.b})`:`rgb(${oi.r*255|0},${oi.g*255|0},${oi.b*255|0})`}offsetHSL(e,t,i){return this.getHSL(ar),ar.h+=e,ar.s+=t,ar.l+=i,this.setHSL(ar.h,ar.s,ar.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(ar),e.getHSL(om);const i=Bd(ar.h,om.h,t),s=Bd(ar.s,om.s,t),r=Bd(ar.l,om.l,t);return this.setHSL(i,s,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}u(Ce,"Color");Ce.NAMES=aI;let Fc;class N_{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Fc===void 0&&(Fc=ip("canvas")),Fc.width=e.width,Fc.height=e.height;const i=Fc.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Fc}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap){const t=ip("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const s=i.getImageData(0,0,e.width,e.height),r=s.data;for(let o=0;o<r.length;o++)r[o]=sc(r[o]/255)*255;return i.putImageData(s,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(sc(t[i]/255)*255):t[i]=sc(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}u(N_,"ImageUtils");class Rp{constructor(e=null){this.isSource=!0,this.uuid=Ar(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let r;if(Array.isArray(s)){r=[];for(let o=0,a=s.length;o<a;o++)s[o].isDataTexture?r.push(jv(s[o].image)):r.push(jv(s[o]))}else r=jv(s);i.url=r}return t||(e.images[this.uuid]=i),i}}u(Rp,"Source");function jv(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?N_.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}u(jv,"serializeImage");let IU=0;class ui extends Sc{constructor(e=ui.DEFAULT_IMAGE,t=ui.DEFAULT_MAPPING,i=Wn,s=Wn,r=Zt,o=Mc,a=rn,l=to,c=1,h=Xo){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:IU++}),this.uuid=Ar(),this.name="",this.source=new Rp(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=s,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Ie(0,0),this.repeat=new Ie(1,1),this.center=new Ie(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ki,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==JR)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Qi:e.x=e.x-Math.floor(e.x);break;case Wn:e.x=e.x<0?0:1;break;case tp:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Qi:e.y=e.y-Math.floor(e.y);break;case Wn:e.y=e.y<0?0:1;break;case tp:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}u(ui,"Texture");ui.DEFAULT_IMAGE=null;ui.DEFAULT_MAPPING=JR;class ut{constructor(e=0,t=0,i=0,s=1){ut.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,s){return this.x=e,this.y=t,this.z=i,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,s=this.z,r=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*s+o[12]*r,this.y=o[1]*t+o[5]*i+o[9]*s+o[13]*r,this.z=o[2]*t+o[6]*i+o[10]*s+o[14]*r,this.w=o[3]*t+o[7]*i+o[11]*s+o[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,s,r;const l=e.elements,c=l[0],h=l[4],f=l[8],d=l[1],p=l[5],g=l[9],m=l[2],v=l[6],y=l[10];if(Math.abs(h-d)<.01&&Math.abs(f-m)<.01&&Math.abs(g-v)<.01){if(Math.abs(h+d)<.1&&Math.abs(f+m)<.1&&Math.abs(g+v)<.1&&Math.abs(c+p+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,w=(p+1)/2,_=(y+1)/2,A=(h+d)/4,S=(f+m)/4,M=(g+v)/4;return x>w&&x>_?x<.01?(i=0,s=.707106781,r=.707106781):(i=Math.sqrt(x),s=A/i,r=S/i):w>_?w<.01?(i=.707106781,s=0,r=.707106781):(s=Math.sqrt(w),i=A/s,r=M/s):_<.01?(i=.707106781,s=.707106781,r=0):(r=Math.sqrt(_),i=S/r,s=M/r),this.set(i,s,r,t),this}let b=Math.sqrt((v-g)*(v-g)+(f-m)*(f-m)+(d-h)*(d-h));return Math.abs(b)<.001&&(b=1),this.x=(v-g)/b,this.y=(f-m)/b,this.z=(d-h)/b,this.w=Math.acos((c+p+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}u(ut,"Vector4");class Ln extends Sc{constructor(e=1,t=1,i={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new ut(0,0,e,t),this.scissorTest=!1,this.viewport=new ut(0,0,e,t);const s={width:e,height:t,depth:1};this.texture=new ui(s,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:Zt,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null,this.samples=i.samples!==void 0?i.samples:0}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Rp(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}u(Ln,"WebGLRenderTarget");class Ip extends ui{constructor(e=null,t=1,i=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:s},this.magFilter=Yt,this.minFilter=Yt,this.wrapR=Wn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}u(Ip,"DataArrayTexture");class k_ extends Ln{constructor(e=1,t=1,i=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new Ip(null,e,t,i),this.texture.isRenderTargetTexture=!0}}u(k_,"WebGLArrayRenderTarget");class lI extends ui{constructor(e=null,t=1,i=1,s=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:s},this.magFilter=Yt,this.minFilter=Yt,this.wrapR=Wn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}u(lI,"Data3DTexture");class je{constructor(e=0,t=0,i=0,s=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=s}static slerpFlat(e,t,i,s,r,o,a){let l=i[s+0],c=i[s+1],h=i[s+2],f=i[s+3];const d=r[o+0],p=r[o+1],g=r[o+2],m=r[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=f;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=g,e[t+3]=m;return}if(f!==m||l!==d||c!==p||h!==g){let v=1-a;const y=l*d+c*p+h*g+f*m,b=y>=0?1:-1,x=1-y*y;if(x>Number.EPSILON){const _=Math.sqrt(x),A=Math.atan2(_,y*b);v=Math.sin(v*A)/_,a=Math.sin(a*A)/_}const w=a*b;if(l=l*v+d*w,c=c*v+p*w,h=h*v+g*w,f=f*v+m*w,v===1-a){const _=1/Math.sqrt(l*l+c*c+h*h+f*f);l*=_,c*=_,h*=_,f*=_}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=f}static multiplyQuaternionsFlat(e,t,i,s,r,o){const a=i[s],l=i[s+1],c=i[s+2],h=i[s+3],f=r[o],d=r[o+1],p=r[o+2],g=r[o+3];return e[t]=a*g+h*f+l*p-c*d,e[t+1]=l*g+h*d+c*f-a*p,e[t+2]=c*g+h*p+a*d-l*f,e[t+3]=h*g-a*f-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,s){return this._x=e,this._y=t,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const i=e._x,s=e._y,r=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),h=a(s/2),f=a(r/2),d=l(i/2),p=l(s/2),g=l(r/2);switch(o){case"XYZ":this._x=d*h*f+c*p*g,this._y=c*p*f-d*h*g,this._z=c*h*g+d*p*f,this._w=c*h*f-d*p*g;break;case"YXZ":this._x=d*h*f+c*p*g,this._y=c*p*f-d*h*g,this._z=c*h*g-d*p*f,this._w=c*h*f+d*p*g;break;case"ZXY":this._x=d*h*f-c*p*g,this._y=c*p*f+d*h*g,this._z=c*h*g+d*p*f,this._w=c*h*f-d*p*g;break;case"ZYX":this._x=d*h*f-c*p*g,this._y=c*p*f+d*h*g,this._z=c*h*g-d*p*f,this._w=c*h*f+d*p*g;break;case"YZX":this._x=d*h*f+c*p*g,this._y=c*p*f+d*h*g,this._z=c*h*g-d*p*f,this._w=c*h*f-d*p*g;break;case"XZY":this._x=d*h*f-c*p*g,this._y=c*p*f-d*h*g,this._z=c*h*g+d*p*f,this._w=c*h*f+d*p*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,s=Math.sin(i);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],s=t[4],r=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],f=t[10],d=i+a+f;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(h-l)*p,this._y=(r-c)*p,this._z=(o-s)*p}else if(i>a&&i>f){const p=2*Math.sqrt(1+i-a-f);this._w=(h-l)/p,this._x=.25*p,this._y=(s+o)/p,this._z=(r+c)/p}else if(a>f){const p=2*Math.sqrt(1+a-i-f);this._w=(r-c)/p,this._x=(s+o)/p,this._y=.25*p,this._z=(l+h)/p}else{const p=2*Math.sqrt(1+f-i-a);this._w=(o-s)/p,this._x=(r+c)/p,this._y=(l+h)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ai(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const s=Math.min(1,t/i);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,s=e._y,r=e._z,o=e._w,a=t._x,l=t._y,c=t._z,h=t._w;return this._x=i*h+o*a+s*c-r*l,this._y=s*h+o*l+r*a-i*c,this._z=r*h+o*c+i*l-s*a,this._w=o*h-i*a-s*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,s=this._y,r=this._z,o=this._w;let a=o*e._w+i*e._x+s*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=s,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*i+t*this._x,this._y=p*s+t*this._y,this._z=p*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),f=Math.sin((1-t)*h)/c,d=Math.sin(t*h)/c;return this._w=o*f+this._w*d,this._x=i*f+this._x*d,this._y=s*f+this._y*d,this._z=r*f+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),s=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(s),i*Math.sin(r),i*Math.cos(r),t*Math.sin(s))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}u(je,"Quaternion");class P{constructor(e=0,t=0,i=0){P.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(rS.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(rS.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*s,this.y=r[1]*t+r[4]*i+r[7]*s,this.z=r[2]*t+r[5]*i+r[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,s=this.z,r=e.elements,o=1/(r[3]*t+r[7]*i+r[11]*s+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*s+r[12])*o,this.y=(r[1]*t+r[5]*i+r[9]*s+r[13])*o,this.z=(r[2]*t+r[6]*i+r[10]*s+r[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,s=this.z,r=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*s-a*i,h=l*i+a*t-r*s,f=l*s+r*i-o*t,d=-r*t-o*i-a*s;return this.x=c*l+d*-r+h*-a-f*-o,this.y=h*l+d*-o+f*-r-c*-a,this.z=f*l+d*-a+c*-o-h*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*s,this.y=r[1]*t+r[5]*i+r[9]*s,this.z=r[2]*t+r[6]*i+r[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,s=e.y,r=e.z,o=t.x,a=t.y,l=t.z;return this.x=s*l-r*a,this.y=r*o-i*l,this.z=i*a-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Xv.copy(this).projectOnVector(e),this.sub(Xv)}reflect(e){return this.sub(Xv.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(ai(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,s=this.z-e.z;return t*t+i*i+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const s=Math.sin(t)*e;return this.x=s*Math.sin(i),this.y=Math.cos(t)*e,this.z=s*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}u(P,"Vector3");const Xv=new P,rS=new je;class un{constructor(e=new P(1/0,1/0,1/0),t=new P(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,s=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const h=e[l],f=e[l+1],d=e[l+2];h<t&&(t=h),f<i&&(i=f),d<s&&(s=d),h>r&&(r=h),f>o&&(o=f),d>a&&(a=d)}return this.min.set(t,i,s),this.max.set(r,o,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,s=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const h=e.getX(l),f=e.getY(l),d=e.getZ(l);h<t&&(t=h),f<i&&(i=f),d<s&&(s=d),h>r&&(r=h),f>o&&(o=f),d>a&&(a=d)}return this.min.set(t,i,s),this.max.set(r,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=ml.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0)if(t&&i.attributes!=null&&i.attributes.position!==void 0){const r=i.attributes.position;for(let o=0,a=r.count;o<a;o++)ml.fromBufferAttribute(r,o).applyMatrix4(e.matrixWorld),this.expandByPoint(ml)}else i.boundingBox===null&&i.computeBoundingBox(),qv.copy(i.boundingBox),qv.applyMatrix4(e.matrixWorld),this.union(qv);const s=e.children;for(let r=0,o=s.length;r<o;r++)this.expandByObject(s[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,ml),ml.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(af),lm.subVectors(this.max,af),Nc.subVectors(e.a,af),kc.subVectors(e.b,af),zc.subVectors(e.c,af),ua.subVectors(kc,Nc),ha.subVectors(zc,kc),gl.subVectors(Nc,zc);let t=[0,-ua.z,ua.y,0,-ha.z,ha.y,0,-gl.z,gl.y,ua.z,0,-ua.x,ha.z,0,-ha.x,gl.z,0,-gl.x,-ua.y,ua.x,0,-ha.y,ha.x,0,-gl.y,gl.x,0];return!Yv(t,Nc,kc,zc,lm)||(t=[1,0,0,0,1,0,0,0,1],!Yv(t,Nc,kc,zc,lm))?!1:(cm.crossVectors(ua,ha),t=[cm.x,cm.y,cm.z],Yv(t,Nc,kc,zc,lm))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return ml.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(ml).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(ao[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ao[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ao[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ao[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ao[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ao[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ao[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ao[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ao),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}u(un,"Box3");const ao=[new P,new P,new P,new P,new P,new P,new P,new P],ml=new P,qv=new un,Nc=new P,kc=new P,zc=new P,ua=new P,ha=new P,gl=new P,af=new P,lm=new P,cm=new P,vl=new P;function Yv(n,e,t,i,s){for(let r=0,o=n.length-3;r<=o;r+=3){vl.fromArray(n,r);const a=s.x*Math.abs(vl.x)+s.y*Math.abs(vl.y)+s.z*Math.abs(vl.z),l=e.dot(vl),c=t.dot(vl),h=i.dot(vl);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}u(Yv,"satForAxes");const DU=new un,lf=new P,Zv=new P;class na{constructor(e=new P,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):DU.setFromPoints(e).getCenter(i);let s=0;for(let r=0,o=e.length;r<o;r++)s=Math.max(s,i.distanceToSquared(e[r]));return this.radius=Math.sqrt(s),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;lf.subVectors(e,this.center);const t=lf.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),s=(i-this.radius)*.5;this.center.addScaledVector(lf,s/i),this.radius+=s}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Zv.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(lf.copy(e.center).add(Zv)),this.expandByPoint(lf.copy(e.center).sub(Zv))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}u(na,"Sphere");const lo=new P,Kv=new P,um=new P,fa=new P,Qv=new P,hm=new P,Jv=new P;class sl{constructor(e=new P,t=new P(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,lo)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=lo.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(lo.copy(this.direction).multiplyScalar(t).add(this.origin),lo.distanceToSquared(e))}distanceSqToSegment(e,t,i,s){Kv.copy(e).add(t).multiplyScalar(.5),um.copy(t).sub(e).normalize(),fa.copy(this.origin).sub(Kv);const r=e.distanceTo(t)*.5,o=-this.direction.dot(um),a=fa.dot(this.direction),l=-fa.dot(um),c=fa.lengthSq(),h=Math.abs(1-o*o);let f,d,p,g;if(h>0)if(f=o*l-a,d=o*a-l,g=r*h,f>=0)if(d>=-g)if(d<=g){const m=1/h;f*=m,d*=m,p=f*(f+o*d+2*a)+d*(o*f+d+2*l)+c}else d=r,f=Math.max(0,-(o*d+a)),p=-f*f+d*(d+2*l)+c;else d=-r,f=Math.max(0,-(o*d+a)),p=-f*f+d*(d+2*l)+c;else d<=-g?(f=Math.max(0,-(-o*r+a)),d=f>0?-r:Math.min(Math.max(-r,-l),r),p=-f*f+d*(d+2*l)+c):d<=g?(f=0,d=Math.min(Math.max(-r,-l),r),p=d*(d+2*l)+c):(f=Math.max(0,-(o*r+a)),d=f>0?r:Math.min(Math.max(-r,-l),r),p=-f*f+d*(d+2*l)+c);else d=o>0?-r:r,f=Math.max(0,-(o*d+a)),p=-f*f+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(f).add(this.origin),s&&s.copy(um).multiplyScalar(d).add(Kv),p}intersectSphere(e,t){lo.subVectors(e.center,this.origin);const i=lo.dot(this.direction),s=lo.dot(lo)-i*i,r=e.radius*e.radius;if(s>r)return null;const o=Math.sqrt(r-s),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,s,r,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,f=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,s=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,s=(e.min.x-d.x)*c),h>=0?(r=(e.min.y-d.y)*h,o=(e.max.y-d.y)*h):(r=(e.max.y-d.y)*h,o=(e.min.y-d.y)*h),i>o||r>s||((r>i||isNaN(i))&&(i=r),(o<s||isNaN(s))&&(s=o),f>=0?(a=(e.min.z-d.z)*f,l=(e.max.z-d.z)*f):(a=(e.max.z-d.z)*f,l=(e.min.z-d.z)*f),i>l||a>s)||((a>i||i!==i)&&(i=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(i>=0?i:s,t)}intersectsBox(e){return this.intersectBox(e,lo)!==null}intersectTriangle(e,t,i,s,r){Qv.subVectors(t,e),hm.subVectors(i,e),Jv.crossVectors(Qv,hm);let o=this.direction.dot(Jv),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;fa.subVectors(this.origin,e);const l=a*this.direction.dot(hm.crossVectors(fa,hm));if(l<0)return null;const c=a*this.direction.dot(Qv.cross(fa));if(c<0||l+c>o)return null;const h=-a*fa.dot(Jv);return h<0?null:this.at(h/o,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}u(sl,"Ray");class me{constructor(){me.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,i,s,r,o,a,l,c,h,f,d,p,g,m,v){const y=this.elements;return y[0]=e,y[4]=t,y[8]=i,y[12]=s,y[1]=r,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=h,y[10]=f,y[14]=d,y[3]=p,y[7]=g,y[11]=m,y[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new me().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,s=1/Bc.setFromMatrixColumn(e,0).length(),r=1/Bc.setFromMatrixColumn(e,1).length(),o=1/Bc.setFromMatrixColumn(e,2).length();return t[0]=i[0]*s,t[1]=i[1]*s,t[2]=i[2]*s,t[3]=0,t[4]=i[4]*r,t[5]=i[5]*r,t[6]=i[6]*r,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,s=e.y,r=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(s),c=Math.sin(s),h=Math.cos(r),f=Math.sin(r);if(e.order==="XYZ"){const d=o*h,p=o*f,g=a*h,m=a*f;t[0]=l*h,t[4]=-l*f,t[8]=c,t[1]=p+g*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=g+p*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*h,p=l*f,g=c*h,m=c*f;t[0]=d+m*a,t[4]=g*a-p,t[8]=o*c,t[1]=o*f,t[5]=o*h,t[9]=-a,t[2]=p*a-g,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*h,p=l*f,g=c*h,m=c*f;t[0]=d-m*a,t[4]=-o*f,t[8]=g+p*a,t[1]=p+g*a,t[5]=o*h,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*h,p=o*f,g=a*h,m=a*f;t[0]=l*h,t[4]=g*c-p,t[8]=d*c+m,t[1]=l*f,t[5]=m*c+d,t[9]=p*c-g,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*c,g=a*l,m=a*c;t[0]=l*h,t[4]=m-d*f,t[8]=g*f+p,t[1]=f,t[5]=o*h,t[9]=-a*h,t[2]=-c*h,t[6]=p*f+g,t[10]=d-m*f}else if(e.order==="XZY"){const d=o*l,p=o*c,g=a*l,m=a*c;t[0]=l*h,t[4]=-f,t[8]=c*h,t[1]=d*f+m,t[5]=o*h,t[9]=p*f-g,t[2]=g*f-p,t[6]=a*h,t[10]=m*f+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(LU,e,OU)}lookAt(e,t,i){const s=this.elements;return bs.subVectors(e,t),bs.lengthSq()===0&&(bs.z=1),bs.normalize(),da.crossVectors(i,bs),da.lengthSq()===0&&(Math.abs(i.z)===1?bs.x+=1e-4:bs.z+=1e-4,bs.normalize(),da.crossVectors(i,bs)),da.normalize(),fm.crossVectors(bs,da),s[0]=da.x,s[4]=fm.x,s[8]=bs.x,s[1]=da.y,s[5]=fm.y,s[9]=bs.y,s[2]=da.z,s[6]=fm.z,s[10]=bs.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,s=t.elements,r=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],h=i[1],f=i[5],d=i[9],p=i[13],g=i[2],m=i[6],v=i[10],y=i[14],b=i[3],x=i[7],w=i[11],_=i[15],A=s[0],S=s[4],M=s[8],C=s[12],I=s[1],F=s[5],O=s[9],N=s[13],E=s[2],k=s[6],G=s[10],X=s[14],te=s[3],j=s[7],ie=s[11],K=s[15];return r[0]=o*A+a*I+l*E+c*te,r[4]=o*S+a*F+l*k+c*j,r[8]=o*M+a*O+l*G+c*ie,r[12]=o*C+a*N+l*X+c*K,r[1]=h*A+f*I+d*E+p*te,r[5]=h*S+f*F+d*k+p*j,r[9]=h*M+f*O+d*G+p*ie,r[13]=h*C+f*N+d*X+p*K,r[2]=g*A+m*I+v*E+y*te,r[6]=g*S+m*F+v*k+y*j,r[10]=g*M+m*O+v*G+y*ie,r[14]=g*C+m*N+v*X+y*K,r[3]=b*A+x*I+w*E+_*te,r[7]=b*S+x*F+w*k+_*j,r[11]=b*M+x*O+w*G+_*ie,r[15]=b*C+x*N+w*X+_*K,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],s=e[8],r=e[12],o=e[1],a=e[5],l=e[9],c=e[13],h=e[2],f=e[6],d=e[10],p=e[14],g=e[3],m=e[7],v=e[11],y=e[15];return g*(+r*l*f-s*c*f-r*a*d+i*c*d+s*a*p-i*l*p)+m*(+t*l*p-t*c*d+r*o*d-s*o*p+s*c*h-r*l*h)+v*(+t*c*f-t*a*p-r*o*f+i*o*p+r*a*h-i*c*h)+y*(-s*a*h-t*l*f+t*a*d+s*o*f-i*o*d+i*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],f=e[9],d=e[10],p=e[11],g=e[12],m=e[13],v=e[14],y=e[15],b=f*v*c-m*d*c+m*l*p-a*v*p-f*l*y+a*d*y,x=g*d*c-h*v*c-g*l*p+o*v*p+h*l*y-o*d*y,w=h*m*c-g*f*c+g*a*p-o*m*p-h*a*y+o*f*y,_=g*f*l-h*m*l-g*a*d+o*m*d+h*a*v-o*f*v,A=t*b+i*x+s*w+r*_;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/A;return e[0]=b*S,e[1]=(m*d*r-f*v*r-m*s*p+i*v*p+f*s*y-i*d*y)*S,e[2]=(a*v*r-m*l*r+m*s*c-i*v*c-a*s*y+i*l*y)*S,e[3]=(f*l*r-a*d*r-f*s*c+i*d*c+a*s*p-i*l*p)*S,e[4]=x*S,e[5]=(h*v*r-g*d*r+g*s*p-t*v*p-h*s*y+t*d*y)*S,e[6]=(g*l*r-o*v*r-g*s*c+t*v*c+o*s*y-t*l*y)*S,e[7]=(o*d*r-h*l*r+h*s*c-t*d*c-o*s*p+t*l*p)*S,e[8]=w*S,e[9]=(g*f*r-h*m*r-g*i*p+t*m*p+h*i*y-t*f*y)*S,e[10]=(o*m*r-g*a*r+g*i*c-t*m*c-o*i*y+t*a*y)*S,e[11]=(h*a*r-o*f*r-h*i*c+t*f*c+o*i*p-t*a*p)*S,e[12]=_*S,e[13]=(h*m*s-g*f*s+g*i*d-t*m*d-h*i*v+t*f*v)*S,e[14]=(g*a*s-o*m*s-g*i*l+t*m*l+o*i*v-t*a*v)*S,e[15]=(o*f*s-h*a*s+h*i*l-t*f*l-o*i*d+t*a*d)*S,this}scale(e){const t=this.elements,i=e.x,s=e.y,r=e.z;return t[0]*=i,t[4]*=s,t[8]*=r,t[1]*=i,t[5]*=s,t[9]*=r,t[2]*=i,t[6]*=s,t[10]*=r,t[3]*=i,t[7]*=s,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,s))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),s=Math.sin(t),r=1-i,o=e.x,a=e.y,l=e.z,c=r*o,h=r*a;return this.set(c*o+i,c*a-s*l,c*l+s*a,0,c*a+s*l,h*a+i,h*l-s*o,0,c*l-s*a,h*l+s*o,r*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,s,r,o){return this.set(1,i,r,0,e,1,o,0,t,s,1,0,0,0,0,1),this}compose(e,t,i){const s=this.elements,r=t._x,o=t._y,a=t._z,l=t._w,c=r+r,h=o+o,f=a+a,d=r*c,p=r*h,g=r*f,m=o*h,v=o*f,y=a*f,b=l*c,x=l*h,w=l*f,_=i.x,A=i.y,S=i.z;return s[0]=(1-(m+y))*_,s[1]=(p+w)*_,s[2]=(g-x)*_,s[3]=0,s[4]=(p-w)*A,s[5]=(1-(d+y))*A,s[6]=(v+b)*A,s[7]=0,s[8]=(g+x)*S,s[9]=(v-b)*S,s[10]=(1-(d+m))*S,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,i){const s=this.elements;let r=Bc.set(s[0],s[1],s[2]).length();const o=Bc.set(s[4],s[5],s[6]).length(),a=Bc.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),e.x=s[12],e.y=s[13],e.z=s[14],lr.copy(this);const c=1/r,h=1/o,f=1/a;return lr.elements[0]*=c,lr.elements[1]*=c,lr.elements[2]*=c,lr.elements[4]*=h,lr.elements[5]*=h,lr.elements[6]*=h,lr.elements[8]*=f,lr.elements[9]*=f,lr.elements[10]*=f,t.setFromRotationMatrix(lr),i.x=r,i.y=o,i.z=a,this}makePerspective(e,t,i,s,r,o){const a=this.elements,l=2*r/(t-e),c=2*r/(i-s),h=(t+e)/(t-e),f=(i+s)/(i-s),d=-(o+r)/(o-r),p=-2*o*r/(o-r);return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=f,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,s,r,o){const a=this.elements,l=1/(t-e),c=1/(i-s),h=1/(o-r),f=(t+e)*l,d=(i+s)*c,p=(o+r)*h;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-f,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let s=0;s<16;s++)if(t[s]!==i[s])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}u(me,"Matrix4");const Bc=new P,lr=new me,LU=new P(0,0,0),OU=new P(1,1,1),da=new P,fm=new P,bs=new P,oS=new me,aS=new je;class ht{constructor(e=0,t=0,i=0,s=ht.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,s=this._order){return this._x=e,this._y=t,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const s=e.elements,r=s[0],o=s[4],a=s[8],l=s[1],c=s[5],h=s[9],f=s[2],d=s[6],p=s[10];switch(t){case"XYZ":this._y=Math.asin(ai(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-ai(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-f,r),this._z=0);break;case"ZXY":this._x=Math.asin(ai(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-ai(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(ai(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-f,r)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-ai(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return oS.makeRotationFromQuaternion(e),this.setFromRotationMatrix(oS,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return aS.setFromEuler(this),this.setFromQuaternion(aS,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}u(ht,"Euler");ht.DefaultOrder="XYZ";ht.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class P1{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}u(P1,"Layers");let FU=0;const lS=new P,Uc=new je,co=new me,dm=new P,cf=new P,NU=new P,kU=new je,cS=new P(1,0,0),uS=new P(0,1,0),hS=new P(0,0,1),zU={type:"added"},fS={type:"removed"};class It extends Sc{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:FU++}),this.uuid=Ar(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=It.DefaultUp.clone();const e=new P,t=new ht,i=new je,s=new P(1,1,1);function r(){i.setFromEuler(t,!1)}u(r,"onRotationChange");function o(){t.setFromQuaternion(i,void 0,!1)}u(o,"onQuaternionChange"),t._onChange(r),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new me},normalMatrix:{value:new ki}}),this.matrix=new me,this.matrixWorld=new me,this.matrixAutoUpdate=It.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=It.DefaultMatrixWorldAutoUpdate,this.layers=new P1,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Uc.setFromAxisAngle(e,t),this.quaternion.multiply(Uc),this}rotateOnWorldAxis(e,t){return Uc.setFromAxisAngle(e,t),this.quaternion.premultiply(Uc),this}rotateX(e){return this.rotateOnAxis(cS,e)}rotateY(e){return this.rotateOnAxis(uS,e)}rotateZ(e){return this.rotateOnAxis(hS,e)}translateOnAxis(e,t){return lS.copy(e).applyQuaternion(this.quaternion),this.position.add(lS.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(cS,e)}translateY(e){return this.translateOnAxis(uS,e)}translateZ(e){return this.translateOnAxis(hS,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(co.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?dm.copy(e):dm.set(e,t,i);const s=this.parent;this.updateWorldMatrix(!0,!1),cf.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?co.lookAt(cf,dm,this.up):co.lookAt(dm,cf,this.up),this.quaternion.setFromRotationMatrix(co),s&&(co.extractRotation(s.matrixWorld),Uc.setFromRotationMatrix(co),this.quaternion.premultiply(Uc.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(zU)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(fS)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(fS)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),co.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),co.multiply(e.parent.matrixWorld)),e.applyMatrix4(co),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,s=this.children.length;i<s;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(cf,e,NU),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(cf,kU,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,s=t.length;i<s;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,s=t.length;i<s;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,s=t.length;i<s;i++){const r=t[i];(r.matrixWorldAutoUpdate===!0||e===!0)&&r.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.matrixWorldAutoUpdate===!0&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const s=this.children;for(let r=0,o=s.length;r<o;r++){const a=s[r];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(u(r,"serialize"),this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=r(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const f=l[c];r(e.shapes,f)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(e.materials,this.material[l]));s.material=a}else s.material=r(e.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];s.animations.push(r(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),h=o(e.images),f=o(e.shapes),d=o(e.skeletons),p=o(e.animations),g=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),h.length>0&&(i.images=h),f.length>0&&(i.shapes=f),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),g.length>0&&(i.nodes=g)}return i.object=s,i;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}u(o,"extractFromCache")}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const s=e.children[i];this.add(s.clone())}return this}}u(It,"Object3D");It.DefaultUp=new P(0,1,0);It.DefaultMatrixAutoUpdate=!0;It.DefaultMatrixWorldAutoUpdate=!0;const cr=new P,uo=new P,ey=new P,ho=new P,$c=new P,Vc=new P,dS=new P,ty=new P,ny=new P,iy=new P;class Ls{constructor(e=new P,t=new P,i=new P){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,s){s.subVectors(i,t),cr.subVectors(e,t),s.cross(cr);const r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)}static getBarycoord(e,t,i,s,r){cr.subVectors(s,t),uo.subVectors(i,t),ey.subVectors(e,t);const o=cr.dot(cr),a=cr.dot(uo),l=cr.dot(ey),c=uo.dot(uo),h=uo.dot(ey),f=o*c-a*a;if(f===0)return r.set(-2,-1,-1);const d=1/f,p=(c*l-a*h)*d,g=(o*h-a*l)*d;return r.set(1-p-g,g,p)}static containsPoint(e,t,i,s){return this.getBarycoord(e,t,i,s,ho),ho.x>=0&&ho.y>=0&&ho.x+ho.y<=1}static getUV(e,t,i,s,r,o,a,l){return this.getBarycoord(e,t,i,s,ho),l.set(0,0),l.addScaledVector(r,ho.x),l.addScaledVector(o,ho.y),l.addScaledVector(a,ho.z),l}static isFrontFacing(e,t,i,s){return cr.subVectors(i,t),uo.subVectors(e,t),cr.cross(uo).dot(s)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,s){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[s]),this}setFromAttributeAndIndices(e,t,i,s){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return cr.subVectors(this.c,this.b),uo.subVectors(this.a,this.b),cr.cross(uo).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ls.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ls.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,s,r){return Ls.getUV(e,this.a,this.b,this.c,t,i,s,r)}containsPoint(e){return Ls.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ls.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,s=this.b,r=this.c;let o,a;$c.subVectors(s,i),Vc.subVectors(r,i),ty.subVectors(e,i);const l=$c.dot(ty),c=Vc.dot(ty);if(l<=0&&c<=0)return t.copy(i);ny.subVectors(e,s);const h=$c.dot(ny),f=Vc.dot(ny);if(h>=0&&f<=h)return t.copy(s);const d=l*f-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),t.copy(i).addScaledVector($c,o);iy.subVectors(e,r);const p=$c.dot(iy),g=Vc.dot(iy);if(g>=0&&p<=g)return t.copy(r);const m=p*c-l*g;if(m<=0&&c>=0&&g<=0)return a=c/(c-g),t.copy(i).addScaledVector(Vc,a);const v=h*g-p*f;if(v<=0&&f-h>=0&&p-g>=0)return dS.subVectors(r,s),a=(f-h)/(f-h+(p-g)),t.copy(s).addScaledVector(dS,a);const y=1/(v+m+d);return o=m*y,a=d*y,t.copy(i).addScaledVector($c,o).addScaledVector(Vc,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}u(Ls,"Triangle");let BU=0;class ns extends Sc{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:BU++}),this.uuid=Ar(),this.name="",this.type="Material",this.blending=nc,this.side=eo,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=KR,this.blendDst=QR,this.blendEquation=Su,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=bx,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=vU,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Hv,this.stencilZFail=Hv,this.stencilZPass=Hv,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}const s=this[t];if(s===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==nc&&(i.blending=this.blending),this.side!==eo&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function s(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(u(s,"extractFromCache"),t){const r=s(e.textures),o=s(e.images);r.length>0&&(i.textures=r),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const s=t.length;i=new Array(s);for(let r=0;r!==s;++r)i[r]=t[r].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}u(ns,"Material");class xi extends ns{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ce(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=C1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}u(xi,"MeshBasicMaterial");const Kn=new P,pm=new Ie;class Rt{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i===!0,this.usage=wx,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let s=0,r=this.itemSize;s<r;s++)this.array[e+s]=t.array[i+s];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)pm.fromBufferAttribute(this,t),pm.applyMatrix3(e),this.setXY(t,pm.x,pm.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Kn.fromBufferAttribute(this,t),Kn.applyMatrix3(e),this.setXYZ(t,Kn.x,Kn.y,Kn.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Kn.fromBufferAttribute(this,t),Kn.applyMatrix4(e),this.setXYZ(t,Kn.x,Kn.y,Kn.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Kn.fromBufferAttribute(this,t),Kn.applyNormalMatrix(e),this.setXYZ(t,Kn.x,Kn.y,Kn.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Kn.fromBufferAttribute(this,t),Kn.transformDirection(e),this.setXYZ(t,Kn.x,Kn.y,Kn.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Uo(t,this.array)),t}setX(e,t){return this.normalized&&(t=sn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Uo(t,this.array)),t}setY(e,t){return this.normalized&&(t=sn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Uo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=sn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Uo(t,this.array)),t}setW(e,t){return this.normalized&&(t=sn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array)),this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,s){return e*=this.itemSize,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array),s=sn(s,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=s,this}setXYZW(e,t,i,s,r){return e*=this.itemSize,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array),s=sn(s,this.array),r=sn(r,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=s,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==wx&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}u(Rt,"BufferAttribute");class R1 extends Rt{constructor(e,t,i){super(new Uint16Array(e),t,i)}}u(R1,"Uint16BufferAttribute");class z_ extends Rt{constructor(e,t,i){super(new Uint32Array(e),t,i)}}u(z_,"Uint32BufferAttribute");class Ve extends Rt{constructor(e,t,i){super(new Float32Array(e),t,i)}}u(Ve,"Float32BufferAttribute");let UU=0;const Vs=new me,sy=new It,Hc=new P,xs=new un,uf=new un,mi=new P;class Je extends Sc{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:UU++}),this.uuid=Ar(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(oI(e)?z_:R1)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new ki().getNormalMatrix(e);i.applyNormalMatrix(r),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(e),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Vs.makeRotationFromQuaternion(e),this.applyMatrix4(Vs),this}rotateX(e){return Vs.makeRotationX(e),this.applyMatrix4(Vs),this}rotateY(e){return Vs.makeRotationY(e),this.applyMatrix4(Vs),this}rotateZ(e){return Vs.makeRotationZ(e),this.applyMatrix4(Vs),this}translate(e,t,i){return Vs.makeTranslation(e,t,i),this.applyMatrix4(Vs),this}scale(e,t,i){return Vs.makeScale(e,t,i),this.applyMatrix4(Vs),this}lookAt(e){return sy.lookAt(e),sy.updateMatrix(),this.applyMatrix4(sy.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Hc).negate(),this.translate(Hc.x,Hc.y,Hc.z),this}setFromPoints(e){const t=[];for(let i=0,s=e.length;i<s;i++){const r=e[i];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ve(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new un);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new P(-1/0,-1/0,-1/0),new P(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,s=t.length;i<s;i++){const r=t[i];xs.setFromBufferAttribute(r),this.morphTargetsRelative?(mi.addVectors(this.boundingBox.min,xs.min),this.boundingBox.expandByPoint(mi),mi.addVectors(this.boundingBox.max,xs.max),this.boundingBox.expandByPoint(mi)):(this.boundingBox.expandByPoint(xs.min),this.boundingBox.expandByPoint(xs.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new na);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new P,1/0);return}if(e){const i=this.boundingSphere.center;if(xs.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++){const a=t[r];uf.setFromBufferAttribute(a),this.morphTargetsRelative?(mi.addVectors(xs.min,uf.min),xs.expandByPoint(mi),mi.addVectors(xs.max,uf.max),xs.expandByPoint(mi)):(xs.expandByPoint(uf.min),xs.expandByPoint(uf.max))}xs.getCenter(i);let s=0;for(let r=0,o=e.count;r<o;r++)mi.fromBufferAttribute(e,r),s=Math.max(s,i.distanceToSquared(mi));if(t)for(let r=0,o=t.length;r<o;r++){const a=t[r],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)mi.fromBufferAttribute(a,c),l&&(Hc.fromBufferAttribute(e,c),mi.add(Hc)),s=Math.max(s,i.distanceToSquared(mi))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,s=t.position.array,r=t.normal.array,o=t.uv.array,a=s.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Rt(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],h=[];for(let I=0;I<a;I++)c[I]=new P,h[I]=new P;const f=new P,d=new P,p=new P,g=new Ie,m=new Ie,v=new Ie,y=new P,b=new P;function x(I,F,O){f.fromArray(s,I*3),d.fromArray(s,F*3),p.fromArray(s,O*3),g.fromArray(o,I*2),m.fromArray(o,F*2),v.fromArray(o,O*2),d.sub(f),p.sub(f),m.sub(g),v.sub(g);const N=1/(m.x*v.y-v.x*m.y);!isFinite(N)||(y.copy(d).multiplyScalar(v.y).addScaledVector(p,-m.y).multiplyScalar(N),b.copy(p).multiplyScalar(m.x).addScaledVector(d,-v.x).multiplyScalar(N),c[I].add(y),c[F].add(y),c[O].add(y),h[I].add(b),h[F].add(b),h[O].add(b))}u(x,"handleTriangle");let w=this.groups;w.length===0&&(w=[{start:0,count:i.length}]);for(let I=0,F=w.length;I<F;++I){const O=w[I],N=O.start,E=O.count;for(let k=N,G=N+E;k<G;k+=3)x(i[k+0],i[k+1],i[k+2])}const _=new P,A=new P,S=new P,M=new P;function C(I){S.fromArray(r,I*3),M.copy(S);const F=c[I];_.copy(F),_.sub(S.multiplyScalar(S.dot(F))).normalize(),A.crossVectors(M,F);const N=A.dot(h[I])<0?-1:1;l[I*4]=_.x,l[I*4+1]=_.y,l[I*4+2]=_.z,l[I*4+3]=N}u(C,"handleVertex");for(let I=0,F=w.length;I<F;++I){const O=w[I],N=O.start,E=O.count;for(let k=N,G=N+E;k<G;k+=3)C(i[k+0]),C(i[k+1]),C(i[k+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new Rt(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const s=new P,r=new P,o=new P,a=new P,l=new P,c=new P,h=new P,f=new P;if(e)for(let d=0,p=e.count;d<p;d+=3){const g=e.getX(d+0),m=e.getX(d+1),v=e.getX(d+2);s.fromBufferAttribute(t,g),r.fromBufferAttribute(t,m),o.fromBufferAttribute(t,v),h.subVectors(o,r),f.subVectors(s,r),h.cross(f),a.fromBufferAttribute(i,g),l.fromBufferAttribute(i,m),c.fromBufferAttribute(i,v),a.add(h),l.add(h),c.add(h),i.setXYZ(g,a.x,a.y,a.z),i.setXYZ(m,l.x,l.y,l.z),i.setXYZ(v,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)s.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),h.subVectors(o,r),f.subVectors(s,r),h.cross(f),i.setXYZ(d+0,h.x,h.y,h.z),i.setXYZ(d+1,h.x,h.y,h.z),i.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)mi.fromBufferAttribute(e,t),mi.normalize(),e.setXYZ(t,mi.x,mi.y,mi.z)}toNonIndexed(){function e(a,l){const c=a.array,h=a.itemSize,f=a.normalized,d=new c.constructor(l.length*h);let p=0,g=0;for(let m=0,v=l.length;m<v;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*h;for(let y=0;y<h;y++)d[g++]=c[p++]}return new Rt(d,h,f)}if(u(e,"convertBufferAttribute"),this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Je,i=this.index.array,s=this.attributes;for(const a in s){const l=s[a],c=e(l,i);t.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let h=0,f=c.length;h<f;h++){const d=c[h],p=e(d,i);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const c=i[l];e.data.attributes[l]=c.toJSON(e.data)}const s={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let f=0,d=c.length;f<d;f++){const p=c[f];h.push(p.toJSON(e.data))}h.length>0&&(s[l]=h,r=!0)}r&&(e.data.morphAttributes=s,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const s=e.attributes;for(const c in s){const h=s[c];this.setAttribute(c,h.clone(t))}const r=e.morphAttributes;for(const c in r){const h=[],f=r[c];for(let d=0,p=f.length;d<p;d++)h.push(f[d].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,h=o.length;c<h;c++){const f=o[c];this.addGroup(f.start,f.count,f.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}u(Je,"BufferGeometry");const pS=new me,Gc=new sl,ry=new na,pa=new P,ma=new P,ga=new P,oy=new P,ay=new P,ly=new P,mm=new P,gm=new P,vm=new P,ym=new Ie,bm=new Ie,xm=new Ie,cy=new P,_m=new P;class We extends It{constructor(e=new Je,t=new xi){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}raycast(e,t){const i=this.geometry,s=this.material,r=this.matrixWorld;if(s===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),ry.copy(i.boundingSphere),ry.applyMatrix4(r),e.ray.intersectsSphere(ry)===!1)||(pS.copy(r).invert(),Gc.copy(e.ray).applyMatrix4(pS),i.boundingBox!==null&&Gc.intersectsBox(i.boundingBox)===!1))return;let o;const a=i.index,l=i.attributes.position,c=i.morphAttributes.position,h=i.morphTargetsRelative,f=i.attributes.uv,d=i.attributes.uv2,p=i.groups,g=i.drawRange;if(a!==null)if(Array.isArray(s))for(let m=0,v=p.length;m<v;m++){const y=p[m],b=s[y.materialIndex],x=Math.max(y.start,g.start),w=Math.min(a.count,Math.min(y.start+y.count,g.start+g.count));for(let _=x,A=w;_<A;_+=3){const S=a.getX(_),M=a.getX(_+1),C=a.getX(_+2);o=wm(this,b,e,Gc,l,c,h,f,d,S,M,C),o&&(o.faceIndex=Math.floor(_/3),o.face.materialIndex=y.materialIndex,t.push(o))}}else{const m=Math.max(0,g.start),v=Math.min(a.count,g.start+g.count);for(let y=m,b=v;y<b;y+=3){const x=a.getX(y),w=a.getX(y+1),_=a.getX(y+2);o=wm(this,s,e,Gc,l,c,h,f,d,x,w,_),o&&(o.faceIndex=Math.floor(y/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(s))for(let m=0,v=p.length;m<v;m++){const y=p[m],b=s[y.materialIndex],x=Math.max(y.start,g.start),w=Math.min(l.count,Math.min(y.start+y.count,g.start+g.count));for(let _=x,A=w;_<A;_+=3){const S=_,M=_+1,C=_+2;o=wm(this,b,e,Gc,l,c,h,f,d,S,M,C),o&&(o.faceIndex=Math.floor(_/3),o.face.materialIndex=y.materialIndex,t.push(o))}}else{const m=Math.max(0,g.start),v=Math.min(l.count,g.start+g.count);for(let y=m,b=v;y<b;y+=3){const x=y,w=y+1,_=y+2;o=wm(this,s,e,Gc,l,c,h,f,d,x,w,_),o&&(o.faceIndex=Math.floor(y/3),t.push(o))}}}}u(We,"Mesh");function $U(n,e,t,i,s,r,o,a){let l;if(e.side===ms?l=i.intersectTriangle(o,r,s,!0,a):l=i.intersectTriangle(s,r,o,e.side!==Ki,a),l===null)return null;_m.copy(a),_m.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(_m);return c<t.near||c>t.far?null:{distance:c,point:_m.clone(),object:n}}u($U,"checkIntersection$1");function wm(n,e,t,i,s,r,o,a,l,c,h,f){pa.fromBufferAttribute(s,c),ma.fromBufferAttribute(s,h),ga.fromBufferAttribute(s,f);const d=n.morphTargetInfluences;if(r&&d){mm.set(0,0,0),gm.set(0,0,0),vm.set(0,0,0);for(let g=0,m=r.length;g<m;g++){const v=d[g],y=r[g];v!==0&&(oy.fromBufferAttribute(y,c),ay.fromBufferAttribute(y,h),ly.fromBufferAttribute(y,f),o?(mm.addScaledVector(oy,v),gm.addScaledVector(ay,v),vm.addScaledVector(ly,v)):(mm.addScaledVector(oy.sub(pa),v),gm.addScaledVector(ay.sub(ma),v),vm.addScaledVector(ly.sub(ga),v)))}pa.add(mm),ma.add(gm),ga.add(vm)}n.isSkinnedMesh&&(n.boneTransform(c,pa),n.boneTransform(h,ma),n.boneTransform(f,ga));const p=$U(n,e,t,i,pa,ma,ga,cy);if(p){a&&(ym.fromBufferAttribute(a,c),bm.fromBufferAttribute(a,h),xm.fromBufferAttribute(a,f),p.uv=Ls.getUV(cy,pa,ma,ga,ym,bm,xm,new Ie)),l&&(ym.fromBufferAttribute(l,c),bm.fromBufferAttribute(l,h),xm.fromBufferAttribute(l,f),p.uv2=Ls.getUV(cy,pa,ma,ga,ym,bm,xm,new Ie));const g={a:c,b:h,c:f,normal:new P,materialIndex:0};Ls.getNormal(pa,ma,ga,g.normal),p.face=g}return p}u(wm,"checkBufferGeometryIntersection$1");class br extends Je{constructor(e=1,t=1,i=1,s=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:s,heightSegments:r,depthSegments:o};const a=this;s=Math.floor(s),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],h=[],f=[];let d=0,p=0;g("z","y","x",-1,-1,i,t,e,o,r,0),g("z","y","x",1,-1,i,t,-e,o,r,1),g("x","z","y",1,1,e,i,t,s,o,2),g("x","z","y",1,-1,e,i,-t,s,o,3),g("x","y","z",1,-1,e,t,i,s,r,4),g("x","y","z",-1,-1,e,t,-i,s,r,5),this.setIndex(l),this.setAttribute("position",new Ve(c,3)),this.setAttribute("normal",new Ve(h,3)),this.setAttribute("uv",new Ve(f,2));function g(m,v,y,b,x,w,_,A,S,M,C){const I=w/S,F=_/M,O=w/2,N=_/2,E=A/2,k=S+1,G=M+1;let X=0,te=0;const j=new P;for(let ie=0;ie<G;ie++){const K=ie*F-N;for(let $=0;$<k;$++){const le=$*I-O;j[m]=le*b,j[v]=K*x,j[y]=E,c.push(j.x,j.y,j.z),j[m]=0,j[v]=0,j[y]=A>0?1:-1,h.push(j.x,j.y,j.z),f.push($/S),f.push(1-ie/M),X+=1}}for(let ie=0;ie<M;ie++)for(let K=0;K<S;K++){const $=d+K+k*ie,le=d+K+k*(ie+1),ae=d+(K+1)+k*(ie+1),J=d+(K+1)+k*ie;l.push($,le,J),l.push(le,ae,J),te+=6}a.addGroup(p,te,C),p+=te,d+=X}u(g,"buildPlane")}static fromJSON(e){return new br(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}u(br,"BoxGeometry");function rh(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const s=n[t][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?e[t][i]=s.clone():Array.isArray(s)?e[t][i]=s.slice():e[t][i]=s}}return e}u(rh,"cloneUniforms");function ji(n){const e={};for(let t=0;t<n.length;t++){const i=rh(n[t]);for(const s in i)e[s]=i[s]}return e}u(ji,"mergeUniforms");function VU(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}u(VU,"cloneUniformsGroups");const I1={clone:rh,merge:ji};var HU=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,GU=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Ci extends ns{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=HU,this.fragmentShader=GU,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=rh(e.uniforms),this.uniformsGroups=VU(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const s in this.uniforms){const o=this.uniforms[s].value;o&&o.isTexture?t.uniforms[s]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[s]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[s]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[s]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[s]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[s]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[s]={type:"m4",value:o.toArray()}:t.uniforms[s]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}u(Ci,"ShaderMaterial");class D1 extends It{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new me,this.projectionMatrix=new me,this.projectionMatrixInverse=new me}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}u(D1,"Camera");class li extends D1{constructor(e=50,t=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=np*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(zd*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return np*2*Math.atan(Math.tan(zd*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,s,r,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(zd*.5*this.fov)/this.zoom,i=2*t,s=this.aspect*i,r=-.5*s;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*s/l,t-=o.offsetY*i/c,s*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(r+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+s,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}u(li,"PerspectiveCamera");const Wc=90,jc=1;class cI extends It{constructor(e,t,i){super(),this.type="CubeCamera",this.renderTarget=i;const s=new li(Wc,jc,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new P(1,0,0)),this.add(s);const r=new li(Wc,jc,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new P(-1,0,0)),this.add(r);const o=new li(Wc,jc,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new P(0,1,0)),this.add(o);const a=new li(Wc,jc,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new P(0,-1,0)),this.add(a);const l=new li(Wc,jc,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new P(0,0,1)),this.add(l);const c=new li(Wc,jc,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new P(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[s,r,o,a,l,c]=this.children,h=e.getRenderTarget(),f=e.toneMapping,d=e.xr.enabled;e.toneMapping=Qs,e.xr.enabled=!1;const p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,s),e.setRenderTarget(i,1),e.render(t,r),e.setRenderTarget(i,2),e.render(t,o),e.setRenderTarget(i,3),e.render(t,a),e.setRenderTarget(i,4),e.render(t,l),i.texture.generateMipmaps=p,e.setRenderTarget(i,5),e.render(t,c),e.setRenderTarget(h),e.toneMapping=f,e.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}u(cI,"CubeCamera");class B_ extends ui{constructor(e,t,i,s,r,o,a,l,c,h){e=e!==void 0?e:[],t=t!==void 0?t:eh,super(e,t,i,s,r,o,a,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}u(B_,"CubeTexture");class uI extends Ln{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},s=[i,i,i,i,i,i];this.texture=new B_(s,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Zt}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new br(5,5,5),r=new Ci({name:"CubemapFromEquirect",uniforms:rh(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:ms,blending:Ns});r.uniforms.tEquirect.value=t;const o=new We(s,r),a=t.minFilter;return t.minFilter===Mc&&(t.minFilter=Zt),new cI(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,s){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,s);e.setRenderTarget(r)}}u(uI,"WebGLCubeRenderTarget");const uy=new P,WU=new P,jU=new ki;class gr{constructor(e=new P(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,s){return this.normal.set(e,t,i),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const s=uy.subVectors(i,t).cross(WU.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(uy),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:t.copy(i).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||jU.getNormalMatrix(e),s=this.coplanarPoint(uy).applyMatrix4(e),r=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}u(gr,"Plane$1");const Xc=new na,Am=new P;class Dp{constructor(e=new gr,t=new gr,i=new gr,s=new gr,r=new gr,o=new gr){this.planes=[e,t,i,s,r,o]}set(e,t,i,s,r,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(s),a[4].copy(r),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,s=i[0],r=i[1],o=i[2],a=i[3],l=i[4],c=i[5],h=i[6],f=i[7],d=i[8],p=i[9],g=i[10],m=i[11],v=i[12],y=i[13],b=i[14],x=i[15];return t[0].setComponents(a-s,f-l,m-d,x-v).normalize(),t[1].setComponents(a+s,f+l,m+d,x+v).normalize(),t[2].setComponents(a+r,f+c,m+p,x+y).normalize(),t[3].setComponents(a-r,f-c,m-p,x-y).normalize(),t[4].setComponents(a-o,f-h,m-g,x-b).normalize(),t[5].setComponents(a+o,f+h,m+g,x+b).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Xc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Xc)}intersectsSprite(e){return Xc.center.set(0,0,0),Xc.radius=.7071067811865476,Xc.applyMatrix4(e.matrixWorld),this.intersectsSphere(Xc)}intersectsSphere(e){const t=this.planes,i=e.center,s=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(i)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const s=t[i];if(Am.x=s.normal.x>0?e.max.x:e.min.x,Am.y=s.normal.y>0?e.max.y:e.min.y,Am.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(Am)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}u(Dp,"Frustum");function hI(){let n=null,e=!1,t=null,i=null;function s(r,o){t(r,o),i=n.requestAnimationFrame(s)}return u(s,"onAnimationFrame"),{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}u(hI,"WebGLAnimation");function XU(n,e){const t=e.isWebGL2,i=new WeakMap;function s(c,h){const f=c.array,d=c.usage,p=n.createBuffer();n.bindBuffer(h,p),n.bufferData(h,f,d),c.onUploadCallback();let g;if(f instanceof Float32Array)g=5126;else if(f instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)g=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else g=5123;else if(f instanceof Int16Array)g=5122;else if(f instanceof Uint32Array)g=5125;else if(f instanceof Int32Array)g=5124;else if(f instanceof Int8Array)g=5120;else if(f instanceof Uint8Array)g=5121;else if(f instanceof Uint8ClampedArray)g=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+f);return{buffer:p,type:g,bytesPerElement:f.BYTES_PER_ELEMENT,version:c.version}}u(s,"createBuffer");function r(c,h,f){const d=h.array,p=h.updateRange;n.bindBuffer(f,c),p.count===-1?n.bufferSubData(f,0,d):(t?n.bufferSubData(f,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(f,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}u(r,"updateBuffer");function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}u(o,"get");function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h&&(n.deleteBuffer(h.buffer),i.delete(c))}u(a,"remove");function l(c,h){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const f=i.get(c);f===void 0?i.set(c,s(c,h)):f.version<c.version&&(r(f.buffer,c,h),f.version=c.version)}return u(l,"update"),{get:o,remove:a,update:l}}u(XU,"WebGLAttributes");class oh extends Je{constructor(e=1,t=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:s};const r=e/2,o=t/2,a=Math.floor(i),l=Math.floor(s),c=a+1,h=l+1,f=e/a,d=t/l,p=[],g=[],m=[],v=[];for(let y=0;y<h;y++){const b=y*d-o;for(let x=0;x<c;x++){const w=x*f-r;g.push(w,-b,0),m.push(0,0,1),v.push(x/a),v.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const x=b+c*y,w=b+c*(y+1),_=b+1+c*(y+1),A=b+1+c*y;p.push(x,w,A),p.push(w,_,A)}this.setIndex(p),this.setAttribute("position",new Ve(g,3)),this.setAttribute("normal",new Ve(m,3)),this.setAttribute("uv",new Ve(v,2))}static fromJSON(e){return new oh(e.width,e.height,e.widthSegments,e.heightSegments)}}u(oh,"PlaneGeometry");var qU=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,YU=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ZU=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,KU=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,QU=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,JU=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,e6="vec3 transformed = vec3( position );",t6=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,n6=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,i6=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,s6=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,r6=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,o6=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,a6=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,l6=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,c6=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,u6=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,h6=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,f6=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,d6=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,p6=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,m6=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,g6=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,v6=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,y6=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,b6=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,x6="gl_FragColor = linearToOutputTexel( gl_FragColor );",_6=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,w6=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,A6=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,M6=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,S6=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,T6=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,C6=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,E6=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,P6=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,R6=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,I6=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,D6=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,L6=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,O6=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,F6=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`,N6=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,k6=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,z6=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,B6=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,U6=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,$6=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,V6=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,H6=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,G6=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,W6=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,j6=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,X6=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,q6=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Y6=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Z6=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,K6=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Q6=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,J6=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,e$=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,t$=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,n$=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,i$=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,s$=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,r$=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,o$=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,a$=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,l$=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,c$=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,u$=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,h$=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,f$=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,d$=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,p$=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,m$=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,g$=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,v$=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,y$=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,b$=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,x$=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,_$=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,w$=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,A$=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,M$=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,S$=`#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,T$=`#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,C$=`#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,E$=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,P$=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,R$=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,I$=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,D$=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,L$=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,O$=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,F$=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,N$=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,k$=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,z$=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,B$=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,U$=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,$$=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,V$=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,H$=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,G$=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,W$=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const j$=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,X$=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,q$=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Y$=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Z$=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,K$=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Q$=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,J$=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,eV=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,tV=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,nV=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,iV=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sV=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,rV=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,oV=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,aV=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,lV=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,cV=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uV=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,hV=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fV=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,dV=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,pV=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,mV=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gV=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,vV=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,yV=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bV=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xV=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,_V=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,wV=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,AV=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,MV=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,SV=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,bt={alphamap_fragment:qU,alphamap_pars_fragment:YU,alphatest_fragment:ZU,alphatest_pars_fragment:KU,aomap_fragment:QU,aomap_pars_fragment:JU,begin_vertex:e6,beginnormal_vertex:t6,bsdfs:n6,iridescence_fragment:i6,bumpmap_pars_fragment:s6,clipping_planes_fragment:r6,clipping_planes_pars_fragment:o6,clipping_planes_pars_vertex:a6,clipping_planes_vertex:l6,color_fragment:c6,color_pars_fragment:u6,color_pars_vertex:h6,color_vertex:f6,common:d6,cube_uv_reflection_fragment:p6,defaultnormal_vertex:m6,displacementmap_pars_vertex:g6,displacementmap_vertex:v6,emissivemap_fragment:y6,emissivemap_pars_fragment:b6,encodings_fragment:x6,encodings_pars_fragment:_6,envmap_fragment:w6,envmap_common_pars_fragment:A6,envmap_pars_fragment:M6,envmap_pars_vertex:S6,envmap_physical_pars_fragment:k6,envmap_vertex:T6,fog_vertex:C6,fog_pars_vertex:E6,fog_fragment:P6,fog_pars_fragment:R6,gradientmap_pars_fragment:I6,lightmap_fragment:D6,lightmap_pars_fragment:L6,lights_lambert_fragment:O6,lights_lambert_pars_fragment:F6,lights_pars_begin:N6,lights_toon_fragment:z6,lights_toon_pars_fragment:B6,lights_phong_fragment:U6,lights_phong_pars_fragment:$6,lights_physical_fragment:V6,lights_physical_pars_fragment:H6,lights_fragment_begin:G6,lights_fragment_maps:W6,lights_fragment_end:j6,logdepthbuf_fragment:X6,logdepthbuf_pars_fragment:q6,logdepthbuf_pars_vertex:Y6,logdepthbuf_vertex:Z6,map_fragment:K6,map_pars_fragment:Q6,map_particle_fragment:J6,map_particle_pars_fragment:e$,metalnessmap_fragment:t$,metalnessmap_pars_fragment:n$,morphcolor_vertex:i$,morphnormal_vertex:s$,morphtarget_pars_vertex:r$,morphtarget_vertex:o$,normal_fragment_begin:a$,normal_fragment_maps:l$,normal_pars_fragment:c$,normal_pars_vertex:u$,normal_vertex:h$,normalmap_pars_fragment:f$,clearcoat_normal_fragment_begin:d$,clearcoat_normal_fragment_maps:p$,clearcoat_pars_fragment:m$,iridescence_pars_fragment:g$,output_fragment:v$,packing:y$,premultiplied_alpha_fragment:b$,project_vertex:x$,dithering_fragment:_$,dithering_pars_fragment:w$,roughnessmap_fragment:A$,roughnessmap_pars_fragment:M$,shadowmap_pars_fragment:S$,shadowmap_pars_vertex:T$,shadowmap_vertex:C$,shadowmask_pars_fragment:E$,skinbase_vertex:P$,skinning_pars_vertex:R$,skinning_vertex:I$,skinnormal_vertex:D$,specularmap_fragment:L$,specularmap_pars_fragment:O$,tonemapping_fragment:F$,tonemapping_pars_fragment:N$,transmission_fragment:k$,transmission_pars_fragment:z$,uv_pars_fragment:B$,uv_pars_vertex:U$,uv_vertex:$$,uv2_pars_fragment:V$,uv2_pars_vertex:H$,uv2_vertex:G$,worldpos_vertex:W$,background_vert:j$,background_frag:X$,backgroundCube_vert:q$,backgroundCube_frag:Y$,cube_vert:Z$,cube_frag:K$,depth_vert:Q$,depth_frag:J$,distanceRGBA_vert:eV,distanceRGBA_frag:tV,equirect_vert:nV,equirect_frag:iV,linedashed_vert:sV,linedashed_frag:rV,meshbasic_vert:oV,meshbasic_frag:aV,meshlambert_vert:lV,meshlambert_frag:cV,meshmatcap_vert:uV,meshmatcap_frag:hV,meshnormal_vert:fV,meshnormal_frag:dV,meshphong_vert:pV,meshphong_frag:mV,meshphysical_vert:gV,meshphysical_frag:vV,meshtoon_vert:yV,meshtoon_frag:bV,points_vert:xV,points_frag:_V,shadow_vert:wV,shadow_frag:AV,sprite_vert:MV,sprite_frag:SV},Oe={common:{diffuse:{value:new Ce(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ki},uv2Transform:{value:new ki},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Ie(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ce(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ce(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ki}},sprite:{diffuse:{value:new Ce(16777215)},opacity:{value:1},center:{value:new Ie(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ki}}},Hr={basic:{uniforms:ji([Oe.common,Oe.specularmap,Oe.envmap,Oe.aomap,Oe.lightmap,Oe.fog]),vertexShader:bt.meshbasic_vert,fragmentShader:bt.meshbasic_frag},lambert:{uniforms:ji([Oe.common,Oe.specularmap,Oe.envmap,Oe.aomap,Oe.lightmap,Oe.emissivemap,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,Oe.fog,Oe.lights,{emissive:{value:new Ce(0)}}]),vertexShader:bt.meshlambert_vert,fragmentShader:bt.meshlambert_frag},phong:{uniforms:ji([Oe.common,Oe.specularmap,Oe.envmap,Oe.aomap,Oe.lightmap,Oe.emissivemap,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,Oe.fog,Oe.lights,{emissive:{value:new Ce(0)},specular:{value:new Ce(1118481)},shininess:{value:30}}]),vertexShader:bt.meshphong_vert,fragmentShader:bt.meshphong_frag},standard:{uniforms:ji([Oe.common,Oe.envmap,Oe.aomap,Oe.lightmap,Oe.emissivemap,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,Oe.roughnessmap,Oe.metalnessmap,Oe.fog,Oe.lights,{emissive:{value:new Ce(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:bt.meshphysical_vert,fragmentShader:bt.meshphysical_frag},toon:{uniforms:ji([Oe.common,Oe.aomap,Oe.lightmap,Oe.emissivemap,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,Oe.gradientmap,Oe.fog,Oe.lights,{emissive:{value:new Ce(0)}}]),vertexShader:bt.meshtoon_vert,fragmentShader:bt.meshtoon_frag},matcap:{uniforms:ji([Oe.common,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,Oe.fog,{matcap:{value:null}}]),vertexShader:bt.meshmatcap_vert,fragmentShader:bt.meshmatcap_frag},points:{uniforms:ji([Oe.points,Oe.fog]),vertexShader:bt.points_vert,fragmentShader:bt.points_frag},dashed:{uniforms:ji([Oe.common,Oe.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:bt.linedashed_vert,fragmentShader:bt.linedashed_frag},depth:{uniforms:ji([Oe.common,Oe.displacementmap]),vertexShader:bt.depth_vert,fragmentShader:bt.depth_frag},normal:{uniforms:ji([Oe.common,Oe.bumpmap,Oe.normalmap,Oe.displacementmap,{opacity:{value:1}}]),vertexShader:bt.meshnormal_vert,fragmentShader:bt.meshnormal_frag},sprite:{uniforms:ji([Oe.sprite,Oe.fog]),vertexShader:bt.sprite_vert,fragmentShader:bt.sprite_frag},background:{uniforms:{uvTransform:{value:new ki},t2D:{value:null}},vertexShader:bt.background_vert,fragmentShader:bt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0}},vertexShader:bt.backgroundCube_vert,fragmentShader:bt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:bt.cube_vert,fragmentShader:bt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:bt.equirect_vert,fragmentShader:bt.equirect_frag},distanceRGBA:{uniforms:ji([Oe.common,Oe.displacementmap,{referencePosition:{value:new P},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:bt.distanceRGBA_vert,fragmentShader:bt.distanceRGBA_frag},shadow:{uniforms:ji([Oe.lights,Oe.fog,{color:{value:new Ce(0)},opacity:{value:1}}]),vertexShader:bt.shadow_vert,fragmentShader:bt.shadow_frag}};Hr.physical={uniforms:ji([Hr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Ie(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Ce(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Ie},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Ce(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Ce(1,1,1)},specularColorMap:{value:null}}]),vertexShader:bt.meshphysical_vert,fragmentShader:bt.meshphysical_frag};function TV(n,e,t,i,s,r,o){const a=new Ce(0);let l=r===!0?0:1,c,h,f=null,d=0,p=null;function g(v,y){let b=!1,x=y.isScene===!0?y.background:null;x&&x.isTexture&&(x=(y.backgroundBlurriness>0?t:e).get(x));const w=n.xr,_=w.getSession&&w.getSession();_&&_.environmentBlendMode==="additive"&&(x=null),x===null?m(a,l):x&&x.isColor&&(m(x,1),b=!0),(n.autoClear||b)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),x&&(x.isCubeTexture||x.mapping===E1)?(h===void 0&&(h=new We(new br(1,1,1),new Ci({name:"BackgroundCubeMaterial",uniforms:rh(Hr.backgroundCube.uniforms),vertexShader:Hr.backgroundCube.vertexShader,fragmentShader:Hr.backgroundCube.fragmentShader,side:ms,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(A,S,M){this.matrixWorld.copyPosition(M.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(h)),h.material.uniforms.envMap.value=x,h.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,(f!==x||d!==x.version||p!==n.toneMapping)&&(h.material.needsUpdate=!0,f=x,d=x.version,p=n.toneMapping),h.layers.enableAll(),v.unshift(h,h.geometry,h.material,0,0,null)):x&&x.isTexture&&(c===void 0&&(c=new We(new oh(2,2),new Ci({name:"BackgroundMaterial",uniforms:rh(Hr.background.uniforms),vertexShader:Hr.background.vertexShader,fragmentShader:Hr.background.fragmentShader,side:eo,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(c)),c.material.uniforms.t2D.value=x,x.matrixAutoUpdate===!0&&x.updateMatrix(),c.material.uniforms.uvTransform.value.copy(x.matrix),(f!==x||d!==x.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,f=x,d=x.version,p=n.toneMapping),c.layers.enableAll(),v.unshift(c,c.geometry,c.material,0,0,null))}u(g,"render");function m(v,y){i.buffers.color.setClear(v.r,v.g,v.b,y,o)}return u(m,"setClear"),{getClearColor:function(){return a},setClearColor:function(v,y=1){a.set(v),l=y,m(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(v){l=v,m(a,l)},render:g}}u(TV,"WebGLBackground");function CV(n,e,t,i){const s=n.getParameter(34921),r=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||r!==null,a={},l=v(null);let c=l,h=!1;function f(E,k,G,X,te){let j=!1;if(o){const ie=m(X,G,k);c!==ie&&(c=ie,p(c.object)),j=y(E,X,G,te),j&&b(E,X,G,te)}else{const ie=k.wireframe===!0;(c.geometry!==X.id||c.program!==G.id||c.wireframe!==ie)&&(c.geometry=X.id,c.program=G.id,c.wireframe=ie,j=!0)}te!==null&&t.update(te,34963),(j||h)&&(h=!1,M(E,k,G,X),te!==null&&n.bindBuffer(34963,t.get(te).buffer))}u(f,"setup");function d(){return i.isWebGL2?n.createVertexArray():r.createVertexArrayOES()}u(d,"createVertexArrayObject");function p(E){return i.isWebGL2?n.bindVertexArray(E):r.bindVertexArrayOES(E)}u(p,"bindVertexArrayObject");function g(E){return i.isWebGL2?n.deleteVertexArray(E):r.deleteVertexArrayOES(E)}u(g,"deleteVertexArrayObject");function m(E,k,G){const X=G.wireframe===!0;let te=a[E.id];te===void 0&&(te={},a[E.id]=te);let j=te[k.id];j===void 0&&(j={},te[k.id]=j);let ie=j[X];return ie===void 0&&(ie=v(d()),j[X]=ie),ie}u(m,"getBindingState");function v(E){const k=[],G=[],X=[];for(let te=0;te<s;te++)k[te]=0,G[te]=0,X[te]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:k,enabledAttributes:G,attributeDivisors:X,object:E,attributes:{},index:null}}u(v,"createBindingState");function y(E,k,G,X){const te=c.attributes,j=k.attributes;let ie=0;const K=G.getAttributes();for(const $ in K)if(K[$].location>=0){const ae=te[$];let J=j[$];if(J===void 0&&($==="instanceMatrix"&&E.instanceMatrix&&(J=E.instanceMatrix),$==="instanceColor"&&E.instanceColor&&(J=E.instanceColor)),ae===void 0||ae.attribute!==J||J&&ae.data!==J.data)return!0;ie++}return c.attributesNum!==ie||c.index!==X}u(y,"needsUpdate");function b(E,k,G,X){const te={},j=k.attributes;let ie=0;const K=G.getAttributes();for(const $ in K)if(K[$].location>=0){let ae=j[$];ae===void 0&&($==="instanceMatrix"&&E.instanceMatrix&&(ae=E.instanceMatrix),$==="instanceColor"&&E.instanceColor&&(ae=E.instanceColor));const J={};J.attribute=ae,ae&&ae.data&&(J.data=ae.data),te[$]=J,ie++}c.attributes=te,c.attributesNum=ie,c.index=X}u(b,"saveCache");function x(){const E=c.newAttributes;for(let k=0,G=E.length;k<G;k++)E[k]=0}u(x,"initAttributes");function w(E){_(E,0)}u(w,"enableAttribute");function _(E,k){const G=c.newAttributes,X=c.enabledAttributes,te=c.attributeDivisors;G[E]=1,X[E]===0&&(n.enableVertexAttribArray(E),X[E]=1),te[E]!==k&&((i.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](E,k),te[E]=k)}u(_,"enableAttributeAndDivisor");function A(){const E=c.newAttributes,k=c.enabledAttributes;for(let G=0,X=k.length;G<X;G++)k[G]!==E[G]&&(n.disableVertexAttribArray(G),k[G]=0)}u(A,"disableUnusedAttributes");function S(E,k,G,X,te,j){i.isWebGL2===!0&&(G===5124||G===5125)?n.vertexAttribIPointer(E,k,G,te,j):n.vertexAttribPointer(E,k,G,X,te,j)}u(S,"vertexAttribPointer");function M(E,k,G,X){if(i.isWebGL2===!1&&(E.isInstancedMesh||X.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;x();const te=X.attributes,j=G.getAttributes(),ie=k.defaultAttributeValues;for(const K in j){const $=j[K];if($.location>=0){let le=te[K];if(le===void 0&&(K==="instanceMatrix"&&E.instanceMatrix&&(le=E.instanceMatrix),K==="instanceColor"&&E.instanceColor&&(le=E.instanceColor)),le!==void 0){const ae=le.normalized,J=le.itemSize,ne=t.get(le);if(ne===void 0)continue;const ve=ne.buffer,he=ne.type,_e=ne.bytesPerElement;if(le.isInterleavedBufferAttribute){const we=le.data,Se=we.stride,V=le.offset;if(we.isInstancedInterleavedBuffer){for(let Y=0;Y<$.locationSize;Y++)_($.location+Y,we.meshPerAttribute);E.isInstancedMesh!==!0&&X._maxInstanceCount===void 0&&(X._maxInstanceCount=we.meshPerAttribute*we.count)}else for(let Y=0;Y<$.locationSize;Y++)w($.location+Y);n.bindBuffer(34962,ve);for(let Y=0;Y<$.locationSize;Y++)S($.location+Y,J/$.locationSize,he,ae,Se*_e,(V+J/$.locationSize*Y)*_e)}else{if(le.isInstancedBufferAttribute){for(let we=0;we<$.locationSize;we++)_($.location+we,le.meshPerAttribute);E.isInstancedMesh!==!0&&X._maxInstanceCount===void 0&&(X._maxInstanceCount=le.meshPerAttribute*le.count)}else for(let we=0;we<$.locationSize;we++)w($.location+we);n.bindBuffer(34962,ve);for(let we=0;we<$.locationSize;we++)S($.location+we,J/$.locationSize,he,ae,J*_e,J/$.locationSize*we*_e)}}else if(ie!==void 0){const ae=ie[K];if(ae!==void 0)switch(ae.length){case 2:n.vertexAttrib2fv($.location,ae);break;case 3:n.vertexAttrib3fv($.location,ae);break;case 4:n.vertexAttrib4fv($.location,ae);break;default:n.vertexAttrib1fv($.location,ae)}}}}A()}u(M,"setupVertexAttributes");function C(){O();for(const E in a){const k=a[E];for(const G in k){const X=k[G];for(const te in X)g(X[te].object),delete X[te];delete k[G]}delete a[E]}}u(C,"dispose");function I(E){if(a[E.id]===void 0)return;const k=a[E.id];for(const G in k){const X=k[G];for(const te in X)g(X[te].object),delete X[te];delete k[G]}delete a[E.id]}u(I,"releaseStatesOfGeometry");function F(E){for(const k in a){const G=a[k];if(G[E.id]===void 0)continue;const X=G[E.id];for(const te in X)g(X[te].object),delete X[te];delete G[E.id]}}u(F,"releaseStatesOfProgram");function O(){N(),h=!0,c!==l&&(c=l,p(c.object))}u(O,"reset");function N(){l.geometry=null,l.program=null,l.wireframe=!1}return u(N,"resetDefaultState"),{setup:f,reset:O,resetDefaultState:N,dispose:C,releaseStatesOfGeometry:I,releaseStatesOfProgram:F,initAttributes:x,enableAttribute:w,disableUnusedAttributes:A}}u(CV,"WebGLBindingStates");function EV(n,e,t,i){const s=i.isWebGL2;let r;function o(c){r=c}u(o,"setMode");function a(c,h){n.drawArrays(r,c,h),t.update(h,r,1)}u(a,"render");function l(c,h,f){if(f===0)return;let d,p;if(s)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](r,c,h,f),t.update(h,r,f)}u(l,"renderInstances"),this.setMode=o,this.render=a,this.renderInstances=l}u(EV,"WebGLBufferRenderer");function PV(n,e,t){let i;function s(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}u(s,"getMaxAnisotropy");function r(S){if(S==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";S="mediump"}return S==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}u(r,"getMaxPrecision");const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=r(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),h=t.logarithmicDepthBuffer===!0,f=n.getParameter(34930),d=n.getParameter(35660),p=n.getParameter(3379),g=n.getParameter(34076),m=n.getParameter(34921),v=n.getParameter(36347),y=n.getParameter(36348),b=n.getParameter(36349),x=d>0,w=o||e.has("OES_texture_float"),_=x&&w,A=o?n.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:s,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:f,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:g,maxAttributes:m,maxVertexUniforms:v,maxVaryings:y,maxFragmentUniforms:b,vertexTextures:x,floatFragmentTextures:w,floatVertexTextures:_,maxSamples:A}}u(PV,"WebGLCapabilities");function RV(n){const e=this;let t=null,i=0,s=!1,r=!1;const o=new gr,a=new ki,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(f,d,p){const g=f.length!==0||d||i!==0||s;return s=d,t=h(f,p,0),i=f.length,g},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1,c()},this.setState=function(f,d,p){const g=f.clippingPlanes,m=f.clipIntersection,v=f.clipShadows,y=n.get(f);if(!s||g===null||g.length===0||r&&!v)r?h(null):c();else{const b=r?0:i,x=b*4;let w=y.clippingState||null;l.value=w,w=h(g,d,x,p);for(let _=0;_!==x;++_)w[_]=t[_];y.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}u(c,"resetGlobalState");function h(f,d,p,g){const m=f!==null?f.length:0;let v=null;if(m!==0){if(v=l.value,g!==!0||v===null){const y=p+m*4,b=d.matrixWorldInverse;a.getNormalMatrix(b),(v===null||v.length<y)&&(v=new Float32Array(y));for(let x=0,w=p;x!==m;++x,w+=4)o.copy(f[x]).applyMatrix4(b,a),o.normal.toArray(v,w),v[w+3]=o.constant}l.value=v,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,v}u(h,"projectPlanes")}u(RV,"WebGLClipping");function IV(n){let e=new WeakMap;function t(o,a){return a===$0?o.mapping=eh:a===xx&&(o.mapping=th),o}u(t,"mapTextureMapping");function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===$0||a===xx)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new uI(l.height/2);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",s),t(c.texture,o.mapping)}else return null}}return o}u(i,"get");function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}u(s,"onTextureDispose");function r(){e=new WeakMap}return u(r,"dispose"),{get:i,dispose:r}}u(IV,"WebGLCubeMaps");class rl extends D1{constructor(e=-1,t=1,i=1,s=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=s,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,s,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let r=i-e,o=i+e,a=s+t,l=s-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}u(rl,"OrthographicCamera");const Du=4,mS=[.125,.215,.35,.446,.526,.582],Xl=20,hy=new rl,gS=new Ce;let fy=null;const Hl=(1+Math.sqrt(5))/2,qc=1/Hl,vS=[new P(1,1,1),new P(-1,1,1),new P(1,1,-1),new P(-1,1,-1),new P(0,Hl,qc),new P(0,Hl,-qc),new P(qc,0,Hl),new P(-qc,0,Hl),new P(Hl,qc,0),new P(-Hl,qc,0)];class Sx{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,s=100){fy=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,i,s,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=xS(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=bS(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(fy),e.scissorTest=!1,Mm(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===eh||e.mapping===th?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),fy=this._renderer.getRenderTarget();const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:Zt,minFilter:Zt,generateMipmaps:!1,type:cc,format:rn,encoding:Xo,depthBuffer:!1},s=yS(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=yS(e,t,i);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=DV(r)),this._blurMaterial=LV(r,e,t)}return s}_compileMaterial(e){const t=new We(this._lodPlanes[0],e);this._renderer.compile(t,hy)}_sceneToCubeUV(e,t,i,s){const a=new li(90,1,t,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,f=h.autoClear,d=h.toneMapping;h.getClearColor(gS),h.toneMapping=Qs,h.autoClear=!1;const p=new xi({name:"PMREM.Background",side:ms,depthWrite:!1,depthTest:!1}),g=new We(new br,p);let m=!1;const v=e.background;v?v.isColor&&(p.color.copy(v),e.background=null,m=!0):(p.color.copy(gS),m=!0);for(let y=0;y<6;y++){const b=y%3;b===0?(a.up.set(0,l[y],0),a.lookAt(c[y],0,0)):b===1?(a.up.set(0,0,l[y]),a.lookAt(0,c[y],0)):(a.up.set(0,l[y],0),a.lookAt(0,0,c[y]));const x=this._cubeSize;Mm(s,b*x,y>2?x:0,x,x),h.setRenderTarget(s),m&&h.render(g,a),h.render(e,a)}g.geometry.dispose(),g.material.dispose(),h.toneMapping=d,h.autoClear=f,e.background=v}_textureToCubeUV(e,t){const i=this._renderer,s=e.mapping===eh||e.mapping===th;s?(this._cubemapMaterial===null&&(this._cubemapMaterial=xS()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=bS());const r=s?this._cubemapMaterial:this._equirectMaterial,o=new We(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=e;const l=this._cubeSize;Mm(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,hy)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let s=1;s<this._lodPlanes.length;s++){const r=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),o=vS[(s-1)%vS.length];this._blur(e,s-1,s,r,o)}t.autoClear=i}_blur(e,t,i,s,r){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,s,"latitudinal",r),this._halfBlur(o,e,i,i,s,"longitudinal",r)}_halfBlur(e,t,i,s,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,f=new We(this._lodPlanes[s],c),d=c.uniforms,p=this._sizeLods[i]-1,g=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*Xl-1),m=r/g,v=isFinite(r)?1+Math.floor(h*m):Xl;v>Xl&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Xl}`);const y=[];let b=0;for(let S=0;S<Xl;++S){const M=S/m,C=Math.exp(-M*M/2);y.push(C),S===0?b+=C:S<v&&(b+=2*C)}for(let S=0;S<y.length;S++)y[S]=y[S]/b;d.envMap.value=e.texture,d.samples.value=v,d.weights.value=y,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:x}=this;d.dTheta.value=g,d.mipInt.value=x-i;const w=this._sizeLods[s],_=3*w*(s>x-Du?s-x+Du:0),A=4*(this._cubeSize-w);Mm(t,_,A,3*w,2*w),l.setRenderTarget(t),l.render(f,hy)}}u(Sx,"PMREMGenerator");function DV(n){const e=[],t=[],i=[];let s=n;const r=n-Du+1+mS.length;for(let o=0;o<r;o++){const a=Math.pow(2,s);t.push(a);let l=1/a;o>n-Du?l=mS[o-n+Du-1]:o===0&&(l=0),i.push(l);const c=1/(a-2),h=-c,f=1+c,d=[h,h,f,h,f,f,h,h,f,f,h,f],p=6,g=6,m=3,v=2,y=1,b=new Float32Array(m*g*p),x=new Float32Array(v*g*p),w=new Float32Array(y*g*p);for(let A=0;A<p;A++){const S=A%3*2/3-1,M=A>2?0:-1,C=[S,M,0,S+2/3,M,0,S+2/3,M+1,0,S,M,0,S+2/3,M+1,0,S,M+1,0];b.set(C,m*g*A),x.set(d,v*g*A);const I=[A,A,A,A,A,A];w.set(I,y*g*A)}const _=new Je;_.setAttribute("position",new Rt(b,m)),_.setAttribute("uv",new Rt(x,v)),_.setAttribute("faceIndex",new Rt(w,y)),e.push(_),s>Du&&s--}return{lodPlanes:e,sizeLods:t,sigmas:i}}u(DV,"_createPlanes");function yS(n,e,t){const i=new Ln(n,e,t);return i.texture.mapping=E1,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}u(yS,"_createRenderTarget");function Mm(n,e,t,i,s){n.viewport.set(e,t,i,s),n.scissor.set(e,t,i,s)}u(Mm,"_setViewport");function LV(n,e,t){const i=new Float32Array(Xl),s=new P(0,1,0);return new Ci({name:"SphericalGaussianBlur",defines:{n:Xl,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:U_(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Ns,depthTest:!1,depthWrite:!1})}u(LV,"_getBlurShader");function bS(){return new Ci({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:U_(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Ns,depthTest:!1,depthWrite:!1})}u(bS,"_getEquirectMaterial");function xS(){return new Ci({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:U_(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Ns,depthTest:!1,depthWrite:!1})}u(xS,"_getCubemapMaterial");function U_(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}u(U_,"_getCommonVertexShader");function OV(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,c=l===$0||l===xx,h=l===eh||l===th;if(c||h)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let f=e.get(a);return t===null&&(t=new Sx(n)),f=c?t.fromEquirectangular(a,f):t.fromCubemap(a,f),e.set(a,f),f.texture}else{if(e.has(a))return e.get(a).texture;{const f=a.image;if(c&&f&&f.height>0||h&&f&&s(f)){t===null&&(t=new Sx(n));const d=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",r),d.texture}else return null}}}return a}u(i,"get");function s(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}u(s,"isCubeTextureComplete");function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}u(r,"onTextureDispose");function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return u(o,"dispose"),{get:i,dispose:o}}u(OV,"WebGLCubeUVMaps");function FV(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let s;switch(i){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(i)}return e[i]=s,s}return u(t,"getExtension"),{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(i){const s=t(i);return s===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),s}}}u(FV,"WebGLExtensions");function NV(n,e,t,i){const s={},r=new WeakMap;function o(f){const d=f.target;d.index!==null&&e.remove(d.index);for(const g in d.attributes)e.remove(d.attributes[g]);d.removeEventListener("dispose",o),delete s[d.id];const p=r.get(d);p&&(e.remove(p),r.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}u(o,"onGeometryDispose");function a(f,d){return s[d.id]===!0||(d.addEventListener("dispose",o),s[d.id]=!0,t.memory.geometries++),d}u(a,"get");function l(f){const d=f.attributes;for(const g in d)e.update(d[g],34962);const p=f.morphAttributes;for(const g in p){const m=p[g];for(let v=0,y=m.length;v<y;v++)e.update(m[v],34962)}}u(l,"update");function c(f){const d=[],p=f.index,g=f.attributes.position;let m=0;if(p!==null){const b=p.array;m=p.version;for(let x=0,w=b.length;x<w;x+=3){const _=b[x+0],A=b[x+1],S=b[x+2];d.push(_,A,A,S,S,_)}}else{const b=g.array;m=g.version;for(let x=0,w=b.length/3-1;x<w;x+=3){const _=x+0,A=x+1,S=x+2;d.push(_,A,A,S,S,_)}}const v=new(oI(d)?z_:R1)(d,1);v.version=m;const y=r.get(f);y&&e.remove(y),r.set(f,v)}u(c,"updateWireframeAttribute");function h(f){const d=r.get(f);if(d){const p=f.index;p!==null&&d.version<p.version&&c(f)}else c(f);return r.get(f)}return u(h,"getWireframeAttribute"),{get:a,update:l,getWireframeAttribute:h}}u(NV,"WebGLGeometries");function kV(n,e,t,i){const s=i.isWebGL2;let r;function o(d){r=d}u(o,"setMode");let a,l;function c(d){a=d.type,l=d.bytesPerElement}u(c,"setIndex");function h(d,p){n.drawElements(r,p,a,d*l),t.update(p,r,1)}u(h,"render");function f(d,p,g){if(g===0)return;let m,v;if(s)m=n,v="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),v="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[v](r,p,a,d*l,g),t.update(p,r,g)}u(f,"renderInstances"),this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=f}u(kV,"WebGLIndexedBufferRenderer");function zV(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(r,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(r/3);break;case 1:t.lines+=a*(r/2);break;case 3:t.lines+=a*(r-1);break;case 2:t.lines+=a*r;break;case 0:t.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}u(i,"update");function s(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return u(s,"reset"),{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:i}}u(zV,"WebGLInfo");function BV(n,e){return n[0]-e[0]}u(BV,"numericalSort");function UV(n,e){return Math.abs(e[1])-Math.abs(n[1])}u(UV,"absNumericalSort");function $V(n,e,t){const i={},s=new Float32Array(8),r=new WeakMap,o=new ut,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,h,f,d){const p=c.morphTargetInfluences;if(e.isWebGL2===!0){const m=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,v=m!==void 0?m.length:0;let y=r.get(h);if(y===void 0||y.count!==v){let G=function(){E.dispose(),r.delete(h),h.removeEventListener("dispose",G)};var g=G;u(G,"disposeTexture"),y!==void 0&&y.texture.dispose();const w=h.morphAttributes.position!==void 0,_=h.morphAttributes.normal!==void 0,A=h.morphAttributes.color!==void 0,S=h.morphAttributes.position||[],M=h.morphAttributes.normal||[],C=h.morphAttributes.color||[];let I=0;w===!0&&(I=1),_===!0&&(I=2),A===!0&&(I=3);let F=h.attributes.position.count*I,O=1;F>e.maxTextureSize&&(O=Math.ceil(F/e.maxTextureSize),F=e.maxTextureSize);const N=new Float32Array(F*O*4*v),E=new Ip(N,F,O,v);E.type=on,E.needsUpdate=!0;const k=I*4;for(let X=0;X<v;X++){const te=S[X],j=M[X],ie=C[X],K=F*O*4*X;for(let $=0;$<te.count;$++){const le=$*k;w===!0&&(o.fromBufferAttribute(te,$),N[K+le+0]=o.x,N[K+le+1]=o.y,N[K+le+2]=o.z,N[K+le+3]=0),_===!0&&(o.fromBufferAttribute(j,$),N[K+le+4]=o.x,N[K+le+5]=o.y,N[K+le+6]=o.z,N[K+le+7]=0),A===!0&&(o.fromBufferAttribute(ie,$),N[K+le+8]=o.x,N[K+le+9]=o.y,N[K+le+10]=o.z,N[K+le+11]=ie.itemSize===4?o.w:1)}}y={count:v,texture:E,size:new Ie(F,O)},r.set(h,y),h.addEventListener("dispose",G)}let b=0;for(let w=0;w<p.length;w++)b+=p[w];const x=h.morphTargetsRelative?1:1-b;d.getUniforms().setValue(n,"morphTargetBaseInfluence",x),d.getUniforms().setValue(n,"morphTargetInfluences",p),d.getUniforms().setValue(n,"morphTargetsTexture",y.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",y.size)}else{const m=p===void 0?0:p.length;let v=i[h.id];if(v===void 0||v.length!==m){v=[];for(let _=0;_<m;_++)v[_]=[_,0];i[h.id]=v}for(let _=0;_<m;_++){const A=v[_];A[0]=_,A[1]=p[_]}v.sort(UV);for(let _=0;_<8;_++)_<m&&v[_][1]?(a[_][0]=v[_][0],a[_][1]=v[_][1]):(a[_][0]=Number.MAX_SAFE_INTEGER,a[_][1]=0);a.sort(BV);const y=h.morphAttributes.position,b=h.morphAttributes.normal;let x=0;for(let _=0;_<8;_++){const A=a[_],S=A[0],M=A[1];S!==Number.MAX_SAFE_INTEGER&&M?(y&&h.getAttribute("morphTarget"+_)!==y[S]&&h.setAttribute("morphTarget"+_,y[S]),b&&h.getAttribute("morphNormal"+_)!==b[S]&&h.setAttribute("morphNormal"+_,b[S]),s[_]=M,x+=M):(y&&h.hasAttribute("morphTarget"+_)===!0&&h.deleteAttribute("morphTarget"+_),b&&h.hasAttribute("morphNormal"+_)===!0&&h.deleteAttribute("morphNormal"+_),s[_]=0)}const w=h.morphTargetsRelative?1:1-x;d.getUniforms().setValue(n,"morphTargetBaseInfluence",w),d.getUniforms().setValue(n,"morphTargetInfluences",s)}}return u(l,"update"),{update:l}}u($V,"WebGLMorphtargets");function VV(n,e,t,i){let s=new WeakMap;function r(l){const c=i.render.frame,h=l.geometry,f=e.get(l,h);return s.get(f)!==c&&(e.update(f),s.set(f,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),f}u(r,"update");function o(){s=new WeakMap}u(o,"dispose");function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return u(a,"onInstancedMeshDispose"),{update:r,dispose:o}}u(VV,"WebGLObjects");const fI=new ui,dI=new Ip,pI=new lI,mI=new B_,_S=[],wS=[],AS=new Float32Array(16),MS=new Float32Array(9),SS=new Float32Array(4);function kh(n,e,t){const i=n[0];if(i<=0||i>0)return n;const s=e*t;let r=_S[s];if(r===void 0&&(r=new Float32Array(s),_S[s]=r),e!==0){i.toArray(r,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(r,a)}return r}u(kh,"flatten$u");function hi(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}u(hi,"arraysEqual");function fi(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}u(fi,"copyArray");function L1(n,e){let t=wS[e];t===void 0&&(t=new Int32Array(e),wS[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}u(L1,"allocTexUnits");function HV(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}u(HV,"setValueV1f");function GV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(hi(t,e))return;n.uniform2fv(this.addr,e),fi(t,e)}}u(GV,"setValueV2f");function WV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(hi(t,e))return;n.uniform3fv(this.addr,e),fi(t,e)}}u(WV,"setValueV3f");function jV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(hi(t,e))return;n.uniform4fv(this.addr,e),fi(t,e)}}u(jV,"setValueV4f");function XV(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(hi(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),fi(t,e)}else{if(hi(t,i))return;SS.set(i),n.uniformMatrix2fv(this.addr,!1,SS),fi(t,i)}}u(XV,"setValueM2");function qV(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(hi(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),fi(t,e)}else{if(hi(t,i))return;MS.set(i),n.uniformMatrix3fv(this.addr,!1,MS),fi(t,i)}}u(qV,"setValueM3");function YV(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(hi(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),fi(t,e)}else{if(hi(t,i))return;AS.set(i),n.uniformMatrix4fv(this.addr,!1,AS),fi(t,i)}}u(YV,"setValueM4");function ZV(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}u(ZV,"setValueV1i");function KV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(hi(t,e))return;n.uniform2iv(this.addr,e),fi(t,e)}}u(KV,"setValueV2i");function QV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(hi(t,e))return;n.uniform3iv(this.addr,e),fi(t,e)}}u(QV,"setValueV3i");function JV(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(hi(t,e))return;n.uniform4iv(this.addr,e),fi(t,e)}}u(JV,"setValueV4i");function e8(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}u(e8,"setValueV1ui");function t8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(hi(t,e))return;n.uniform2uiv(this.addr,e),fi(t,e)}}u(t8,"setValueV2ui");function n8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(hi(t,e))return;n.uniform3uiv(this.addr,e),fi(t,e)}}u(n8,"setValueV3ui");function i8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(hi(t,e))return;n.uniform4uiv(this.addr,e),fi(t,e)}}u(i8,"setValueV4ui");function s8(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTexture2D(e||fI,s)}u(s8,"setValueT1");function r8(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTexture3D(e||pI,s)}u(r8,"setValueT3D1");function o8(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTextureCube(e||mI,s)}u(o8,"setValueT6");function a8(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTexture2DArray(e||dI,s)}u(a8,"setValueT2DArray1");function l8(n){switch(n){case 5126:return HV;case 35664:return GV;case 35665:return WV;case 35666:return jV;case 35674:return XV;case 35675:return qV;case 35676:return YV;case 5124:case 35670:return ZV;case 35667:case 35671:return KV;case 35668:case 35672:return QV;case 35669:case 35673:return JV;case 5125:return e8;case 36294:return t8;case 36295:return n8;case 36296:return i8;case 35678:case 36198:case 36298:case 36306:case 35682:return s8;case 35679:case 36299:case 36307:return r8;case 35680:case 36300:case 36308:case 36293:return o8;case 36289:case 36303:case 36311:case 36292:return a8}}u(l8,"getSingularSetter");function c8(n,e){n.uniform1fv(this.addr,e)}u(c8,"setValueV1fArray");function u8(n,e){const t=kh(e,this.size,2);n.uniform2fv(this.addr,t)}u(u8,"setValueV2fArray");function h8(n,e){const t=kh(e,this.size,3);n.uniform3fv(this.addr,t)}u(h8,"setValueV3fArray");function f8(n,e){const t=kh(e,this.size,4);n.uniform4fv(this.addr,t)}u(f8,"setValueV4fArray");function d8(n,e){const t=kh(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}u(d8,"setValueM2Array");function p8(n,e){const t=kh(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}u(p8,"setValueM3Array");function m8(n,e){const t=kh(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}u(m8,"setValueM4Array");function g8(n,e){n.uniform1iv(this.addr,e)}u(g8,"setValueV1iArray");function v8(n,e){n.uniform2iv(this.addr,e)}u(v8,"setValueV2iArray");function y8(n,e){n.uniform3iv(this.addr,e)}u(y8,"setValueV3iArray");function b8(n,e){n.uniform4iv(this.addr,e)}u(b8,"setValueV4iArray");function x8(n,e){n.uniform1uiv(this.addr,e)}u(x8,"setValueV1uiArray");function _8(n,e){n.uniform2uiv(this.addr,e)}u(_8,"setValueV2uiArray");function w8(n,e){n.uniform3uiv(this.addr,e)}u(w8,"setValueV3uiArray");function A8(n,e){n.uniform4uiv(this.addr,e)}u(A8,"setValueV4uiArray");function M8(n,e,t){const i=this.cache,s=e.length,r=L1(t,s);hi(i,r)||(n.uniform1iv(this.addr,r),fi(i,r));for(let o=0;o!==s;++o)t.setTexture2D(e[o]||fI,r[o])}u(M8,"setValueT1Array");function S8(n,e,t){const i=this.cache,s=e.length,r=L1(t,s);hi(i,r)||(n.uniform1iv(this.addr,r),fi(i,r));for(let o=0;o!==s;++o)t.setTexture3D(e[o]||pI,r[o])}u(S8,"setValueT3DArray");function T8(n,e,t){const i=this.cache,s=e.length,r=L1(t,s);hi(i,r)||(n.uniform1iv(this.addr,r),fi(i,r));for(let o=0;o!==s;++o)t.setTextureCube(e[o]||mI,r[o])}u(T8,"setValueT6Array");function C8(n,e,t){const i=this.cache,s=e.length,r=L1(t,s);hi(i,r)||(n.uniform1iv(this.addr,r),fi(i,r));for(let o=0;o!==s;++o)t.setTexture2DArray(e[o]||dI,r[o])}u(C8,"setValueT2DArrayArray");function E8(n){switch(n){case 5126:return c8;case 35664:return u8;case 35665:return h8;case 35666:return f8;case 35674:return d8;case 35675:return p8;case 35676:return m8;case 5124:case 35670:return g8;case 35667:case 35671:return v8;case 35668:case 35672:return y8;case 35669:case 35673:return b8;case 5125:return x8;case 36294:return _8;case 36295:return w8;case 36296:return A8;case 35678:case 36198:case 36298:case 36306:case 35682:return M8;case 35679:case 36299:case 36307:return S8;case 35680:case 36300:case 36308:case 36293:return T8;case 36289:case 36303:case 36311:case 36292:return C8}}u(E8,"getPureArraySetter");class gI{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.setValue=l8(t.type)}}u(gI,"SingleUniform");class vI{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.size=t.size,this.setValue=E8(t.type)}}u(vI,"PureArrayUniform");class yI{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const s=this.seq;for(let r=0,o=s.length;r!==o;++r){const a=s[r];a.setValue(e,t[a.id],i)}}}u(yI,"StructuredUniform");const dy=/(\w+)(\])?(\[|\.)?/g;function TS(n,e){n.seq.push(e),n.map[e.id]=e}u(TS,"addUniform");function P8(n,e,t){const i=n.name,s=i.length;for(dy.lastIndex=0;;){const r=dy.exec(i),o=dy.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===s){TS(t,c===void 0?new gI(a,n,e):new vI(a,n,e));break}else{let f=t.map[a];f===void 0&&(f=new yI(a),TS(t,f)),t=f}}}u(P8,"parseUniform");class Ud{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,35718);for(let s=0;s<i;++s){const r=e.getActiveUniform(t,s),o=e.getUniformLocation(t,r.name);P8(r,o,this)}}setValue(e,t,i,s){const r=this.map[t];r!==void 0&&r.setValue(e,i,s)}setOptional(e,t,i){const s=t[i];s!==void 0&&this.setValue(e,i,s)}static upload(e,t,i,s){for(let r=0,o=t.length;r!==o;++r){const a=t[r],l=i[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,s)}}static seqWithValue(e,t){const i=[];for(let s=0,r=e.length;s!==r;++s){const o=e[s];o.id in t&&i.push(o)}return i}}u(Ud,"WebGLUniforms");function CS(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}u(CS,"WebGLShader");let R8=0;function I8(n,e){const t=n.split(`
`),i=[],s=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let o=s;o<r;o++){const a=o+1;i.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return i.join(`
`)}u(I8,"handleSource");function D8(n){switch(n){case Xo:return["Linear","( value )"];case Lt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}u(D8,"getEncodingComponents");function ES(n,e,t){const i=n.getShaderParameter(e,35713),s=n.getShaderInfoLog(e).trim();if(i&&s==="")return"";const r=/ERROR: 0:(\d+)/.exec(s);if(r){const o=parseInt(r[1]);return t.toUpperCase()+`

`+s+`

`+I8(n.getShaderSource(e),o)}else return s}u(ES,"getShaderErrors");function L8(n,e){const t=D8(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}u(L8,"getTexelEncodingFunction");function O8(n,e){let t;switch(e){case tU:t="Linear";break;case nU:t="Reinhard";break;case iU:t="OptimizedCineon";break;case sU:t="ACESFilmic";break;case rU:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}u(O8,"getToneMappingFunction");function F8(n){return[n.extensionDerivatives||!!n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(bd).join(`
`)}u(F8,"generateExtensions");function N8(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}u(N8,"generateDefines");function k8(n,e){const t={},i=n.getProgramParameter(e,35721);for(let s=0;s<i;s++){const r=n.getActiveAttrib(e,s),o=r.name;let a=1;r.type===35674&&(a=2),r.type===35675&&(a=3),r.type===35676&&(a=4),t[o]={type:r.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}u(k8,"fetchAttributeLocations");function bd(n){return n!==""}u(bd,"filterEmptyLine");function PS(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}u(PS,"replaceLightNums");function RS(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}u(RS,"replaceClippingPlaneNums");const z8=/^[ \t]*#include +<([\w\d./]+)>/gm;function Tx(n){return n.replace(z8,B8)}u(Tx,"resolveIncludes");function B8(n,e){const t=bt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Tx(t)}u(B8,"includeReplacer");const U8=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function IS(n){return n.replace(U8,$8)}u(IS,"unrollLoops");function $8(n,e,t,i){let s="";for(let r=parseInt(e);r<parseInt(t);r++)s+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return s}u($8,"loopReplacer");function DS(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}u(DS,"generatePrecision");function V8(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===qR?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===YR?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===yd&&(e="SHADOWMAP_TYPE_VSM"),e}u(V8,"generateShadowMapTypeDefine");function H8(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case eh:case th:e="ENVMAP_TYPE_CUBE";break;case E1:e="ENVMAP_TYPE_CUBE_UV";break}return e}u(H8,"generateEnvMapTypeDefine");function G8(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case th:e="ENVMAP_MODE_REFRACTION";break}return e}u(G8,"generateEnvMapModeDefine");function W8(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case C1:e="ENVMAP_BLENDING_MULTIPLY";break;case JB:e="ENVMAP_BLENDING_MIX";break;case eU:e="ENVMAP_BLENDING_ADD";break}return e}u(W8,"generateEnvMapBlendingDefine");function j8(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}u(j8,"generateCubeUVSize");function X8(n,e,t,i){const s=n.getContext(),r=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=V8(t),c=H8(t),h=G8(t),f=W8(t),d=j8(t),p=t.isWebGL2?"":F8(t),g=N8(r),m=s.createProgram();let v,y,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(v=[g].filter(bd).join(`
`),v.length>0&&(v+=`
`),y=[p,g].filter(bd).join(`
`),y.length>0&&(y+=`
`)):(v=[DS(t),"#define SHADER_NAME "+t.shaderName,g,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(bd).join(`
`),y=[p,DS(t),"#define SHADER_NAME "+t.shaderName,g,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+f:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Qs?"#define TONE_MAPPING":"",t.toneMapping!==Qs?bt.tonemapping_pars_fragment:"",t.toneMapping!==Qs?O8("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",bt.encodings_pars_fragment,L8("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(bd).join(`
`)),o=Tx(o),o=PS(o,t),o=RS(o,t),a=Tx(a),a=PS(a,t),a=RS(a,t),o=IS(o),a=IS(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,v=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+v,y=["#define varying in",t.glslVersion===iS?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===iS?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const x=b+v+o,w=b+y+a,_=CS(s,35633,x),A=CS(s,35632,w);if(s.attachShader(m,_),s.attachShader(m,A),t.index0AttributeName!==void 0?s.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(m,0,"position"),s.linkProgram(m),n.debug.checkShaderErrors){const C=s.getProgramInfoLog(m).trim(),I=s.getShaderInfoLog(_).trim(),F=s.getShaderInfoLog(A).trim();let O=!0,N=!0;if(s.getProgramParameter(m,35714)===!1){O=!1;const E=ES(s,_,"vertex"),k=ES(s,A,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(m,35715)+`

Program Info Log: `+C+`
`+E+`
`+k)}else C!==""?console.warn("THREE.WebGLProgram: Program Info Log:",C):(I===""||F==="")&&(N=!1);N&&(this.diagnostics={runnable:O,programLog:C,vertexShader:{log:I,prefix:v},fragmentShader:{log:F,prefix:y}})}s.deleteShader(_),s.deleteShader(A);let S;this.getUniforms=function(){return S===void 0&&(S=new Ud(s,m)),S};let M;return this.getAttributes=function(){return M===void 0&&(M=k8(s,m)),M},this.destroy=function(){i.releaseStatesOfProgram(this),s.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=R8++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=_,this.fragmentShader=A,this}u(X8,"WebGLProgram");let q8=0;class bI{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,s=this._getShaderStage(t),r=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(s)===!1&&(o.add(s),s.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let i=t.get(e);return i===void 0&&(i=new Set,t.set(e,i)),i}_getShaderStage(e){const t=this.shaderCache;let i=t.get(e);return i===void 0&&(i=new xI(e),t.set(e,i)),i}}u(bI,"WebGLShaderCache");class xI{constructor(e){this.id=q8++,this.code=e,this.usedTimes=0}}u(xI,"WebGLShaderStage");function Y8(n,e,t,i,s,r,o){const a=new P1,l=new bI,c=[],h=s.isWebGL2,f=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(M,C,I,F,O){const N=F.fog,E=O.geometry,k=M.isMeshStandardMaterial?F.environment:null,G=(M.isMeshStandardMaterial?t:e).get(M.envMap||k),X=!!G&&G.mapping===E1?G.image.height:null,te=g[M.type];M.precision!==null&&(p=s.getMaxPrecision(M.precision),p!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",p,"instead."));const j=E.morphAttributes.position||E.morphAttributes.normal||E.morphAttributes.color,ie=j!==void 0?j.length:0;let K=0;E.morphAttributes.position!==void 0&&(K=1),E.morphAttributes.normal!==void 0&&(K=2),E.morphAttributes.color!==void 0&&(K=3);let $,le,ae,J;if(te){const Se=Hr[te];$=Se.vertexShader,le=Se.fragmentShader}else $=M.vertexShader,le=M.fragmentShader,l.update(M),ae=l.getVertexShaderID(M),J=l.getFragmentShaderID(M);const ne=n.getRenderTarget(),ve=M.alphaTest>0,he=M.clearcoat>0,_e=M.iridescence>0;return{isWebGL2:h,shaderID:te,shaderName:M.type,vertexShader:$,fragmentShader:le,defines:M.defines,customVertexShaderID:ae,customFragmentShaderID:J,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:p,instancing:O.isInstancedMesh===!0,instancingColor:O.isInstancedMesh===!0&&O.instanceColor!==null,supportsVertexTextures:d,outputEncoding:ne===null?n.outputEncoding:ne.isXRRenderTarget===!0?ne.texture.encoding:Xo,map:!!M.map,matcap:!!M.matcap,envMap:!!G,envMapMode:G&&G.mapping,envMapCubeUVHeight:X,lightMap:!!M.lightMap,aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===gU,tangentSpaceNormalMap:M.normalMapType===Pp,decodeVideoTexture:!!M.map&&M.map.isVideoTexture===!0&&M.map.encoding===Lt,clearcoat:he,clearcoatMap:he&&!!M.clearcoatMap,clearcoatRoughnessMap:he&&!!M.clearcoatRoughnessMap,clearcoatNormalMap:he&&!!M.clearcoatNormalMap,iridescence:_e,iridescenceMap:_e&&!!M.iridescenceMap,iridescenceThicknessMap:_e&&!!M.iridescenceThicknessMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,specularIntensityMap:!!M.specularIntensityMap,specularColorMap:!!M.specularColorMap,opaque:M.transparent===!1&&M.blending===nc,alphaMap:!!M.alphaMap,alphaTest:ve,gradientMap:!!M.gradientMap,sheen:M.sheen>0,sheenColorMap:!!M.sheenColorMap,sheenRoughnessMap:!!M.sheenRoughnessMap,transmission:M.transmission>0,transmissionMap:!!M.transmissionMap,thicknessMap:!!M.thicknessMap,combine:M.combine,vertexTangents:!!M.normalMap&&!!E.attributes.tangent,vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!E.attributes.color&&E.attributes.color.itemSize===4,vertexUvs:!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatMap||!!M.clearcoatRoughnessMap||!!M.clearcoatNormalMap||!!M.iridescenceMap||!!M.iridescenceThicknessMap||!!M.displacementMap||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||!!M.sheenColorMap||!!M.sheenRoughnessMap,uvsVertexOnly:!(!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatNormalMap||!!M.iridescenceMap||!!M.iridescenceThicknessMap||M.transmission>0||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||M.sheen>0||!!M.sheenColorMap||!!M.sheenRoughnessMap)&&!!M.displacementMap,fog:!!N,useFog:M.fog===!0,fogExp2:N&&N.isFogExp2,flatShading:!!M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:f,skinning:O.isSkinnedMesh===!0,morphTargets:E.morphAttributes.position!==void 0,morphNormals:E.morphAttributes.normal!==void 0,morphColors:E.morphAttributes.color!==void 0,morphTargetsCount:ie,morphTextureStride:K,numDirLights:C.directional.length,numPointLights:C.point.length,numSpotLights:C.spot.length,numSpotLightMaps:C.spotLightMap.length,numRectAreaLights:C.rectArea.length,numHemiLights:C.hemi.length,numDirLightShadows:C.directionalShadowMap.length,numPointLightShadows:C.pointShadowMap.length,numSpotLightShadows:C.spotShadowMap.length,numSpotLightShadowsWithMaps:C.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:M.dithering,shadowMapEnabled:n.shadowMap.enabled&&I.length>0,shadowMapType:n.shadowMap.type,toneMapping:M.toneMapped?n.toneMapping:Qs,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===Ki,flipSided:M.side===ms,useDepthPacking:!!M.depthPacking,depthPacking:M.depthPacking||0,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||i.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}}u(m,"getParameters");function v(M){const C=[];if(M.shaderID?C.push(M.shaderID):(C.push(M.customVertexShaderID),C.push(M.customFragmentShaderID)),M.defines!==void 0)for(const I in M.defines)C.push(I),C.push(M.defines[I]);return M.isRawShaderMaterial===!1&&(y(C,M),b(C,M),C.push(n.outputEncoding)),C.push(M.customProgramCacheKey),C.join()}u(v,"getProgramCacheKey");function y(M,C){M.push(C.precision),M.push(C.outputEncoding),M.push(C.envMapMode),M.push(C.envMapCubeUVHeight),M.push(C.combine),M.push(C.vertexUvs),M.push(C.fogExp2),M.push(C.sizeAttenuation),M.push(C.morphTargetsCount),M.push(C.morphAttributeCount),M.push(C.numDirLights),M.push(C.numPointLights),M.push(C.numSpotLights),M.push(C.numSpotLightMaps),M.push(C.numHemiLights),M.push(C.numRectAreaLights),M.push(C.numDirLightShadows),M.push(C.numPointLightShadows),M.push(C.numSpotLightShadows),M.push(C.numSpotLightShadowsWithMaps),M.push(C.shadowMapType),M.push(C.toneMapping),M.push(C.numClippingPlanes),M.push(C.numClipIntersection),M.push(C.depthPacking)}u(y,"getProgramCacheKeyParameters");function b(M,C){a.disableAll(),C.isWebGL2&&a.enable(0),C.supportsVertexTextures&&a.enable(1),C.instancing&&a.enable(2),C.instancingColor&&a.enable(3),C.map&&a.enable(4),C.matcap&&a.enable(5),C.envMap&&a.enable(6),C.lightMap&&a.enable(7),C.aoMap&&a.enable(8),C.emissiveMap&&a.enable(9),C.bumpMap&&a.enable(10),C.normalMap&&a.enable(11),C.objectSpaceNormalMap&&a.enable(12),C.tangentSpaceNormalMap&&a.enable(13),C.clearcoat&&a.enable(14),C.clearcoatMap&&a.enable(15),C.clearcoatRoughnessMap&&a.enable(16),C.clearcoatNormalMap&&a.enable(17),C.iridescence&&a.enable(18),C.iridescenceMap&&a.enable(19),C.iridescenceThicknessMap&&a.enable(20),C.displacementMap&&a.enable(21),C.specularMap&&a.enable(22),C.roughnessMap&&a.enable(23),C.metalnessMap&&a.enable(24),C.gradientMap&&a.enable(25),C.alphaMap&&a.enable(26),C.alphaTest&&a.enable(27),C.vertexColors&&a.enable(28),C.vertexAlphas&&a.enable(29),C.vertexUvs&&a.enable(30),C.vertexTangents&&a.enable(31),C.uvsVertexOnly&&a.enable(32),M.push(a.mask),a.disableAll(),C.fog&&a.enable(0),C.useFog&&a.enable(1),C.flatShading&&a.enable(2),C.logarithmicDepthBuffer&&a.enable(3),C.skinning&&a.enable(4),C.morphTargets&&a.enable(5),C.morphNormals&&a.enable(6),C.morphColors&&a.enable(7),C.premultipliedAlpha&&a.enable(8),C.shadowMapEnabled&&a.enable(9),C.physicallyCorrectLights&&a.enable(10),C.doubleSided&&a.enable(11),C.flipSided&&a.enable(12),C.useDepthPacking&&a.enable(13),C.dithering&&a.enable(14),C.specularIntensityMap&&a.enable(15),C.specularColorMap&&a.enable(16),C.transmission&&a.enable(17),C.transmissionMap&&a.enable(18),C.thicknessMap&&a.enable(19),C.sheen&&a.enable(20),C.sheenColorMap&&a.enable(21),C.sheenRoughnessMap&&a.enable(22),C.decodeVideoTexture&&a.enable(23),C.opaque&&a.enable(24),M.push(a.mask)}u(b,"getProgramCacheKeyBooleans");function x(M){const C=g[M.type];let I;if(C){const F=Hr[C];I=I1.clone(F.uniforms)}else I=M.uniforms;return I}u(x,"getUniforms");function w(M,C){let I;for(let F=0,O=c.length;F<O;F++){const N=c[F];if(N.cacheKey===C){I=N,++I.usedTimes;break}}return I===void 0&&(I=new X8(n,C,M,r),c.push(I)),I}u(w,"acquireProgram");function _(M){if(--M.usedTimes===0){const C=c.indexOf(M);c[C]=c[c.length-1],c.pop(),M.destroy()}}u(_,"releaseProgram");function A(M){l.remove(M)}u(A,"releaseShaderCache");function S(){l.dispose()}return u(S,"dispose"),{getParameters:m,getProgramCacheKey:v,getUniforms:x,acquireProgram:w,releaseProgram:_,releaseShaderCache:A,programs:c,dispose:S}}u(Y8,"WebGLPrograms");function Z8(){let n=new WeakMap;function e(r){let o=n.get(r);return o===void 0&&(o={},n.set(r,o)),o}u(e,"get");function t(r){n.delete(r)}u(t,"remove");function i(r,o,a){n.get(r)[o]=a}u(i,"update");function s(){n=new WeakMap}return u(s,"dispose"),{get:e,remove:t,update:i,dispose:s}}u(Z8,"WebGLProperties");function K8(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}u(K8,"painterSortStable");function LS(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}u(LS,"reversePainterSortStable");function OS(){const n=[];let e=0;const t=[],i=[],s=[];function r(){e=0,t.length=0,i.length=0,s.length=0}u(r,"init");function o(f,d,p,g,m,v){let y=n[e];return y===void 0?(y={id:f.id,object:f,geometry:d,material:p,groupOrder:g,renderOrder:f.renderOrder,z:m,group:v},n[e]=y):(y.id=f.id,y.object=f,y.geometry=d,y.material=p,y.groupOrder=g,y.renderOrder=f.renderOrder,y.z=m,y.group=v),e++,y}u(o,"getNextRenderItem");function a(f,d,p,g,m,v){const y=o(f,d,p,g,m,v);p.transmission>0?i.push(y):p.transparent===!0?s.push(y):t.push(y)}u(a,"push");function l(f,d,p,g,m,v){const y=o(f,d,p,g,m,v);p.transmission>0?i.unshift(y):p.transparent===!0?s.unshift(y):t.unshift(y)}u(l,"unshift");function c(f,d){t.length>1&&t.sort(f||K8),i.length>1&&i.sort(d||LS),s.length>1&&s.sort(d||LS)}u(c,"sort");function h(){for(let f=e,d=n.length;f<d;f++){const p=n[f];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return u(h,"finish"),{opaque:t,transmissive:i,transparent:s,init:r,push:a,unshift:l,finish:h,sort:c}}u(OS,"WebGLRenderList");function Q8(){let n=new WeakMap;function e(i,s){const r=n.get(i);let o;return r===void 0?(o=new OS,n.set(i,[o])):s>=r.length?(o=new OS,r.push(o)):o=r[s],o}u(e,"get");function t(){n=new WeakMap}return u(t,"dispose"),{get:e,dispose:t}}u(Q8,"WebGLRenderLists");function J8(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new P,color:new Ce};break;case"SpotLight":t={position:new P,direction:new P,color:new Ce,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new P,color:new Ce,distance:0,decay:0};break;case"HemisphereLight":t={direction:new P,skyColor:new Ce,groundColor:new Ce};break;case"RectAreaLight":t={color:new Ce,position:new P,halfWidth:new P,halfHeight:new P};break}return n[e.id]=t,t}}}u(J8,"UniformsCache");function eH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ie};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ie};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ie,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}u(eH,"ShadowUniformsCache");let tH=0;function nH(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}u(nH,"shadowCastingAndTexturingLightsFirst");function iH(n,e){const t=new J8,i=eH(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let h=0;h<9;h++)s.probe.push(new P);const r=new P,o=new me,a=new me;function l(h,f){let d=0,p=0,g=0;for(let F=0;F<9;F++)s.probe[F].set(0,0,0);let m=0,v=0,y=0,b=0,x=0,w=0,_=0,A=0,S=0,M=0;h.sort(nH);const C=f!==!0?Math.PI:1;for(let F=0,O=h.length;F<O;F++){const N=h[F],E=N.color,k=N.intensity,G=N.distance,X=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)d+=E.r*k*C,p+=E.g*k*C,g+=E.b*k*C;else if(N.isLightProbe)for(let te=0;te<9;te++)s.probe[te].addScaledVector(N.sh.coefficients[te],k);else if(N.isDirectionalLight){const te=t.get(N);if(te.color.copy(N.color).multiplyScalar(N.intensity*C),N.castShadow){const j=N.shadow,ie=i.get(N);ie.shadowBias=j.bias,ie.shadowNormalBias=j.normalBias,ie.shadowRadius=j.radius,ie.shadowMapSize=j.mapSize,s.directionalShadow[m]=ie,s.directionalShadowMap[m]=X,s.directionalShadowMatrix[m]=N.shadow.matrix,w++}s.directional[m]=te,m++}else if(N.isSpotLight){const te=t.get(N);te.position.setFromMatrixPosition(N.matrixWorld),te.color.copy(E).multiplyScalar(k*C),te.distance=G,te.coneCos=Math.cos(N.angle),te.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),te.decay=N.decay,s.spot[y]=te;const j=N.shadow;if(N.map&&(s.spotLightMap[S]=N.map,S++,j.updateMatrices(N),N.castShadow&&M++),s.spotLightMatrix[y]=j.matrix,N.castShadow){const ie=i.get(N);ie.shadowBias=j.bias,ie.shadowNormalBias=j.normalBias,ie.shadowRadius=j.radius,ie.shadowMapSize=j.mapSize,s.spotShadow[y]=ie,s.spotShadowMap[y]=X,A++}y++}else if(N.isRectAreaLight){const te=t.get(N);te.color.copy(E).multiplyScalar(k),te.halfWidth.set(N.width*.5,0,0),te.halfHeight.set(0,N.height*.5,0),s.rectArea[b]=te,b++}else if(N.isPointLight){const te=t.get(N);if(te.color.copy(N.color).multiplyScalar(N.intensity*C),te.distance=N.distance,te.decay=N.decay,N.castShadow){const j=N.shadow,ie=i.get(N);ie.shadowBias=j.bias,ie.shadowNormalBias=j.normalBias,ie.shadowRadius=j.radius,ie.shadowMapSize=j.mapSize,ie.shadowCameraNear=j.camera.near,ie.shadowCameraFar=j.camera.far,s.pointShadow[v]=ie,s.pointShadowMap[v]=X,s.pointShadowMatrix[v]=N.shadow.matrix,_++}s.point[v]=te,v++}else if(N.isHemisphereLight){const te=t.get(N);te.skyColor.copy(N.color).multiplyScalar(k*C),te.groundColor.copy(N.groundColor).multiplyScalar(k*C),s.hemi[x]=te,x++}}b>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Oe.LTC_FLOAT_1,s.rectAreaLTC2=Oe.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Oe.LTC_HALF_1,s.rectAreaLTC2=Oe.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=d,s.ambient[1]=p,s.ambient[2]=g;const I=s.hash;(I.directionalLength!==m||I.pointLength!==v||I.spotLength!==y||I.rectAreaLength!==b||I.hemiLength!==x||I.numDirectionalShadows!==w||I.numPointShadows!==_||I.numSpotShadows!==A||I.numSpotMaps!==S)&&(s.directional.length=m,s.spot.length=y,s.rectArea.length=b,s.point.length=v,s.hemi.length=x,s.directionalShadow.length=w,s.directionalShadowMap.length=w,s.pointShadow.length=_,s.pointShadowMap.length=_,s.spotShadow.length=A,s.spotShadowMap.length=A,s.directionalShadowMatrix.length=w,s.pointShadowMatrix.length=_,s.spotLightMatrix.length=A+S-M,s.spotLightMap.length=S,s.numSpotLightShadowsWithMaps=M,I.directionalLength=m,I.pointLength=v,I.spotLength=y,I.rectAreaLength=b,I.hemiLength=x,I.numDirectionalShadows=w,I.numPointShadows=_,I.numSpotShadows=A,I.numSpotMaps=S,s.version=tH++)}u(l,"setup");function c(h,f){let d=0,p=0,g=0,m=0,v=0;const y=f.matrixWorldInverse;for(let b=0,x=h.length;b<x;b++){const w=h[b];if(w.isDirectionalLight){const _=s.directional[d];_.direction.setFromMatrixPosition(w.matrixWorld),r.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(r),_.direction.transformDirection(y),d++}else if(w.isSpotLight){const _=s.spot[g];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),_.direction.setFromMatrixPosition(w.matrixWorld),r.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(r),_.direction.transformDirection(y),g++}else if(w.isRectAreaLight){const _=s.rectArea[m];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),a.identity(),o.copy(w.matrixWorld),o.premultiply(y),a.extractRotation(o),_.halfWidth.set(w.width*.5,0,0),_.halfHeight.set(0,w.height*.5,0),_.halfWidth.applyMatrix4(a),_.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const _=s.point[p];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),p++}else if(w.isHemisphereLight){const _=s.hemi[v];_.direction.setFromMatrixPosition(w.matrixWorld),_.direction.transformDirection(y),v++}}}return u(c,"setupView"),{setup:l,setupView:c,state:s}}u(iH,"WebGLLights");function FS(n,e){const t=new iH(n,e),i=[],s=[];function r(){i.length=0,s.length=0}u(r,"init");function o(f){i.push(f)}u(o,"pushLight");function a(f){s.push(f)}u(a,"pushShadow");function l(f){t.setup(i,f)}u(l,"setupLights");function c(f){t.setupView(i,f)}return u(c,"setupLightsView"),{init:r,state:{lightsArray:i,shadowsArray:s,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}u(FS,"WebGLRenderState");function sH(n,e){let t=new WeakMap;function i(r,o=0){const a=t.get(r);let l;return a===void 0?(l=new FS(n,e),t.set(r,[l])):o>=a.length?(l=new FS(n,e),a.push(l)):l=a[o],l}u(i,"get");function s(){t=new WeakMap}return u(s,"dispose"),{get:i,dispose:s}}u(sH,"WebGLRenderStates");class $_ extends ns{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=mU,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}u($_,"MeshDepthMaterial");class _I extends ns{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new P,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}u(_I,"MeshDistanceMaterial");const rH=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,oH=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function aH(n,e,t){let i=new Dp;const s=new Ie,r=new Ie,o=new ut,a=new $_({depthPacking:sI}),l=new _I,c={},h=t.maxTextureSize,f={0:ms,1:eo,2:Ki},d=new Ci({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ie},radius:{value:4}},vertexShader:rH,fragmentShader:oH}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const g=new Je;g.setAttribute("position",new Rt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new We(g,d),v=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=qR,this.render=function(w,_,A){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||w.length===0)return;const S=n.getRenderTarget(),M=n.getActiveCubeFace(),C=n.getActiveMipmapLevel(),I=n.state;I.setBlending(Ns),I.buffers.color.setClear(1,1,1,1),I.buffers.depth.setTest(!0),I.setScissorTest(!1);for(let F=0,O=w.length;F<O;F++){const N=w[F],E=N.shadow;if(E===void 0){console.warn("THREE.WebGLShadowMap:",N,"has no shadow.");continue}if(E.autoUpdate===!1&&E.needsUpdate===!1)continue;s.copy(E.mapSize);const k=E.getFrameExtents();if(s.multiply(k),r.copy(E.mapSize),(s.x>h||s.y>h)&&(s.x>h&&(r.x=Math.floor(h/k.x),s.x=r.x*k.x,E.mapSize.x=r.x),s.y>h&&(r.y=Math.floor(h/k.y),s.y=r.y*k.y,E.mapSize.y=r.y)),E.map===null){const X=this.type!==yd?{minFilter:Yt,magFilter:Yt}:{};E.map=new Ln(s.x,s.y,X),E.map.texture.name=N.name+".shadowMap",E.camera.updateProjectionMatrix()}n.setRenderTarget(E.map),n.clear();const G=E.getViewportCount();for(let X=0;X<G;X++){const te=E.getViewport(X);o.set(r.x*te.x,r.y*te.y,r.x*te.z,r.y*te.w),I.viewport(o),E.updateMatrices(N,X),i=E.getFrustum(),x(_,A,E.camera,N,this.type)}E.isPointLightShadow!==!0&&this.type===yd&&y(E,A),E.needsUpdate=!1}v.needsUpdate=!1,n.setRenderTarget(S,M,C)};function y(w,_){const A=e.update(m);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,p.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),w.mapPass===null&&(w.mapPass=new Ln(s.x,s.y)),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(_,null,A,d,m,null),p.uniforms.shadow_pass.value=w.mapPass.texture,p.uniforms.resolution.value=w.mapSize,p.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(_,null,A,p,m,null)}u(y,"VSMPass");function b(w,_,A,S,M,C){let I=null;const F=A.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(F!==void 0?I=F:I=A.isPointLight===!0?l:a,n.localClippingEnabled&&_.clipShadows===!0&&Array.isArray(_.clippingPlanes)&&_.clippingPlanes.length!==0||_.displacementMap&&_.displacementScale!==0||_.alphaMap&&_.alphaTest>0){const O=I.uuid,N=_.uuid;let E=c[O];E===void 0&&(E={},c[O]=E);let k=E[N];k===void 0&&(k=I.clone(),E[N]=k),I=k}return I.visible=_.visible,I.wireframe=_.wireframe,C===yd?I.side=_.shadowSide!==null?_.shadowSide:_.side:I.side=_.shadowSide!==null?_.shadowSide:f[_.side],I.alphaMap=_.alphaMap,I.alphaTest=_.alphaTest,I.clipShadows=_.clipShadows,I.clippingPlanes=_.clippingPlanes,I.clipIntersection=_.clipIntersection,I.displacementMap=_.displacementMap,I.displacementScale=_.displacementScale,I.displacementBias=_.displacementBias,I.wireframeLinewidth=_.wireframeLinewidth,I.linewidth=_.linewidth,A.isPointLight===!0&&I.isMeshDistanceMaterial===!0&&(I.referencePosition.setFromMatrixPosition(A.matrixWorld),I.nearDistance=S,I.farDistance=M),I}u(b,"getDepthMaterial");function x(w,_,A,S,M){if(w.visible===!1)return;if(w.layers.test(_.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&M===yd)&&(!w.frustumCulled||i.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse,w.matrixWorld);const F=e.update(w),O=w.material;if(Array.isArray(O)){const N=F.groups;for(let E=0,k=N.length;E<k;E++){const G=N[E],X=O[G.materialIndex];if(X&&X.visible){const te=b(w,X,S,A.near,A.far,M);n.renderBufferDirect(A,null,F,te,w,G)}}}else if(O.visible){const N=b(w,O,S,A.near,A.far,M);n.renderBufferDirect(A,null,F,N,w,null)}}const I=w.children;for(let F=0,O=I.length;F<O;F++)x(I[F],_,A,S,M)}u(x,"renderObject")}u(aH,"WebGLShadowMap");function lH(n,e,t){const i=t.isWebGL2;function s(){let oe=!1;const be=new ut;let Ee=null;const Ue=new ut(0,0,0,0);return{setMask:function(Xe){Ee!==Xe&&!oe&&(n.colorMask(Xe,Xe,Xe,Xe),Ee=Xe)},setLocked:function(Xe){oe=Xe},setClear:function(Xe,Ut,pi,Pi,ul){ul===!0&&(Xe*=Pi,Ut*=Pi,pi*=Pi),be.set(Xe,Ut,pi,Pi),Ue.equals(be)===!1&&(n.clearColor(Xe,Ut,pi,Pi),Ue.copy(be))},reset:function(){oe=!1,Ee=null,Ue.set(-1,0,0,0)}}}u(s,"ColorBuffer");function r(){let oe=!1,be=null,Ee=null,Ue=null;return{setTest:function(Xe){Xe?ve(2929):he(2929)},setMask:function(Xe){be!==Xe&&!oe&&(n.depthMask(Xe),be=Xe)},setFunc:function(Xe){if(Ee!==Xe){switch(Xe){case jB:n.depthFunc(512);break;case XB:n.depthFunc(519);break;case qB:n.depthFunc(513);break;case bx:n.depthFunc(515);break;case YB:n.depthFunc(514);break;case ZB:n.depthFunc(518);break;case KB:n.depthFunc(516);break;case QB:n.depthFunc(517);break;default:n.depthFunc(515)}Ee=Xe}},setLocked:function(Xe){oe=Xe},setClear:function(Xe){Ue!==Xe&&(n.clearDepth(Xe),Ue=Xe)},reset:function(){oe=!1,be=null,Ee=null,Ue=null}}}u(r,"DepthBuffer");function o(){let oe=!1,be=null,Ee=null,Ue=null,Xe=null,Ut=null,pi=null,Pi=null,ul=null;return{setTest:function(gn){oe||(gn?ve(2960):he(2960))},setMask:function(gn){be!==gn&&!oe&&(n.stencilMask(gn),be=gn)},setFunc:function(gn,ro,Us){(Ee!==gn||Ue!==ro||Xe!==Us)&&(n.stencilFunc(gn,ro,Us),Ee=gn,Ue=ro,Xe=Us)},setOp:function(gn,ro,Us){(Ut!==gn||pi!==ro||Pi!==Us)&&(n.stencilOp(gn,ro,Us),Ut=gn,pi=ro,Pi=Us)},setLocked:function(gn){oe=gn},setClear:function(gn){ul!==gn&&(n.clearStencil(gn),ul=gn)},reset:function(){oe=!1,be=null,Ee=null,Ue=null,Xe=null,Ut=null,pi=null,Pi=null,ul=null}}}u(o,"StencilBuffer");const a=new s,l=new r,c=new o,h=new WeakMap,f=new WeakMap;let d={},p={},g=new WeakMap,m=[],v=null,y=!1,b=null,x=null,w=null,_=null,A=null,S=null,M=null,C=!1,I=null,F=null,O=null,N=null,E=null;const k=n.getParameter(35661);let G=!1,X=0;const te=n.getParameter(7938);te.indexOf("WebGL")!==-1?(X=parseFloat(/^WebGL (\d)/.exec(te)[1]),G=X>=1):te.indexOf("OpenGL ES")!==-1&&(X=parseFloat(/^OpenGL ES (\d)/.exec(te)[1]),G=X>=2);let j=null,ie={};const K=n.getParameter(3088),$=n.getParameter(2978),le=new ut().fromArray(K),ae=new ut().fromArray($);function J(oe,be,Ee){const Ue=new Uint8Array(4),Xe=n.createTexture();n.bindTexture(oe,Xe),n.texParameteri(oe,10241,9728),n.texParameteri(oe,10240,9728);for(let Ut=0;Ut<Ee;Ut++)n.texImage2D(be+Ut,0,6408,1,1,0,6408,5121,Ue);return Xe}u(J,"createTexture");const ne={};ne[3553]=J(3553,3553,1),ne[34067]=J(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ve(2929),l.setFunc(bx),Q(!1),U(E2),ve(2884),R(Ns);function ve(oe){d[oe]!==!0&&(n.enable(oe),d[oe]=!0)}u(ve,"enable");function he(oe){d[oe]!==!1&&(n.disable(oe),d[oe]=!1)}u(he,"disable");function _e(oe,be){return p[oe]!==be?(n.bindFramebuffer(oe,be),p[oe]=be,i&&(oe===36009&&(p[36160]=be),oe===36160&&(p[36009]=be)),!0):!1}u(_e,"bindFramebuffer");function we(oe,be){let Ee=m,Ue=!1;if(oe)if(Ee=g.get(be),Ee===void 0&&(Ee=[],g.set(be,Ee)),oe.isWebGLMultipleRenderTargets){const Xe=oe.texture;if(Ee.length!==Xe.length||Ee[0]!==36064){for(let Ut=0,pi=Xe.length;Ut<pi;Ut++)Ee[Ut]=36064+Ut;Ee.length=Xe.length,Ue=!0}}else Ee[0]!==36064&&(Ee[0]=36064,Ue=!0);else Ee[0]!==1029&&(Ee[0]=1029,Ue=!0);Ue&&(t.isWebGL2?n.drawBuffers(Ee):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ee))}u(we,"drawBuffers");function Se(oe){return v!==oe?(n.useProgram(oe),v=oe,!0):!1}u(Se,"useProgram");const V={[Su]:32774,[FB]:32778,[NB]:32779};if(i)V[I2]=32775,V[D2]=32776;else{const oe=e.get("EXT_blend_minmax");oe!==null&&(V[I2]=oe.MIN_EXT,V[D2]=oe.MAX_EXT)}const Y={[kB]:0,[zB]:1,[BB]:768,[KR]:770,[WB]:776,[HB]:774,[$B]:772,[UB]:769,[QR]:771,[GB]:775,[VB]:773};function R(oe,be,Ee,Ue,Xe,Ut,pi,Pi){if(oe===Ns){y===!0&&(he(3042),y=!1);return}if(y===!1&&(ve(3042),y=!0),oe!==ZR){if(oe!==b||Pi!==C){if((x!==Su||A!==Su)&&(n.blendEquation(32774),x=Su,A=Su),Pi)switch(oe){case nc:n.blendFuncSeparate(1,771,1,771);break;case yx:n.blendFunc(1,1);break;case P2:n.blendFuncSeparate(0,769,0,1);break;case R2:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",oe);break}else switch(oe){case nc:n.blendFuncSeparate(770,771,1,771);break;case yx:n.blendFunc(770,1);break;case P2:n.blendFuncSeparate(0,769,0,1);break;case R2:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",oe);break}w=null,_=null,S=null,M=null,b=oe,C=Pi}return}Xe=Xe||be,Ut=Ut||Ee,pi=pi||Ue,(be!==x||Xe!==A)&&(n.blendEquationSeparate(V[be],V[Xe]),x=be,A=Xe),(Ee!==w||Ue!==_||Ut!==S||pi!==M)&&(n.blendFuncSeparate(Y[Ee],Y[Ue],Y[Ut],Y[pi]),w=Ee,_=Ue,S=Ut,M=pi),b=oe,C=null}u(R,"setBlending");function ee(oe,be){oe.side===Ki?he(2884):ve(2884);let Ee=oe.side===ms;be&&(Ee=!Ee),Q(Ee),oe.blending===nc&&oe.transparent===!1?R(Ns):R(oe.blending,oe.blendEquation,oe.blendSrc,oe.blendDst,oe.blendEquationAlpha,oe.blendSrcAlpha,oe.blendDstAlpha,oe.premultipliedAlpha),l.setFunc(oe.depthFunc),l.setTest(oe.depthTest),l.setMask(oe.depthWrite),a.setMask(oe.colorWrite);const Ue=oe.stencilWrite;c.setTest(Ue),Ue&&(c.setMask(oe.stencilWriteMask),c.setFunc(oe.stencilFunc,oe.stencilRef,oe.stencilFuncMask),c.setOp(oe.stencilFail,oe.stencilZFail,oe.stencilZPass)),W(oe.polygonOffset,oe.polygonOffsetFactor,oe.polygonOffsetUnits),oe.alphaToCoverage===!0?ve(32926):he(32926)}u(ee,"setMaterial");function Q(oe){I!==oe&&(oe?n.frontFace(2304):n.frontFace(2305),I=oe)}u(Q,"setFlipSided");function U(oe){oe!==LB?(ve(2884),oe!==F&&(oe===E2?n.cullFace(1029):oe===OB?n.cullFace(1028):n.cullFace(1032))):he(2884),F=oe}u(U,"setCullFace");function z(oe){oe!==O&&(G&&n.lineWidth(oe),O=oe)}u(z,"setLineWidth");function W(oe,be,Ee){oe?(ve(32823),(N!==be||E!==Ee)&&(n.polygonOffset(be,Ee),N=be,E=Ee)):he(32823)}u(W,"setPolygonOffset");function re(oe){oe?ve(3089):he(3089)}u(re,"setScissorTest");function B(oe){oe===void 0&&(oe=33984+k-1),j!==oe&&(n.activeTexture(oe),j=oe)}u(B,"activeTexture");function D(oe,be,Ee){Ee===void 0&&(j===null?Ee=33984+k-1:Ee=j);let Ue=ie[Ee];Ue===void 0&&(Ue={type:void 0,texture:void 0},ie[Ee]=Ue),(Ue.type!==oe||Ue.texture!==be)&&(j!==Ee&&(n.activeTexture(Ee),j=Ee),n.bindTexture(oe,be||ne[oe]),Ue.type=oe,Ue.texture=be)}u(D,"bindTexture");function L(){const oe=ie[j];oe!==void 0&&oe.type!==void 0&&(n.bindTexture(oe.type,null),oe.type=void 0,oe.texture=void 0)}u(L,"unbindTexture");function H(){try{n.compressedTexImage2D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(H,"compressedTexImage2D");function q(){try{n.compressedTexImage3D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(q,"compressedTexImage3D");function se(){try{n.texSubImage2D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(se,"texSubImage2D");function de(){try{n.texSubImage3D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(de,"texSubImage3D");function ge(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(ge,"compressedTexSubImage2D");function ye(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(ye,"compressedTexSubImage3D");function pe(){try{n.texStorage2D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(pe,"texStorage2D");function Ne(){try{n.texStorage3D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(Ne,"texStorage3D");function Ye(){try{n.texImage2D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(Ye,"texImage2D");function Re(){try{n.texImage3D.apply(n,arguments)}catch(oe){console.error("THREE.WebGLState:",oe)}}u(Re,"texImage3D");function Ke(oe){le.equals(oe)===!1&&(n.scissor(oe.x,oe.y,oe.z,oe.w),le.copy(oe))}u(Ke,"scissor");function $e(oe){ae.equals(oe)===!1&&(n.viewport(oe.x,oe.y,oe.z,oe.w),ae.copy(oe))}u($e,"viewport");function Qe(oe,be){let Ee=f.get(be);Ee===void 0&&(Ee=new WeakMap,f.set(be,Ee));let Ue=Ee.get(oe);Ue===void 0&&(Ue=n.getUniformBlockIndex(be,oe.name),Ee.set(oe,Ue))}u(Qe,"updateUBOMapping");function Bt(oe,be){const Ue=f.get(be).get(oe);h.get(oe)!==Ue&&(n.uniformBlockBinding(be,Ue,oe.__bindingPointIndex),h.set(oe,Ue))}u(Bt,"uniformBlockBinding");function Yn(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),i===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),d={},j=null,ie={},p={},g=new WeakMap,m=[],v=null,y=!1,b=null,x=null,w=null,_=null,A=null,S=null,M=null,C=!1,I=null,F=null,O=null,N=null,E=null,le.set(0,0,n.canvas.width,n.canvas.height),ae.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return u(Yn,"reset"),{buffers:{color:a,depth:l,stencil:c},enable:ve,disable:he,bindFramebuffer:_e,drawBuffers:we,useProgram:Se,setBlending:R,setMaterial:ee,setFlipSided:Q,setCullFace:U,setLineWidth:z,setPolygonOffset:W,setScissorTest:re,activeTexture:B,bindTexture:D,unbindTexture:L,compressedTexImage2D:H,compressedTexImage3D:q,texImage2D:Ye,texImage3D:Re,updateUBOMapping:Qe,uniformBlockBinding:Bt,texStorage2D:pe,texStorage3D:Ne,texSubImage2D:se,texSubImage3D:de,compressedTexSubImage2D:ge,compressedTexSubImage3D:ye,scissor:Ke,viewport:$e,reset:Yn}}u(lH,"WebGLState");function cH(n,e,t,i,s,r,o){const a=s.isWebGL2,l=s.maxTextures,c=s.maxCubemapSize,h=s.maxTextureSize,f=s.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(typeof navigator=="undefined"?"":navigator.userAgent),g=new WeakMap;let m;const v=new WeakMap;let y=!1;try{y=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function b(D,L){return y?new OffscreenCanvas(D,L):ip("canvas")}u(b,"createCanvas");function x(D,L,H,q){let se=1;if((D.width>q||D.height>q)&&(se=q/Math.max(D.width,D.height)),se<1||L===!0)if(typeof HTMLImageElement!="undefined"&&D instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&D instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&D instanceof ImageBitmap){const de=L?W0:Math.floor,ge=de(se*D.width),ye=de(se*D.height);m===void 0&&(m=b(ge,ye));const pe=H?b(ge,ye):m;return pe.width=ge,pe.height=ye,pe.getContext("2d").drawImage(D,0,0,ge,ye),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+D.width+"x"+D.height+") to ("+ge+"x"+ye+")."),pe}else return"data"in D&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+D.width+"x"+D.height+")."),D;return D}u(x,"resizeImage");function w(D){return Mx(D.width)&&Mx(D.height)}u(w,"isPowerOfTwo$1");function _(D){return a?!1:D.wrapS!==Wn||D.wrapT!==Wn||D.minFilter!==Yt&&D.minFilter!==Zt}u(_,"textureNeedsPowerOfTwo");function A(D,L){return D.generateMipmaps&&L&&D.minFilter!==Yt&&D.minFilter!==Zt}u(A,"textureNeedsGenerateMipmaps");function S(D){n.generateMipmap(D)}u(S,"generateMipmap");function M(D,L,H,q,se=!1){if(a===!1)return L;if(D!==null){if(n[D]!==void 0)return n[D];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+D+"'")}let de=L;return L===6403&&(H===5126&&(de=33326),H===5131&&(de=33325),H===5121&&(de=33321)),L===33319&&(H===5126&&(de=33328),H===5131&&(de=33327),H===5121&&(de=33323)),L===6408&&(H===5126&&(de=34836),H===5131&&(de=34842),H===5121&&(de=q===Lt&&se===!1?35907:32856),H===32819&&(de=32854),H===32820&&(de=32855)),(de===33325||de===33326||de===33327||de===33328||de===34842||de===34836)&&e.get("EXT_color_buffer_float"),de}u(M,"getInternalFormat");function C(D,L,H){return A(D,H)===!0||D.isFramebufferTexture&&D.minFilter!==Yt&&D.minFilter!==Zt?Math.log2(Math.max(L.width,L.height))+1:D.mipmaps!==void 0&&D.mipmaps.length>0?D.mipmaps.length:D.isCompressedTexture&&Array.isArray(D.image)?L.mipmaps.length:1}u(C,"getMipLevels");function I(D){return D===Yt||D===V0||D===H0?9728:9729}u(I,"filterFallback");function F(D){const L=D.target;L.removeEventListener("dispose",F),N(L),L.isVideoTexture&&g.delete(L)}u(F,"onTextureDispose");function O(D){const L=D.target;L.removeEventListener("dispose",O),k(L)}u(O,"onRenderTargetDispose");function N(D){const L=i.get(D);if(L.__webglInit===void 0)return;const H=D.source,q=v.get(H);if(q){const se=q[L.__cacheKey];se.usedTimes--,se.usedTimes===0&&E(D),Object.keys(q).length===0&&v.delete(H)}i.remove(D)}u(N,"deallocateTexture");function E(D){const L=i.get(D);n.deleteTexture(L.__webglTexture);const H=D.source,q=v.get(H);delete q[L.__cacheKey],o.memory.textures--}u(E,"deleteTexture");function k(D){const L=D.texture,H=i.get(D),q=i.get(L);if(q.__webglTexture!==void 0&&(n.deleteTexture(q.__webglTexture),o.memory.textures--),D.depthTexture&&D.depthTexture.dispose(),D.isWebGLCubeRenderTarget)for(let se=0;se<6;se++)n.deleteFramebuffer(H.__webglFramebuffer[se]),H.__webglDepthbuffer&&n.deleteRenderbuffer(H.__webglDepthbuffer[se]);else{if(n.deleteFramebuffer(H.__webglFramebuffer),H.__webglDepthbuffer&&n.deleteRenderbuffer(H.__webglDepthbuffer),H.__webglMultisampledFramebuffer&&n.deleteFramebuffer(H.__webglMultisampledFramebuffer),H.__webglColorRenderbuffer)for(let se=0;se<H.__webglColorRenderbuffer.length;se++)H.__webglColorRenderbuffer[se]&&n.deleteRenderbuffer(H.__webglColorRenderbuffer[se]);H.__webglDepthRenderbuffer&&n.deleteRenderbuffer(H.__webglDepthRenderbuffer)}if(D.isWebGLMultipleRenderTargets)for(let se=0,de=L.length;se<de;se++){const ge=i.get(L[se]);ge.__webglTexture&&(n.deleteTexture(ge.__webglTexture),o.memory.textures--),i.remove(L[se])}i.remove(L),i.remove(D)}u(k,"deallocateRenderTarget");let G=0;function X(){G=0}u(X,"resetTextureUnits");function te(){const D=G;return D>=l&&console.warn("THREE.WebGLTextures: Trying to use "+D+" texture units while this GPU supports only "+l),G+=1,D}u(te,"allocateTextureUnit");function j(D){const L=[];return L.push(D.wrapS),L.push(D.wrapT),L.push(D.wrapR||0),L.push(D.magFilter),L.push(D.minFilter),L.push(D.anisotropy),L.push(D.internalFormat),L.push(D.format),L.push(D.type),L.push(D.generateMipmaps),L.push(D.premultiplyAlpha),L.push(D.flipY),L.push(D.unpackAlignment),L.push(D.encoding),L.join()}u(j,"getTextureCacheKey");function ie(D,L){const H=i.get(D);if(D.isVideoTexture&&re(D),D.isRenderTargetTexture===!1&&D.version>0&&H.__version!==D.version){const q=D.image;if(q===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(q.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{he(H,D,L);return}}t.bindTexture(3553,H.__webglTexture,33984+L)}u(ie,"setTexture2D");function K(D,L){const H=i.get(D);if(D.version>0&&H.__version!==D.version){he(H,D,L);return}t.bindTexture(35866,H.__webglTexture,33984+L)}u(K,"setTexture2DArray");function $(D,L){const H=i.get(D);if(D.version>0&&H.__version!==D.version){he(H,D,L);return}t.bindTexture(32879,H.__webglTexture,33984+L)}u($,"setTexture3D");function le(D,L){const H=i.get(D);if(D.version>0&&H.__version!==D.version){_e(H,D,L);return}t.bindTexture(34067,H.__webglTexture,33984+L)}u(le,"setTextureCube");const ae={[Qi]:10497,[Wn]:33071,[tp]:33648},J={[Yt]:9728,[V0]:9984,[H0]:9986,[Zt]:9729,[D_]:9985,[Mc]:9987};function ne(D,L,H){if(H?(n.texParameteri(D,10242,ae[L.wrapS]),n.texParameteri(D,10243,ae[L.wrapT]),(D===32879||D===35866)&&n.texParameteri(D,32882,ae[L.wrapR]),n.texParameteri(D,10240,J[L.magFilter]),n.texParameteri(D,10241,J[L.minFilter])):(n.texParameteri(D,10242,33071),n.texParameteri(D,10243,33071),(D===32879||D===35866)&&n.texParameteri(D,32882,33071),(L.wrapS!==Wn||L.wrapT!==Wn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(D,10240,I(L.magFilter)),n.texParameteri(D,10241,I(L.minFilter)),L.minFilter!==Yt&&L.minFilter!==Zt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const q=e.get("EXT_texture_filter_anisotropic");if(L.type===on&&e.has("OES_texture_float_linear")===!1||a===!1&&L.type===cc&&e.has("OES_texture_half_float_linear")===!1)return;(L.anisotropy>1||i.get(L).__currentAnisotropy)&&(n.texParameterf(D,q.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(L.anisotropy,s.getMaxAnisotropy())),i.get(L).__currentAnisotropy=L.anisotropy)}}u(ne,"setTextureParameters");function ve(D,L){let H=!1;D.__webglInit===void 0&&(D.__webglInit=!0,L.addEventListener("dispose",F));const q=L.source;let se=v.get(q);se===void 0&&(se={},v.set(q,se));const de=j(L);if(de!==D.__cacheKey){se[de]===void 0&&(se[de]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,H=!0),se[de].usedTimes++;const ge=se[D.__cacheKey];ge!==void 0&&(se[D.__cacheKey].usedTimes--,ge.usedTimes===0&&E(L)),D.__cacheKey=de,D.__webglTexture=se[de].texture}return H}u(ve,"initTexture");function he(D,L,H){let q=3553;(L.isDataArrayTexture||L.isCompressedArrayTexture)&&(q=35866),L.isData3DTexture&&(q=32879);const se=ve(D,L),de=L.source;t.bindTexture(q,D.__webglTexture,33984+H);const ge=i.get(de);if(de.version!==ge.__version||se===!0){t.activeTexture(33984+H),n.pixelStorei(37440,L.flipY),n.pixelStorei(37441,L.premultiplyAlpha),n.pixelStorei(3317,L.unpackAlignment),n.pixelStorei(37443,0);const ye=_(L)&&w(L.image)===!1;let pe=x(L.image,ye,!1,h);pe=B(L,pe);const Ne=w(pe)||a,Ye=r.convert(L.format,L.encoding);let Re=r.convert(L.type),Ke=M(L.internalFormat,Ye,Re,L.encoding,L.isVideoTexture);ne(q,L,Ne);let $e;const Qe=L.mipmaps,Bt=a&&L.isVideoTexture!==!0,Yn=ge.__version===void 0||se===!0,oe=C(L,pe,Ne);if(L.isDepthTexture)Ke=6402,a?L.type===on?Ke=36012:L.type===Ys?Ke=33190:L.type===Wu?Ke=35056:Ke=33189:L.type===on&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),L.format===ic&&Ke===6402&&L.type!==L_&&L.type!==Ys&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),L.type=Ys,Re=r.convert(L.type)),L.format===nh&&Ke===6402&&(Ke=34041,L.type!==Wu&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),L.type=Wu,Re=r.convert(L.type))),Yn&&(Bt?t.texStorage2D(3553,1,Ke,pe.width,pe.height):t.texImage2D(3553,0,Ke,pe.width,pe.height,0,Ye,Re,null));else if(L.isDataTexture)if(Qe.length>0&&Ne){Bt&&Yn&&t.texStorage2D(3553,oe,Ke,Qe[0].width,Qe[0].height);for(let be=0,Ee=Qe.length;be<Ee;be++)$e=Qe[be],Bt?t.texSubImage2D(3553,be,0,0,$e.width,$e.height,Ye,Re,$e.data):t.texImage2D(3553,be,Ke,$e.width,$e.height,0,Ye,Re,$e.data);L.generateMipmaps=!1}else Bt?(Yn&&t.texStorage2D(3553,oe,Ke,pe.width,pe.height),t.texSubImage2D(3553,0,0,0,pe.width,pe.height,Ye,Re,pe.data)):t.texImage2D(3553,0,Ke,pe.width,pe.height,0,Ye,Re,pe.data);else if(L.isCompressedTexture)if(L.isCompressedArrayTexture){Bt&&Yn&&t.texStorage3D(35866,oe,Ke,Qe[0].width,Qe[0].height,pe.depth);for(let be=0,Ee=Qe.length;be<Ee;be++)$e=Qe[be],L.format!==rn?Ye!==null?Bt?t.compressedTexSubImage3D(35866,be,0,0,0,$e.width,$e.height,pe.depth,Ye,$e.data,0,0):t.compressedTexImage3D(35866,be,Ke,$e.width,$e.height,pe.depth,0,$e.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Bt?t.texSubImage3D(35866,be,0,0,0,$e.width,$e.height,pe.depth,Ye,Re,$e.data):t.texImage3D(35866,be,Ke,$e.width,$e.height,pe.depth,0,Ye,Re,$e.data)}else{Bt&&Yn&&t.texStorage2D(3553,oe,Ke,Qe[0].width,Qe[0].height);for(let be=0,Ee=Qe.length;be<Ee;be++)$e=Qe[be],L.format!==rn?Ye!==null?Bt?t.compressedTexSubImage2D(3553,be,0,0,$e.width,$e.height,Ye,$e.data):t.compressedTexImage2D(3553,be,Ke,$e.width,$e.height,0,$e.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Bt?t.texSubImage2D(3553,be,0,0,$e.width,$e.height,Ye,Re,$e.data):t.texImage2D(3553,be,Ke,$e.width,$e.height,0,Ye,Re,$e.data)}else if(L.isDataArrayTexture)Bt?(Yn&&t.texStorage3D(35866,oe,Ke,pe.width,pe.height,pe.depth),t.texSubImage3D(35866,0,0,0,0,pe.width,pe.height,pe.depth,Ye,Re,pe.data)):t.texImage3D(35866,0,Ke,pe.width,pe.height,pe.depth,0,Ye,Re,pe.data);else if(L.isData3DTexture)Bt?(Yn&&t.texStorage3D(32879,oe,Ke,pe.width,pe.height,pe.depth),t.texSubImage3D(32879,0,0,0,0,pe.width,pe.height,pe.depth,Ye,Re,pe.data)):t.texImage3D(32879,0,Ke,pe.width,pe.height,pe.depth,0,Ye,Re,pe.data);else if(L.isFramebufferTexture){if(Yn)if(Bt)t.texStorage2D(3553,oe,Ke,pe.width,pe.height);else{let be=pe.width,Ee=pe.height;for(let Ue=0;Ue<oe;Ue++)t.texImage2D(3553,Ue,Ke,be,Ee,0,Ye,Re,null),be>>=1,Ee>>=1}}else if(Qe.length>0&&Ne){Bt&&Yn&&t.texStorage2D(3553,oe,Ke,Qe[0].width,Qe[0].height);for(let be=0,Ee=Qe.length;be<Ee;be++)$e=Qe[be],Bt?t.texSubImage2D(3553,be,0,0,Ye,Re,$e):t.texImage2D(3553,be,Ke,Ye,Re,$e);L.generateMipmaps=!1}else Bt?(Yn&&t.texStorage2D(3553,oe,Ke,pe.width,pe.height),t.texSubImage2D(3553,0,0,0,Ye,Re,pe)):t.texImage2D(3553,0,Ke,Ye,Re,pe);A(L,Ne)&&S(q),ge.__version=de.version,L.onUpdate&&L.onUpdate(L)}D.__version=L.version}u(he,"uploadTexture");function _e(D,L,H){if(L.image.length!==6)return;const q=ve(D,L),se=L.source;t.bindTexture(34067,D.__webglTexture,33984+H);const de=i.get(se);if(se.version!==de.__version||q===!0){t.activeTexture(33984+H),n.pixelStorei(37440,L.flipY),n.pixelStorei(37441,L.premultiplyAlpha),n.pixelStorei(3317,L.unpackAlignment),n.pixelStorei(37443,0);const ge=L.isCompressedTexture||L.image[0].isCompressedTexture,ye=L.image[0]&&L.image[0].isDataTexture,pe=[];for(let be=0;be<6;be++)!ge&&!ye?pe[be]=x(L.image[be],!1,!0,c):pe[be]=ye?L.image[be].image:L.image[be],pe[be]=B(L,pe[be]);const Ne=pe[0],Ye=w(Ne)||a,Re=r.convert(L.format,L.encoding),Ke=r.convert(L.type),$e=M(L.internalFormat,Re,Ke,L.encoding),Qe=a&&L.isVideoTexture!==!0,Bt=de.__version===void 0||q===!0;let Yn=C(L,Ne,Ye);ne(34067,L,Ye);let oe;if(ge){Qe&&Bt&&t.texStorage2D(34067,Yn,$e,Ne.width,Ne.height);for(let be=0;be<6;be++){oe=pe[be].mipmaps;for(let Ee=0;Ee<oe.length;Ee++){const Ue=oe[Ee];L.format!==rn?Re!==null?Qe?t.compressedTexSubImage2D(34069+be,Ee,0,0,Ue.width,Ue.height,Re,Ue.data):t.compressedTexImage2D(34069+be,Ee,$e,Ue.width,Ue.height,0,Ue.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Qe?t.texSubImage2D(34069+be,Ee,0,0,Ue.width,Ue.height,Re,Ke,Ue.data):t.texImage2D(34069+be,Ee,$e,Ue.width,Ue.height,0,Re,Ke,Ue.data)}}}else{oe=L.mipmaps,Qe&&Bt&&(oe.length>0&&Yn++,t.texStorage2D(34067,Yn,$e,pe[0].width,pe[0].height));for(let be=0;be<6;be++)if(ye){Qe?t.texSubImage2D(34069+be,0,0,0,pe[be].width,pe[be].height,Re,Ke,pe[be].data):t.texImage2D(34069+be,0,$e,pe[be].width,pe[be].height,0,Re,Ke,pe[be].data);for(let Ee=0;Ee<oe.length;Ee++){const Xe=oe[Ee].image[be].image;Qe?t.texSubImage2D(34069+be,Ee+1,0,0,Xe.width,Xe.height,Re,Ke,Xe.data):t.texImage2D(34069+be,Ee+1,$e,Xe.width,Xe.height,0,Re,Ke,Xe.data)}}else{Qe?t.texSubImage2D(34069+be,0,0,0,Re,Ke,pe[be]):t.texImage2D(34069+be,0,$e,Re,Ke,pe[be]);for(let Ee=0;Ee<oe.length;Ee++){const Ue=oe[Ee];Qe?t.texSubImage2D(34069+be,Ee+1,0,0,Re,Ke,Ue.image[be]):t.texImage2D(34069+be,Ee+1,$e,Re,Ke,Ue.image[be])}}}A(L,Ye)&&S(34067),de.__version=se.version,L.onUpdate&&L.onUpdate(L)}D.__version=L.version}u(_e,"uploadCubeTexture");function we(D,L,H,q,se){const de=r.convert(H.format,H.encoding),ge=r.convert(H.type),ye=M(H.internalFormat,de,ge,H.encoding);i.get(L).__hasExternalTextures||(se===32879||se===35866?t.texImage3D(se,0,ye,L.width,L.height,L.depth,0,de,ge,null):t.texImage2D(se,0,ye,L.width,L.height,0,de,ge,null)),t.bindFramebuffer(36160,D),W(L)?d.framebufferTexture2DMultisampleEXT(36160,q,se,i.get(H).__webglTexture,0,z(L)):(se===3553||se>=34069&&se<=34074)&&n.framebufferTexture2D(36160,q,se,i.get(H).__webglTexture,0),t.bindFramebuffer(36160,null)}u(we,"setupFrameBufferTexture");function Se(D,L,H){if(n.bindRenderbuffer(36161,D),L.depthBuffer&&!L.stencilBuffer){let q=33189;if(H||W(L)){const se=L.depthTexture;se&&se.isDepthTexture&&(se.type===on?q=36012:se.type===Ys&&(q=33190));const de=z(L);W(L)?d.renderbufferStorageMultisampleEXT(36161,de,q,L.width,L.height):n.renderbufferStorageMultisample(36161,de,q,L.width,L.height)}else n.renderbufferStorage(36161,q,L.width,L.height);n.framebufferRenderbuffer(36160,36096,36161,D)}else if(L.depthBuffer&&L.stencilBuffer){const q=z(L);H&&W(L)===!1?n.renderbufferStorageMultisample(36161,q,35056,L.width,L.height):W(L)?d.renderbufferStorageMultisampleEXT(36161,q,35056,L.width,L.height):n.renderbufferStorage(36161,34041,L.width,L.height),n.framebufferRenderbuffer(36160,33306,36161,D)}else{const q=L.isWebGLMultipleRenderTargets===!0?L.texture:[L.texture];for(let se=0;se<q.length;se++){const de=q[se],ge=r.convert(de.format,de.encoding),ye=r.convert(de.type),pe=M(de.internalFormat,ge,ye,de.encoding),Ne=z(L);H&&W(L)===!1?n.renderbufferStorageMultisample(36161,Ne,pe,L.width,L.height):W(L)?d.renderbufferStorageMultisampleEXT(36161,Ne,pe,L.width,L.height):n.renderbufferStorage(36161,pe,L.width,L.height)}}n.bindRenderbuffer(36161,null)}u(Se,"setupRenderBufferStorage");function V(D,L){if(L&&L.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,D),!(L.depthTexture&&L.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(L.depthTexture).__webglTexture||L.depthTexture.image.width!==L.width||L.depthTexture.image.height!==L.height)&&(L.depthTexture.image.width=L.width,L.depthTexture.image.height=L.height,L.depthTexture.needsUpdate=!0),ie(L.depthTexture,0);const q=i.get(L.depthTexture).__webglTexture,se=z(L);if(L.depthTexture.format===ic)W(L)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,q,0,se):n.framebufferTexture2D(36160,36096,3553,q,0);else if(L.depthTexture.format===nh)W(L)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,q,0,se):n.framebufferTexture2D(36160,33306,3553,q,0);else throw new Error("Unknown depthTexture format")}u(V,"setupDepthTexture");function Y(D){const L=i.get(D),H=D.isWebGLCubeRenderTarget===!0;if(D.depthTexture&&!L.__autoAllocateDepthBuffer){if(H)throw new Error("target.depthTexture not supported in Cube render targets");V(L.__webglFramebuffer,D)}else if(H){L.__webglDepthbuffer=[];for(let q=0;q<6;q++)t.bindFramebuffer(36160,L.__webglFramebuffer[q]),L.__webglDepthbuffer[q]=n.createRenderbuffer(),Se(L.__webglDepthbuffer[q],D,!1)}else t.bindFramebuffer(36160,L.__webglFramebuffer),L.__webglDepthbuffer=n.createRenderbuffer(),Se(L.__webglDepthbuffer,D,!1);t.bindFramebuffer(36160,null)}u(Y,"setupDepthRenderbuffer");function R(D,L,H){const q=i.get(D);L!==void 0&&we(q.__webglFramebuffer,D,D.texture,36064,3553),H!==void 0&&Y(D)}u(R,"rebindTextures");function ee(D){const L=D.texture,H=i.get(D),q=i.get(L);D.addEventListener("dispose",O),D.isWebGLMultipleRenderTargets!==!0&&(q.__webglTexture===void 0&&(q.__webglTexture=n.createTexture()),q.__version=L.version,o.memory.textures++);const se=D.isWebGLCubeRenderTarget===!0,de=D.isWebGLMultipleRenderTargets===!0,ge=w(D)||a;if(se){H.__webglFramebuffer=[];for(let ye=0;ye<6;ye++)H.__webglFramebuffer[ye]=n.createFramebuffer()}else{if(H.__webglFramebuffer=n.createFramebuffer(),de)if(s.drawBuffers){const ye=D.texture;for(let pe=0,Ne=ye.length;pe<Ne;pe++){const Ye=i.get(ye[pe]);Ye.__webglTexture===void 0&&(Ye.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&D.samples>0&&W(D)===!1){const ye=de?L:[L];H.__webglMultisampledFramebuffer=n.createFramebuffer(),H.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,H.__webglMultisampledFramebuffer);for(let pe=0;pe<ye.length;pe++){const Ne=ye[pe];H.__webglColorRenderbuffer[pe]=n.createRenderbuffer(),n.bindRenderbuffer(36161,H.__webglColorRenderbuffer[pe]);const Ye=r.convert(Ne.format,Ne.encoding),Re=r.convert(Ne.type),Ke=M(Ne.internalFormat,Ye,Re,Ne.encoding,D.isXRRenderTarget===!0),$e=z(D);n.renderbufferStorageMultisample(36161,$e,Ke,D.width,D.height),n.framebufferRenderbuffer(36160,36064+pe,36161,H.__webglColorRenderbuffer[pe])}n.bindRenderbuffer(36161,null),D.depthBuffer&&(H.__webglDepthRenderbuffer=n.createRenderbuffer(),Se(H.__webglDepthRenderbuffer,D,!0)),t.bindFramebuffer(36160,null)}}if(se){t.bindTexture(34067,q.__webglTexture),ne(34067,L,ge);for(let ye=0;ye<6;ye++)we(H.__webglFramebuffer[ye],D,L,36064,34069+ye);A(L,ge)&&S(34067),t.unbindTexture()}else if(de){const ye=D.texture;for(let pe=0,Ne=ye.length;pe<Ne;pe++){const Ye=ye[pe],Re=i.get(Ye);t.bindTexture(3553,Re.__webglTexture),ne(3553,Ye,ge),we(H.__webglFramebuffer,D,Ye,36064+pe,3553),A(Ye,ge)&&S(3553)}t.unbindTexture()}else{let ye=3553;(D.isWebGL3DRenderTarget||D.isWebGLArrayRenderTarget)&&(a?ye=D.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(ye,q.__webglTexture),ne(ye,L,ge),we(H.__webglFramebuffer,D,L,36064,ye),A(L,ge)&&S(ye),t.unbindTexture()}D.depthBuffer&&Y(D)}u(ee,"setupRenderTarget");function Q(D){const L=w(D)||a,H=D.isWebGLMultipleRenderTargets===!0?D.texture:[D.texture];for(let q=0,se=H.length;q<se;q++){const de=H[q];if(A(de,L)){const ge=D.isWebGLCubeRenderTarget?34067:3553,ye=i.get(de).__webglTexture;t.bindTexture(ge,ye),S(ge),t.unbindTexture()}}}u(Q,"updateRenderTargetMipmap");function U(D){if(a&&D.samples>0&&W(D)===!1){const L=D.isWebGLMultipleRenderTargets?D.texture:[D.texture],H=D.width,q=D.height;let se=16384;const de=[],ge=D.stencilBuffer?33306:36096,ye=i.get(D),pe=D.isWebGLMultipleRenderTargets===!0;if(pe)for(let Ne=0;Ne<L.length;Ne++)t.bindFramebuffer(36160,ye.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+Ne,36161,null),t.bindFramebuffer(36160,ye.__webglFramebuffer),n.framebufferTexture2D(36009,36064+Ne,3553,null,0);t.bindFramebuffer(36008,ye.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,ye.__webglFramebuffer);for(let Ne=0;Ne<L.length;Ne++){de.push(36064+Ne),D.depthBuffer&&de.push(ge);const Ye=ye.__ignoreDepthValues!==void 0?ye.__ignoreDepthValues:!1;if(Ye===!1&&(D.depthBuffer&&(se|=256),D.stencilBuffer&&(se|=1024)),pe&&n.framebufferRenderbuffer(36008,36064,36161,ye.__webglColorRenderbuffer[Ne]),Ye===!0&&(n.invalidateFramebuffer(36008,[ge]),n.invalidateFramebuffer(36009,[ge])),pe){const Re=i.get(L[Ne]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,Re,0)}n.blitFramebuffer(0,0,H,q,0,0,H,q,se,9728),p&&n.invalidateFramebuffer(36008,de)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),pe)for(let Ne=0;Ne<L.length;Ne++){t.bindFramebuffer(36160,ye.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+Ne,36161,ye.__webglColorRenderbuffer[Ne]);const Ye=i.get(L[Ne]).__webglTexture;t.bindFramebuffer(36160,ye.__webglFramebuffer),n.framebufferTexture2D(36009,36064+Ne,3553,Ye,0)}t.bindFramebuffer(36009,ye.__webglMultisampledFramebuffer)}}u(U,"updateMultisampleRenderTarget");function z(D){return Math.min(f,D.samples)}u(z,"getRenderTargetSamples");function W(D){const L=i.get(D);return a&&D.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&L.__useRenderToTexture!==!1}u(W,"useMultisampledRTT");function re(D){const L=o.render.frame;g.get(D)!==L&&(g.set(D,L),D.update())}u(re,"updateVideoTexture");function B(D,L){const H=D.encoding,q=D.format,se=D.type;return D.isCompressedTexture===!0||D.isVideoTexture===!0||D.format===Ax||H!==Xo&&(H===Lt?a===!1?e.has("EXT_sRGB")===!0&&q===rn?(D.format=Ax,D.minFilter=Zt,D.generateMipmaps=!1):L=N_.sRGBToLinear(L):(q!==rn||se!==to)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",H)),L}u(B,"verifyColorSpace"),this.allocateTextureUnit=te,this.resetTextureUnits=X,this.setTexture2D=ie,this.setTexture2DArray=K,this.setTexture3D=$,this.setTextureCube=le,this.rebindTextures=R,this.setupRenderTarget=ee,this.updateRenderTargetMipmap=Q,this.updateMultisampleRenderTarget=U,this.setupDepthRenderbuffer=Y,this.setupFrameBufferTexture=we,this.useMultisampledRTT=W}u(cH,"WebGLTextures");function uH(n,e,t){const i=t.isWebGL2;function s(r,o=null){let a;if(r===to)return 5121;if(r===oU)return 32819;if(r===aU)return 32820;if(r===_x)return 5120;if(r===eI)return 5122;if(r===L_)return 5123;if(r===b0)return 5124;if(r===Ys)return 5125;if(r===on)return 5126;if(r===cc)return i?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(r===lU)return 6406;if(r===rn)return 6408;if(r===uU)return 6409;if(r===hU)return 6410;if(r===ic)return 6402;if(r===nh)return 34041;if(r===ih)return 6403;if(r===cU)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(r===Ax)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(r===tI)return 36244;if(r===nI)return 33319;if(r===O_)return 33320;if(r===G0)return 36249;if(r===zv||r===Bv||r===Uv||r===$v)if(o===Lt)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(r===zv)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Bv)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===Uv)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===$v)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(r===zv)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Bv)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Uv)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===$v)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===L2||r===O2||r===F2||r===N2)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(r===L2)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===O2)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===F2)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===N2)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===fU)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===k2||r===z2)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(r===k2)return o===Lt?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(r===z2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===B2||r===U2||r===$2||r===V2||r===H2||r===G2||r===W2||r===j2||r===X2||r===q2||r===Y2||r===Z2||r===K2||r===Q2)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(r===B2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===U2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===$2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===V2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===H2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===G2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===W2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===j2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===X2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===q2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===Y2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===Z2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===K2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===Q2)return o===Lt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===J2)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(r===J2)return o===Lt?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return r===Wu?i?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[r]!==void 0?n[r]:null}return u(s,"convert"),{convert:s}}u(uH,"WebGLUtils");class wI extends li{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}u(wI,"ArrayCamera");class _i extends It{constructor(){super(),this.isGroup=!0,this.type="Group"}}u(_i,"Group");const hH={type:"move"};class _0{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new _i,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new _i,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new P,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new P),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new _i,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new P,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new P),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let s=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const m of e.hand.values()){const v=t.getJointPose(m,i);if(c.joints[m.jointName]===void 0){const b=new _i;b.matrixAutoUpdate=!1,b.visible=!1,c.joints[m.jointName]=b,c.add(b)}const y=c.joints[m.jointName];v!==null&&(y.matrix.fromArray(v.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.jointRadius=v.radius),y.visible=v!==null}const h=c.joints["index-finger-tip"],f=c.joints["thumb-tip"],d=h.position.distanceTo(f.position),p=.02,g=.005;c.inputState.pinching&&d>p+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,i),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(s=t.getPose(e.targetRaySpace,i),s===null&&r!==null&&(s=r),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),s.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(s.linearVelocity)):a.hasLinearVelocity=!1,s.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(s.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(hH)))}return a!==null&&(a.visible=s!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}}u(_0,"WebXRController");class AI extends ui{constructor(e,t,i,s,r,o,a,l,c,h){if(h=h!==void 0?h:ic,h!==ic&&h!==nh)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&h===ic&&(i=Ys),i===void 0&&h===nh&&(i=Wu),super(null,s,r,o,a,l,h,i,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:Yt,this.minFilter=l!==void 0?l:Yt,this.flipY=!1,this.generateMipmaps=!1}}u(AI,"DepthTexture");class MI extends Sc{constructor(e,t){super();const i=this;let s=null,r=1,o=null,a="local-floor",l=null,c=null,h=null,f=null,d=null,p=null;const g=t.getContextAttributes();let m=null,v=null;const y=[],b=[],x=new li;x.layers.enable(1),x.viewport=new ut;const w=new li;w.layers.enable(2),w.viewport=new ut;const _=[x,w],A=new wI;A.layers.enable(1),A.layers.enable(2);let S=null,M=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(j){let ie=y[j];return ie===void 0&&(ie=new _0,y[j]=ie),ie.getTargetRaySpace()},this.getControllerGrip=function(j){let ie=y[j];return ie===void 0&&(ie=new _0,y[j]=ie),ie.getGripSpace()},this.getHand=function(j){let ie=y[j];return ie===void 0&&(ie=new _0,y[j]=ie),ie.getHandSpace()};function C(j){const ie=b.indexOf(j.inputSource);if(ie===-1)return;const K=y[ie];K!==void 0&&K.dispatchEvent({type:j.type,data:j.inputSource})}u(C,"onSessionEvent");function I(){s.removeEventListener("select",C),s.removeEventListener("selectstart",C),s.removeEventListener("selectend",C),s.removeEventListener("squeeze",C),s.removeEventListener("squeezestart",C),s.removeEventListener("squeezeend",C),s.removeEventListener("end",I),s.removeEventListener("inputsourceschange",F);for(let j=0;j<y.length;j++){const ie=b[j];ie!==null&&(b[j]=null,y[j].disconnect(ie))}S=null,M=null,e.setRenderTarget(m),d=null,f=null,h=null,s=null,v=null,te.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}u(I,"onSessionEnd"),this.setFramebufferScaleFactor=function(j){r=j,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(j){a=j,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(j){l=j},this.getBaseLayer=function(){return f!==null?f:d},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return s},this.setSession=async function(j){if(s=j,s!==null){if(m=e.getRenderTarget(),s.addEventListener("select",C),s.addEventListener("selectstart",C),s.addEventListener("selectend",C),s.addEventListener("squeeze",C),s.addEventListener("squeezestart",C),s.addEventListener("squeezeend",C),s.addEventListener("end",I),s.addEventListener("inputsourceschange",F),g.xrCompatible!==!0&&await t.makeXRCompatible(),s.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const ie={antialias:s.renderState.layers===void 0?g.antialias:!0,alpha:g.alpha,depth:g.depth,stencil:g.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(s,t,ie),s.updateRenderState({baseLayer:d}),v=new Ln(d.framebufferWidth,d.framebufferHeight,{format:rn,type:to,encoding:e.outputEncoding,stencilBuffer:g.stencil})}else{let ie=null,K=null,$=null;g.depth&&($=g.stencil?35056:33190,ie=g.stencil?nh:ic,K=g.stencil?Wu:Ys);const le={colorFormat:32856,depthFormat:$,scaleFactor:r};h=new XRWebGLBinding(s,t),f=h.createProjectionLayer(le),s.updateRenderState({layers:[f]}),v=new Ln(f.textureWidth,f.textureHeight,{format:rn,type:to,depthTexture:new AI(f.textureWidth,f.textureHeight,K,void 0,void 0,void 0,void 0,void 0,void 0,ie),stencilBuffer:g.stencil,encoding:e.outputEncoding,samples:g.antialias?4:0});const ae=e.properties.get(v);ae.__ignoreDepthValues=f.ignoreDepthValues}v.isXRRenderTarget=!0,this.setFoveation(1),l=null,o=await s.requestReferenceSpace(a),te.setContext(s),te.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function F(j){for(let ie=0;ie<j.removed.length;ie++){const K=j.removed[ie],$=b.indexOf(K);$>=0&&(b[$]=null,y[$].dispatchEvent({type:"disconnected",data:K}))}for(let ie=0;ie<j.added.length;ie++){const K=j.added[ie];let $=b.indexOf(K);if($===-1){for(let ae=0;ae<y.length;ae++)if(ae>=b.length){b.push(K),$=ae;break}else if(b[ae]===null){b[ae]=K,$=ae;break}if($===-1)break}const le=y[$];le&&le.dispatchEvent({type:"connected",data:K})}}u(F,"onInputSourcesChange");const O=new P,N=new P;function E(j,ie,K){O.setFromMatrixPosition(ie.matrixWorld),N.setFromMatrixPosition(K.matrixWorld);const $=O.distanceTo(N),le=ie.projectionMatrix.elements,ae=K.projectionMatrix.elements,J=le[14]/(le[10]-1),ne=le[14]/(le[10]+1),ve=(le[9]+1)/le[5],he=(le[9]-1)/le[5],_e=(le[8]-1)/le[0],we=(ae[8]+1)/ae[0],Se=J*_e,V=J*we,Y=$/(-_e+we),R=Y*-_e;ie.matrixWorld.decompose(j.position,j.quaternion,j.scale),j.translateX(R),j.translateZ(Y),j.matrixWorld.compose(j.position,j.quaternion,j.scale),j.matrixWorldInverse.copy(j.matrixWorld).invert();const ee=J+Y,Q=ne+Y,U=Se-R,z=V+($-R),W=ve*ne/Q*ee,re=he*ne/Q*ee;j.projectionMatrix.makePerspective(U,z,W,re,ee,Q)}u(E,"setProjectionFromUnion");function k(j,ie){ie===null?j.matrixWorld.copy(j.matrix):j.matrixWorld.multiplyMatrices(ie.matrixWorld,j.matrix),j.matrixWorldInverse.copy(j.matrixWorld).invert()}u(k,"updateCamera"),this.updateCamera=function(j){if(s===null)return;A.near=w.near=x.near=j.near,A.far=w.far=x.far=j.far,(S!==A.near||M!==A.far)&&(s.updateRenderState({depthNear:A.near,depthFar:A.far}),S=A.near,M=A.far);const ie=j.parent,K=A.cameras;k(A,ie);for(let le=0;le<K.length;le++)k(K[le],ie);A.matrixWorld.decompose(A.position,A.quaternion,A.scale),j.matrix.copy(A.matrix),j.matrix.decompose(j.position,j.quaternion,j.scale);const $=j.children;for(let le=0,ae=$.length;le<ae;le++)$[le].updateMatrixWorld(!0);K.length===2?E(A,x,w):A.projectionMatrix.copy(x.projectionMatrix)},this.getCamera=function(){return A},this.getFoveation=function(){if(f!==null)return f.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(j){f!==null&&(f.fixedFoveation=j),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=j)};let G=null;function X(j,ie){if(c=ie.getViewerPose(l||o),p=ie,c!==null){const K=c.views;d!==null&&(e.setRenderTargetFramebuffer(v,d.framebuffer),e.setRenderTarget(v));let $=!1;K.length!==A.cameras.length&&(A.cameras.length=0,$=!0);for(let le=0;le<K.length;le++){const ae=K[le];let J=null;if(d!==null)J=d.getViewport(ae);else{const ve=h.getViewSubImage(f,ae);J=ve.viewport,le===0&&(e.setRenderTargetTextures(v,ve.colorTexture,f.ignoreDepthValues?void 0:ve.depthStencilTexture),e.setRenderTarget(v))}let ne=_[le];ne===void 0&&(ne=new li,ne.layers.enable(le),ne.viewport=new ut,_[le]=ne),ne.matrix.fromArray(ae.transform.matrix),ne.projectionMatrix.fromArray(ae.projectionMatrix),ne.viewport.set(J.x,J.y,J.width,J.height),le===0&&A.matrix.copy(ne.matrix),$===!0&&A.cameras.push(ne)}}for(let K=0;K<y.length;K++){const $=b[K],le=y[K];$!==null&&le!==void 0&&le.update($,ie,l||o)}G&&G(j,ie),p=null}u(X,"onAnimationFrame");const te=new hI;te.setAnimationLoop(X),this.setAnimationLoop=function(j){G=j},this.dispose=function(){}}}u(MI,"WebXRManager");function fH(n,e){function t(m,v){m.fogColor.value.copy(v.color),v.isFog?(m.fogNear.value=v.near,m.fogFar.value=v.far):v.isFogExp2&&(m.fogDensity.value=v.density)}u(t,"refreshFogUniforms");function i(m,v,y,b,x){v.isMeshBasicMaterial||v.isMeshLambertMaterial?s(m,v):v.isMeshToonMaterial?(s(m,v),h(m,v)):v.isMeshPhongMaterial?(s(m,v),c(m,v)):v.isMeshStandardMaterial?(s(m,v),f(m,v),v.isMeshPhysicalMaterial&&d(m,v,x)):v.isMeshMatcapMaterial?(s(m,v),p(m,v)):v.isMeshDepthMaterial?s(m,v):v.isMeshDistanceMaterial?(s(m,v),g(m,v)):v.isMeshNormalMaterial?s(m,v):v.isLineBasicMaterial?(r(m,v),v.isLineDashedMaterial&&o(m,v)):v.isPointsMaterial?a(m,v,y,b):v.isSpriteMaterial?l(m,v):v.isShadowMaterial?(m.color.value.copy(v.color),m.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}u(i,"refreshMaterialUniforms");function s(m,v){m.opacity.value=v.opacity,v.color&&m.diffuse.value.copy(v.color),v.emissive&&m.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ms&&(m.bumpScale.value*=-1)),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias),v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ms&&m.normalScale.value.negate()),v.specularMap&&(m.specularMap.value=v.specularMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);const y=e.get(v).envMap;if(y&&(m.envMap.value=y,m.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=v.reflectivity,m.ior.value=v.ior,m.refractionRatio.value=v.refractionRatio),v.lightMap){m.lightMap.value=v.lightMap;const w=n.physicallyCorrectLights!==!0?Math.PI:1;m.lightMapIntensity.value=v.lightMapIntensity*w}v.aoMap&&(m.aoMap.value=v.aoMap,m.aoMapIntensity.value=v.aoMapIntensity);let b;v.map?b=v.map:v.specularMap?b=v.specularMap:v.displacementMap?b=v.displacementMap:v.normalMap?b=v.normalMap:v.bumpMap?b=v.bumpMap:v.roughnessMap?b=v.roughnessMap:v.metalnessMap?b=v.metalnessMap:v.alphaMap?b=v.alphaMap:v.emissiveMap?b=v.emissiveMap:v.clearcoatMap?b=v.clearcoatMap:v.clearcoatNormalMap?b=v.clearcoatNormalMap:v.clearcoatRoughnessMap?b=v.clearcoatRoughnessMap:v.iridescenceMap?b=v.iridescenceMap:v.iridescenceThicknessMap?b=v.iridescenceThicknessMap:v.specularIntensityMap?b=v.specularIntensityMap:v.specularColorMap?b=v.specularColorMap:v.transmissionMap?b=v.transmissionMap:v.thicknessMap?b=v.thicknessMap:v.sheenColorMap?b=v.sheenColorMap:v.sheenRoughnessMap&&(b=v.sheenRoughnessMap),b!==void 0&&(b.isWebGLRenderTarget&&(b=b.texture),b.matrixAutoUpdate===!0&&b.updateMatrix(),m.uvTransform.value.copy(b.matrix));let x;v.aoMap?x=v.aoMap:v.lightMap&&(x=v.lightMap),x!==void 0&&(x.isWebGLRenderTarget&&(x=x.texture),x.matrixAutoUpdate===!0&&x.updateMatrix(),m.uv2Transform.value.copy(x.matrix))}u(s,"refreshUniformsCommon");function r(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity}u(r,"refreshUniformsLine");function o(m,v){m.dashSize.value=v.dashSize,m.totalSize.value=v.dashSize+v.gapSize,m.scale.value=v.scale}u(o,"refreshUniformsDash");function a(m,v,y,b){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.size.value=v.size*y,m.scale.value=b*.5,v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);let x;v.map?x=v.map:v.alphaMap&&(x=v.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),m.uvTransform.value.copy(x.matrix))}u(a,"refreshUniformsPoints");function l(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.rotation.value=v.rotation,v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);let y;v.map?y=v.map:v.alphaMap&&(y=v.alphaMap),y!==void 0&&(y.matrixAutoUpdate===!0&&y.updateMatrix(),m.uvTransform.value.copy(y.matrix))}u(l,"refreshUniformsSprites");function c(m,v){m.specular.value.copy(v.specular),m.shininess.value=Math.max(v.shininess,1e-4)}u(c,"refreshUniformsPhong");function h(m,v){v.gradientMap&&(m.gradientMap.value=v.gradientMap)}u(h,"refreshUniformsToon");function f(m,v){m.roughness.value=v.roughness,m.metalness.value=v.metalness,v.roughnessMap&&(m.roughnessMap.value=v.roughnessMap),v.metalnessMap&&(m.metalnessMap.value=v.metalnessMap),e.get(v).envMap&&(m.envMapIntensity.value=v.envMapIntensity)}u(f,"refreshUniformsStandard");function d(m,v,y){m.ior.value=v.ior,v.sheen>0&&(m.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),m.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(m.sheenColorMap.value=v.sheenColorMap),v.sheenRoughnessMap&&(m.sheenRoughnessMap.value=v.sheenRoughnessMap)),v.clearcoat>0&&(m.clearcoat.value=v.clearcoat,m.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(m.clearcoatMap.value=v.clearcoatMap),v.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap),v.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),m.clearcoatNormalMap.value=v.clearcoatNormalMap,v.side===ms&&m.clearcoatNormalScale.value.negate())),v.iridescence>0&&(m.iridescence.value=v.iridescence,m.iridescenceIOR.value=v.iridescenceIOR,m.iridescenceThicknessMinimum.value=v.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=v.iridescenceThicknessRange[1],v.iridescenceMap&&(m.iridescenceMap.value=v.iridescenceMap),v.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=v.iridescenceThicknessMap)),v.transmission>0&&(m.transmission.value=v.transmission,m.transmissionSamplerMap.value=y.texture,m.transmissionSamplerSize.value.set(y.width,y.height),v.transmissionMap&&(m.transmissionMap.value=v.transmissionMap),m.thickness.value=v.thickness,v.thicknessMap&&(m.thicknessMap.value=v.thicknessMap),m.attenuationDistance.value=v.attenuationDistance,m.attenuationColor.value.copy(v.attenuationColor)),m.specularIntensity.value=v.specularIntensity,m.specularColor.value.copy(v.specularColor),v.specularIntensityMap&&(m.specularIntensityMap.value=v.specularIntensityMap),v.specularColorMap&&(m.specularColorMap.value=v.specularColorMap)}u(d,"refreshUniformsPhysical");function p(m,v){v.matcap&&(m.matcap.value=v.matcap)}u(p,"refreshUniformsMatcap");function g(m,v){m.referencePosition.value.copy(v.referencePosition),m.nearDistance.value=v.nearDistance,m.farDistance.value=v.farDistance}return u(g,"refreshUniformsDistance"),{refreshFogUniforms:t,refreshMaterialUniforms:i}}u(fH,"WebGLMaterials");function dH(n,e,t,i){let s={},r={},o=[];const a=t.isWebGL2?n.getParameter(35375):0;function l(b,x){const w=x.program;i.uniformBlockBinding(b,w)}u(l,"bind");function c(b,x){let w=s[b.id];w===void 0&&(g(b),w=h(b),s[b.id]=w,b.addEventListener("dispose",v));const _=x.program;i.updateUBOMapping(b,_);const A=e.render.frame;r[b.id]!==A&&(d(b),r[b.id]=A)}u(c,"update");function h(b){const x=f();b.__bindingPointIndex=x;const w=n.createBuffer(),_=b.__size,A=b.usage;return n.bindBuffer(35345,w),n.bufferData(35345,_,A),n.bindBuffer(35345,null),n.bindBufferBase(35345,x,w),w}u(h,"createBuffer");function f(){for(let b=0;b<a;b++)if(o.indexOf(b)===-1)return o.push(b),b;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}u(f,"allocateBindingPointIndex");function d(b){const x=s[b.id],w=b.uniforms,_=b.__cache;n.bindBuffer(35345,x);for(let A=0,S=w.length;A<S;A++){const M=w[A];if(p(M,A,_)===!0){const C=M.value,I=M.__offset;typeof C=="number"?(M.__data[0]=C,n.bufferSubData(35345,I,M.__data)):(M.value.isMatrix3?(M.__data[0]=M.value.elements[0],M.__data[1]=M.value.elements[1],M.__data[2]=M.value.elements[2],M.__data[3]=M.value.elements[0],M.__data[4]=M.value.elements[3],M.__data[5]=M.value.elements[4],M.__data[6]=M.value.elements[5],M.__data[7]=M.value.elements[0],M.__data[8]=M.value.elements[6],M.__data[9]=M.value.elements[7],M.__data[10]=M.value.elements[8],M.__data[11]=M.value.elements[0]):C.toArray(M.__data),n.bufferSubData(35345,I,M.__data))}}n.bindBuffer(35345,null)}u(d,"updateBufferData");function p(b,x,w){const _=b.value;if(w[x]===void 0)return typeof _=="number"?w[x]=_:w[x]=_.clone(),!0;if(typeof _=="number"){if(w[x]!==_)return w[x]=_,!0}else{const A=w[x];if(A.equals(_)===!1)return A.copy(_),!0}return!1}u(p,"hasUniformChanged");function g(b){const x=b.uniforms;let w=0;const _=16;let A=0;for(let S=0,M=x.length;S<M;S++){const C=x[S],I=m(C);if(C.__data=new Float32Array(I.storage/Float32Array.BYTES_PER_ELEMENT),C.__offset=w,S>0){A=w%_;const F=_-A;A!==0&&F-I.boundary<0&&(w+=_-A,C.__offset=w)}w+=I.storage}return A=w%_,A>0&&(w+=_-A),b.__size=w,b.__cache={},this}u(g,"prepareUniformsGroup");function m(b){const x=b.value,w={boundary:0,storage:0};return typeof x=="number"?(w.boundary=4,w.storage=4):x.isVector2?(w.boundary=8,w.storage=8):x.isVector3||x.isColor?(w.boundary=16,w.storage=12):x.isVector4?(w.boundary=16,w.storage=16):x.isMatrix3?(w.boundary=48,w.storage=48):x.isMatrix4?(w.boundary=64,w.storage=64):x.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",x),w}u(m,"getUniformSize");function v(b){const x=b.target;x.removeEventListener("dispose",v);const w=o.indexOf(x.__bindingPointIndex);o.splice(w,1),n.deleteBuffer(s[x.id]),delete s[x.id],delete r[x.id]}u(v,"onUniformsGroupsDispose");function y(){for(const b in s)n.deleteBuffer(s[b]);o=[],s={},r={}}return u(y,"dispose"),{bind:l,update:c,dispose:y}}u(dH,"WebGLUniformsGroups");function pH(){const n=ip("canvas");return n.style.display="block",n}u(pH,"createCanvasElement");function SI(n={}){this.isWebGLRenderer=!0;const e=n.canvas!==void 0?n.canvas:pH(),t=n.context!==void 0?n.context:null,i=n.depth!==void 0?n.depth:!0,s=n.stencil!==void 0?n.stencil:!0,r=n.antialias!==void 0?n.antialias:!1,o=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,a=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,l=n.powerPreference!==void 0?n.powerPreference:"default",c=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h;t!==null?h=t.getContextAttributes().alpha:h=n.alpha!==void 0?n.alpha:!1;let f=null,d=null;const p=[],g=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Xo,this.physicallyCorrectLights=!1,this.toneMapping=Qs,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const m=this;let v=!1,y=0,b=0,x=null,w=-1,_=null;const A=new ut,S=new ut;let M=null,C=e.width,I=e.height,F=1,O=null,N=null;const E=new ut(0,0,C,I),k=new ut(0,0,C,I);let G=!1;const X=new Dp;let te=!1,j=!1,ie=null;const K=new me,$=new Ie,le=new P,ae={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function J(){return x===null?F:1}u(J,"getTargetPixelRatio");let ne=t;function ve(Z,fe){for(let xe=0;xe<Z.length;xe++){const ce=Z[xe],Ae=e.getContext(ce,fe);if(Ae!==null)return Ae}return null}u(ve,"getContext");try{const Z={alpha:!0,depth:i,stencil:s,antialias:r,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${I_}`),e.addEventListener("webglcontextlost",Ke,!1),e.addEventListener("webglcontextrestored",$e,!1),e.addEventListener("webglcontextcreationerror",Qe,!1),ne===null){const fe=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&fe.shift(),ne=ve(fe,Z),ne===null)throw ve(fe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}ne.getShaderPrecisionFormat===void 0&&(ne.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Z){throw console.error("THREE.WebGLRenderer: "+Z.message),Z}let he,_e,we,Se,V,Y,R,ee,Q,U,z,W,re,B,D,L,H,q,se,de,ge,ye,pe,Ne;function Ye(){he=new FV(ne),_e=new PV(ne,he,n),he.init(_e),ye=new uH(ne,he,_e),we=new lH(ne,he,_e),Se=new zV,V=new Z8,Y=new cH(ne,he,we,V,_e,ye,Se),R=new IV(m),ee=new OV(m),Q=new XU(ne,_e),pe=new CV(ne,he,Q,_e),U=new NV(ne,Q,Se,pe),z=new VV(ne,U,Q,Se),se=new $V(ne,_e,Y),L=new RV(V),W=new Y8(m,R,ee,he,_e,pe,L),re=new fH(m,V),B=new Q8,D=new sH(he,_e),q=new TV(m,R,ee,we,z,h,o),H=new aH(m,z,_e),Ne=new dH(ne,Se,_e,we),de=new EV(ne,he,Se,_e),ge=new kV(ne,he,Se,_e),Se.programs=W.programs,m.capabilities=_e,m.extensions=he,m.properties=V,m.renderLists=B,m.shadowMap=H,m.state=we,m.info=Se}u(Ye,"initGLContext"),Ye();const Re=new MI(m,ne);this.xr=Re,this.getContext=function(){return ne},this.getContextAttributes=function(){return ne.getContextAttributes()},this.forceContextLoss=function(){const Z=he.get("WEBGL_lose_context");Z&&Z.loseContext()},this.forceContextRestore=function(){const Z=he.get("WEBGL_lose_context");Z&&Z.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(Z){Z!==void 0&&(F=Z,this.setSize(C,I,!1))},this.getSize=function(Z){return Z.set(C,I)},this.setSize=function(Z,fe,xe){if(Re.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}C=Z,I=fe,e.width=Math.floor(Z*F),e.height=Math.floor(fe*F),xe!==!1&&(e.style.width=Z+"px",e.style.height=fe+"px"),this.setViewport(0,0,Z,fe)},this.getDrawingBufferSize=function(Z){return Z.set(C*F,I*F).floor()},this.setDrawingBufferSize=function(Z,fe,xe){C=Z,I=fe,F=xe,e.width=Math.floor(Z*xe),e.height=Math.floor(fe*xe),this.setViewport(0,0,Z,fe)},this.getCurrentViewport=function(Z){return Z.copy(A)},this.getViewport=function(Z){return Z.copy(E)},this.setViewport=function(Z,fe,xe,ce){Z.isVector4?E.set(Z.x,Z.y,Z.z,Z.w):E.set(Z,fe,xe,ce),we.viewport(A.copy(E).multiplyScalar(F).floor())},this.getScissor=function(Z){return Z.copy(k)},this.setScissor=function(Z,fe,xe,ce){Z.isVector4?k.set(Z.x,Z.y,Z.z,Z.w):k.set(Z,fe,xe,ce),we.scissor(S.copy(k).multiplyScalar(F).floor())},this.getScissorTest=function(){return G},this.setScissorTest=function(Z){we.setScissorTest(G=Z)},this.setOpaqueSort=function(Z){O=Z},this.setTransparentSort=function(Z){N=Z},this.getClearColor=function(Z){return Z.copy(q.getClearColor())},this.setClearColor=function(){q.setClearColor.apply(q,arguments)},this.getClearAlpha=function(){return q.getClearAlpha()},this.setClearAlpha=function(){q.setClearAlpha.apply(q,arguments)},this.clear=function(Z=!0,fe=!0,xe=!0){let ce=0;Z&&(ce|=16384),fe&&(ce|=256),xe&&(ce|=1024),ne.clear(ce)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ke,!1),e.removeEventListener("webglcontextrestored",$e,!1),e.removeEventListener("webglcontextcreationerror",Qe,!1),B.dispose(),D.dispose(),V.dispose(),R.dispose(),ee.dispose(),z.dispose(),pe.dispose(),Ne.dispose(),W.dispose(),Re.dispose(),Re.removeEventListener("sessionstart",Ue),Re.removeEventListener("sessionend",Xe),ie&&(ie.dispose(),ie=null),Ut.stop()};function Ke(Z){Z.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}u(Ke,"onContextLost");function $e(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const Z=Se.autoReset,fe=H.enabled,xe=H.autoUpdate,ce=H.needsUpdate,Ae=H.type;Ye(),Se.autoReset=Z,H.enabled=fe,H.autoUpdate=xe,H.needsUpdate=ce,H.type=Ae}u($e,"onContextRestore");function Qe(Z){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Z.statusMessage)}u(Qe,"onContextCreationError");function Bt(Z){const fe=Z.target;fe.removeEventListener("dispose",Bt),Yn(fe)}u(Bt,"onMaterialDispose");function Yn(Z){oe(Z),V.remove(Z)}u(Yn,"deallocateMaterial");function oe(Z){const fe=V.get(Z).programs;fe!==void 0&&(fe.forEach(function(xe){W.releaseProgram(xe)}),Z.isShaderMaterial&&W.releaseShaderCache(Z))}u(oe,"releaseMaterialProgramReferences"),this.renderBufferDirect=function(Z,fe,xe,ce,Ae,et){fe===null&&(fe=ae);const lt=Ae.isMesh&&Ae.matrixWorld.determinant()<0,xt=qN(Z,fe,xe,ce,Ae);we.setMaterial(ce,lt);let yt=xe.index;const $t=xe.attributes.position;if(yt===null){if($t===void 0||$t.count===0)return}else if(yt.count===0)return;let Ct=1;ce.wireframe===!0&&(yt=U.getWireframeAttribute(xe),Ct=2),pe.setup(Ae,ce,xt,xe,yt);let Ot,Tn=de;yt!==null&&(Ot=Q.get(yt),Tn=ge,Tn.setIndex(Ot));const hl=yt!==null?yt.count:$t.count,Ic=xe.drawRange.start*Ct,Dc=xe.drawRange.count*Ct,Dr=et!==null?et.start*Ct:0,Vt=et!==null?et.count*Ct:1/0,Lc=Math.max(Ic,Dr),Zn=Math.min(hl,Ic+Dc,Dr+Vt)-1,$s=Math.max(0,Zn-Lc+1);if($s!==0){if(Ae.isMesh)ce.wireframe===!0?(we.setLineWidth(ce.wireframeLinewidth*J()),Tn.setMode(1)):Tn.setMode(4);else if(Ae.isLine){let aa=ce.linewidth;aa===void 0&&(aa=1),we.setLineWidth(aa*J()),Ae.isLineSegments?Tn.setMode(1):Ae.isLineLoop?Tn.setMode(2):Tn.setMode(3)}else Ae.isPoints?Tn.setMode(0):Ae.isSprite&&Tn.setMode(4);if(Ae.isInstancedMesh)Tn.renderInstances(Lc,$s,Ae.count);else if(xe.isInstancedBufferGeometry){const aa=Math.min(xe.instanceCount,xe._maxInstanceCount);Tn.renderInstances(Lc,$s,aa)}else Tn.render(Lc,$s)}},this.compile=function(Z,fe){function xe(ce,Ae,et){ce.transparent===!0&&ce.side===Ki?(ce.side=ms,ce.needsUpdate=!0,Us(ce,Ae,et),ce.side=eo,ce.needsUpdate=!0,Us(ce,Ae,et),ce.side=Ki):Us(ce,Ae,et)}u(xe,"prepare"),d=D.get(Z),d.init(),g.push(d),Z.traverseVisible(function(ce){ce.isLight&&ce.layers.test(fe.layers)&&(d.pushLight(ce),ce.castShadow&&d.pushShadow(ce))}),d.setupLights(m.physicallyCorrectLights),Z.traverse(function(ce){const Ae=ce.material;if(Ae)if(Array.isArray(Ae))for(let et=0;et<Ae.length;et++){const lt=Ae[et];xe(lt,Z,ce)}else xe(Ae,Z,ce)}),g.pop(),d=null};let be=null;function Ee(Z){be&&be(Z)}u(Ee,"onAnimationFrame");function Ue(){Ut.stop()}u(Ue,"onXRSessionStart");function Xe(){Ut.start()}u(Xe,"onXRSessionEnd");const Ut=new hI;Ut.setAnimationLoop(Ee),typeof self!="undefined"&&Ut.setContext(self),this.setAnimationLoop=function(Z){be=Z,Re.setAnimationLoop(Z),Z===null?Ut.stop():Ut.start()},Re.addEventListener("sessionstart",Ue),Re.addEventListener("sessionend",Xe),this.render=function(Z,fe){if(fe!==void 0&&fe.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(v===!0)return;Z.matrixWorldAutoUpdate===!0&&Z.updateMatrixWorld(),fe.parent===null&&fe.matrixWorldAutoUpdate===!0&&fe.updateMatrixWorld(),Re.enabled===!0&&Re.isPresenting===!0&&(Re.cameraAutoUpdate===!0&&Re.updateCamera(fe),fe=Re.getCamera()),Z.isScene===!0&&Z.onBeforeRender(m,Z,fe,x),d=D.get(Z,g.length),d.init(),g.push(d),K.multiplyMatrices(fe.projectionMatrix,fe.matrixWorldInverse),X.setFromProjectionMatrix(K),j=this.localClippingEnabled,te=L.init(this.clippingPlanes,j,fe),f=B.get(Z,p.length),f.init(),p.push(f),pi(Z,fe,0,m.sortObjects),f.finish(),m.sortObjects===!0&&f.sort(O,N),te===!0&&L.beginShadows();const xe=d.state.shadowsArray;if(H.render(xe,Z,fe),te===!0&&L.endShadows(),this.info.autoReset===!0&&this.info.reset(),q.render(f,Z),d.setupLights(m.physicallyCorrectLights),fe.isArrayCamera){const ce=fe.cameras;for(let Ae=0,et=ce.length;Ae<et;Ae++){const lt=ce[Ae];Pi(f,Z,lt,lt.viewport)}}else Pi(f,Z,fe);x!==null&&(Y.updateMultisampleRenderTarget(x),Y.updateRenderTargetMipmap(x)),Z.isScene===!0&&Z.onAfterRender(m,Z,fe),pe.resetDefaultState(),w=-1,_=null,g.pop(),g.length>0?d=g[g.length-1]:d=null,p.pop(),p.length>0?f=p[p.length-1]:f=null};function pi(Z,fe,xe,ce){if(Z.visible===!1)return;if(Z.layers.test(fe.layers)){if(Z.isGroup)xe=Z.renderOrder;else if(Z.isLOD)Z.autoUpdate===!0&&Z.update(fe);else if(Z.isLight)d.pushLight(Z),Z.castShadow&&d.pushShadow(Z);else if(Z.isSprite){if(!Z.frustumCulled||X.intersectsSprite(Z)){ce&&le.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(K);const lt=z.update(Z),xt=Z.material;xt.visible&&f.push(Z,lt,xt,xe,le.z,null)}}else if((Z.isMesh||Z.isLine||Z.isPoints)&&(Z.isSkinnedMesh&&Z.skeleton.frame!==Se.render.frame&&(Z.skeleton.update(),Z.skeleton.frame=Se.render.frame),!Z.frustumCulled||X.intersectsObject(Z))){ce&&le.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(K);const lt=z.update(Z),xt=Z.material;if(Array.isArray(xt)){const yt=lt.groups;for(let $t=0,Ct=yt.length;$t<Ct;$t++){const Ot=yt[$t],Tn=xt[Ot.materialIndex];Tn&&Tn.visible&&f.push(Z,lt,Tn,xe,le.z,Ot)}}else xt.visible&&f.push(Z,lt,xt,xe,le.z,null)}}const et=Z.children;for(let lt=0,xt=et.length;lt<xt;lt++)pi(et[lt],fe,xe,ce)}u(pi,"projectObject");function Pi(Z,fe,xe,ce){const Ae=Z.opaque,et=Z.transmissive,lt=Z.transparent;d.setupLightsView(xe),et.length>0&&ul(Ae,fe,xe),ce&&we.viewport(A.copy(ce)),Ae.length>0&&gn(Ae,fe,xe),et.length>0&&gn(et,fe,xe),lt.length>0&&gn(lt,fe,xe),we.buffers.depth.setTest(!0),we.buffers.depth.setMask(!0),we.buffers.color.setMask(!0),we.setPolygonOffset(!1)}u(Pi,"renderScene");function ul(Z,fe,xe){const ce=_e.isWebGL2;ie===null&&(ie=new Ln(1,1,{generateMipmaps:!0,type:he.has("EXT_color_buffer_half_float")?cc:to,minFilter:Mc,samples:ce&&r===!0?4:0})),m.getDrawingBufferSize($),ce?ie.setSize($.x,$.y):ie.setSize(W0($.x),W0($.y));const Ae=m.getRenderTarget();m.setRenderTarget(ie),m.clear();const et=m.toneMapping;m.toneMapping=Qs,gn(Z,fe,xe),m.toneMapping=et,Y.updateMultisampleRenderTarget(ie),Y.updateRenderTargetMipmap(ie),m.setRenderTarget(Ae)}u(ul,"renderTransmissionPass");function gn(Z,fe,xe){const ce=fe.isScene===!0?fe.overrideMaterial:null;for(let Ae=0,et=Z.length;Ae<et;Ae++){const lt=Z[Ae],xt=lt.object,yt=lt.geometry,$t=ce===null?lt.material:ce,Ct=lt.group;xt.layers.test(xe.layers)&&ro(xt,fe,xe,yt,$t,Ct)}}u(gn,"renderObjects");function ro(Z,fe,xe,ce,Ae,et){Z.onBeforeRender(m,fe,xe,ce,Ae,et),Z.modelViewMatrix.multiplyMatrices(xe.matrixWorldInverse,Z.matrixWorld),Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix),Ae.onBeforeRender(m,fe,xe,ce,Z,et),Ae.transparent===!0&&Ae.side===Ki?(Ae.side=ms,Ae.needsUpdate=!0,m.renderBufferDirect(xe,fe,ce,Ae,Z,et),Ae.side=eo,Ae.needsUpdate=!0,m.renderBufferDirect(xe,fe,ce,Ae,Z,et),Ae.side=Ki):m.renderBufferDirect(xe,fe,ce,Ae,Z,et),Z.onAfterRender(m,fe,xe,ce,Ae,et)}u(ro,"renderObject");function Us(Z,fe,xe){fe.isScene!==!0&&(fe=ae);const ce=V.get(Z),Ae=d.state.lights,et=d.state.shadowsArray,lt=Ae.state.version,xt=W.getParameters(Z,Ae.state,et,fe,xe),yt=W.getProgramCacheKey(xt);let $t=ce.programs;ce.environment=Z.isMeshStandardMaterial?fe.environment:null,ce.fog=fe.fog,ce.envMap=(Z.isMeshStandardMaterial?ee:R).get(Z.envMap||ce.environment),$t===void 0&&(Z.addEventListener("dispose",Bt),$t=new Map,ce.programs=$t);let Ct=$t.get(yt);if(Ct!==void 0){if(ce.currentProgram===Ct&&ce.lightsStateVersion===lt)return LM(Z,xt),Ct}else xt.uniforms=W.getUniforms(Z),Z.onBuild(xe,xt,m),Z.onBeforeCompile(xt,m),Ct=W.acquireProgram(xt,yt),$t.set(yt,Ct),ce.uniforms=xt.uniforms;const Ot=ce.uniforms;(!Z.isShaderMaterial&&!Z.isRawShaderMaterial||Z.clipping===!0)&&(Ot.clippingPlanes=L.uniform),LM(Z,xt),ce.needsLights=ZN(Z),ce.lightsStateVersion=lt,ce.needsLights&&(Ot.ambientLightColor.value=Ae.state.ambient,Ot.lightProbe.value=Ae.state.probe,Ot.directionalLights.value=Ae.state.directional,Ot.directionalLightShadows.value=Ae.state.directionalShadow,Ot.spotLights.value=Ae.state.spot,Ot.spotLightShadows.value=Ae.state.spotShadow,Ot.rectAreaLights.value=Ae.state.rectArea,Ot.ltc_1.value=Ae.state.rectAreaLTC1,Ot.ltc_2.value=Ae.state.rectAreaLTC2,Ot.pointLights.value=Ae.state.point,Ot.pointLightShadows.value=Ae.state.pointShadow,Ot.hemisphereLights.value=Ae.state.hemi,Ot.directionalShadowMap.value=Ae.state.directionalShadowMap,Ot.directionalShadowMatrix.value=Ae.state.directionalShadowMatrix,Ot.spotShadowMap.value=Ae.state.spotShadowMap,Ot.spotLightMatrix.value=Ae.state.spotLightMatrix,Ot.spotLightMap.value=Ae.state.spotLightMap,Ot.pointShadowMap.value=Ae.state.pointShadowMap,Ot.pointShadowMatrix.value=Ae.state.pointShadowMatrix);const Tn=Ct.getUniforms(),hl=Ud.seqWithValue(Tn.seq,Ot);return ce.currentProgram=Ct,ce.uniformsList=hl,Ct}u(Us,"getProgram");function LM(Z,fe){const xe=V.get(Z);xe.outputEncoding=fe.outputEncoding,xe.instancing=fe.instancing,xe.skinning=fe.skinning,xe.morphTargets=fe.morphTargets,xe.morphNormals=fe.morphNormals,xe.morphColors=fe.morphColors,xe.morphTargetsCount=fe.morphTargetsCount,xe.numClippingPlanes=fe.numClippingPlanes,xe.numIntersection=fe.numClipIntersection,xe.vertexAlphas=fe.vertexAlphas,xe.vertexTangents=fe.vertexTangents,xe.toneMapping=fe.toneMapping}u(LM,"updateCommonMaterialProperties");function qN(Z,fe,xe,ce,Ae){fe.isScene!==!0&&(fe=ae),Y.resetTextureUnits();const et=fe.fog,lt=ce.isMeshStandardMaterial?fe.environment:null,xt=x===null?m.outputEncoding:x.isXRRenderTarget===!0?x.texture.encoding:Xo,yt=(ce.isMeshStandardMaterial?ee:R).get(ce.envMap||lt),$t=ce.vertexColors===!0&&!!xe.attributes.color&&xe.attributes.color.itemSize===4,Ct=!!ce.normalMap&&!!xe.attributes.tangent,Ot=!!xe.morphAttributes.position,Tn=!!xe.morphAttributes.normal,hl=!!xe.morphAttributes.color,Ic=ce.toneMapped?m.toneMapping:Qs,Dc=xe.morphAttributes.position||xe.morphAttributes.normal||xe.morphAttributes.color,Dr=Dc!==void 0?Dc.length:0,Vt=V.get(ce),Lc=d.state.lights;if(te===!0&&(j===!0||Z!==_)){const ys=Z===_&&ce.id===w;L.setState(ce,Z,ys)}let Zn=!1;ce.version===Vt.__version?(Vt.needsLights&&Vt.lightsStateVersion!==Lc.state.version||Vt.outputEncoding!==xt||Ae.isInstancedMesh&&Vt.instancing===!1||!Ae.isInstancedMesh&&Vt.instancing===!0||Ae.isSkinnedMesh&&Vt.skinning===!1||!Ae.isSkinnedMesh&&Vt.skinning===!0||Vt.envMap!==yt||ce.fog===!0&&Vt.fog!==et||Vt.numClippingPlanes!==void 0&&(Vt.numClippingPlanes!==L.numPlanes||Vt.numIntersection!==L.numIntersection)||Vt.vertexAlphas!==$t||Vt.vertexTangents!==Ct||Vt.morphTargets!==Ot||Vt.morphNormals!==Tn||Vt.morphColors!==hl||Vt.toneMapping!==Ic||_e.isWebGL2===!0&&Vt.morphTargetsCount!==Dr)&&(Zn=!0):(Zn=!0,Vt.__version=ce.version);let $s=Vt.currentProgram;Zn===!0&&($s=Us(ce,fe,Ae));let aa=!1,nf=!1,Sv=!1;const $i=$s.getUniforms(),fl=Vt.uniforms;if(we.useProgram($s.program)&&(aa=!0,nf=!0,Sv=!0),ce.id!==w&&(w=ce.id,nf=!0),aa||_!==Z){if($i.setValue(ne,"projectionMatrix",Z.projectionMatrix),_e.logarithmicDepthBuffer&&$i.setValue(ne,"logDepthBufFC",2/(Math.log(Z.far+1)/Math.LN2)),_!==Z&&(_=Z,nf=!0,Sv=!0),ce.isShaderMaterial||ce.isMeshPhongMaterial||ce.isMeshToonMaterial||ce.isMeshStandardMaterial||ce.envMap){const ys=$i.map.cameraPosition;ys!==void 0&&ys.setValue(ne,le.setFromMatrixPosition(Z.matrixWorld))}(ce.isMeshPhongMaterial||ce.isMeshToonMaterial||ce.isMeshLambertMaterial||ce.isMeshBasicMaterial||ce.isMeshStandardMaterial||ce.isShaderMaterial)&&$i.setValue(ne,"isOrthographic",Z.isOrthographicCamera===!0),(ce.isMeshPhongMaterial||ce.isMeshToonMaterial||ce.isMeshLambertMaterial||ce.isMeshBasicMaterial||ce.isMeshStandardMaterial||ce.isShaderMaterial||ce.isShadowMaterial||Ae.isSkinnedMesh)&&$i.setValue(ne,"viewMatrix",Z.matrixWorldInverse)}if(Ae.isSkinnedMesh){$i.setOptional(ne,Ae,"bindMatrix"),$i.setOptional(ne,Ae,"bindMatrixInverse");const ys=Ae.skeleton;ys&&(_e.floatVertexTextures?(ys.boneTexture===null&&ys.computeBoneTexture(),$i.setValue(ne,"boneTexture",ys.boneTexture,Y),$i.setValue(ne,"boneTextureSize",ys.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Tv=xe.morphAttributes;if((Tv.position!==void 0||Tv.normal!==void 0||Tv.color!==void 0&&_e.isWebGL2===!0)&&se.update(Ae,xe,ce,$s),(nf||Vt.receiveShadow!==Ae.receiveShadow)&&(Vt.receiveShadow=Ae.receiveShadow,$i.setValue(ne,"receiveShadow",Ae.receiveShadow)),ce.isMeshGouraudMaterial&&ce.envMap!==null&&(fl.envMap.value=yt,fl.flipEnvMap.value=yt.isCubeTexture&&yt.isRenderTargetTexture===!1?-1:1),nf&&($i.setValue(ne,"toneMappingExposure",m.toneMappingExposure),Vt.needsLights&&YN(fl,Sv),et&&ce.fog===!0&&re.refreshFogUniforms(fl,et),re.refreshMaterialUniforms(fl,ce,F,I,ie),Ud.upload(ne,Vt.uniformsList,fl,Y)),ce.isShaderMaterial&&ce.uniformsNeedUpdate===!0&&(Ud.upload(ne,Vt.uniformsList,fl,Y),ce.uniformsNeedUpdate=!1),ce.isSpriteMaterial&&$i.setValue(ne,"center",Ae.center),$i.setValue(ne,"modelViewMatrix",Ae.modelViewMatrix),$i.setValue(ne,"normalMatrix",Ae.normalMatrix),$i.setValue(ne,"modelMatrix",Ae.matrixWorld),ce.isShaderMaterial||ce.isRawShaderMaterial){const ys=ce.uniformsGroups;for(let Cv=0,KN=ys.length;Cv<KN;Cv++)if(_e.isWebGL2){const OM=ys[Cv];Ne.update(OM,$s),Ne.bind(OM,$s)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return $s}u(qN,"setProgram");function YN(Z,fe){Z.ambientLightColor.needsUpdate=fe,Z.lightProbe.needsUpdate=fe,Z.directionalLights.needsUpdate=fe,Z.directionalLightShadows.needsUpdate=fe,Z.pointLights.needsUpdate=fe,Z.pointLightShadows.needsUpdate=fe,Z.spotLights.needsUpdate=fe,Z.spotLightShadows.needsUpdate=fe,Z.rectAreaLights.needsUpdate=fe,Z.hemisphereLights.needsUpdate=fe}u(YN,"markUniformsLightsNeedsUpdate");function ZN(Z){return Z.isMeshLambertMaterial||Z.isMeshToonMaterial||Z.isMeshPhongMaterial||Z.isMeshStandardMaterial||Z.isShadowMaterial||Z.isShaderMaterial&&Z.lights===!0}u(ZN,"materialNeedsLights"),this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderTarget=function(){return x},this.setRenderTargetTextures=function(Z,fe,xe){V.get(Z.texture).__webglTexture=fe,V.get(Z.depthTexture).__webglTexture=xe;const ce=V.get(Z);ce.__hasExternalTextures=!0,ce.__hasExternalTextures&&(ce.__autoAllocateDepthBuffer=xe===void 0,ce.__autoAllocateDepthBuffer||he.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ce.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(Z,fe){const xe=V.get(Z);xe.__webglFramebuffer=fe,xe.__useDefaultFramebuffer=fe===void 0},this.setRenderTarget=function(Z,fe=0,xe=0){x=Z,y=fe,b=xe;let ce=!0,Ae=null,et=!1,lt=!1;if(Z){const yt=V.get(Z);yt.__useDefaultFramebuffer!==void 0?(we.bindFramebuffer(36160,null),ce=!1):yt.__webglFramebuffer===void 0?Y.setupRenderTarget(Z):yt.__hasExternalTextures&&Y.rebindTextures(Z,V.get(Z.texture).__webglTexture,V.get(Z.depthTexture).__webglTexture);const $t=Z.texture;($t.isData3DTexture||$t.isDataArrayTexture||$t.isCompressedArrayTexture)&&(lt=!0);const Ct=V.get(Z).__webglFramebuffer;Z.isWebGLCubeRenderTarget?(Ae=Ct[fe],et=!0):_e.isWebGL2&&Z.samples>0&&Y.useMultisampledRTT(Z)===!1?Ae=V.get(Z).__webglMultisampledFramebuffer:Ae=Ct,A.copy(Z.viewport),S.copy(Z.scissor),M=Z.scissorTest}else A.copy(E).multiplyScalar(F).floor(),S.copy(k).multiplyScalar(F).floor(),M=G;if(we.bindFramebuffer(36160,Ae)&&_e.drawBuffers&&ce&&we.drawBuffers(Z,Ae),we.viewport(A),we.scissor(S),we.setScissorTest(M),et){const yt=V.get(Z.texture);ne.framebufferTexture2D(36160,36064,34069+fe,yt.__webglTexture,xe)}else if(lt){const yt=V.get(Z.texture),$t=fe||0;ne.framebufferTextureLayer(36160,36064,yt.__webglTexture,xe||0,$t)}w=-1},this.readRenderTargetPixels=function(Z,fe,xe,ce,Ae,et,lt){if(!(Z&&Z.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let xt=V.get(Z).__webglFramebuffer;if(Z.isWebGLCubeRenderTarget&&lt!==void 0&&(xt=xt[lt]),xt){we.bindFramebuffer(36160,xt);try{const yt=Z.texture,$t=yt.format,Ct=yt.type;if($t!==rn&&ye.convert($t)!==ne.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ot=Ct===cc&&(he.has("EXT_color_buffer_half_float")||_e.isWebGL2&&he.has("EXT_color_buffer_float"));if(Ct!==to&&ye.convert(Ct)!==ne.getParameter(35738)&&!(Ct===on&&(_e.isWebGL2||he.has("OES_texture_float")||he.has("WEBGL_color_buffer_float")))&&!Ot){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}fe>=0&&fe<=Z.width-ce&&xe>=0&&xe<=Z.height-Ae&&ne.readPixels(fe,xe,ce,Ae,ye.convert($t),ye.convert(Ct),et)}finally{const yt=x!==null?V.get(x).__webglFramebuffer:null;we.bindFramebuffer(36160,yt)}}},this.copyFramebufferToTexture=function(Z,fe,xe=0){const ce=Math.pow(2,-xe),Ae=Math.floor(fe.image.width*ce),et=Math.floor(fe.image.height*ce);Y.setTexture2D(fe,0),ne.copyTexSubImage2D(3553,xe,0,0,Z.x,Z.y,Ae,et),we.unbindTexture()},this.copyTextureToTexture=function(Z,fe,xe,ce=0){const Ae=fe.image.width,et=fe.image.height,lt=ye.convert(xe.format),xt=ye.convert(xe.type);Y.setTexture2D(xe,0),ne.pixelStorei(37440,xe.flipY),ne.pixelStorei(37441,xe.premultiplyAlpha),ne.pixelStorei(3317,xe.unpackAlignment),fe.isDataTexture?ne.texSubImage2D(3553,ce,Z.x,Z.y,Ae,et,lt,xt,fe.image.data):fe.isCompressedTexture?ne.compressedTexSubImage2D(3553,ce,Z.x,Z.y,fe.mipmaps[0].width,fe.mipmaps[0].height,lt,fe.mipmaps[0].data):ne.texSubImage2D(3553,ce,Z.x,Z.y,lt,xt,fe.image),ce===0&&xe.generateMipmaps&&ne.generateMipmap(3553),we.unbindTexture()},this.copyTextureToTexture3D=function(Z,fe,xe,ce,Ae=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const et=Z.max.x-Z.min.x+1,lt=Z.max.y-Z.min.y+1,xt=Z.max.z-Z.min.z+1,yt=ye.convert(ce.format),$t=ye.convert(ce.type);let Ct;if(ce.isData3DTexture)Y.setTexture3D(ce,0),Ct=32879;else if(ce.isDataArrayTexture)Y.setTexture2DArray(ce,0),Ct=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ne.pixelStorei(37440,ce.flipY),ne.pixelStorei(37441,ce.premultiplyAlpha),ne.pixelStorei(3317,ce.unpackAlignment);const Ot=ne.getParameter(3314),Tn=ne.getParameter(32878),hl=ne.getParameter(3316),Ic=ne.getParameter(3315),Dc=ne.getParameter(32877),Dr=xe.isCompressedTexture?xe.mipmaps[0]:xe.image;ne.pixelStorei(3314,Dr.width),ne.pixelStorei(32878,Dr.height),ne.pixelStorei(3316,Z.min.x),ne.pixelStorei(3315,Z.min.y),ne.pixelStorei(32877,Z.min.z),xe.isDataTexture||xe.isData3DTexture?ne.texSubImage3D(Ct,Ae,fe.x,fe.y,fe.z,et,lt,xt,yt,$t,Dr.data):xe.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ne.compressedTexSubImage3D(Ct,Ae,fe.x,fe.y,fe.z,et,lt,xt,yt,Dr.data)):ne.texSubImage3D(Ct,Ae,fe.x,fe.y,fe.z,et,lt,xt,yt,$t,Dr),ne.pixelStorei(3314,Ot),ne.pixelStorei(32878,Tn),ne.pixelStorei(3316,hl),ne.pixelStorei(3315,Ic),ne.pixelStorei(32877,Dc),Ae===0&&ce.generateMipmaps&&ne.generateMipmap(Ct),we.unbindTexture()},this.initTexture=function(Z){Z.isCubeTexture?Y.setTextureCube(Z,0):Z.isData3DTexture?Y.setTexture3D(Z,0):Z.isDataArrayTexture||Z.isCompressedArrayTexture?Y.setTexture2DArray(Z,0):Y.setTexture2D(Z,0),we.unbindTexture()},this.resetState=function(){y=0,b=0,x=null,we.reset(),pe.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}u(SI,"WebGLRenderer");class TI extends SI{}u(TI,"WebGL1Renderer");TI.prototype.isWebGL1Renderer=!0;class sp extends It{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.backgroundBlurriness=this.backgroundBlurriness),t}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(e){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=e}}u(sp,"Scene");class CI{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=wx,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ar()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let s=0,r=this.stride;s<r;s++)this.array[e+s]=t.array[i+s];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ar()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ar()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}u(CI,"InterleavedBuffer");const Vi=new P;class O1{constructor(e,t,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=s===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)Vi.fromBufferAttribute(this,t),Vi.applyMatrix4(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Vi.fromBufferAttribute(this,t),Vi.applyNormalMatrix(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Vi.fromBufferAttribute(this,t),Vi.transformDirection(e),this.setXYZ(t,Vi.x,Vi.y,Vi.z);return this}setX(e,t){return this.normalized&&(t=sn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Uo(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Uo(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Uo(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Uo(t,this.array)),t}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array),s=sn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=s,this}setXYZW(e,t,i,s,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=sn(t,this.array),i=sn(i,this.array),s=sn(s,this.array),r=sn(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=s,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return new Rt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new O1(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}u(O1,"InterleavedBufferAttribute");const NS=new P,kS=new ut,zS=new ut,mH=new P,BS=new me;class V_ extends We{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new me,this.bindMatrixInverse=new me}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new ut,t=this.geometry.attributes.skinWeight;for(let i=0,s=t.count;i<s;i++){e.fromBufferAttribute(t,i);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const i=this.skeleton,s=this.geometry;kS.fromBufferAttribute(s.attributes.skinIndex,e),zS.fromBufferAttribute(s.attributes.skinWeight,e),NS.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=zS.getComponent(r);if(o!==0){const a=kS.getComponent(r);BS.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),t.addScaledVector(mH.copy(NS).applyMatrix4(BS),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}u(V_,"SkinnedMesh");class rp extends It{constructor(){super(),this.isBone=!0,this.type="Bone"}}u(rp,"Bone");class Js extends ui{constructor(e=null,t=1,i=1,s,r,o,a,l,c=Yt,h=Yt,f,d){super(null,o,a,l,c,h,s,r,f,d),this.isDataTexture=!0,this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}u(Js,"DataTexture");const US=new me,gH=new me;class Lp{constructor(e=[],t=[]){this.uuid=Ar(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new me)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const i=new me;this.bones[e]&&i.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&i.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const a=e[r]?e[r].matrixWorld:gH;US.multiplyMatrices(a,t[r]),US.toArray(i,r*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new Lp(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=rI(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new Js(t,e,e,rn,on);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const s=this.bones[t];if(s.name===e)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,s=e.bones.length;i<s;i++){const r=e.bones[i];let o=t[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new rp),this.bones.push(o),this.boneInverses.push(new me().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let s=0,r=t.length;s<r;s++){const o=t[s];e.bones.push(o.uuid);const a=i[s];e.boneInverses.push(a.toArray())}return e}}u(Lp,"Skeleton");class Cx extends Rt{constructor(e,t,i,s=1){super(e,t,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}u(Cx,"InstancedBufferAttribute");const $S=new me,VS=new me,Sm=[],vH=new me,hf=new We;class EI extends We{constructor(e,t,i){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Cx(new Float32Array(i*16),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1;for(let s=0;s<i;s++)this.setMatrixAt(s,vH)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const i=this.matrixWorld,s=this.count;if(hf.geometry=this.geometry,hf.material=this.material,hf.material!==void 0)for(let r=0;r<s;r++){this.getMatrixAt(r,$S),VS.multiplyMatrices(i,$S),hf.matrixWorld=VS,hf.raycast(e,Sm);for(let o=0,a=Sm.length;o<a;o++){const l=Sm[o];l.instanceId=r,l.object=this,t.push(l)}Sm.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Cx(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}u(EI,"InstancedMesh");class Bi extends ns{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Ce(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}u(Bi,"LineBasicMaterial");const HS=new P,GS=new P,WS=new me,py=new sl,Tm=new na;class er extends It{constructor(e=new Je,t=new Bi){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[0];for(let s=1,r=t.count;s<r;s++)HS.fromBufferAttribute(t,s-1),GS.fromBufferAttribute(t,s),i[s]=i[s-1],i[s]+=HS.distanceTo(GS);e.setAttribute("lineDistance",new Ve(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const i=this.geometry,s=this.matrixWorld,r=e.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Tm.copy(i.boundingSphere),Tm.applyMatrix4(s),Tm.radius+=r,e.ray.intersectsSphere(Tm)===!1)return;WS.copy(s).invert(),py.copy(e.ray).applyMatrix4(WS);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new P,h=new P,f=new P,d=new P,p=this.isLineSegments?2:1,g=i.index,v=i.attributes.position;if(g!==null){const y=Math.max(0,o.start),b=Math.min(g.count,o.start+o.count);for(let x=y,w=b-1;x<w;x+=p){const _=g.getX(x),A=g.getX(x+1);if(c.fromBufferAttribute(v,_),h.fromBufferAttribute(v,A),py.distanceSqToSegment(c,h,d,f)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:f.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,o.start),b=Math.min(v.count,o.start+o.count);for(let x=y,w=b-1;x<w;x+=p){if(c.fromBufferAttribute(v,x),h.fromBufferAttribute(v,x+1),py.distanceSqToSegment(c,h,d,f)>l)continue;d.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(d);A<e.near||A>e.far||t.push({distance:A,point:f.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}u(er,"Line");const jS=new P,XS=new P;class Tr extends er{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[];for(let s=0,r=t.count;s<r;s+=2)jS.fromBufferAttribute(t,s),XS.fromBufferAttribute(t,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+jS.distanceTo(XS);e.setAttribute("lineDistance",new Ve(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}u(Tr,"LineSegments");class PI extends er{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}u(PI,"LineLoop");class Yr extends ns{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Ce(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}u(Yr,"PointsMaterial");const qS=new me,Ex=new sl,Cm=new na,Em=new P;class Wa extends It{constructor(e=new Je,t=new Yr){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,s=this.matrixWorld,r=e.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Cm.copy(i.boundingSphere),Cm.applyMatrix4(s),Cm.radius+=r,e.ray.intersectsSphere(Cm)===!1)return;qS.copy(s).invert(),Ex.copy(e.ray).applyMatrix4(qS);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=i.index,f=i.attributes.position;if(c!==null){const d=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let g=d,m=p;g<m;g++){const v=c.getX(g);Em.fromBufferAttribute(f,v),YS(Em,v,l,s,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(f.count,o.start+o.count);for(let g=d,m=p;g<m;g++)Em.fromBufferAttribute(f,g),YS(Em,g,l,s,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}u(Wa,"Points");function YS(n,e,t,i,s,r,o){const a=Ex.distanceSqToPoint(n);if(a<t){const l=new P;Ex.closestPointToPoint(n,l),l.applyMatrix4(i);const c=s.ray.origin.distanceTo(l);if(c<s.near||c>s.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}u(YS,"testPoint");class H_{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,s=this.getPoint(0),r=0;t.push(0);for(let o=1;o<=e;o++)i=this.getPoint(o/e),r+=i.distanceTo(s),t.push(r),s=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let s=0;const r=i.length;let o;t?o=t:o=e*i[r-1];let a=0,l=r-1,c;for(;a<=l;)if(s=Math.floor(a+(l-a)/2),c=i[s]-o,c<0)a=s+1;else if(c>0)l=s-1;else{l=s;break}if(s=l,i[s]===o)return s/(r-1);const h=i[s],d=i[s+1]-h,p=(o-h)/d;return(s+p)/(r-1)}getTangent(e,t){let s=e-1e-4,r=e+1e-4;s<0&&(s=0),r>1&&(r=1);const o=this.getPoint(s),a=this.getPoint(r),l=t||(o.isVector2?new Ie:new P);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new P,s=[],r=[],o=[],a=new P,l=new me;for(let p=0;p<=e;p++){const g=p/e;s[p]=this.getTangentAt(g,new P)}r[0]=new P,o[0]=new P;let c=Number.MAX_VALUE;const h=Math.abs(s[0].x),f=Math.abs(s[0].y),d=Math.abs(s[0].z);h<=c&&(c=h,i.set(1,0,0)),f<=c&&(c=f,i.set(0,1,0)),d<=c&&i.set(0,0,1),a.crossVectors(s[0],i).normalize(),r[0].crossVectors(s[0],a),o[0].crossVectors(s[0],r[0]);for(let p=1;p<=e;p++){if(r[p]=r[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(s[p-1],s[p]),a.length()>Number.EPSILON){a.normalize();const g=Math.acos(ai(s[p-1].dot(s[p]),-1,1));r[p].applyMatrix4(l.makeRotationAxis(a,g))}o[p].crossVectors(s[p],r[p])}if(t===!0){let p=Math.acos(ai(r[0].dot(r[e]),-1,1));p/=e,s[0].dot(a.crossVectors(r[0],r[e]))>0&&(p=-p);for(let g=1;g<=e;g++)r[g].applyMatrix4(l.makeRotationAxis(s[g],p*g)),o[g].crossVectors(s[g],r[g])}return{tangents:s,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}u(H_,"Curve");class ah extends Je{constructor(e=1,t=8,i=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:s},t=Math.max(3,t);const r=[],o=[],a=[],l=[],c=new P,h=new Ie;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let f=0,d=3;f<=t;f++,d+=3){const p=i+f/t*s;c.x=e*Math.cos(p),c.y=e*Math.sin(p),o.push(c.x,c.y,c.z),a.push(0,0,1),h.x=(o[d]/e+1)/2,h.y=(o[d+1]/e+1)/2,l.push(h.x,h.y)}for(let f=1;f<=t;f++)r.push(f,f+1,0);this.setIndex(r),this.setAttribute("position",new Ve(o,3)),this.setAttribute("normal",new Ve(a,3)),this.setAttribute("uv",new Ve(l,2))}static fromJSON(e){return new ah(e.radius,e.segments,e.thetaStart,e.thetaLength)}}u(ah,"CircleGeometry");class lh extends Je{constructor(e=1,t=1,i=1,s=8,r=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:s,heightSegments:r,openEnded:o,thetaStart:a,thetaLength:l};const c=this;s=Math.floor(s),r=Math.floor(r);const h=[],f=[],d=[],p=[];let g=0;const m=[],v=i/2;let y=0;b(),o===!1&&(e>0&&x(!0),t>0&&x(!1)),this.setIndex(h),this.setAttribute("position",new Ve(f,3)),this.setAttribute("normal",new Ve(d,3)),this.setAttribute("uv",new Ve(p,2));function b(){const w=new P,_=new P;let A=0;const S=(t-e)/i;for(let M=0;M<=r;M++){const C=[],I=M/r,F=I*(t-e)+e;for(let O=0;O<=s;O++){const N=O/s,E=N*l+a,k=Math.sin(E),G=Math.cos(E);_.x=F*k,_.y=-I*i+v,_.z=F*G,f.push(_.x,_.y,_.z),w.set(k,S,G).normalize(),d.push(w.x,w.y,w.z),p.push(N,1-I),C.push(g++)}m.push(C)}for(let M=0;M<s;M++)for(let C=0;C<r;C++){const I=m[C][M],F=m[C+1][M],O=m[C+1][M+1],N=m[C][M+1];h.push(I,F,N),h.push(F,O,N),A+=6}c.addGroup(y,A,0),y+=A}u(b,"generateTorso");function x(w){const _=g,A=new Ie,S=new P;let M=0;const C=w===!0?e:t,I=w===!0?1:-1;for(let O=1;O<=s;O++)f.push(0,v*I,0),d.push(0,I,0),p.push(.5,.5),g++;const F=g;for(let O=0;O<=s;O++){const E=O/s*l+a,k=Math.cos(E),G=Math.sin(E);S.x=C*G,S.y=v*I,S.z=C*k,f.push(S.x,S.y,S.z),d.push(0,I,0),A.x=k*.5+.5,A.y=G*.5*I+.5,p.push(A.x,A.y),g++}for(let O=0;O<s;O++){const N=_+O,E=F+O;w===!0?h.push(E,E+1,N):h.push(E+1,E,N),M+=3}c.addGroup(y,M,w===!0?1:2),y+=M}u(x,"generateCap")}static fromJSON(e){return new lh(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}u(lh,"CylinderGeometry");class F1 extends lh{constructor(e=1,t=1,i=8,s=1,r=!1,o=0,a=Math.PI*2){super(0,e,t,i,s,r,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:s,openEnded:r,thetaStart:o,thetaLength:a}}static fromJSON(e){return new F1(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}u(F1,"ConeGeometry");class N1 extends Je{constructor(e=[],t=[],i=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:s};const r=[],o=[];a(s),c(i),h(),this.setAttribute("position",new Ve(r,3)),this.setAttribute("normal",new Ve(r.slice(),3)),this.setAttribute("uv",new Ve(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const x=new P,w=new P,_=new P;for(let A=0;A<t.length;A+=3)p(t[A+0],x),p(t[A+1],w),p(t[A+2],_),l(x,w,_,b)}u(a,"subdivide");function l(b,x,w,_){const A=_+1,S=[];for(let M=0;M<=A;M++){S[M]=[];const C=b.clone().lerp(w,M/A),I=x.clone().lerp(w,M/A),F=A-M;for(let O=0;O<=F;O++)O===0&&M===A?S[M][O]=C:S[M][O]=C.clone().lerp(I,O/F)}for(let M=0;M<A;M++)for(let C=0;C<2*(A-M)-1;C++){const I=Math.floor(C/2);C%2===0?(d(S[M][I+1]),d(S[M+1][I]),d(S[M][I])):(d(S[M][I+1]),d(S[M+1][I+1]),d(S[M+1][I]))}}u(l,"subdivideFace");function c(b){const x=new P;for(let w=0;w<r.length;w+=3)x.x=r[w+0],x.y=r[w+1],x.z=r[w+2],x.normalize().multiplyScalar(b),r[w+0]=x.x,r[w+1]=x.y,r[w+2]=x.z}u(c,"applyRadius");function h(){const b=new P;for(let x=0;x<r.length;x+=3){b.x=r[x+0],b.y=r[x+1],b.z=r[x+2];const w=v(b)/2/Math.PI+.5,_=y(b)/Math.PI+.5;o.push(w,1-_)}g(),f()}u(h,"generateUVs");function f(){for(let b=0;b<o.length;b+=6){const x=o[b+0],w=o[b+2],_=o[b+4],A=Math.max(x,w,_),S=Math.min(x,w,_);A>.9&&S<.1&&(x<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),_<.2&&(o[b+4]+=1))}}u(f,"correctSeam");function d(b){r.push(b.x,b.y,b.z)}u(d,"pushVertex");function p(b,x){const w=b*3;x.x=e[w+0],x.y=e[w+1],x.z=e[w+2]}u(p,"getVertexByIndex");function g(){const b=new P,x=new P,w=new P,_=new P,A=new Ie,S=new Ie,M=new Ie;for(let C=0,I=0;C<r.length;C+=9,I+=6){b.set(r[C+0],r[C+1],r[C+2]),x.set(r[C+3],r[C+4],r[C+5]),w.set(r[C+6],r[C+7],r[C+8]),A.set(o[I+0],o[I+1]),S.set(o[I+2],o[I+3]),M.set(o[I+4],o[I+5]),_.copy(b).add(x).add(w).divideScalar(3);const F=v(_);m(A,I+0,b,F),m(S,I+2,x,F),m(M,I+4,w,F)}}u(g,"correctUVs");function m(b,x,w,_){_<0&&b.x===1&&(o[x]=b.x-1),w.x===0&&w.z===0&&(o[x]=_/2/Math.PI+.5)}u(m,"correctUV");function v(b){return Math.atan2(b.z,-b.x)}u(v,"azimuth");function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}u(y,"inclination")}static fromJSON(e){return new N1(e.vertices,e.indices,e.radius,e.details)}}u(N1,"PolyhedronGeometry");class k1 extends N1{constructor(e=1,t=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new k1(e.radius,e.detail)}}u(k1,"OctahedronGeometry");class z1 extends Je{constructor(e=1,t=32,i=16,s=0,r=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:s,phiLength:r,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const l=Math.min(o+a,Math.PI);let c=0;const h=[],f=new P,d=new P,p=[],g=[],m=[],v=[];for(let y=0;y<=i;y++){const b=[],x=y/i;let w=0;y==0&&o==0?w=.5/t:y==i&&l==Math.PI&&(w=-.5/t);for(let _=0;_<=t;_++){const A=_/t;f.x=-e*Math.cos(s+A*r)*Math.sin(o+x*a),f.y=e*Math.cos(o+x*a),f.z=e*Math.sin(s+A*r)*Math.sin(o+x*a),g.push(f.x,f.y,f.z),d.copy(f).normalize(),m.push(d.x,d.y,d.z),v.push(A+w,1-x),b.push(c++)}h.push(b)}for(let y=0;y<i;y++)for(let b=0;b<t;b++){const x=h[y][b+1],w=h[y][b],_=h[y+1][b],A=h[y+1][b+1];(y!==0||o>0)&&p.push(x,w,A),(y!==i-1||l<Math.PI)&&p.push(w,_,A)}this.setIndex(p),this.setAttribute("position",new Ve(g,3)),this.setAttribute("normal",new Ve(m,3)),this.setAttribute("uv",new Ve(v,2))}static fromJSON(e){return new z1(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}u(z1,"SphereGeometry$2");class Ua extends Je{constructor(e=1,t=.4,i=8,s=6,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:s,arc:r},i=Math.floor(i),s=Math.floor(s);const o=[],a=[],l=[],c=[],h=new P,f=new P,d=new P;for(let p=0;p<=i;p++)for(let g=0;g<=s;g++){const m=g/s*r,v=p/i*Math.PI*2;f.x=(e+t*Math.cos(v))*Math.cos(m),f.y=(e+t*Math.cos(v))*Math.sin(m),f.z=t*Math.sin(v),a.push(f.x,f.y,f.z),h.x=e*Math.cos(m),h.y=e*Math.sin(m),d.subVectors(f,h).normalize(),l.push(d.x,d.y,d.z),c.push(g/s),c.push(p/i)}for(let p=1;p<=i;p++)for(let g=1;g<=s;g++){const m=(s+1)*p+g-1,v=(s+1)*(p-1)+g-1,y=(s+1)*(p-1)+g,b=(s+1)*p+g;o.push(m,v,b),o.push(v,y,b)}this.setIndex(o),this.setAttribute("position",new Ve(a,3)),this.setAttribute("normal",new Ve(l,3)),this.setAttribute("uv",new Ve(c,2))}static fromJSON(e){return new Ua(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}u(Ua,"TorusGeometry");class rr extends ns{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ce(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ce(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pp,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}u(rr,"MeshStandardMaterial");class ol extends rr{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ie(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ai(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Ce(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Ce(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ce(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}u(ol,"MeshPhysicalMaterial");class $d extends ns{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Ce(16777215),this.specular=new Ce(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ce(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pp,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=C1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}u($d,"MeshPhongMaterial");class G_ extends ns{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Ce(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ce(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pp,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=C1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}u(G_,"MeshLambertMaterial");function va(n,e,t){return RI(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)}u(va,"arraySlice");function Pm(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}u(Pm,"convertArray");function RI(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}u(RI,"isTypedArray");function yH(n){function e(s,r){return n[s]-n[r]}u(e,"compareTime");const t=n.length,i=new Array(t);for(let s=0;s!==t;++s)i[s]=s;return i.sort(e),i}u(yH,"getKeyframeOrder");function ZS(n,e,t){const i=n.length,s=new n.constructor(i);for(let r=0,o=0;o!==i;++r){const a=t[r]*e;for(let l=0;l!==e;++l)s[o++]=n[a+l]}return s}u(ZS,"sortedArray");function II(n,e,t,i){let s=1,r=n[0];for(;r!==void 0&&r[i]===void 0;)r=n[s++];if(r===void 0)return;let o=r[i];if(o!==void 0)if(Array.isArray(o))do o=r[i],o!==void 0&&(e.push(r.time),t.push.apply(t,o)),r=n[s++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[i],o!==void 0&&(e.push(r.time),o.toArray(t,t.length)),r=n[s++];while(r!==void 0);else do o=r[i],o!==void 0&&(e.push(r.time),t.push(o)),r=n[s++];while(r!==void 0)}u(II,"flattenJSON");class zh{constructor(e,t,i,s){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,s=t[i],r=t[i-1];e:{t:{let o;n:{i:if(!(e<s)){for(let a=i+2;;){if(s===void 0){if(e<r)break i;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(r=s,s=t[++i],e<s)break t}o=t.length;break n}if(!(e>=r)){const a=t[1];e<a&&(i=2,r=a);for(let l=i-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(s=r,r=t[--i-1],e>=r)break t}o=i,i=0;break n}break e}for(;i<o;){const a=i+o>>>1;e<t[a]?o=a:i=a+1}if(s=t[i],r=t[i-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,r,s)}return this.interpolate_(i,r,e,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=e*s;for(let o=0;o!==s;++o)t[o]=i[r+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}u(zh,"Interpolant");class DI extends zh{constructor(e,t,i,s){super(e,t,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:eS,endingEnd:eS}}intervalChanged_(e,t,i){const s=this.parameterPositions;let r=e-2,o=e+1,a=s[r],l=s[o];if(a===void 0)switch(this.getSettings_().endingStart){case tS:r=e,a=2*t-i;break;case nS:r=s.length-2,a=t+s[r]-s[r+1];break;default:r=e,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case tS:o=e,l=2*i-t;break;case nS:o=1,l=i+s[1]-s[0];break;default:o=e-1,l=t}const c=(i-t)*.5,h=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-i),this._offsetPrev=r*h,this._offsetNext=o*h}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=this._offsetPrev,f=this._offsetNext,d=this._weightPrev,p=this._weightNext,g=(i-t)/(s-t),m=g*g,v=m*g,y=-d*v+2*d*m-d*g,b=(1+d)*v+(-1.5-2*d)*m+(-.5+d)*g+1,x=(-1-p)*v+(1.5+p)*m+.5*g,w=p*v-p*m;for(let _=0;_!==a;++_)r[_]=y*o[h+_]+b*o[c+_]+x*o[l+_]+w*o[f+_];return r}}u(DI,"CubicInterpolant");class LI extends zh{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=(i-t)/(s-t),f=1-h;for(let d=0;d!==a;++d)r[d]=o[c+d]*f+o[l+d]*h;return r}}u(LI,"LinearInterpolant");class OI extends zh{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e){return this.copySampleValue_(e-1)}}u(OI,"DiscreteInterpolant");class Rr{constructor(e,t,i,s){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Pm(t,this.TimeBufferType),this.values=Pm(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:Pm(e.times,Array),values:Pm(e.values,Array)};const s=e.getInterpolation();s!==e.DefaultInterpolation&&(i.interpolation=s)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new OI(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new LI(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new DI(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case sh:t=this.InterpolantFactoryMethodDiscrete;break;case uc:t=this.InterpolantFactoryMethodLinear;break;case Vv:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return sh;case this.InterpolantFactoryMethodLinear:return uc;case this.InterpolantFactoryMethodSmooth:return Vv}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let i=0,s=t.length;i!==s;++i)t[i]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let i=0,s=t.length;i!==s;++i)t[i]*=e}return this}trim(e,t){const i=this.times,s=i.length;let r=0,o=s-1;for(;r!==s&&i[r]<e;)++r;for(;o!==-1&&i[o]>t;)--o;if(++o,r!==0||o!==s){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=va(i,r,o),this.values=va(this.values,r*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,s=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==r;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(s!==void 0&&RI(s))for(let a=0,l=s.length;a!==l;++a){const c=s[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=va(this.times),t=va(this.values),i=this.getValueSize(),s=this.getInterpolation()===Vv,r=e.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=e[a],h=e[a+1];if(c!==h&&(a!==1||c!==e[0]))if(s)l=!0;else{const f=a*i,d=f-i,p=f+i;for(let g=0;g!==i;++g){const m=t[f+g];if(m!==t[d+g]||m!==t[p+g]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const f=a*i,d=o*i;for(let p=0;p!==i;++p)t[d+p]=t[f+p]}++o}}if(r>0){e[o]=e[r];for(let a=r*i,l=o*i,c=0;c!==i;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=va(e,0,o),this.values=va(t,0,o*i)):(this.times=e,this.values=t),this}clone(){const e=va(this.times,0),t=va(this.values,0),i=this.constructor,s=new i(this.name,e,t);return s.createInterpolant=this.createInterpolant,s}}u(Rr,"KeyframeTrack");Rr.prototype.TimeBufferType=Float32Array;Rr.prototype.ValueBufferType=Float32Array;Rr.prototype.DefaultInterpolation=uc;class Tc extends Rr{}u(Tc,"BooleanKeyframeTrack");Tc.prototype.ValueTypeName="bool";Tc.prototype.ValueBufferType=Array;Tc.prototype.DefaultInterpolation=sh;Tc.prototype.InterpolantFactoryMethodLinear=void 0;Tc.prototype.InterpolantFactoryMethodSmooth=void 0;class W_ extends Rr{}u(W_,"ColorKeyframeTrack");W_.prototype.ValueTypeName="color";class hc extends Rr{}u(hc,"NumberKeyframeTrack");hc.prototype.ValueTypeName="number";class FI extends zh{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(i-t)/(s-t);let c=e*a;for(let h=c+a;c!==h;c+=4)je.slerpFlat(r,0,o,c-a,o,c,l);return r}}u(FI,"QuaternionLinearInterpolant");class qo extends Rr{InterpolantFactoryMethodLinear(e){return new FI(this.times,this.values,this.getValueSize(),e)}}u(qo,"QuaternionKeyframeTrack");qo.prototype.ValueTypeName="quaternion";qo.prototype.DefaultInterpolation=uc;qo.prototype.InterpolantFactoryMethodSmooth=void 0;class Cc extends Rr{}u(Cc,"StringKeyframeTrack");Cc.prototype.ValueTypeName="string";Cc.prototype.ValueBufferType=Array;Cc.prototype.DefaultInterpolation=sh;Cc.prototype.InterpolantFactoryMethodLinear=void 0;Cc.prototype.InterpolantFactoryMethodSmooth=void 0;class fc extends Rr{}u(fc,"VectorKeyframeTrack");fc.prototype.ValueTypeName="vector";class j_{constructor(e,t=-1,i,s=dU){this.name=e,this.tracks=i,this.duration=t,this.blendMode=s,this.uuid=Ar(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,s=1/(e.fps||1);for(let o=0,a=i.length;o!==a;++o)t.push(xH(i[o]).scale(s));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],i=e.tracks,s={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,o=i.length;r!==o;++r)t.push(Rr.toJSON(i[r]));return s}static CreateFromMorphTargetSequence(e,t,i,s){const r=t.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const h=yH(l);l=ZS(l,1,h),c=ZS(c,1,h),!s&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new hc(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/i))}return new this(e,-1,o)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const s=e;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===t)return i[s];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const s={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],h=c.name.match(r);if(h&&h.length>1){const f=h[1];let d=s[f];d||(s[f]=d=[]),d.push(c)}}const o=[];for(const a in s)o.push(this.CreateFromMorphTargetSequence(a,s[a],t,i));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=u(function(f,d,p,g,m){if(p.length!==0){const v=[],y=[];II(p,v,y,g),v.length!==0&&m.push(new f(d,v,y))}},"addNonemptyTrack"),s=[],r=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let f=0;f<c.length;f++){const d=c[f].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let g;for(g=0;g<d.length;g++)if(d[g].morphTargets)for(let m=0;m<d[g].morphTargets.length;m++)p[d[g].morphTargets[m]]=-1;for(const m in p){const v=[],y=[];for(let b=0;b!==d[g].morphTargets.length;++b){const x=d[g];v.push(x.time),y.push(x.morphTarget===m?1:0)}s.push(new hc(".morphTargetInfluence["+m+"]",v,y))}l=p.length*o}else{const p=".bones["+t[f].name+"]";i(fc,p+".position",d,"pos",s),i(qo,p+".quaternion",d,"rot",s),i(fc,p+".scale",d,"scl",s)}}return s.length===0?null:new this(r,l,s,a)}resetDuration(){const e=this.tracks;let t=0;for(let i=0,s=e.length;i!==s;++i){const r=this.tracks[i];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}u(j_,"AnimationClip");function bH(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return hc;case"vector":case"vector2":case"vector3":case"vector4":return fc;case"color":return W_;case"quaternion":return qo;case"bool":case"boolean":return Tc;case"string":return Cc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}u(bH,"getTrackTypeForValueTypeName");function xH(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=bH(n.type);if(n.times===void 0){const t=[],i=[];II(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}u(xH,"parseKeyframeTrack");const ch={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class X_{constructor(e,t,i){const s=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(h){a++,r===!1&&s.onStart!==void 0&&s.onStart(h,o,a),r=!0},this.itemEnd=function(h){o++,s.onProgress!==void 0&&s.onProgress(h,o,a),o===a&&(r=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(h){s.onError!==void 0&&s.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,f){return c.push(h,f),this},this.removeHandler=function(h){const f=c.indexOf(h);return f!==-1&&c.splice(f,2),this},this.getHandler=function(h){for(let f=0,d=c.length;f<d;f+=2){const p=c[f],g=c[f+1];if(p.global&&(p.lastIndex=0),p.test(h))return g}return null}}}u(X_,"LoadingManager");const _H=new X_;class ia{constructor(e){this.manager=e!==void 0?e:_H,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise(function(s,r){i.load(e,s,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}u(ia,"Loader");const fo={};class NI extends Error{constructor(e,t){super(e),this.response=t}}u(NI,"HttpError");class Bh extends ia{constructor(e){super(e)}load(e,t,i,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=ch.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(fo[e]!==void 0){fo[e].push({onLoad:t,onProgress:i,onError:s});return}fo[e]=[],fo[e].push({onLoad:t,onProgress:i,onError:s});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream=="undefined"||c.body===void 0||c.body.getReader===void 0)return c;const h=fo[e],f=c.body.getReader(),d=c.headers.get("Content-Length"),p=d?parseInt(d):0,g=p!==0;let m=0;const v=new ReadableStream({start(y){b();function b(){f.read().then(({done:x,value:w})=>{if(x)y.close();else{m+=w.byteLength;const _=new ProgressEvent("progress",{lengthComputable:g,loaded:m,total:p});for(let A=0,S=h.length;A<S;A++){const M=h[A];M.onProgress&&M.onProgress(_)}y.enqueue(w),b()}})}u(b,"readData")}});return new Response(v)}else throw new NI(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,a));case"json":return c.json();default:if(a===void 0)return c.text();{const f=/charset="?([^;"\s]*)"?/i.exec(a),d=f&&f[1]?f[1].toLowerCase():void 0,p=new TextDecoder(d);return c.arrayBuffer().then(g=>p.decode(g))}}}).then(c=>{ch.add(e,c);const h=fo[e];delete fo[e];for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onLoad&&p.onLoad(c)}}).catch(c=>{const h=fo[e];if(h===void 0)throw this.manager.itemError(e),c;delete fo[e];for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}u(Bh,"FileLoader");class kI extends ia{constructor(e){super(e)}load(e,t,i,s){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=ch.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a=ip("img");function l(){h(),ch.add(e,this),t&&t(this),r.manager.itemEnd(e)}u(l,"onImageLoad");function c(f){h(),s&&s(f),r.manager.itemError(e),r.manager.itemEnd(e)}u(c,"onImageError");function h(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return u(h,"removeEventListeners"),a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(e),a.src=e,a}}u(kI,"ImageLoader");class Op extends ia{constructor(e){super(e)}load(e,t,i,s){const r=new ui,o=new kI(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){r.image=a,r.needsUpdate=!0,t!==void 0&&t(r)},i,s),r}}u(Op,"TextureLoader");class Uh extends It{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Ce(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}u(Uh,"Light");class zI extends Uh{constructor(e,t,i){super(e,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.groundColor=new Ce(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}u(zI,"HemisphereLight");const my=new me,KS=new P,QS=new P;class B1{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ie(512,512),this.map=null,this.mapPass=null,this.matrix=new me,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Dp,this._frameExtents=new Ie(1,1),this._viewportCount=1,this._viewports=[new ut(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;KS.setFromMatrixPosition(e.matrixWorld),t.position.copy(KS),QS.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(QS),t.updateMatrixWorld(),my.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(my),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(my)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}u(B1,"LightShadow");class BI extends B1{constructor(){super(new li(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,i=np*2*e.angle*this.focus,s=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(i!==t.fov||s!==t.aspect||r!==t.far)&&(t.fov=i,t.aspect=s,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}u(BI,"SpotLightShadow");class U1 extends Uh{constructor(e,t,i=0,s=Math.PI/3,r=0,o=1){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.target=new It,this.distance=i,this.angle=s,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new BI}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}u(U1,"SpotLight");const JS=new me,ff=new P,gy=new P;class UI extends B1{constructor(){super(new li(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ie(4,2),this._viewportCount=6,this._viewports=[new ut(2,1,1,1),new ut(0,1,1,1),new ut(3,1,1,1),new ut(1,1,1,1),new ut(3,0,1,1),new ut(1,0,1,1)],this._cubeDirections=[new P(1,0,0),new P(-1,0,0),new P(0,0,1),new P(0,0,-1),new P(0,1,0),new P(0,-1,0)],this._cubeUps=[new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,1,0),new P(0,0,1),new P(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,s=this.matrix,r=e.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),ff.setFromMatrixPosition(e.matrixWorld),i.position.copy(ff),gy.copy(i.position),gy.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(gy),i.updateMatrixWorld(),s.makeTranslation(-ff.x,-ff.y,-ff.z),JS.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(JS)}}u(UI,"PointLightShadow");class op extends Uh{constructor(e,t,i=0,s=1){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new UI}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}u(op,"PointLight");class $I extends B1{constructor(){super(new rl(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}u($I,"DirectionalLightShadow");class Fp extends Uh{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(It.DefaultUp),this.updateMatrix(),this.target=new It,this.shadow=new $I}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}u(Fp,"DirectionalLight");class $1 extends Uh{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}u($1,"AmbientLight");class Mr{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let i=0,s=e.length;i<s;i++)t+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}u(Mr,"LoaderUtils");class VI extends ia{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=ch.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){ch.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){s&&s(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}u(VI,"ImageBitmapLoader");class HI{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=e3(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=e3();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}u(HI,"Clock");function e3(){return(typeof performance=="undefined"?Date:performance).now()}u(e3,"now");const q_="\\[\\]\\.:\\/",wH=new RegExp("["+q_+"]","g"),Y_="[^"+q_+"]",AH="[^"+q_.replace("\\.","")+"]",MH=/((?:WC+[\/:])*)/.source.replace("WC",Y_),SH=/(WCOD+)?/.source.replace("WCOD",AH),TH=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Y_),CH=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Y_),EH=new RegExp("^"+MH+SH+TH+CH+"$"),PH=["material","materials","bones","map"];class GI{constructor(e,t,i){const s=i||_t.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,s)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,r=i.length;s!==r;++s)i[s].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}}u(GI,"Composite");class _t{constructor(e,t,i){this.path=t,this.parsedPath=i||_t.parseTrackName(t),this.node=_t.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new _t.Composite(e,t,i):new _t(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(wH,"")}static parseTrackName(e){const t=EH.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const r=i.nodeName.substring(s+1);PH.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(i!==void 0)return i}if(e.children){const i=u(function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===t||a.uuid===t)return a;const l=i(a.children);if(l)return l}return null},"searchNodeSubtree"),s=i(e.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)e[t++]=i[s]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,s=t.propertyName;let r=t.propertyIndex;if(e||(e=_t.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let c=t.objectIndex;switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let h=0;h<e.length;h++)if(e[h].name===c){c=h;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[s];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+s+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(s==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}u(_t,"PropertyBinding");_t.Composite=GI;_t.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};_t.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};_t.prototype.GetterByBindingType=[_t.prototype._getValue_direct,_t.prototype._getValue_array,_t.prototype._getValue_arrayElement,_t.prototype._getValue_toArray];_t.prototype.SetterByBindingTypeAndVersioning=[[_t.prototype._setValue_direct,_t.prototype._setValue_direct_setNeedsUpdate,_t.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[_t.prototype._setValue_array,_t.prototype._setValue_array_setNeedsUpdate,_t.prototype._setValue_array_setMatrixWorldNeedsUpdate],[_t.prototype._setValue_arrayElement,_t.prototype._setValue_arrayElement_setNeedsUpdate,_t.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[_t.prototype._setValue_fromArray,_t.prototype._setValue_fromArray_setNeedsUpdate,_t.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class WI{constructor(e,t,i=0,s=1/0){this.ray=new sl(e,t),this.near=i,this.far=s,this.camera=null,this.layers=new P1,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,i=[]){return Px(e,this,i,t),i.sort(t3),i}intersectObjects(e,t=!0,i=[]){for(let s=0,r=e.length;s<r;s++)Px(e[s],this,i,t);return i.sort(t3),i}}u(WI,"Raycaster");function t3(n,e){return n.distance-e.distance}u(t3,"ascSort");function Px(n,e,t,i){if(n.layers.test(e.layers)&&n.raycast(e,t),i===!0){const s=n.children;for(let r=0,o=s.length;r<o;r++)Px(s[r],e,t,!0)}}u(Px,"intersectObject");const n3=new P,Rm=new P;class Kr{constructor(e=new P,t=new P){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){n3.subVectors(e,this.start),Rm.subVectors(this.end,this.start);const i=Rm.dot(Rm);let r=Rm.dot(n3)/i;return t&&(r=ai(r,0,1)),r}closestPointToPoint(e,t,i){const s=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}u(Kr,"Line3");const i3=new P;class jI extends It{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const i=new Je,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,h=a/l*Math.PI*2;s.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}i.setAttribute("position",new Ve(s,3));const r=new Bi({fog:!1,toneMapped:!1});this.cone=new Tr(i,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),i3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(i3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}u(jI,"SpotLightHelper");class XI extends We{constructor(e,t,i){const s=new z1(t,4,2),r=new xi({wireframe:!0,fog:!1,toneMapped:!1});super(s,r),this.light=e,this.light.updateMatrixWorld(),this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}u(XI,"PointLightHelper");const RH=new P,s3=new Ce,r3=new Ce;class qI extends It{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i;const s=new k1(t);s.rotateY(Math.PI*.5),this.material=new xi({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=s.getAttribute("position"),o=new Float32Array(r.count*3);s.setAttribute("color",new Rt(o,3)),this.add(new We(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");s3.copy(this.light.color),r3.copy(this.light.groundColor);for(let i=0,s=t.count;i<s;i++){const r=i<s/2?s3:r3;t.setXYZ(i,r.r,r.g,r.b)}t.needsUpdate=!0}e.lookAt(RH.setFromMatrixPosition(this.light.matrixWorld).negate())}}u(qI,"HemisphereLightHelper");const o3=new P,Im=new P,a3=new P;class YI extends It{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,t===void 0&&(t=1);let s=new Je;s.setAttribute("position",new Ve([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new Bi({fog:!1,toneMapped:!1});this.lightPlane=new er(s,r),this.add(this.lightPlane),s=new Je,s.setAttribute("position",new Ve([0,0,0,0,0,1],3)),this.targetLine=new er(s,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){o3.setFromMatrixPosition(this.light.matrixWorld),Im.setFromMatrixPosition(this.light.target.matrixWorld),a3.subVectors(Im,o3),this.lightPlane.lookAt(Im),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Im),this.targetLine.scale.z=a3.length()}}u(YI,"DirectionalLightHelper");const Dm=new P,Cn=new D1;class ZI extends Tr{constructor(e){const t=new Je,i=new Bi({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],r=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(g,m){l(g),l(m)}u(a,"addLine");function l(g){s.push(0,0,0),r.push(0,0,0),o[g]===void 0&&(o[g]=[]),o[g].push(s.length/3-1)}u(l,"addPoint"),t.setAttribute("position",new Ve(s,3)),t.setAttribute("color",new Ve(r,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new Ce(16755200),h=new Ce(16711680),f=new Ce(43775),d=new Ce(16777215),p=new Ce(3355443);this.setColors(c,h,f,d,p)}setColors(e,t,i,s,r){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,i.r,i.g,i.b),a.setXYZ(33,i.r,i.g,i.b),a.setXYZ(34,i.r,i.g,i.b),a.setXYZ(35,i.r,i.g,i.b),a.setXYZ(36,i.r,i.g,i.b),a.setXYZ(37,i.r,i.g,i.b),a.setXYZ(38,s.r,s.g,s.b),a.setXYZ(39,s.r,s.g,s.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,i=1,s=1;Cn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Nn("c",t,e,Cn,0,0,-1),Nn("t",t,e,Cn,0,0,1),Nn("n1",t,e,Cn,-i,-s,-1),Nn("n2",t,e,Cn,i,-s,-1),Nn("n3",t,e,Cn,-i,s,-1),Nn("n4",t,e,Cn,i,s,-1),Nn("f1",t,e,Cn,-i,-s,1),Nn("f2",t,e,Cn,i,-s,1),Nn("f3",t,e,Cn,-i,s,1),Nn("f4",t,e,Cn,i,s,1),Nn("u1",t,e,Cn,i*.7,s*1.1,-1),Nn("u2",t,e,Cn,-i*.7,s*1.1,-1),Nn("u3",t,e,Cn,0,s*2,-1),Nn("cf1",t,e,Cn,-i,0,1),Nn("cf2",t,e,Cn,i,0,1),Nn("cf3",t,e,Cn,0,-s,1),Nn("cf4",t,e,Cn,0,s,1),Nn("cn1",t,e,Cn,-i,0,-1),Nn("cn2",t,e,Cn,i,0,-1),Nn("cn3",t,e,Cn,0,-s,-1),Nn("cn4",t,e,Cn,0,s,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}u(ZI,"CameraHelper");function Nn(n,e,t,i,s,r,o){Dm.set(s,r,o).unproject(i);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],Dm.x,Dm.y,Dm.z)}}u(Nn,"setPoint");const ko=IH();function IH(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),i=new Uint32Array(512),s=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(i[l]=0,i[l|256]=32768,s[l]=24,s[l|256]=24):c<-14?(i[l]=1024>>-c-14,i[l|256]=1024>>-c-14|32768,s[l]=-c-1,s[l|256]=-c-1):c<=15?(i[l]=c+15<<10,i[l|256]=c+15<<10|32768,s[l]=13,s[l|256]=13):c<128?(i[l]=31744,i[l|256]=64512,s[l]=24,s[l|256]=24):(i[l]=31744,i[l|256]=64512,s[l]=13,s[l|256]=13)}const r=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)===0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,r[l]=c|h}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:i,shiftTable:s,mantissaTable:r,exponentTable:o,offsetTable:a}}u(IH,"_generateTables");function DH(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=ai(n,-65504,65504),ko.floatView[0]=n;const e=ko.uint32View[0],t=e>>23&511;return ko.baseTable[t]+((e&8388607)>>ko.shiftTable[t])}u(DH,"toHalfFloat");function LH(n){const e=n>>10;return ko.uint32View[0]=ko.mantissaTable[ko.offsetTable[e]+(n&1023)]+ko.exponentTable[e],ko.floatView[0]}u(LH,"fromHalfFloat");var OH=Object.freeze({__proto__:null,toHalfFloat:DH,fromHalfFloat:LH});typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:I_}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=I_);var FH=Object.defineProperty,w0=u((n,e)=>FH(n,"name",{value:e,configurable:!0}),"__name$3l");function dc(n,e,t){let i,s,r=w0(a=>e(a),"_onDragMove"),o=w0(a=>(document.removeEventListener("pointermove",r),document.removeEventListener("pointerup",i),document.removeEventListener("pointerout",s),t&&t(a)),"_onDragEnd");i=o,s=w0(a=>{(!a.relatedTarget||a.relatedTarget.nodeName==="HTML")&&o(a)},"onPointerOut"),document.addEventListener("pointermove",r),document.addEventListener("pointerup",i),document.addEventListener("pointerout",s),n&&r(n)}u(dc,"addGlobalDragListener");w0(dc,"addGlobalDragListener");var NH=Object.defineProperty,Lm=u((n,e)=>NH(n,"name",{value:e,configurable:!0}),"__name$3k");const l3="color-box",c3="color-box-active";var kH=zt({props:{value:{type:Array,default:[1,1,1]},colorBox:Boolean},emits:["update:value"],setup(n,e){const t=He(),i=He(),s=160/2,r=13,o=Ho(new Ce),a=Ho({h:0,s:0,l:0}),l=He(0),c=He(0),h=He(0),f=He(0),d=Ho([16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215]);try{const A=localStorage.getItem(l3);if(A){const M=JSON.parse(A);for(let C=0,I=d.length;C<I;++C)d[C]=M[C]}const S=localStorage.getItem(c3);S&&(f.value=JSON.parse(S))}catch(A){console.error(A)}ts(d,function(){!n.colorBox||localStorage.setItem(l3,JSON.stringify(d))},{deep:!0}),ts(f,function(){!n.colorBox||localStorage.setItem(c3,JSON.stringify(f.value))}),ts(()=>n.value,function(){o.setRGB(n.value[0],n.value[1],n.value[2]),o.getHSL(a);let A=a.h,S=a.s,M=a.l,C=S*Math.min(M,1-M)+M;S=C?2-2*M/C:0,(S||C||h.value&&!S&&!C)&&(c.value=S,h.value=C),S&&(l.value=A),d[f.value]=o.getHex()},{immediate:!0});const p=st(function(){return o.getHexString()}),g=st(function(){return d.map(A=>new Ce().setHex(A).getHexString())}),m=st(function(){return{transform:`rotate(${Math.round(l.value*360)-60}deg)`,"transform-origin":`0 ${s}px`}}),v=st(function(){return{"background-color":`#${new Ce().setHSL(l.value,1,.5).getHexString()}`}}),y=st(function(){return{left:`${Math.round(100*c.value)}%`,top:`${Math.round(100*(1-h.value))}%`}});function b(A){A.stopPropagation();const S=t.value.getBoundingClientRect(),M=s,C=s,I=A.clientX-S.left,F=A.clientY-S.top,O=Math.sqrt((I-M)**2+(F-C)**2);O>=s-r&&O<=s&&dc(A,N=>{const E=N.clientX-S.left-M,k=N.clientY-S.top-C,X=(Math.atan2(k,E)/Math.PI*180+360*2+90+60)%360/360,te=new Ce().setHSL(X,a.s,a.l);e.emit("update:value",[te.r,te.g,te.b]),l.value=X})}u(b,"onHueRingMouseDown"),Lm(b,"onHueRingMouseDown");function x(A){A.stopPropagation();const S=i.value.getBoundingClientRect();dc(A,M=>{let C=Math.min(Math.max(M.clientX-S.left,0),S.width)/S.width,I=1-Math.min(Math.max(M.clientY-S.top,0),S.height)/S.height;c.value=C,h.value=I;let F=I-I*C/2,O=Math.min(F,1-F);C=O?(I-F)/O:0;const N=new Ce().setHSL(l.value,C,F);e.emit("update:value",[N.r,N.g,N.b])})}u(x,"onSvRectMouseDown"),Lm(x,"onSvRectMouseDown");function w(A){const M=(A.target.value||"").trim();if(/^([a-fA-F0-9]{6})$/.test(M)){const C=Number.parseInt(M.substring(0,6),16),I=new Ce().setHex(C);e.emit("update:value",[I.r,I.g,I.b])}}u(w,"onTextInput"),Lm(w,"onTextInput");function _(A){f.value=A;const S=new Ce().setHex(d[A]);e.emit("update:value",[S.r,S.g,S.b])}return u(_,"onBoxClick"),Lm(_,"onBoxClick"),{hueRing:t,svRect:i,activeBox:f,hex:p,colorBoxHex:g,hueRingHandlerStyle:m,svRectStyle:v,svRectHandlerStyle:y,onHueRingMouseDown:b,onSvRectMouseDown:x,onTextInput:w,onBoxClick:_}}});const Z_=u(n=>(tl("data-v-3618be33"),n=n(),nl(),n),"_withScopeId$6"),zH={class:"color-picker"},BH={class:"hue-ring-inner"},UH=Z_(()=>ue("div",{class:"bg1 bg"},null,-1)),$H=Z_(()=>ue("div",{class:"bg2 bg"},null,-1)),VH={class:"color-value"},HH=Z_(()=>ue("span",null,"#",-1)),GH=["value"],WH={key:0,class:"color-box"},jH=["onClick"];function XH(n,e,t,i,s,r){return Te(),Be("div",zH,[ue("div",{class:"hue-ring",onPointerdown:e[1]||(e[1]=(...o)=>n.onHueRingMouseDown&&n.onHueRingMouseDown(...o)),ref:"hueRing"},[ue("div",{class:"hue-ring-handler",style:ci(n.hueRingHandlerStyle)},null,4),ue("div",BH,[ue("div",{class:"sv-rect",style:ci(n.svRectStyle),onPointerdown:e[0]||(e[0]=(...o)=>n.onSvRectMouseDown&&n.onSvRectMouseDown(...o)),ref:"svRect"},[UH,$H,ue("div",{class:"sv-rect-handler",style:ci(n.svRectHandlerStyle)},null,4)],36)])],544),ue("div",VH,[ue("div",{class:"block",style:ci({"background-color":`#${n.hex}`})},null,4),HH,ue("input",{type:"text",value:n.hex,onInput:e[2]||(e[2]=(...o)=>n.onTextInput&&n.onTextInput(...o))},null,40,GH)]),n.colorBox?(Te(),Be("div",WH,[(Te(!0),Be(kt,null,Ga(n.colorBoxHex,(o,a)=>(Te(),Be("div",{class:Mn(["color",{active:n.activeBox===a}]),style:ci({"background-color":`#${o}`}),onClick:l=>n.onBoxClick(a)},null,14,jH))),256))])):nt("",!0)])}u(XH,"_sfc_render$s");var KI=jt(kH,[["render",XH],["__scopeId","data-v-3618be33"]]);const qH={},YH=u(n=>(tl("data-v-488ada72"),n=n(),nl(),n),"_withScopeId$5"),ZH=YH(()=>ue("div",{class:"fullscreen-loading"},[ue("div",{class:"lds-dual-ring"})],-1));function KH(n,e){return Te(),cn(C_,{to:"body"},[ZH])}u(KH,"_sfc_render$r");var QH=jt(qH,[["render",KH],["__scopeId","data-v-488ada72"]]),JH=Object.defineProperty,eG=u((n,e)=>JH(n,"name",{value:e,configurable:!0}),"__name$3j"),tG=zt({props:{value:Boolean,label:String},emits:["input"],setup(n,e){function t(){e.emit("input",!n.value)}return u(t,"flip"),eG(t,"flip"),{flip:t}}});const nG={class:"input-boolean"};function iG(n,e,t,i,s,r){return Te(),Be("div",nG,[ue("div",{class:Mn(["input-boolean__checkbox",{checked:!!n.value}]),onClick:e[0]||(e[0]=(...o)=>n.flip&&n.flip(...o))},null,2),n.label?(Te(),Be("div",{key:0,class:"input-boolean__label",onClick:e[1]||(e[1]=(...o)=>n.flip&&n.flip(...o))},On(n.label),1)):nt("",!0)])}u(iG,"_sfc_render$q");var sa=jt(tG,[["render",iG],["__scopeId","data-v-271a8ef3"]]),sG=Object.defineProperty,Om=u((n,e)=>sG(n,"name",{value:e,configurable:!0}),"__name$3i"),rG=zt({props:{value:Number,readonly:Boolean,disabled:Boolean,min:Number,max:Number,step:Number,resettable:Boolean,defaultValue:Number},emits:["input"],setup(n,e){const t=He();let i=!1;function s(){i&&(o(),document.removeEventListener("mousedown",s))}u(s,"postOnMouseDown"),Om(s,"postOnMouseDown");function r(){i||(i=!0,document.addEventListener("mousedown",s))}u(r,"onChange"),Om(r,"onChange"),il(function(){document.removeEventListener("mousedown",s)});function o(){if(i){i=!1;const l=t.value;if(l){const c=l.value;let h=Number(c);isFinite(h)||(h=0),n.step!=null&&(h=Math.round(h/n.step)*n.step),n.min!=null&&(h=Math.max(n.min,h)),n.max!=null&&(h=Math.min(n.max,h)),e.emit("input",h)}}}u(o,"onPost"),Om(o,"onPost");function a(){e.emit("input",n.defaultValue||0)}return u(a,"onReset"),Om(a,"onReset"),{inputDom:t,onChange:r,onPost:o,onReset:a}}}),V1="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFxJREFUSIntlEsOACEIQ2Xuf+e6MkFiLCN+Nryl0AoxtZQkiSLeRgDohCJuLTW25vZ8VHebrw7Q+JZu/jHAGbEitME1jr1BCChY36xON9gWKIsOEQvajPdfRZJQKkl2V7+RNsIHAAAAAElFTkSuQmCC";const oG=u(n=>(tl("data-v-3550c3d4"),n=n(),nl(),n),"_withScopeId$4"),aG={class:"input-number"},lG=["value","readonly","disabled"],cG=oG(()=>ue("img",{src:V1,alt:""},null,-1)),uG=[cG];function hG(n,e,t,i,s,r){return Te(),Be("div",aG,[ue("input",{type:"text",value:n.value,readonly:n.readonly,disabled:n.disabled,onInput:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[1]||(e[1]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[2]||(e[2]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"inputDom"},null,40,lG),n.resettable?(Te(),Be("button",{key:0,class:"normal-button",onClick:e[3]||(e[3]=(...o)=>n.onReset&&n.onReset(...o))},uG)):nt("",!0)])}u(hG,"_sfc_render$p");var si=jt(rG,[["render",hG],["__scopeId","data-v-3550c3d4"]]),fG=Object.defineProperty,u3=u((n,e)=>fG(n,"name",{value:e,configurable:!0}),"__name$3h"),dG=zt({props:{value:{type:Number,required:!0},min:{type:Number,required:!0},max:{type:Number,required:!0},step:{type:Number,required:!0},fractionDigits:Number,label:String},emits:["update:value"],setup(n,e){const t=He(),i=st(function(){return n.value.toFixed(n.fractionDigits)}),s=st(function(){return{width:`${Math.round((n.value-n.min)/(n.max-n.min)*100)}%`}});function r(a){dc(a,function(l){const c=t.value.getBoundingClientRect();let f=Math.max(0,Math.min(1,(l.clientX-c.left)/c.width))*(n.max-n.min)+n.min;f=Math.round(f/n.step)*n.step,e.emit("update:value",f)})}u(r,"onMouseDown"),u3(r,"onMouseDown");function o(a){switch(a.key){case"ArrowLeft":e.emit("update:value",Math.max(n.min,n.value-n.step));break;case"ArrowRight":e.emit("update:value",Math.min(n.max,n.value+n.step));break}}return u(o,"onKeyDown"),u3(o,"onKeyDown"),{dom:t,valueText:i,barStyle:s,onMouseDown:r,onKeyDown:o}}});const pG={class:"label"},mG={class:"value"};function gG(n,e,t,i,s,r){return Te(),Be("div",{class:"label-range",onPointerdown:e[0]||(e[0]=(...o)=>n.onMouseDown&&n.onMouseDown(...o)),ref:"dom",tabindex:"0",onKeydown:e[1]||(e[1]=(...o)=>n.onKeyDown&&n.onKeyDown(...o))},[ue("div",{class:"bar",style:ci(n.barStyle)},null,4),ue("div",pG,On(n.label),1),ue("div",mG,On(n.valueText),1)],544)}u(gG,"_sfc_render$o");var vG=jt(dG,[["render",gG],["__scopeId","data-v-2e301f78"]]);class $h{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}u($h,"Pass");const yG=new rl(-1,1,1,-1,0,1),K_=new Je;K_.setAttribute("position",new Ve([-1,3,0,-1,-1,0,3,-1,0],3));K_.setAttribute("uv",new Ve([0,2,0,0,2,0],2));class Ka{constructor(e){this._mesh=new We(K_,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,yG)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}u(Ka,"FullScreenQuad$1");class H1 extends Ci{constructor(e){super(e);for(const t in this.uniforms)Object.defineProperty(this,t,{get(){return this.uniforms[t].value},set(i){this.uniforms[t].value=i}})}setDefine(e,t=void 0){t==null?e in this.defines&&(delete this.defines[e],this.needsUpdate=!0):this.defines[e]!==t&&(this.defines[e]=t,this.needsUpdate=!0)}}u(H1,"MaterialBase");class QI extends H1{constructor(e){super({blending:Ns,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:`

				varying vec2 vUv;

				void main() {

					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}`,fragmentShader:`

				uniform float opacity;

				uniform sampler2D target1;
				uniform sampler2D target2;

				varying vec2 vUv;

				void main() {

					vec4 color1 = texture2D( target1, vUv );
					vec4 color2 = texture2D( target2, vUv );

					float invOpacity = 1.0 - opacity;
					float totalAlpha = color1.a * invOpacity + color2.a * opacity;

					if ( color1.a != 0.0 || color2.a != 0.0 ) {

						gl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );
						gl_FragColor.a = totalAlpha;

					} else {

						gl_FragColor = vec4( 0.0 );

					}

				}`}),this.setValues(e)}}u(QI,"BlendMaterial");function Fm(n=1){let e="uint";return n>1&&(e="uvec"+n),`
		${e} sobolReverseBits( ${e} x ) {

			x = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );
			x = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );
			x = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );
			x = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );
			return ( ( x >> 16 ) | ( x << 16 ) );

		}

		${e} sobolHashCombine( uint seed, ${e} v ) {

			return seed ^ ( v + ${e}( ( seed << 6 ) + ( seed >> 2 ) ) );

		}

		${e} sobolLaineKarrasPermutation( ${e} x, ${e} seed ) {

			x += seed;
			x ^= x * 0x6c50b47cu;
			x ^= x * 0xb82f1e52u;
			x ^= x * 0xc7afe638u;
			x ^= x * 0x8d22f6e6u;
			return x;

		}

		${e} nestedUniformScrambleBase2( ${e} x, ${e} seed ) {

			x = sobolLaineKarrasPermutation( x, seed );
			x = sobolReverseBits( x );
			return x;

		}
	`}u(Fm,"generateSobolFunctionVariants");function Nm(n=1){let e="uint",t="float",i="",s=".r",r="1u";return n>1&&(e="uvec"+n,t="vec"+n,i=n+"",n===2?(s=".rg",r="uvec2( 1u, 2u )"):n===3?(s=".rgb",r="uvec3( 1u, 2u, 3u )"):(s="",r="uvec4( 1u, 2u, 3u, 4u )")),`

		${t} sobol${i}( int effect ) {

			uint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );
			uint index = sobolPathIndex;

			uint shuffle_seed = sobolHashCombine( seed, 0u );
			uint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );
			${t} sobol_pt = sobolGetTexturePoint( shuffled_index )${s};
			${e} result = ${e}( sobol_pt * 16777216.0 );

			${e} seed2 = sobolHashCombine( seed, ${r} );
			result = nestedUniformScrambleBase2( result, seed2 );

			return SOBOL_FACTOR * ${t}( result >> 8 );

		}
	`}u(Nm,"generateSobolSampleFunctions");const JI=`

	// Utils
	const float SOBOL_FACTOR = 1.0 / 16777216.0;
	const uint SOBOL_MAX_POINTS = 256u * 256u;

	${Fm(1)}
	${Fm(2)}
	${Fm(3)}
	${Fm(4)}

	uint sobolHash( uint x ) {

		// finalizer from murmurhash3
		x ^= x >> 16;
		x *= 0x85ebca6bu;
		x ^= x >> 13;
		x *= 0xc2b2ae35u;
		x ^= x >> 16;
		return x;

	}

`,bG=`

	const uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](
		0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,
		0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,
		0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,
		0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,
		0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,
		0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,
		0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,
		0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu
	);

	const uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](
		0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,
		0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,
		0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,
		0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,
		0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,
		0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,
		0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,
		0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u
	);

	const uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](
		0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,
		0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,
		0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,
		0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,
		0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,
		0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,
		0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,
		0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u
	);

	const uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](
		0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,
		0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,
		0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,
		0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,
		0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,
		0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,
		0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,
		0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du
	);

	uint getMaskedSobol( uint index, uint directions[ 32 ] ) {

		uint X = 0u;
		for ( int bit = 0; bit < 32; bit ++ ) {

			uint mask = ( index >> bit ) & 1u;
			X ^= mask * directions[ bit ];

		}
		return X;

	}

	vec4 generateSobolPoint( uint index ) {

		if ( index >= SOBOL_MAX_POINTS ) {

			return vec4( 0.0 );

		}

		// NOTEL this sobol "direction" is also available but we can't write out 5 components
		// uint x = index & 0x00ffffffu;
		uint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;
		uint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;
		uint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;
		uint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;

		return vec4( x, y, z, w ) * SOBOL_FACTOR;

	}

`,xG=`

	// Seeds
	uniform sampler2D sobolTexture;
	uint sobolPixelIndex;
	uint sobolPathIndex;
	uint sobolBounceIndex;

	uint sobolGetSeed( uint bounce, uint effect ) {

		return sobolHash(
			sobolHashCombine(
				sobolHashCombine(
					sobolHash( bounce ),
					sobolPixelIndex
				),
				effect
			)
		);

	}

	vec4 sobolGetTexturePoint( uint index ) {

		if ( index >= SOBOL_MAX_POINTS ) {

			index = index % SOBOL_MAX_POINTS;

		}

		uvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );
		uint y = index / dim.x;
		uint x = index - y * dim.x;
		vec2 uv = vec2( x, y ) / vec2( dim );
		return texture( sobolTexture, uv );

	}

	${Nm(1)}
	${Nm(2)}
	${Nm(3)}
	${Nm(4)}

`;class eD extends H1{constructor(){super({blending:Ns,uniforms:{resolution:{value:new Ie}},vertexShader:`

				varying vec2 vUv;
				void main() {

					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,fragmentShader:`

				${JI}
				${bG}

				varying vec2 vUv;
				uniform vec2 resolution;
				void main() {

					uint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );
					gl_FragColor = generateSobolPoint( index );

				}
			`})}}u(eD,"SobolNumbersMaterial");class tD{generate(e,t=256){const i=new Ln(t,t,{type:on,format:rn,minFilter:Yt,magFilter:Yt,generateMipmaps:!1}),s=e.getRenderTarget();e.setRenderTarget(i);const r=new Ka(new eD);return r.material.resolution.set(t,t),r.render(e),e.setRenderTarget(s),r.dispose(),i}}u(tD,"SobolNumberMapGenerator");const En=new ut,Yc=new ut;function*_G(){const{_renderer:n,_fsQuad:e,_blendQuad:t,_primaryTarget:i,_blendTargets:s,_sobolTarget:r,_subframe:o,alpha:a,camera:l,material:c}=this,h=new ut,f=new ut,d=t.material;let[p,g]=s;for(;;){a?(d.opacity=this._opacityFactor/(this._samples+1),c.blending=Ns,c.opacity=1):(c.opacity=this._opacityFactor/(this._samples+1),c.blending=nc);const[m,v,y,b]=o,x=i.width,w=i.height;c.resolution.set(x*y,w*b),c.sobolTexture=r.texture,c.seed++;const _=this.tiles.x||1,A=this.tiles.y||1,S=_*A,M=1/n.getPixelRatio();for(let C=0;C<A;C++)for(let I=0;I<_;I++){c.cameraWorldMatrix.copy(l.matrixWorld),c.invProjectionMatrix.copy(l.projectionMatrixInverse);let F=0;l.projectionMatrix.elements[15]>0&&(F=1),l.isEquirectCamera&&(F=2),c.setDefine("CAMERA_TYPE",F);const O=n.getRenderTarget(),N=n.autoClear,E=n.getScissorTest();n.getScissor(h),n.getViewport(f);let k=I,G=C;if(!this.stableTiles){const X=this._currentTile%(_*A);k=X%_,G=~~(X/_),this._currentTile=X+1}n.setRenderTarget(i),n.setScissorTest(!0),En.x=k*x/_,En.y=(A-G-1)*w/A,En.z=x/_,En.w=w/A,En.x=m*x+y*En.x,En.y=v*w+b*En.y,En.z=y*En.z,En.w=b*En.w,En.x=En.x,En.y=En.y,En.z=En.z,En.w=En.w,En.multiplyScalar(M).ceil(),Yc.x=m*x,Yc.y=v*w,Yc.z=y*x,Yc.w=b*w,Yc.multiplyScalar(M).ceil(),n.setScissor(En),n.setViewport(Yc),n.autoClear=!1,e.render(n),n.setViewport(f),n.setScissor(h),n.setScissorTest(E),n.setRenderTarget(O),n.autoClear=N,a&&(d.target1=p.texture,d.target2=i.texture,n.setRenderTarget(g),t.render(n),n.setRenderTarget(O)),this._samples+=1/S,I===_-1&&C===A-1&&(this._samples=Math.round(this._samples)),yield}[p,g]=[g,p]}}u(_G,"renderTask");const h3=new Ce;class nD{get material(){return this._fsQuad.material}set material(e){this._fsQuad.material=e}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(e){this._alpha!==e&&(e||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=e,this.reset())}get alpha(){return this._alpha}get samples(){return this._samples}constructor(e){this.camera=null,this.tiles=new Ie(1,1),this.stableNoise=!1,this.stableTiles=!0,this._samples=0,this._subframe=new ut(0,0,1,1),this._opacityFactor=1,this._renderer=e,this._alpha=!1,this._fsQuad=new Ka(null),this._blendQuad=new Ka(new QI),this._task=null,this._currentTile=0,this._sobolTarget=new tD().generate(e),this._primaryTarget=new Ln(1,1,{format:rn,type:on}),this._blendTargets=[new Ln(1,1,{format:rn,type:on}),new Ln(1,1,{format:rn,type:on})]}setSize(e,t){e=Math.ceil(e),t=Math.ceil(t),!(this._primaryTarget.width===e&&this._primaryTarget.height===t)&&(this._primaryTarget.setSize(e,t),this._blendTargets[0].setSize(e,t),this._blendTargets[1].setSize(e,t),this.reset())}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._sobolTarget.dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:e,_primaryTarget:t,_blendTargets:i}=this,s=e.getRenderTarget(),r=e.getClearAlpha();e.getClearColor(h3),e.setRenderTarget(t),e.setClearColor(0,0),e.clearColor(),e.setRenderTarget(i[0]),e.setClearColor(0,0),e.clearColor(),e.setRenderTarget(i[1]),e.setClearColor(0,0),e.clearColor(),e.setClearColor(h3,r),e.setRenderTarget(s),this._samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=_G.call(this)),this._task.next()}}u(nD,"PathTracingRenderer");const iD=0,wG=1,AG=2,f3=2,vy=1.25,d3=1,rc=6*4+4+4,Rx=65535,MG=Math.pow(2,-24);class xd{constructor(){}}u(xd,"MeshBVHNode");function jr(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}u(jr,"arrayToBox");function p3(n){let e=-1,t=-1/0;for(let i=0;i<3;i++){const s=n[i+3]-n[i];s>t&&(t=s,e=i)}return e}u(p3,"getLongestEdgeIndex");function m3(n,e){e.set(n)}u(m3,"copyBounds");function g3(n,e,t){let i,s;for(let r=0;r<3;r++){const o=r+3;i=n[r],s=e[r],t[r]=i<s?i:s,i=n[o],s=e[o],t[o]=i>s?i:s}}u(g3,"unionBounds");function km(n,e,t){for(let i=0;i<3;i++){const s=e[n+2*i],r=e[n+2*i+1],o=s-r,a=s+r;o<t[i]&&(t[i]=o),a>t[i+3]&&(t[i+3]=a)}}u(km,"expandByTriangleBounds");function df(n){const e=n[3]-n[0],t=n[4]-n[1],i=n[5]-n[2];return 2*(e*t+t*i+i*e)}u(df,"computeSurfaceArea");function SG(n,e){if(!n.index){const t=n.attributes.position.count,i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;t>65535?s=new Uint32Array(new i(4*t)):s=new Uint16Array(new i(2*t)),n.setIndex(new Rt(s,1));for(let r=0;r<t;r++)s[r]=r}}u(SG,"ensureIndex");function TG(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const e=[],t=new Set;for(const s of n.groups)t.add(s.start),t.add(s.start+s.count);const i=Array.from(t.values()).sort((s,r)=>s-r);for(let s=0;s<i.length-1;s++){const r=i[s],o=i[s+1];e.push({offset:r/3,count:(o-r)/3})}return e}u(TG,"getRootIndexRanges");function yy(n,e,t,i,s=null){let r=1/0,o=1/0,a=1/0,l=-1/0,c=-1/0,h=-1/0,f=1/0,d=1/0,p=1/0,g=-1/0,m=-1/0,v=-1/0;const y=s!==null;for(let b=e*6,x=(e+t)*6;b<x;b+=6){const w=n[b+0],_=n[b+1],A=w-_,S=w+_;A<r&&(r=A),S>l&&(l=S),y&&w<f&&(f=w),y&&w>g&&(g=w);const M=n[b+2],C=n[b+3],I=M-C,F=M+C;I<o&&(o=I),F>c&&(c=F),y&&M<d&&(d=M),y&&M>m&&(m=M);const O=n[b+4],N=n[b+5],E=O-N,k=O+N;E<a&&(a=E),k>h&&(h=k),y&&O<p&&(p=O),y&&O>v&&(v=O)}i[0]=r,i[1]=o,i[2]=a,i[3]=l,i[4]=c,i[5]=h,y&&(s[0]=f,s[1]=d,s[2]=p,s[3]=g,s[4]=m,s[5]=v)}u(yy,"getBounds");function CG(n,e,t,i){let s=1/0,r=1/0,o=1/0,a=-1/0,l=-1/0,c=-1/0;for(let h=e*6,f=(e+t)*6;h<f;h+=6){const d=n[h+0];d<s&&(s=d),d>a&&(a=d);const p=n[h+2];p<r&&(r=p),p>l&&(l=p);const g=n[h+4];g<o&&(o=g),g>c&&(c=g)}i[0]=s,i[1]=r,i[2]=o,i[3]=a,i[4]=l,i[5]=c}u(CG,"getCentroidBounds");function EG(n,e,t,i,s){let r=t,o=t+i-1;const a=s.pos,l=s.axis*2;for(;;){for(;r<=o&&e[r*6+l]<a;)r++;for(;r<=o&&e[o*6+l]>=a;)o--;if(r<o){for(let c=0;c<3;c++){let h=n[r*3+c];n[r*3+c]=n[o*3+c],n[o*3+c]=h;let f=e[r*6+c*2+0];e[r*6+c*2+0]=e[o*6+c*2+0],e[o*6+c*2+0]=f;let d=e[r*6+c*2+1];e[r*6+c*2+1]=e[o*6+c*2+1],e[o*6+c*2+1]=d}r++,o--}else return r}}u(EG,"partition");const Do=32,PG=u((n,e)=>n.candidate-e.candidate,"binsSort"),ya=new Array(Do).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),zm=new Float32Array(6);function RG(n,e,t,i,s,r){let o=-1,a=0;if(r===iD)o=p3(e),o!==-1&&(a=(e[o]+e[o+3])/2);else if(r===wG)o=p3(n),o!==-1&&(a=IG(t,i,s,o));else if(r===AG){const l=df(n);let c=vy*s;const h=i*6,f=(i+s)*6;for(let d=0;d<3;d++){const p=e[d],v=(e[d+3]-p)/Do;if(s<Do/4){const y=[...ya];y.length=s;let b=0;for(let w=h;w<f;w+=6,b++){const _=y[b];_.candidate=t[w+2*d],_.count=0;const{bounds:A,leftCacheBounds:S,rightCacheBounds:M}=_;for(let C=0;C<3;C++)M[C]=1/0,M[C+3]=-1/0,S[C]=1/0,S[C+3]=-1/0,A[C]=1/0,A[C+3]=-1/0;km(w,t,A)}y.sort(PG);let x=s;for(let w=0;w<x;w++){const _=y[w];for(;w+1<x&&y[w+1].candidate===_.candidate;)y.splice(w+1,1),x--}for(let w=h;w<f;w+=6){const _=t[w+2*d];for(let A=0;A<x;A++){const S=y[A];_>=S.candidate?km(w,t,S.rightCacheBounds):(km(w,t,S.leftCacheBounds),S.count++)}}for(let w=0;w<x;w++){const _=y[w],A=_.count,S=s-_.count,M=_.leftCacheBounds,C=_.rightCacheBounds;let I=0;A!==0&&(I=df(M)/l);let F=0;S!==0&&(F=df(C)/l);const O=d3+vy*(I*A+F*S);O<c&&(o=d,c=O,a=_.candidate)}}else{for(let x=0;x<Do;x++){const w=ya[x];w.count=0,w.candidate=p+v+x*v;const _=w.bounds;for(let A=0;A<3;A++)_[A]=1/0,_[A+3]=-1/0}for(let x=h;x<f;x+=6){let A=~~((t[x+2*d]-p)/v);A>=Do&&(A=Do-1);const S=ya[A];S.count++,km(x,t,S.bounds)}const y=ya[Do-1];m3(y.bounds,y.rightCacheBounds);for(let x=Do-2;x>=0;x--){const w=ya[x],_=ya[x+1];g3(w.bounds,_.rightCacheBounds,w.rightCacheBounds)}let b=0;for(let x=0;x<Do-1;x++){const w=ya[x],_=w.count,A=w.bounds,M=ya[x+1].rightCacheBounds;_!==0&&(b===0?m3(A,zm):g3(A,zm,zm)),b+=_;let C=0,I=0;b!==0&&(C=df(zm)/l);const F=s-b;F!==0&&(I=df(M)/l);const O=d3+vy*(C*b+I*F);O<c&&(o=d,c=O,a=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}u(RG,"getOptimalSplit");function IG(n,e,t,i){let s=0;for(let r=e,o=e+t;r<o;r++)s+=n[r*6+i*2];return s/t}u(IG,"getAverage");function DG(n,e){const t=n.attributes.position,i=n.index.array,s=i.length/3,r=new Float32Array(s*6),o=t.normalized,a=t.array,l=t.offset||0;let c=3;t.isInterleavedBufferAttribute&&(c=t.data.stride);const h=["getX","getY","getZ"];for(let f=0;f<s;f++){const d=f*3,p=f*6;let g,m,v;o?(g=i[d+0],m=i[d+1],v=i[d+2]):(g=i[d+0]*c+l,m=i[d+1]*c+l,v=i[d+2]*c+l);for(let y=0;y<3;y++){let b,x,w;o?(b=t[h[y]](g),x=t[h[y]](m),w=t[h[y]](v)):(b=a[g+y],x=a[m+y],w=a[v+y]);let _=b;x<_&&(_=x),w<_&&(_=w);let A=b;x>A&&(A=x),w>A&&(A=w);const S=(A-_)/2,M=y*2;r[p+M+0]=_+S,r[p+M+1]=S+(Math.abs(_)+S)*MG,_<e[y]&&(e[y]=_),A>e[y+3]&&(e[y+3]=A)}}return r}u(DG,"computeTriangleBounds");function LG(n,e){function t(y){d&&d(y/p)}u(t,"triggerProgress");function i(y,b,x,w=null,_=0){if(!g&&_>=l&&(g=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),x<=h||_>=l)return t(b+x),y.offset=b,y.count=x,y;const A=RG(y.boundingData,w,o,b,x,f);if(A.axis===-1)return t(b+x),y.offset=b,y.count=x,y;const S=EG(a,o,b,x,A);if(S===b||S===b+x)t(b+x),y.offset=b,y.count=x;else{y.splitAxis=A.axis;const M=new xd,C=b,I=S-b;y.left=M,M.boundingData=new Float32Array(6),yy(o,C,I,M.boundingData,r),i(M,C,I,r,_+1);const F=new xd,O=S,N=x-I;y.right=F,F.boundingData=new Float32Array(6),yy(o,O,N,F.boundingData,r),i(F,O,N,r,_+1)}return y}u(i,"splitNode"),SG(n,e);const s=new Float32Array(6),r=new Float32Array(6),o=DG(n,s),a=n.index.array,l=e.maxDepth,c=e.verbose,h=e.maxLeafTris,f=e.strategy,d=e.onProgress,p=n.index.count/3;let g=!1;const m=[],v=TG(n);if(v.length===1){const y=v[0],b=new xd;b.boundingData=s,CG(o,y.offset,y.count,r),i(b,y.offset,y.count,r),m.push(b)}else for(let y of v){const b=new xd;b.boundingData=new Float32Array(6),yy(o,y.offset,y.count,b.boundingData,r),i(b,y.offset,y.count,r),m.push(b)}return m}u(LG,"buildTree");function OG(n,e){const t=LG(n,e);let i,s,r;const o=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let h=0;h<t.length;h++){const f=t[h];let d=l(f);const p=new a(rc*d);i=new Float32Array(p),s=new Uint32Array(p),r=new Uint16Array(p),c(0,f),o.push(p)}return o;function l(h){return h.count?1:1+l(h.left)+l(h.right)}function c(h,f){const d=h/4,p=h/2,g=!!f.count,m=f.boundingData;for(let v=0;v<6;v++)i[d+v]=m[v];if(g){const v=f.offset,y=f.count;return s[d+6]=v,r[p+14]=y,r[p+15]=Rx,h+rc}else{const v=f.left,y=f.right,b=f.splitAxis;let x;if(x=c(h+rc,v),x/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[d+6]=x/4,x=c(x,y),s[d+7]=b,x}}}u(OG,"buildPackedTree");class Cr{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let i=1/0,s=-1/0;for(let r=0,o=e.length;r<o;r++){const l=e[r][t];i=l<i?l:i,s=l>s?l:s}this.min=i,this.max=s}setFromPoints(e,t){let i=1/0,s=-1/0;for(let r=0,o=t.length;r<o;r++){const a=t[r],l=e.dot(a);i=l<i?l:i,s=l>s?l:s}this.min=i,this.max=s}isSeparated(e){return this.min>e.max||e.min>this.max}}u(Cr,"SeparatingAxisBounds");Cr.prototype.setFromBox=function(){const n=new P;return u(function(t,i){const s=i.min,r=i.max;let o=1/0,a=-1/0;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let h=0;h<=1;h++){n.x=s.x*l+r.x*(1-l),n.y=s.y*c+r.y*(1-c),n.z=s.z*h+r.z*(1-h);const f=t.dot(n);o=Math.min(f,o),a=Math.max(f,a)}this.min=o,this.max=a},"setFromBox")}();(function(){const n=new Cr;return u(function(t,i){const s=t.points,r=t.satAxes,o=t.satBounds,a=i.points,l=i.satAxes,c=i.satBounds;for(let h=0;h<3;h++){const f=o[h],d=r[h];if(n.setFromPoints(d,a),f.isSeparated(n))return!1}for(let h=0;h<3;h++){const f=c[h],d=l[h];if(n.setFromPoints(d,s),f.isSeparated(n))return!1}},"areIntersecting")})();const FG=function(){const n=new P,e=new P,t=new P;return u(function(s,r,o){const a=s.start,l=n,c=r.start,h=e;t.subVectors(a,c),n.subVectors(s.end,s.start),e.subVectors(r.end,r.start);const f=t.dot(h),d=h.dot(l),p=h.dot(h),g=t.dot(l),v=l.dot(l)*p-d*d;let y,b;v!==0?y=(f*d-g*p)/v:y=0,b=(f+y*d)/p,o.x=y,o.y=b},"closestPointLineToLine")}(),Q_=function(){const n=new Ie,e=new P,t=new P;return u(function(s,r,o,a){FG(s,r,n);let l=n.x,c=n.y;if(l>=0&&l<=1&&c>=0&&c<=1){s.at(l,o),r.at(c,a);return}else if(l>=0&&l<=1){c<0?r.at(0,a):r.at(1,a),s.closestPointToPoint(a,!0,o);return}else if(c>=0&&c<=1){l<0?s.at(0,o):s.at(1,o),r.closestPointToPoint(o,!0,a);return}else{let h;l<0?h=s.start:h=s.end;let f;c<0?f=r.start:f=r.end;const d=e,p=t;if(s.closestPointToPoint(f,!0,e),r.closestPointToPoint(h,!0,t),d.distanceToSquared(f)<=p.distanceToSquared(h)){o.copy(d),a.copy(f);return}else{o.copy(h),a.copy(p);return}}},"closestPointsSegmentToSegment")}(),NG=function(){const n=new P,e=new P,t=new gr,i=new Kr;return u(function(r,o){const{radius:a,center:l}=r,{a:c,b:h,c:f}=o;if(i.start=c,i.end=h,i.closestPointToPoint(l,!0,n).distanceTo(l)<=a||(i.start=c,i.end=f,i.closestPointToPoint(l,!0,n).distanceTo(l)<=a)||(i.start=h,i.end=f,i.closestPointToPoint(l,!0,n).distanceTo(l)<=a))return!0;const m=o.getPlane(t);if(Math.abs(m.distanceToPoint(l))<=a){const y=m.projectPoint(l,e);if(o.containsPoint(y))return!0}return!1},"sphereIntersectTriangle")}(),kG=1e-15;function Zc(n){return Math.abs(n)<kG}u(Zc,"isNearZero");class no extends Ls{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new P),this.satBounds=new Array(4).fill().map(()=>new Cr),this.points=[this.a,this.b,this.c],this.sphere=new na,this.plane=new gr,this.needsUpdate=!0}intersectsSphere(e){return NG(e,this)}update(){const e=this.a,t=this.b,i=this.c,s=this.points,r=this.satAxes,o=this.satBounds,a=r[0],l=o[0];this.getNormal(a),l.setFromPoints(a,s);const c=r[1],h=o[1];c.subVectors(e,t),h.setFromPoints(c,s);const f=r[2],d=o[2];f.subVectors(t,i),d.setFromPoints(f,s);const p=r[3],g=o[3];p.subVectors(i,e),g.setFromPoints(p,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}u(no,"ExtendedTriangle");no.prototype.closestPointToSegment=function(){const n=new P,e=new P,t=new Kr;return u(function(s,r=null,o=null){const{start:a,end:l}=s,c=this.points;let h,f=1/0;for(let d=0;d<3;d++){const p=(d+1)%3;t.start.copy(c[d]),t.end.copy(c[p]),Q_(t,s,n,e),h=n.distanceToSquared(e),h<f&&(f=h,r&&r.copy(n),o&&o.copy(e))}return this.closestPointToPoint(a,n),h=a.distanceToSquared(n),h<f&&(f=h,r&&r.copy(n),o&&o.copy(a)),this.closestPointToPoint(l,n),h=l.distanceToSquared(n),h<f&&(f=h,r&&r.copy(n),o&&o.copy(l)),Math.sqrt(f)},"distanceToSegment")}();no.prototype.intersectsTriangle=function(){const n=new no,e=new Array(3),t=new Array(3),i=new Cr,s=new Cr,r=new P,o=new P,a=new P,l=new P,c=new Kr,h=new Kr,f=new Kr;return u(function(p,g=null,m=!1){this.needsUpdate&&this.update(),p.isExtendedTriangle?p.needsUpdate&&p.update():(n.copy(p),n.update(),p=n);const v=this.plane,y=p.plane;if(Math.abs(v.normal.dot(y.normal))>1-1e-10){const b=this.satBounds,x=this.satAxes;t[0]=p.a,t[1]=p.b,t[2]=p.c;for(let A=0;A<4;A++){const S=b[A],M=x[A];if(i.setFromPoints(M,t),S.isSeparated(i))return!1}const w=p.satBounds,_=p.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let A=0;A<4;A++){const S=w[A],M=_[A];if(i.setFromPoints(M,e),S.isSeparated(i))return!1}for(let A=0;A<4;A++){const S=x[A];for(let M=0;M<4;M++){const C=_[M];if(r.crossVectors(S,C),i.setFromPoints(r,e),s.setFromPoints(r,t),i.isSeparated(s))return!1}}return g&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),g.start.set(0,0,0),g.end.set(0,0,0)),!0}else{const b=this.points;let x=!1,w=0;for(let E=0;E<3;E++){const k=b[E],G=b[(E+1)%3];c.start.copy(k),c.end.copy(G),c.delta(o);const X=x?h.start:h.end,te=Zc(y.distanceToPoint(k));if(Zc(y.normal.dot(o))&&te){h.copy(c),w=2;break}if((y.intersectLine(c,X)||te)&&!Zc(X.distanceTo(G))){if(w++,x)break;x=!0}}if(w===1&&p.containsPoint(h.end))return g&&(g.start.copy(h.end),g.end.copy(h.end)),!0;if(w!==2)return!1;const _=p.points;let A=!1,S=0;for(let E=0;E<3;E++){const k=_[E],G=_[(E+1)%3];c.start.copy(k),c.end.copy(G),c.delta(a);const X=A?f.start:f.end,te=Zc(v.distanceToPoint(k));if(Zc(v.normal.dot(a))&&te){f.copy(c),S=2;break}if((v.intersectLine(c,X)||te)&&!Zc(X.distanceTo(G))){if(S++,A)break;A=!0}}if(S===1&&this.containsPoint(f.end))return g&&(g.start.copy(f.end),g.end.copy(f.end)),!0;if(S!==2)return!1;if(h.delta(o),f.delta(a),o.dot(a)<0){let E=f.start;f.start=f.end,f.end=E}const M=h.start.dot(o),C=h.end.dot(o),I=f.start.dot(o),F=f.end.dot(o),O=C<I,N=M<F;return M!==F&&I!==C&&O===N?!1:(g&&(l.subVectors(h.start,f.start),l.dot(o)>0?g.start.copy(h.start):g.start.copy(f.start),l.subVectors(h.end,f.end),l.dot(o)<0?g.end.copy(h.end):g.end.copy(f.end)),!0)}},"intersectsTriangle")}();no.prototype.distanceToPoint=function(){const n=new P;return u(function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)},"distanceToPoint")}();no.prototype.distanceToTriangle=function(){const n=new P,e=new P,t=["a","b","c"],i=new Kr,s=new Kr;return u(function(o,a=null,l=null){const c=a||l?i:null;if(this.intersectsTriangle(o,c))return(a||l)&&(a&&c.getCenter(a),l&&c.getCenter(l)),0;let h=1/0;for(let f=0;f<3;f++){let d;const p=t[f],g=o[p];this.closestPointToPoint(g,n),d=g.distanceToSquared(n),d<h&&(h=d,a&&a.copy(n),l&&l.copy(g));const m=this[p];o.closestPointToPoint(m,n),d=m.distanceToSquared(n),d<h&&(h=d,a&&a.copy(m),l&&l.copy(n))}for(let f=0;f<3;f++){const d=t[f],p=t[(f+1)%3];i.set(this[d],this[p]);for(let g=0;g<3;g++){const m=t[g],v=t[(g+1)%3];s.set(o[m],o[v]),Q_(i,s,n,e);const y=n.distanceToSquared(e);y<h&&(h=y,a&&a.copy(n),l&&l.copy(e))}}return Math.sqrt(h)},"distanceToTriangle")}();class Er{constructor(e,t,i){this.isOrientedBox=!0,this.min=new P,this.max=new P,this.matrix=new me,this.invMatrix=new me,this.points=new Array(8).fill().map(()=>new P),this.satAxes=new Array(3).fill().map(()=>new P),this.satBounds=new Array(3).fill().map(()=>new Cr),this.alignedSatBounds=new Array(3).fill().map(()=>new Cr),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),i&&this.matrix.copy(i)}set(e,t,i){this.min.copy(e),this.max.copy(t),this.matrix.copy(i),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}u(Er,"OrientedBox");Er.prototype.update=function(){return u(function(){const e=this.matrix,t=this.min,i=this.max,s=this.points;for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)for(let f=0;f<=1;f++){const d=1*c|2*h|4*f,p=s[d];p.x=c?i.x:t.x,p.y=h?i.y:t.y,p.z=f?i.z:t.z,p.applyMatrix4(e)}const r=this.satBounds,o=this.satAxes,a=s[0];for(let c=0;c<3;c++){const h=o[c],f=r[c],d=1<<c,p=s[d];h.subVectors(a,p),f.setFromPoints(h,s)}const l=this.alignedSatBounds;l[0].setFromPointsField(s,"x"),l[1].setFromPointsField(s,"y"),l[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},"update")}();Er.prototype.intersectsBox=function(){const n=new Cr;return u(function(t){this.needsUpdate&&this.update();const i=t.min,s=t.max,r=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(n.min=i.x,n.max=s.x,a[0].isSeparated(n)||(n.min=i.y,n.max=s.y,a[1].isSeparated(n))||(n.min=i.z,n.max=s.z,a[2].isSeparated(n)))return!1;for(let l=0;l<3;l++){const c=o[l],h=r[l];if(n.setFromBox(c,t),h.isSeparated(n))return!1}return!0},"intersectsBox")}();Er.prototype.intersectsTriangle=function(){const n=new no,e=new Array(3),t=new Cr,i=new Cr,s=new P;return u(function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const a=this.satBounds,l=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let d=0;d<3;d++){const p=a[d],g=l[d];if(t.setFromPoints(g,e),p.isSeparated(t))return!1}const c=o.satBounds,h=o.satAxes,f=this.points;for(let d=0;d<3;d++){const p=c[d],g=h[d];if(t.setFromPoints(g,f),p.isSeparated(t))return!1}for(let d=0;d<3;d++){const p=l[d];for(let g=0;g<4;g++){const m=h[g];if(s.crossVectors(p,m),t.setFromPoints(s,e),i.setFromPoints(s,f),t.isSeparated(i))return!1}}return!0},"intersectsTriangle")}();Er.prototype.closestPointToPoint=function(){return u(function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t},"closestPointToPoint")}();Er.prototype.distanceToPoint=function(){const n=new P;return u(function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)},"distanceToPoint")}();Er.prototype.distanceToBox=function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new Kr),t=new Array(12).fill().map(()=>new Kr),i=new P,s=new P;return u(function(o,a=0,l=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(l||c)&&(o.getCenter(s),this.closestPointToPoint(s,i),o.closestPointToPoint(i,s),l&&l.copy(i),c&&c.copy(s)),0;const h=a*a,f=o.min,d=o.max,p=this.points;let g=1/0;for(let v=0;v<8;v++){const y=p[v];s.copy(y).clamp(f,d);const b=y.distanceToSquared(s);if(b<g&&(g=b,l&&l.copy(y),c&&c.copy(s),b<h))return Math.sqrt(b)}let m=0;for(let v=0;v<3;v++)for(let y=0;y<=1;y++)for(let b=0;b<=1;b++){const x=(v+1)%3,w=(v+2)%3,_=y<<x|b<<w,A=1<<v|y<<x|b<<w,S=p[_],M=p[A];e[m].set(S,M);const I=n[v],F=n[x],O=n[w],N=t[m],E=N.start,k=N.end;E[I]=f[I],E[F]=y?f[F]:d[F],E[O]=b?f[O]:d[F],k[I]=d[I],k[F]=y?f[F]:d[F],k[O]=b?f[O]:d[F],m++}for(let v=0;v<=1;v++)for(let y=0;y<=1;y++)for(let b=0;b<=1;b++){s.x=v?d.x:f.x,s.y=y?d.y:f.y,s.z=b?d.z:f.z,this.closestPointToPoint(s,i);const x=s.distanceToSquared(i);if(x<g&&(g=x,l&&l.copy(i),c&&c.copy(s),x<h))return Math.sqrt(x)}for(let v=0;v<12;v++){const y=e[v];for(let b=0;b<12;b++){const x=t[b];Q_(y,x,i,s);const w=i.distanceToSquared(s);if(w<g&&(g=w,l&&l.copy(i),c&&c.copy(s),w<h))return Math.sqrt(w)}}return Math.sqrt(g)},"distanceToBox")}();const Bm=new P,Um=new P,$m=new P,v3=new Ie,y3=new Ie,b3=new Ie,x3=new P;function zG(n,e,t,i,s,r){let o;return r===ms?o=n.intersectTriangle(i,t,e,!0,s):o=n.intersectTriangle(e,t,i,r!==Ki,s),o===null?null:{distance:n.origin.distanceTo(s),point:s.clone()}}u(zG,"checkIntersection");function BG(n,e,t,i,s,r,o){Bm.fromBufferAttribute(e,i),Um.fromBufferAttribute(e,s),$m.fromBufferAttribute(e,r);const a=zG(n,Bm,Um,$m,x3,o);if(a){t&&(v3.fromBufferAttribute(t,i),y3.fromBufferAttribute(t,s),b3.fromBufferAttribute(t,r),a.uv=Ls.getUV(x3,Bm,Um,$m,v3,y3,b3,new Ie));const l={a:i,b:s,c:r,normal:new P,materialIndex:0};Ls.getNormal(Bm,Um,$m,l.normal),a.face=l,a.faceIndex=i}return a}u(BG,"checkBufferGeometryIntersection");function sD(n,e,t,i,s){const r=i*3,o=n.index.getX(r),a=n.index.getX(r+1),l=n.index.getX(r+2),c=BG(t,n.attributes.position,n.attributes.uv,o,a,l,e);return c?(c.faceIndex=i,s&&s.push(c),c):null}u(sD,"intersectTri");function UG(n,e,t,i,s,r){for(let o=i,a=i+s;o<a;o++)sD(n,e,t,o,r)}u(UG,"intersectTris");function $G(n,e,t,i,s){let r=1/0,o=null;for(let a=i,l=i+s;a<l;a++){const c=sD(n,e,t,a);c&&c.distance<r&&(o=c,r=c.distance)}return o}u($G,"intersectClosestTri");function Gr(n,e,t,i){const s=n.a,r=n.b,o=n.c;let a=e,l=e+1,c=e+2;t&&(a=t.getX(e),l=t.getX(e+1),c=t.getX(e+2)),s.x=i.getX(a),s.y=i.getY(a),s.z=i.getZ(a),r.x=i.getX(l),r.y=i.getY(l),r.z=i.getZ(l),o.x=i.getX(c),o.y=i.getY(c),o.z=i.getZ(c)}u(Gr,"setTriangle");function _3(n,e,t,i,s,r,o){const a=t.index,l=t.attributes.position;for(let c=n,h=e+n;c<h;c++)if(Gr(o,c*3,a,l),o.needsUpdate=!0,i(o,c,s,r))return!0;return!1}u(_3,"iterateOverTriangles");class J_{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}u(J_,"PrimitivePool");function zo(n,e){return e[n+15]===65535}u(zo,"IS_LEAF");function oc(n,e){return e[n+6]}u(oc,"OFFSET");function uh(n,e){return e[n+14]}u(uh,"COUNT");function ap(n){return n+8}u(ap,"LEFT_NODE");function hh(n,e){return e[n+6]}u(hh,"RIGHT_NODE");function rD(n,e){return e[n+7]}u(rD,"SPLIT_AXIS");const Lu=new un,j0=new P,VG=["x","y","z"];function Ix(n,e,t,i,s){let r=n*2,o=Vh,a=ja,l=Xa;if(zo(r,a)){const h=oc(n,l),f=uh(r,a);UG(e,t,i,h,f,s)}else{const h=ap(n);X0(h,o,i,j0)&&Ix(h,e,t,i,s);const f=hh(n,l);X0(f,o,i,j0)&&Ix(f,e,t,i,s)}}u(Ix,"raycast");function Dx(n,e,t,i){let s=n*2,r=Vh,o=ja,a=Xa;if(zo(s,o)){const c=oc(n,a),h=uh(s,o);return $G(e,t,i,c,h)}else{const c=rD(n,a),h=VG[c],d=i.direction[h]>=0;let p,g;d?(p=ap(n),g=hh(n,a)):(p=hh(n,a),g=ap(n));const v=X0(p,r,i,j0)?Dx(p,e,t,i):null;if(v){const x=v.point[h];if(d?x<=r[g+c]:x>=r[g+c+3])return v}const b=X0(g,r,i,j0)?Dx(g,e,t,i):null;return v&&b?v.distance<=b.distance?v:b:v||b||null}}u(Dx,"raycastFirst");const HG=function(){let n,e;const t=[],i=new J_(()=>new un);return u(function(...o){n=i.getPrimitive(),e=i.getPrimitive(),t.push(n,e);const a=s(...o);i.releasePrimitive(n),i.releasePrimitive(e),t.pop(),t.pop();const l=t.length;return l>0&&(e=t[l-1],n=t[l-2]),a},"shapecast");function s(r,o,a,l,c=null,h=0,f=0){function d(x){let w=x*2,_=ja,A=Xa;for(;!zo(w,_);)x=ap(x),w=x*2;return oc(x,A)}u(d,"getLeftOffset");function p(x){let w=x*2,_=ja,A=Xa;for(;!zo(w,_);)x=hh(x,A),w=x*2;return oc(x,A)+uh(w,_)}u(p,"getRightEndOffset");let g=r*2,m=Vh,v=ja,y=Xa;if(zo(g,v)){const x=oc(r,y),w=uh(g,v);return jr(r,m,n),l(x,w,!1,f,h+r,n)}else{const x=ap(r),w=hh(r,y);let _=x,A=w,S,M,C,I;if(c&&(C=n,I=e,jr(_,m,C),jr(A,m,I),S=c(C),M=c(I),M<S)){_=w,A=x;const X=S;S=M,M=X,C=I}C||(C=n,jr(_,m,C));const F=zo(_*2,v),O=a(C,F,S,f+1,h+_);let N;if(O===f3){const X=d(_),j=p(_)-X;N=l(X,j,!0,f+1,h+_,C)}else N=O&&s(_,o,a,l,c,h,f+1);if(N)return!0;I=e,jr(A,m,I);const E=zo(A*2,v),k=a(I,E,M,f+1,h+A);let G;if(k===f3){const X=d(A),j=p(A)-X;G=l(X,j,!0,f+1,h+A,I)}else G=k&&s(A,o,a,l,c,h,f+1);return!!G}}}(),GG=function(){const n=new no,e=new no,t=new me,i=new Er,s=new Er;return u(function r(o,a,l,c,h=null){let f=o*2,d=Vh,p=ja,g=Xa;if(h===null&&(l.boundingBox||l.computeBoundingBox(),i.set(l.boundingBox.min,l.boundingBox.max,c),h=i),zo(f,p)){const v=a,y=v.index,b=v.attributes.position,x=l.index,w=l.attributes.position,_=oc(o,g),A=uh(f,p);if(t.copy(c).invert(),l.boundsTree)return jr(o,d,s),s.matrix.copy(t),s.needsUpdate=!0,l.boundsTree.shapecast({intersectsBounds:M=>s.intersectsBox(M),intersectsTriangle:M=>{M.a.applyMatrix4(c),M.b.applyMatrix4(c),M.c.applyMatrix4(c),M.needsUpdate=!0;for(let C=_*3,I=(A+_)*3;C<I;C+=3)if(Gr(e,C,y,b),e.needsUpdate=!0,M.intersectsTriangle(e))return!0;return!1}});for(let S=_*3,M=A+_*3;S<M;S+=3){Gr(n,S,y,b),n.a.applyMatrix4(t),n.b.applyMatrix4(t),n.c.applyMatrix4(t),n.needsUpdate=!0;for(let C=0,I=x.count;C<I;C+=3)if(Gr(e,C,x,w),e.needsUpdate=!0,n.intersectsTriangle(e))return!0}}else{const v=o+8,y=g[o+6];return jr(v,d,Lu),!!(h.intersectsBox(Lu)&&r(v,a,l,c,h)||(jr(y,d,Lu),h.intersectsBox(Lu)&&r(y,a,l,c,h)))}},"intersectsGeometry")}();function X0(n,e,t,i){return jr(n,e,Lu),t.intersectBox(Lu,i)}u(X0,"intersectRay");const Lx=[];let A0,Vh,ja,Xa;function _d(n){A0&&Lx.push(A0),A0=n,Vh=new Float32Array(n),ja=new Uint16Array(n),Xa=new Uint32Array(n)}u(_d,"setBuffer");function Vm(){A0=null,Vh=null,ja=null,Xa=null,Lx.length&&_d(Lx.pop())}u(Vm,"clearBuffer");const by=Symbol("skip tree generation"),xy=new un,_y=new un,Kc=new me,yl=new Er,pf=new Er,mf=new P,Hm=new P,WG=new P,jG=new P,XG=new P,w3=new un,Or=new J_(()=>new no);class ju{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ju.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t={cloneBuffers:!0,...t};const i=e.geometry,s=e._roots,r=i.getIndex();let o;return t.cloneBuffers?o={roots:s.map(a=>a.slice()),index:r.array.slice()}:o={roots:s,index:r.array},o}static deserialize(e,t,i={}){if(typeof i=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ju.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});i={setIndex:!0,...i};const{index:s,roots:r}=e,o=new ju(t,{...i,[by]:!0});if(o._roots=r,i.setIndex){const a=t.getIndex();if(a===null){const l=new Rt(e.index,1,!1);t.setIndex(l)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return o}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:iD,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[by]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[by]||(this._roots=OG(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new un))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=this.geometry,i=t.index.array,s=t.attributes.position;let r,o,a,l,c=0;const h=this._roots;for(let d=0,p=h.length;d<p;d++)r=h[d],o=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),f(0,c),c+=r.byteLength;function f(d,p,g=!1){const m=d*2;if(a[m+15]===Rx){const y=o[d+6],b=a[m+14];let x=1/0,w=1/0,_=1/0,A=-1/0,S=-1/0,M=-1/0;for(let C=3*y,I=3*(y+b);C<I;C++){const F=i[C],O=s.getX(F),N=s.getY(F),E=s.getZ(F);O<x&&(x=O),O>A&&(A=O),N<w&&(w=N),N>S&&(S=N),E<_&&(_=E),E>M&&(M=E)}return l[d+0]!==x||l[d+1]!==w||l[d+2]!==_||l[d+3]!==A||l[d+4]!==S||l[d+5]!==M?(l[d+0]=x,l[d+1]=w,l[d+2]=_,l[d+3]=A,l[d+4]=S,l[d+5]=M,!0):!1}else{const y=d+8,b=o[d+6],x=y+p,w=b+p;let _=g,A=!1,S=!1;e?_||(A=e.has(x),S=e.has(w),_=!A&&!S):(A=!0,S=!0);const M=_||A,C=_||S;let I=!1;M&&(I=f(y,p,_));let F=!1;C&&(F=f(b,p,_));const O=I||F;if(O)for(let N=0;N<3;N++){const E=y+N,k=b+N,G=l[E],X=l[E+3],te=l[k],j=l[k+3];l[d+N]=G<te?G:te,l[d+N+3]=X>j?X:j}return O}}u(f,"_traverse")}traverse(e,t=0){const i=this._roots[t],s=new Uint32Array(i),r=new Uint16Array(i);o(0);function o(a,l=0){const c=a*2,h=r[c+15]===Rx;if(h){const f=s[a+6],d=r[c+14];e(l,h,new Float32Array(i,a*4,6),f,d)}else{const f=a+rc/4,d=s[a+6],p=s[a+7];e(l,h,new Float32Array(i,a*4,6),p)||(o(f,l+1),o(d,l+1))}}u(o,"_traverse")}raycast(e,t=eo){const i=this._roots,s=this.geometry,r=[],o=t.isMaterial,a=Array.isArray(t),l=s.groups,c=o?t.side:t;for(let h=0,f=i.length;h<f;h++){const d=a?t[l[h].materialIndex].side:c,p=r.length;if(_d(i[h]),Ix(0,s,d,e,r),Vm(),a){const g=l[h].materialIndex;for(let m=p,v=r.length;m<v;m++)r[m].face.materialIndex=g}}return r}raycastFirst(e,t=eo){const i=this._roots,s=this.geometry,r=t.isMaterial,o=Array.isArray(t);let a=null;const l=s.groups,c=r?t.side:t;for(let h=0,f=i.length;h<f;h++){const d=o?t[l[h].materialIndex].side:c;_d(i[h]);const p=Dx(0,s,d,e);Vm(),p!=null&&(a==null||p.distance<a.distance)&&(a=p,o&&(p.face.materialIndex=l[h].materialIndex))}return a}intersectsGeometry(e,t){const i=this.geometry;let s=!1;for(const r of this._roots)if(_d(r),s=GG(0,i,e,t),Vm(),s)break;return s}shapecast(e,t,i){const s=this.geometry;if(e instanceof Function){if(t){const d=t;t=u((p,g,m,v)=>{const y=g*3;return d(p,y,y+1,y+2,m,v)},"_intersectsTriangleFunc")}e={boundsTraverseOrder:i,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=Or.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:a,intersectsRange:l,intersectsTriangle:c}=e;if(l&&c){const d=l;l=u((p,g,m,v,y)=>d(p,g,m,v,y)?!0:_3(p,g,s,c,m,v,r),"intersectsRange")}else l||(c?l=u((d,p,g,m)=>_3(d,p,s,c,g,m,r),"intersectsRange"):l=u((d,p,g)=>g,"intersectsRange"));let h=!1,f=0;for(const d of this._roots){if(_d(d),h=HG(0,s,a,l,o,f),Vm(),h)break;f+=d.byteLength}return Or.releasePrimitive(r),h}bvhcast(e,t,i){let{intersectsRanges:s,intersectsTriangles:r}=i;const o=this.geometry.index,a=this.geometry.attributes.position,l=e.geometry.index,c=e.geometry.attributes.position;Kc.copy(t).invert();const h=Or.getPrimitive(),f=Or.getPrimitive();if(r){let g=function(m,v,y,b,x,w,_,A){for(let S=y,M=y+b;S<M;S++){Gr(f,S*3,l,c),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let C=m,I=m+v;C<I;C++)if(Gr(h,C*3,o,a),h.needsUpdate=!0,r(h,f,C,S,x,w,_,A))return!0}return!1};var p=g;if(u(g,"iterateOverDoubleTriangles"),s){const m=s;s=u(function(v,y,b,x,w,_,A,S){return m(v,y,b,x,w,_,A,S)?!0:g(v,y,b,x,w,_,A,S)},"intersectsRanges")}else s=g}e.getBoundingBox(_y),_y.applyMatrix4(t);const d=this.shapecast({intersectsBounds:g=>_y.intersectsBox(g),intersectsRange:(g,m,v,y,b,x)=>(xy.copy(x),xy.applyMatrix4(Kc),e.shapecast({intersectsBounds:w=>xy.intersectsBox(w),intersectsRange:(w,_,A,S,M)=>s(g,m,w,_,y,b,S,M)}))});return Or.releasePrimitive(h),Or.releasePrimitive(f),d}intersectsBox(e,t){return yl.set(e.min,e.max,t),yl.needsUpdate=!0,this.shapecast({intersectsBounds:i=>yl.intersectsBox(i),intersectsTriangle:i=>yl.intersectsTriangle(i)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,i={},s={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),yl.set(e.boundingBox.min,e.boundingBox.max,t),yl.needsUpdate=!0;const a=this.geometry,l=a.attributes.position,c=a.index,h=e.attributes.position,f=e.index,d=Or.getPrimitive(),p=Or.getPrimitive();let g=Hm,m=WG,v=null,y=null;s&&(v=jG,y=XG);let b=1/0,x=null,w=null;return Kc.copy(t).invert(),pf.matrix.copy(Kc),this.shapecast({boundsTraverseOrder:_=>yl.distanceToBox(_),intersectsBounds:(_,A,S)=>S<b&&S<o?(A&&(pf.min.copy(_.min),pf.max.copy(_.max),pf.needsUpdate=!0),!0):!1,intersectsRange:(_,A)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:S=>pf.distanceToBox(S),intersectsBounds:(S,M,C)=>C<b&&C<o,intersectsRange:(S,M)=>{for(let C=S*3,I=(S+M)*3;C<I;C+=3){Gr(p,C,f,h),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let F=_*3,O=(_+A)*3;F<O;F+=3){Gr(d,F,c,l),d.needsUpdate=!0;const N=d.distanceToTriangle(p,g,v);if(N<b&&(m.copy(g),y&&y.copy(v),b=N,x=F/3,w=C/3),N<r)return!0}}}});{const S=f?f.count:h.count;for(let M=0,C=S;M<C;M+=3){Gr(p,M,f,h),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let I=_*3,F=(_+A)*3;I<F;I+=3){Gr(d,I,c,l),d.needsUpdate=!0;const O=d.distanceToTriangle(p,g,v);if(O<b&&(m.copy(g),y&&y.copy(v),b=O,x=I/3,w=M/3),O<r)return!0}}}}}),Or.releasePrimitive(d),Or.releasePrimitive(p),b===1/0?null:(i.point?i.point.copy(m):i.point=m.clone(),i.distance=b,i.faceIndex=x,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(Kc),m.applyMatrix4(Kc),s.distance=m.sub(s.point).length(),s.faceIndex=w),i)}closestPointToPoint(e,t={},i=0,s=1/0){const r=i*i,o=s*s;let a=1/0,l=null;if(this.shapecast({boundsTraverseOrder:h=>(mf.copy(e).clamp(h.min,h.max),mf.distanceToSquared(e)),intersectsBounds:(h,f,d)=>d<a&&d<o,intersectsTriangle:(h,f)=>{h.closestPointToPoint(e,mf);const d=e.distanceToSquared(mf);return d<a&&(Hm.copy(mf),a=d,l=f),d<r}}),a===1/0)return null;const c=Math.sqrt(a);return t.point?t.point.copy(Hm):t.point=Hm.clone(),t.distance=c,t.faceIndex=l,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(i=>{jr(0,new Float32Array(i),w3),e.union(w3)}),e}}u(ju,"MeshBVH");function qG(n){switch(n){case 1:return"R";case 2:return"RG";case 3:return"RGBA";case 4:return"RGBA"}throw new Error}u(qG,"countToStringFormat");function YG(n){switch(n){case 1:return ih;case 2:return nI;case 3:return rn;case 4:return rn}}u(YG,"countToFormat");function A3(n){switch(n){case 1:return tI;case 2:return O_;case 3:return G0;case 4:return G0}}u(A3,"countToIntFormat");class ew extends Js{constructor(){super(),this.minFilter=Yt,this.magFilter=Yt,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(e){const t=this.overrideItemSize,i=e.itemSize,s=e.count;if(t!==null){if(i*s%t!==0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");e.itemSize=t,e.count=s*i/t}const r=e.itemSize,o=e.count,a=e.normalized,l=e.array.constructor,c=l.BYTES_PER_ELEMENT;let h=this._forcedType,f=r;if(h===null)switch(l){case Float32Array:h=on;break;case Uint8Array:case Uint16Array:case Uint32Array:h=Ys;break;case Int8Array:case Int16Array:case Int32Array:h=b0;break}let d,p,g,m,v=qG(r);switch(h){case on:g=1,p=YG(r),a&&c===1?(m=l,v+="8",l===Uint8Array?d=to:(d=_x,v+="_SNORM")):(m=Float32Array,v+="32F",d=on);break;case b0:v+=c*8+"I",g=a?Math.pow(2,l.BYTES_PER_ELEMENT*8-1):1,p=A3(r),c===1?(m=Int8Array,d=_x):c===2?(m=Int16Array,d=eI):(m=Int32Array,d=b0);break;case Ys:v+=c*8+"UI",g=a?Math.pow(2,l.BYTES_PER_ELEMENT*8-1):1,p=A3(r),c===1?(m=Uint8Array,d=to):c===2?(m=Uint16Array,d=L_):(m=Uint32Array,d=Ys);break}f===3&&(p===rn||p===G0)&&(f=4);const y=Math.ceil(Math.sqrt(o)),b=f*y*y,x=new m(b),w=e.normalized;e.normalized=!1;for(let _=0;_<o;_++){const A=f*_;x[A]=e.getX(_)/g,r>=2&&(x[A+1]=e.getY(_)/g),r>=3&&(x[A+2]=e.getZ(_)/g,f===4&&(x[A+3]=1)),r>=4&&(x[A+3]=e.getW(_)/g)}e.normalized=w,this.internalFormat=v,this.format=p,this.type=d,this.image.width=y,this.image.height=y,this.image.data=x,this.needsUpdate=!0,this.dispose(),e.itemSize=i,e.count=s}}u(ew,"VertexAttributeTexture");class tw extends ew{constructor(){super(),this._forcedType=Ys}}u(tw,"UIntVertexAttributeTexture");class nw extends ew{constructor(){super(),this._forcedType=on}}u(nw,"FloatVertexAttributeTexture");function ZG(n,e,t){const i=n._roots;if(i.length!==1)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const s=i[0],r=new Uint16Array(s),o=new Uint32Array(s),a=new Float32Array(s),l=s.byteLength/rc,c=2*Math.ceil(Math.sqrt(l/2)),h=new Float32Array(4*c*c),f=Math.ceil(Math.sqrt(l)),d=new Uint32Array(2*f*f);for(let p=0;p<l;p++){const g=p*rc/4,m=g*2,v=g;for(let y=0;y<3;y++)h[8*p+0+y]=a[v+0+y],h[8*p+4+y]=a[v+3+y];if(zo(m,r)){const y=uh(m,r),b=oc(g,o),x=4294901760|y;d[p*2+0]=x,d[p*2+1]=b}else{const y=4*hh(g,o)/rc,b=rD(g,o);d[p*2+0]=b,d[p*2+1]=y}}e.image.data=h,e.image.width=c,e.image.height=c,e.format=rn,e.type=on,e.internalFormat="RGBA32F",e.minFilter=Yt,e.magFilter=Yt,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),t.image.data=d,t.image.width=f,t.image.height=f,t.format=O_,t.type=Ys,t.internalFormat="RG32UI",t.minFilter=Yt,t.magFilter=Yt,t.generateMipmaps=!1,t.needsUpdate=!0,t.dispose()}u(ZG,"bvhToTextures");class oD{constructor(){this.autoDispose=!0,this.index=new tw,this.position=new nw,this.bvhBounds=new Js,this.bvhContents=new Js,this.index.overrideItemSize=3}updateFrom(e){const{geometry:t}=e;ZG(e,this.bvhBounds,this.bvhContents),this.index.updateFrom(t.index),this.position.updateFrom(t.attributes.position)}dispose(){const{index:e,position:t,bvhBounds:i,bvhContents:s}=this;e&&e.dispose(),t&&t.dispose(),i&&i.dispose(),s&&s.dispose()}}u(oD,"MeshBVHUniformStruct");const KG=`
#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`,QG=`

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}

// Raycasting
float intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	float dist = max( t0, 0.0 );

	return t1 >= dist ? dist : INFINITY;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,
	inout float minDistance,

	// output variables
	out uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,
	out float side, out float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;
		vec3 a = texelFetch1D( bvh.position, indices.x ).rgb;
		vec3 b = texelFetch1D( bvh.position, indices.y ).rgb;
		vec3 c = texelFetch1D( bvh.position, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

float intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {

	vec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;
	vec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );

}

bool bvhIntersectFirstHit(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection,

	// output variables
	out uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,
	out float side, out float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ 60 ];
	stack[ 0 ] = 0u;

	float triangleDistance = 1e20;
	bool found = false;
	while ( ptr > - 1 && ptr < 60 ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );
		if ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh, rayOrigin, rayDirection, offset, count, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`,bl=new P,xl=new P,_l=new P,M3=new ut,Gm=new P,wy=new P,S3=new ut,T3=new ut,Wm=new me,C3=new me;function gf(n,e){if(!n&&!e)return;const t=n.count===e.count,i=n.normalized===e.normalized,s=n.array.constructor===e.array.constructor,r=n.itemSize===e.itemSize;if(!t||!i||!s||!r)throw new Error}u(gf,"validateAttributes");function wd(n,e=null){const t=n.array.constructor,i=n.normalized,s=n.itemSize,r=e===null?n.count:e;return new Rt(new t(s*r),s,i)}u(wd,"createAttributeClone");function aD(n,e,t=0){if(n.isInterleavedBufferAttribute){const i=n.itemSize;for(let s=0,r=n.count;s<r;s++){const o=s+t;e.setX(o,n.getX(s)),i>=2&&e.setY(o,n.getY(s)),i>=3&&e.setZ(o,n.getZ(s)),i>=4&&e.setW(o,n.getW(s))}}else{const i=e.array,s=i.constructor,r=i.BYTES_PER_ELEMENT*n.itemSize*t;new s(i.buffer,r,n.array.length).set(n.array)}}u(aD,"copyAttributeContents");function JG(n,e,t){const i=n.elements,s=e.elements;for(let r=0,o=s.length;r<o;r++)i[r]+=s[r]*t}u(JG,"addScaledMatrix");function E3(n,e,t){const i=n.skeleton,s=n.geometry,r=i.bones,o=i.boneInverses;S3.fromBufferAttribute(s.attributes.skinIndex,e),T3.fromBufferAttribute(s.attributes.skinWeight,e),Wm.elements.fill(0);for(let a=0;a<4;a++){const l=T3.getComponent(a);if(l!==0){const c=S3.getComponent(a);C3.multiplyMatrices(r[c].matrixWorld,o[c]),JG(Wm,C3,l)}}return Wm.multiply(n.bindMatrix).premultiply(n.bindMatrixInverse),t.transformDirection(Wm),t}u(E3,"boneNormalTransform");function Ay(n,e,t,i,s){Gm.set(0,0,0);for(let r=0,o=n.length;r<o;r++){const a=e[r],l=n[r];a!==0&&(wy.fromBufferAttribute(l,i),t?Gm.addScaledVector(wy,a):Gm.addScaledVector(wy.sub(s),a))}s.add(Gm)}u(Ay,"applyMorphTarget");function eW(n,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},t=new Je){const i=n[0].index!==null,{useGroups:s=!1,updateIndex:r=!1,skipAttributes:o=[]}=e,a=new Set(Object.keys(n[0].attributes)),l={};let c=0;t.clearGroups();for(let h=0;h<n.length;++h){const f=n[h];let d=0;if(i!==(f.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const p in f.attributes){if(!a.has(p))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.');l[p]===void 0&&(l[p]=[]),l[p].push(f.attributes[p]),d++}if(d!==a.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(s){let p;if(i)p=f.index.count;else if(f.attributes.position!==void 0)p=f.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t.addGroup(c,p,h),c+=p}}if(i){let h=!1;if(!t.index){let f=0;for(let d=0;d<n.length;++d)f+=n[d].index.count;t.setIndex(new Rt(new Uint32Array(f),1,!1)),h=!0}if(r||h){const f=t.index;let d=0,p=0;for(let g=0;g<n.length;++g){const m=n[g],v=m.index;if(o[g]!==!0)for(let y=0;y<v.count;++y)f.setX(d,v.getX(y)+p),d++;p+=m.attributes.position.count}}}for(const h in l){const f=l[h];if(!(h in t.attributes)){let g=0;for(const m in f)g+=f[m].count;t.setAttribute(h,wd(l[h][0],g))}const d=t.attributes[h];let p=0;for(let g=0,m=f.length;g<m;g++){const v=f[g];o[g]!==!0&&aD(v,d,p),p+=v.count}}return t}u(eW,"mergeBufferGeometries");function tW(n,e){if(n===null||e===null)return n===e;if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}u(tW,"checkTypedArrayEquality");class lD{constructor(e){this.matrixWorld=new me,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=e,this.update()}update(){const e=this.mesh,t=e.geometry,i=e.skeleton,s=(t.index?t.index.count:t.attributes.position.count)/3;if(this.matrixWorld.copy(e.matrixWorld),this.geometryHash=t.attributes.position.version,this.primitiveCount=s,i){i.boneTexture||i.computeBoneTexture(),i.update();const r=i.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==r.length?this.boneMatrices=r.slice():this.boneMatrices.set(r)}else this.boneMatrices=null}didChange(){const e=this.mesh,t=e.geometry,i=(t.index?t.index.count:t.attributes.position.count)/3;return!(this.matrixWorld.equals(e.matrixWorld)&&this.geometryHash===t.attributes.position.version&&tW(e.skeleton&&e.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===i)}}u(lD,"GeometryDiff");class Ox{constructor(e){Array.isArray(e)||(e=[e]);const t=[];e.forEach(i=>{i.traverseVisible(s=>{s.isMesh&&t.push(s)})}),this.meshes=t,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(t.length).fill().map(()=>new Je),this._diffMap=new WeakMap}getMaterials(){const e=[];return this.meshes.forEach(t=>{Array.isArray(t.material)?e.push(...t.material):e.push(t.material)}),e}generate(e=new Je){let t=[];const{meshes:i,useGroups:s,_intermediateGeometry:r,_diffMap:o}=this;for(let a=0,l=i.length;a<l;a++){const c=i[a],h=r[a],f=o.get(c);!f||f.didChange(c)?(this._convertToStaticGeometry(c,h),t.push(!1),f?f.update():o.set(c,new lD(c))):t.push(!0)}eW(r,{useGroups:s,skipAttributes:t},e);for(const a in e.attributes)e.attributes[a].needsUpdate=!0;return e}_convertToStaticGeometry(e,t=new Je){const i=e.geometry,s=this.applyWorldTransforms,r=this.attributes.includes("normal"),o=this.attributes.includes("tangent"),a=i.attributes,l=t.attributes;t.index||(t.index=i.index),l.position||t.setAttribute("position",wd(a.position)),r&&!l.normal&&a.normal&&t.setAttribute("normal",wd(a.normal)),o&&!l.tangent&&a.tangent&&t.setAttribute("tangent",wd(a.tangent)),gf(i.index,t.index),gf(a.position,l.position),r&&gf(a.normal,l.normal),o&&gf(a.tangent,l.tangent);const c=a.position,h=r?a.normal:null,f=o?a.tangent:null,d=i.morphAttributes.position,p=i.morphAttributes.normal,g=i.morphAttributes.tangent,m=i.morphTargetsRelative,v=e.morphTargetInfluences,y=new ki;y.getNormalMatrix(e.matrixWorld);for(let b=0,x=a.position.count;b<x;b++)bl.fromBufferAttribute(c,b),h&&xl.fromBufferAttribute(h,b),f&&(M3.fromBufferAttribute(f,b),_l.fromBufferAttribute(f,b)),v&&(d&&Ay(d,v,m,b,bl),p&&Ay(p,v,m,b,xl),g&&Ay(g,v,m,b,_l)),e.isSkinnedMesh&&(e.boneTransform(b,bl),h&&E3(e,b,xl),f&&E3(e,b,_l)),s&&bl.applyMatrix4(e.matrixWorld),l.position.setXYZ(b,bl.x,bl.y,bl.z),h&&(s&&xl.applyNormalMatrix(y),l.normal.setXYZ(b,xl.x,xl.y,xl.z)),f&&(s&&_l.transformDirection(e.matrixWorld),l.tangent.setXYZW(b,_l.x,_l.y,_l.z,M3.w));for(const b in this.attributes){const x=this.attributes[b];x==="position"||x==="tangent"||x==="normal"||!(x in a)||(l[x]||t.setAttribute(x,wd(a[x])),gf(a[x],l[x]),aD(a[x],l[x]))}return t}}u(Ox,"StaticGeometryGenerator");function nW(n,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},i=n.getIndex(),s=n.getAttribute("position"),r=i?i.count:s.count;let o=0;const a=Object.keys(n.attributes),l={},c={},h=[],f=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let v=0,y=a.length;v<y;v++){const b=a[v],x=n.attributes[b];l[b]=new Rt(new x.array.constructor(x.count*x.itemSize),x.itemSize,x.normalized);const w=n.morphAttributes[b];w&&(c[b]=new Rt(new w.array.constructor(w.count*w.itemSize),w.itemSize,w.normalized))}const p=Math.log10(1/e),g=Math.pow(10,p);for(let v=0;v<r;v++){const y=i?i.getX(v):v;let b="";for(let x=0,w=a.length;x<w;x++){const _=a[x],A=n.getAttribute(_),S=A.itemSize;for(let M=0;M<S;M++)b+=`${~~(A[f[M]](y)*g)},`}if(b in t)h.push(t[b]);else{for(let x=0,w=a.length;x<w;x++){const _=a[x],A=n.getAttribute(_),S=n.morphAttributes[_],M=A.itemSize,C=l[_],I=c[_];for(let F=0;F<M;F++){const O=f[F],N=d[F];if(C[N](o,A[O](y)),S)for(let E=0,k=S.length;E<k;E++)I[E][N](o,S[E][O](y))}}t[b]=o,h.push(o),o++}}const m=n.clone();for(const v in n.attributes){const y=l[v];if(m.setAttribute(v,new Rt(y.array.slice(0,o*y.itemSize),y.itemSize,y.normalized)),v in c)for(let b=0;b<c[v].length;b++){const x=c[v][b];m.morphAttributes[v][b]=new Rt(x.array.slice(0,o*x.itemSize),x.itemSize,x.normalized)}}return m.setIndex(h),m}u(nW,"mergeVertices");function iW(n,e,t){const i=n.index,r=n.attributes.position.count,o=i?i.count:r;let a=n.groups;a.length===0&&(a=[{count:o,start:0,materialIndex:0}]);let l;t.length<=255?l=new Uint8Array(r):l=new Uint16Array(r);for(let c=0;c<a.length;c++){const h=a[c],f=h.start,d=h.count,p=Math.min(d,o-f),g=Array.isArray(e)?e[h.materialIndex]:e,m=t.indexOf(g);for(let v=0;v<p;v++){let y=f+v;i&&(y=i.getX(y)),l[y]=m}}return new Rt(l,1,!1)}u(iW,"getGroupMaterialIndicesAttribute");function sW(n,e){const{attributes:t=[],normalMapRequired:i=!1}=e;if(!n.attributes.normal&&t&&t.includes("normal")&&n.computeVertexNormals(),!n.attributes.uv&&t&&t.includes("uv")){const s=n.attributes.position.count;n.setAttribute("uv",new Rt(new Float32Array(s*2),2,!1))}if(!n.attributes.tangent&&t&&t.includes("tangent"))if(i)n.index===null&&(n=nW(n)),n.computeTangents();else{const s=n.attributes.position.count;n.setAttribute("tangent",new Rt(new Float32Array(s*4),4,!1))}if(!n.attributes.color&&t&&t.includes("color")){const s=n.attributes.position.count,r=new Float32Array(s*4);r.fill(1),n.setAttribute("color",new Rt(r,4))}if(!n.index){const s=n.attributes.position.count,r=new Array(s);for(let o=0;o<s;o++)r[o]=o;n.setIndex(r)}}u(sW,"setCommonAttributes");class cD{get initialized(){return Boolean(this.bvh)}constructor(e){this.objects=Array.isArray(e)?e:[e],this.bvh=null,this.geometry=new Je,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new Ox(this.objects)}reset(){this.bvh=null,this.geometry.dispose(),this.geometry=new Je,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new Ox(this.objects)}dispose(){}generate(){const{objects:e,staticGeometryGenerator:t,geometry:i}=this;if(this.bvh===null){const s=["position","normal","tangent","uv","color"];for(let l=0,c=e.length;l<c;l++)e[l].traverse(h=>{if(h.isMesh){const f=!!h.material.normalMap;sW(h.geometry,{attributes:s,normalMapRequired:f})}else(h.isRectAreaLight||h.isSpotLight)&&this.lights.push(h)});const r=new Set,o=t.getMaterials();o.forEach(l=>{for(const c in l){const h=l[c];h&&h.isTexture&&r.add(h)}}),t.attributes=s,t.generate(i);const a=iW(i,o,o);return i.setAttribute("materialIndex",a),i.clearGroups(),this.bvh=new ju(i),this.materials=o,this.textures=Array.from(r),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:e}}else{const{bvh:s}=this;return t.generate(i),s.refit(),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:e}}}}u(cD,"DynamicPathTracingSceneGenerator");class uD extends li{set bokehSize(e){this.fStop=this.getFocalLength()/e}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...e){super(...e),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}}u(uD,"PhysicalCamera");function Fx(n){return`${n.source.uuid}:${n.encoding}`}u(Fx,"getTextureHash");function hD(n){const e=new Set,t=[];for(let i=0,s=n.length;i<s;i++){const r=n[i],o=Fx(r);e.has(o)||(e.add(o),t.push(r))}return t}u(hD,"reduceTexturesToUniqueSources");const fD=45,Qc=fD*4,P3=14*4+0,R3=14*4+1;class dD{constructor(){this._features={}}isUsed(e){return e in this._features}setUsed(e,t=!0){t===!1?delete this._features[e]:this._features[e]=!0}reset(){this._features={}}}u(dD,"MaterialFeatures");class pD extends Js{constructor(){super(new Float32Array(4),1,1),this.format=rn,this.type=on,this.wrapS=Wn,this.wrapT=Wn,this.generateMipmaps=!1,this.threeCompatibilityTransforms=!1,this.features=new dD}setCastShadow(e,t){const i=this.image.data,s=e*Qc+R3;i[s]=t?0:1}getCastShadow(e){const t=this.image.data,i=e*Qc+R3;return!Boolean(t[i])}setMatte(e,t){const i=this.image.data,s=e*Qc+P3;i[s]=t?1:0}getMatte(e){const t=this.image.data,i=e*Qc+P3;return Boolean(t[i])}updateFrom(e,t){function i(v,y,b=-1){if(y in v&&v[y]){const x=Fx(v[y]);return g[x]}else return b}u(i,"getTexture");function s(v,y,b){return y in v?v[y]:b}u(s,"getField");function r(v){return v.map||v.specularMap||v.displacementMap||v.normalMap||v.bumpMap||v.roughnessMap||v.metalnessMap||v.alphaMap||v.emissiveMap||v.clearcoatMap||v.clearcoatNormalMap||v.clearcoatRoughnessMap||v.iridescenceMap||v.iridescenceThicknessMap||v.specularIntensityMap||v.specularColorMap||v.transmissionMap||v.thicknessMap||v.sheenColorMap||v.sheenRoughnessMap||null}u(r,"getUVTransformTexture");function o(v,y,b,x){let w;if(h?w=r(v):w=v[y]&&v[y].isTexture?v[y]:null,w){const _=w.matrix.elements;let A=0;b[x+A++]=_[0],b[x+A++]=_[3],b[x+A++]=_[6],A++,b[x+A++]=_[1],b[x+A++]=_[4],b[x+A++]=_[7],A++}return 8}u(o,"writeTextureMatrixToArray");let a=0;const l=e.length*fD,c=Math.ceil(Math.sqrt(l)),{threeCompatibilityTransforms:h,image:f,features:d}=this,p=hD(t),g={};for(let v=0,y=p.length;v<y;v++)g[Fx(p[v])]=v;f.width!==c&&(this.dispose(),f.data=new Float32Array(c*c*4),f.width=c,f.height=c);const m=f.data;d.reset();for(let v=0,y=e.length;v<y;v++){const b=e[v];if(b.isFogVolumeMaterial){d.setUsed("FOG");for(let _=0;_<Qc;_++)m[a+_]=0;m[a+0*4+0]=b.color.r,m[a+0*4+1]=b.color.g,m[a+0*4+2]=b.color.b,m[a+2*4+3]=s(b,"emissiveIntensity",0),m[a+3*4+0]=b.emissive.r,m[a+3*4+1]=b.emissive.g,m[a+3*4+2]=b.emissive.b,m[a+13*4+1]=b.density,m[a+13*4+3]=0,m[a+14*4+2]=1<<2,a+=Qc;continue}m[a++]=b.color.r,m[a++]=b.color.g,m[a++]=b.color.b,m[a++]=i(b,"map"),m[a++]=s(b,"metalness",0),m[a++]=i(b,"metalnessMap"),m[a++]=s(b,"roughness",0),m[a++]=i(b,"roughnessMap"),m[a++]=s(b,"ior",1.5),m[a++]=s(b,"transmission",0),m[a++]=i(b,"transmissionMap"),m[a++]=s(b,"emissiveIntensity",0),"emissive"in b?(m[a++]=b.emissive.r,m[a++]=b.emissive.g,m[a++]=b.emissive.b):(m[a++]=0,m[a++]=0,m[a++]=0),m[a++]=i(b,"emissiveMap"),m[a++]=i(b,"normalMap"),"normalScale"in b?(m[a++]=b.normalScale.x,m[a++]=b.normalScale.y):(m[a++]=1,m[a++]=1),m[a++]=s(b,"clearcoat",0),m[a++]=i(b,"clearcoatMap"),m[a++]=s(b,"clearcoatRoughness",0),m[a++]=i(b,"clearcoatRoughnessMap"),m[a++]=i(b,"clearcoatNormalMap"),"clearcoatNormalScale"in b?(m[a++]=b.clearcoatNormalScale.x,m[a++]=b.clearcoatNormalScale.y):(m[a++]=1,m[a++]=1),a++,m[a++]=s(b,"sheen",0),"sheenColor"in b?(m[a++]=b.sheenColor.r,m[a++]=b.sheenColor.g,m[a++]=b.sheenColor.b):(m[a++]=0,m[a++]=0,m[a++]=0),m[a++]=i(b,"sheenColorMap"),m[a++]=s(b,"sheenRoughness",0),m[a++]=i(b,"sheenRoughnessMap"),m[a++]=i(b,"iridescenceMap"),m[a++]=i(b,"iridescenceThicknessMap"),m[a++]=s(b,"iridescence",0),m[a++]=s(b,"iridescenceIOR",1.3);const x=s(b,"iridescenceThicknessRange",[100,400]);m[a++]=x[0],m[a++]=x[1],"specularColor"in b?(m[a++]=b.specularColor.r,m[a++]=b.specularColor.g,m[a++]=b.specularColor.b):(m[a++]=1,m[a++]=1,m[a++]=1),m[a++]=i(b,"specularColorMap"),m[a++]=s(b,"specularIntensity",1),m[a++]=i(b,"specularIntensityMap");const w=s(b,"thickness",0)===0&&s(b,"attenuationDistance",1/0)===1/0;if(m[a++]=Number(w),a++,"attenuationColor"in b?(m[a++]=b.attenuationColor.r,m[a++]=b.attenuationColor.g,m[a++]=b.attenuationColor.b):(m[a++]=1,m[a++]=1,m[a++]=1),m[a++]=s(b,"attenuationDistance",1/0),m[a++]=i(b,"alphaMap"),m[a++]=b.opacity,m[a++]=b.alphaTest,!w&&b.transmission>0)m[a++]=0;else switch(b.side){case eo:m[a++]=1;break;case ms:m[a++]=-1;break;case Ki:m[a++]=0;break}a++,a++,m[a++]=Number(b.vertexColors)|Number(b.flatShading)<<1,m[a++]=Number(b.transparent),a+=o(b,"map",m,a),a+=o(b,"metalnessMap",m,a),a+=o(b,"roughnessMap",m,a),a+=o(b,"transmissionMap",m,a),a+=o(b,"emissiveMap",m,a),a+=o(b,"normalMap",m,a),a+=o(b,"clearcoatMap",m,a),a+=o(b,"clearcoatNormalMap",m,a),a+=o(b,"clearcoatRoughnessMap",m,a),a+=o(b,"sheenColorMap",m,a),a+=o(b,"sheenRoughnessMap",m,a),a+=o(b,"iridescenceMap",m,a),a+=o(b,"iridescenceThicknessMap",m,a),a+=o(b,"specularColorMap",m,a),a+=o(b,"specularIntensityMap",m,a)}this.needsUpdate=!0}}u(pD,"MaterialsTexture");const I3=new Ce;class mD extends k_{constructor(...e){super(...e);const t=this.texture;t.format=rn,t.type=to,t.minFilter=Zt,t.magFilter=Zt,t.wrapS=Qi,t.wrapT=Qi,t.setTextures=(...s)=>{this.setTextures(...s)};const i=new Ka(new xi);this.fsQuad=i}setTextures(e,t,i,s){const r=hD(s),o=e.getRenderTarget(),a=e.toneMapping,l=e.getClearAlpha();e.getClearColor(I3);const c=r.length||1;this.setSize(t,i,c),e.setClearColor(0,0),e.toneMapping=Qs;const h=this.fsQuad;for(let f=0,d=c;f<d;f++){const p=r[f];p&&(p.matrixAutoUpdate=!1,p.matrix.identity(),h.material.map=p,h.material.transparent=!0,e.setRenderTarget(this,f),h.render(e),p.updateMatrix(),p.matrixAutoUpdate=!0)}h.material.map=null,e.setClearColor(I3,l),e.setRenderTarget(o),e.toneMapping=a}dispose(){super.dispose(),this.fsQuad.dispose()}}u(mD,"RenderTarget2DArray");function D3(n,e,t=0,i=n.length){let s=t,r=t+i-1;for(;s<r;){const o=s+r>>1;n[o]<e?s=o+1:r=o}return s-t}u(D3,"binarySearchFindClosestIndexOf");function rW(n,e,t){return .2126*n+.7152*e+.0722*t}u(rW,"colorToLuminance");function oW(n){const e=n.clone();e.source=new Rp({...e.image});const{width:t,height:i,data:s}=e.image;let r=s;if(e.type===cc){r=new Float32Array(s.length);for(const o in s)r[o]=OH.fromHalfFloat(s[o]);e.image.data=r,e.type=on}if(e.flipY){const o=r;r=r.slice();for(let a=0;a<i;a++)for(let l=0;l<t;l++){const c=i-a-1,h=4*(a*t+l),f=4*(c*t+l);r[f+0]=o[h+0],r[f+1]=o[h+1],r[f+2]=o[h+2],r[f+3]=o[h+3]}e.flipY=!1,e.image.data=r}return e}u(oW,"preprocessEnvMap");class gD{constructor(){const e=new Js(new Float32Array([1,1,1,1]),1,1);e.type=on,e.format=rn,e.minFilter=Zt,e.magFilter=Zt,e.wrapS=Qi,e.wrapT=Qi,e.generateMipmaps=!1,e.needsUpdate=!0;const t=new Js(new Float32Array([0,1]),1,2);t.type=on,t.format=ih,t.minFilter=Zt,t.magFilter=Zt,t.generateMipmaps=!1,t.needsUpdate=!0;const i=new Js(new Float32Array([0,0,1,1]),2,2);i.type=on,i.format=ih,i.minFilter=Zt,i.magFilter=Zt,i.generateMipmaps=!1,i.needsUpdate=!0,this.map=e,this.marginalWeights=t,this.conditionalWeights=i,this.totalSumWhole=1,this.totalSumDecimal=0}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.map.dispose()}updateFrom(e){const t=oW(e);t.wrapS=Qi,t.wrapT=Qi;const{width:i,height:s,data:r}=t.image,o=new Float32Array(i*s),a=new Float32Array(i*s),l=new Float32Array(s),c=new Float32Array(s);let h=0,f=0;for(let b=0;b<s;b++){let x=0;for(let w=0;w<i;w++){const _=b*i+w,A=r[4*_+0],S=r[4*_+1],M=r[4*_+2],C=rW(A,S,M);x+=C,h+=C,o[_]=C,a[_]=x}if(x!==0)for(let w=b*i,_=b*i+i;w<_;w++)o[w]/=x,a[w]/=x;f+=x,l[b]=x,c[b]=f}if(f!==0)for(let b=0,x=l.length;b<x;b++)l[b]/=f,c[b]/=f;const d=new Float32Array(s),p=new Float32Array(i*s);for(let b=0;b<s;b++){const x=(b+1)/s,w=D3(c,x);d[b]=(w+.5)/s}for(let b=0;b<s;b++)for(let x=0;x<i;x++){const w=b*i+x,_=(x+1)/i,A=D3(a,_,b*i,i);p[w]=(A+.5)/i}this.dispose();const{marginalWeights:g,conditionalWeights:m}=this;g.image={width:s,height:1,data:d},g.needsUpdate=!0,m.image={width:i,height:s,data:p},m.needsUpdate=!0;const v=~~h,y=h-v;this.totalSumWhole=v,this.totalSumDecimal=y,this.map=t}}u(gD,"EquirectHdrInfoUniform");class vD{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(e){e instanceof uD?(this.bokehSize=e.bokehSize,this.apertureBlades=e.apertureBlades,this.apertureRotation=e.apertureRotation,this.focusDistance=e.focusDistance,this.anamorphicRatio=e.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}u(vD,"PhysicalCameraUniform");const L3=6,aW=0,lW=1,cW=2,uW=3,hW=4;class yD{constructor(){const e=new Js(new Float32Array(4),1,1);e.format=rn,e.type=on,e.wrapS=Wn,e.wrapT=Wn,e.generateMipmaps=!1,this.tex=e,this.count=0}updateFrom(e,t=[]){const i=this.tex,s=Math.max(e.length*L3,1),r=Math.ceil(Math.sqrt(s));i.image.width!==r&&(i.dispose(),i.image.data=new Float32Array(r*r*4),i.image.width=r,i.image.height=r);const o=i.image.data,a=new P,l=new P,c=new me,h=new je,f=new P,d=new P,p=new P;for(let g=0,m=e.length;g<m;g++){const v=e[g],y=g*L3*4;let b=0;v.getWorldPosition(l),o[y+b++]=l.x,o[y+b++]=l.y,o[y+b++]=l.z;let x=aW;if(v.isRectAreaLight&&v.isCircular?x=lW:v.isSpotLight?x=cW:v.isDirectionalLight?x=uW:v.isPointLight&&(x=hW),o[y+b++]=x,o[y+b++]=v.color.r,o[y+b++]=v.color.g,o[y+b++]=v.color.b,o[y+b++]=v.intensity,v.getWorldQuaternion(h),v.isRectAreaLight)a.set(v.width,0,0).applyQuaternion(h),o[y+b++]=a.x,o[y+b++]=a.y,o[y+b++]=a.z,b++,l.set(0,v.height,0).applyQuaternion(h),o[y+b++]=l.x,o[y+b++]=l.y,o[y+b++]=l.z,o[y+b++]=a.cross(l).length()*(v.isCircular?Math.PI/4:1);else if(v.isSpotLight){const w=v.radius;f.setFromMatrixPosition(v.matrixWorld),d.setFromMatrixPosition(v.target.matrixWorld),c.lookAt(f,d,p),h.setFromRotationMatrix(c),a.set(1,0,0).applyQuaternion(h),o[y+b++]=a.x,o[y+b++]=a.y,o[y+b++]=a.z,b++,l.set(0,1,0).applyQuaternion(h),o[y+b++]=l.x,o[y+b++]=l.y,o[y+b++]=l.z,o[y+b++]=Math.PI*w*w,o[y+b++]=w,o[y+b++]=v.shadow.camera.near,o[y+b++]=v.decay,o[y+b++]=v.distance,o[y+b++]=Math.cos(v.angle),o[y+b++]=Math.cos(v.angle*(1-v.penumbra)),o[y+b++]=t.indexOf(v.iesTexture)}else if(v.isPointLight){const w=a.setFromMatrixPosition(v.matrixWorld);o[y+b++]=w.x,o[y+b++]=w.y,o[y+b++]=w.z,b++,b+=4,b+=2,o[y+b++]=v.decay,o[y+b++]=v.distance}else if(v.isDirectionalLight){const w=a.setFromMatrixPosition(v.matrixWorld),_=l.setFromMatrixPosition(v.target.matrixWorld);d.subVectors(w,_).normalize(),o[y+b++]=d.x,o[y+b++]=d.y,o[y+b++]=d.z}}i.needsUpdate=!0,this.count=e.length}}u(yD,"LightsInfoUniformStruct");function O3(n){const e=this,t=n.split(`
`);let i=0,s;e.verAngles=[],e.horAngles=[],e.candelaValues=[],e.tiltData={},e.tiltData.angles=[],e.tiltData.mulFactors=[];function r(f){return f=f.trim(),f=f.replace(/,/g," "),f=f.replace(/\s\s+/g," "),f.split(" ")}u(r,"textToArray");function o(f,d){for(;;){const p=t[i++],g=r(p);for(let m=0;m<g.length;++m)d.push(Number(g[m]));if(d.length===f)break}}u(o,"readArray");function a(){let f=t[i++],d=r(f);e.tiltData.lampToLumGeometry=Number(d[0]),f=t[i++],d=r(f),e.tiltData.numAngles=Number(d[0]),o(e.tiltData.numAngles,e.tiltData.angles),o(e.tiltData.numAngles,e.tiltData.mulFactors)}u(a,"readTilt");function l(){const f=[];o(10,f),e.count=Number(f[0]),e.lumens=Number(f[1]),e.multiplier=Number(f[2]),e.numVerAngles=Number(f[3]),e.numHorAngles=Number(f[4]),e.gonioType=Number(f[5]),e.units=Number(f[6]),e.width=Number(f[7]),e.length=Number(f[8]),e.height=Number(f[9])}u(l,"readLampValues");function c(){const f=[];o(3,f),e.ballFactor=Number(f[0]),e.blpFactor=Number(f[1]),e.inputWatts=Number(f[2])}for(u(c,"readLampFactors");s=t[i++],!s.includes("TILT"););s.includes("NONE")||s.includes("INCLUDE")&&a(),l(),c();for(let f=0;f<e.numHorAngles;++f)e.candelaValues.push([]);o(e.numVerAngles,e.verAngles),o(e.numHorAngles,e.horAngles);for(let f=0;f<e.numHorAngles;++f)o(e.numVerAngles,e.candelaValues[f]);for(let f=0;f<e.numHorAngles;++f)for(let d=0;d<e.numVerAngles;++d)e.candelaValues[f][d]*=e.candelaValues[f][d]*e.multiplier*e.ballFactor*e.blpFactor;let h=-1;for(let f=0;f<e.numHorAngles;++f)for(let d=0;d<e.numVerAngles;++d){const p=e.candelaValues[f][d];h=h<p?p:h}if(h>0)for(let f=0;f<e.numHorAngles;++f)for(let d=0;d<e.numVerAngles;++d)e.candelaValues[f][d]/=h}u(O3,"IESLamp");class bD extends ia{_getIESValues(e){const r=new Float32Array(64800);function o(c,h){let f=0,d=0,p=0,g=0,m=0,v=0;for(let C=0;C<e.numHorAngles-1;++C)if(h<e.horAngles[C+1]||C==e.numHorAngles-2){d=C,p=e.horAngles[C],g=e.horAngles[C+1];break}for(let C=0;C<e.numVerAngles-1;++C)if(c<e.verAngles[C+1]||C==e.numVerAngles-2){f=C,m=e.verAngles[C],v=e.verAngles[C+1];break}const y=g-p,b=v-m;if(b===0)return 0;const x=y===0?0:(h-p)/y,w=(c-m)/b,_=y===0?d:d+1,A=Yi.lerp(e.candelaValues[d][f],e.candelaValues[_][f],x),S=Yi.lerp(e.candelaValues[d][f+1],e.candelaValues[_][f+1],x);return Yi.lerp(A,S,w)}u(o,"interpolateCandelaValues");const a=e.horAngles[0],l=e.horAngles[e.numHorAngles-1];for(let c=0;c<64800;++c){let h=c%360;const f=Math.floor(c/360);l-a!==0&&(h<a||h>=l)&&(h%=l*2,h>l&&(h=l*2-h)),r[c]=o(f,h)}return r}load(e,t,i,s){const r=new Bh(this.manager);r.setResponseType("text"),r.setCrossOrigin(this.crossOrigin),r.setWithCredentials(this.withCredentials),r.setPath(this.path),r.setRequestHeader(this.requestHeader);const o=new Js(null,360,180,ih,on);return o.minFilter=Zt,o.magFilter=Zt,r.load(e,a=>{const l=new O3(a);o.image.data=this._getIESValues(l),o.needsUpdate=!0,t!==void 0&&t(o)},i,s),o}parse(e){const t=new O3(e),i=new Js(null,360,180,ih,on);return i.minFilter=Zt,i.magFilter=Zt,i.image.data=this._getIESValues(t),i.needsUpdate=!0,i}}u(bD,"IESLoader");const F3=new Ce;class xD extends k_{constructor(...e){super(...e);const t=this.texture;t.format=rn,t.type=on,t.minFilter=Zt,t.magFilter=Zt,t.wrapS=Wn,t.wrapT=Wn,t.generateMipmaps=!1,t.updateFrom=(...s)=>{this.updateFrom(...s)};const i=new Ka(new xi);this.fsQuad=i,this.iesLoader=new bD}async updateFrom(e,t){const i=e.getRenderTarget(),s=e.toneMapping,r=e.getClearAlpha();e.getClearColor(F3);const o=t.length||1;this.setSize(360,180,o),e.setClearColor(0,0),e.toneMapping=Qs;const a=this.fsQuad;for(let l=0,c=o;l<c;l++){const h=t[l];h&&(h.matrixAutoUpdate=!1,h.matrix.identity(),a.material.map=h,a.material.transparent=!0,e.setRenderTarget(this,l),a.render(e),h.updateMatrix(),h.matrixAutoUpdate=!0)}a.material.map=null,e.setClearColor(F3,r),e.setRenderTarget(i),e.toneMapping=s,a.dispose()}dispose(){super.dispose(),this.fsQuad.dispose()}}u(xD,"IESProfilesTexture");const fW=`

	// TODO: possibly this should be renamed something related to material or path tracing logic

	#ifndef RAY_OFFSET
	#define RAY_OFFSET 1e-4
	#endif

	// adjust the hit point by the surface normal by a factor of some offset and the
	// maximum component-wise value of the current point to accommodate floating point
	// error as values increase.
	vec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {

		vec3 point = rayOrigin + rayDirection * dist;
		vec3 absPoint = abs( point );
		float maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );
		return point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;

	}

	// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
	vec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {

		vec3 ot = - log( attColor ) / attDist;
		return exp( - ot * dist );

	}

	vec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {

		// get the half vector - assuming if the light incident vector is on the other side
		// of the that it's transmissive.
		vec3 h;
		if ( wi.z > 0.0 ) {

			h = normalize( wi + wo );

		} else {

			// Scale by the ior ratio to retrieve the appropriate half vector
			// From Section 2.2 on computing the transmission half vector:
			// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf
			h = normalize( wi + wo * eta );

		}

		h *= sign( h.z );
		return h;

	}

	vec3 getHalfVector( vec3 a, vec3 b ) {

		return normalize( a + b );

	}

	// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray
	// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If
	// we find a ray like that we ignore it to avoid artifacts.
	// This function returns if the direction is on the same side of both planes.
	bool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {

		bool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;
		bool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;
		return aboveSurfaceNormal == aboveGeometryNormal;

	}

	// ray sampling x and z are swapped to align with expected background view
	vec2 equirectDirectionToUv( vec3 direction ) {

		// from Spherical.setFromCartesianCoords
		vec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );
		uv /= vec2( 2.0 * PI, PI );

		// apply adjustments to get values in range [0, 1] and y right side up
		uv.x += 0.5;
		uv.y = 1.0 - uv.y;
		return uv;

	}

	vec3 equirectUvToDirection( vec2 uv ) {

		// undo above adjustments
		uv.x -= 0.5;
		uv.y = 1.0 - uv.y;

		// from Vector3.setFromSphericalCoords
		float theta = uv.x * 2.0 * PI;
		float phi = uv.y * PI;

		float sinPhi = sin( phi );

		return vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );

	}

	// power heuristic for multiple importance sampling
	float misHeuristic( float a, float b ) {

		float aa = a * a;
		float bb = b * b;
		return aa / ( aa + bb );

	}

	// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60
	// erichlof/THREE.js-PathTracing-Renderer/
	float tentFilter( float x ) {

		return x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );

	}
`;function N3(n,e,t,i,s){if(e>i)throw new Error;const r=n.length/e,o=n.constructor.BYTES_PER_ELEMENT*8;let a=1;switch(n.constructor){case Uint8Array:case Uint16Array:case Uint32Array:a=2**o-1;break;case Int8Array:case Int16Array:case Int32Array:a=2**(o-1)-1;break}for(let l=0;l<r;l++){const c=4*l,h=e*l;for(let f=0;f<i;f++)t[s+c+f]=e>=f+1?n[h+f]/a:0}}u(N3,"copyArrayToArray");class _D extends Ip{constructor(){super(),this._textures=[],this.type=on,this.format=rn,this.internalFormat="RGBA32F"}updateAttribute(e,t){const i=this._textures[e];i.updateFrom(t);const s=i.image,r=this.image;if(s.width!==r.width||s.height!==r.height)throw new Error("FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.");const{width:o,height:a,data:l}=r,h=o*a*4*e;let f=t.itemSize;f===3&&(f=4),N3(i.image.data,f,l,4,h),this.dispose(),this.needsUpdate=!0}setAttributes(e){const t=e[0].count,i=e.length;for(let f=0,d=i;f<d;f++)if(e[f].count!==t)throw new Error("FloatAttributeTextureArray: All attributes must have the same item count.");const s=this._textures;for(;s.length<i;){const f=new nw;s.push(f)}for(;s.length>i;)s.pop();for(let f=0,d=i;f<d;f++)s[f].updateFrom(e[f]);const o=s[0].image,a=this.image;(o.width!==a.width||o.height!==a.height||o.depth!==i)&&(a.width=o.width,a.height=o.height,a.depth=i,a.data=new Float32Array(a.width*a.height*a.depth*4));const{data:l,width:c,height:h}=a;for(let f=0,d=i;f<d;f++){const p=s[f],m=c*h*4*f;let v=e[f].itemSize;v===3&&(v=4),N3(p.image.data,v,l,4,m)}this.dispose(),this.needsUpdate=!0}}u(_D,"FloatAttributeTextureArray");class wD extends _D{updateNormalAttribute(e){this.updateAttribute(0,e)}updateTangentAttribute(e){this.updateAttribute(1,e)}updateUvAttribute(e){this.updateAttribute(2,e)}updateColorAttribute(e){this.updateAttribute(3,e)}updateFrom(e,t,i,s){this.setAttributes([e,t,i,s])}}u(wD,"AttributesTextureArray");const dW=`

	struct PhysicalCamera {

		float focusDistance;
		float anamorphicRatio;
		float bokehSize;
		int apertureBlades;
		float apertureRotation;

	};

`,pW=`

	struct EquirectHdrInfo {

		sampler2D marginalWeights;
		sampler2D conditionalWeights;
		sampler2D map;

		float totalSumWhole;
		float totalSumDecimal;

	};

`,mW=`

	#define RECT_AREA_LIGHT_TYPE 0
	#define CIRC_AREA_LIGHT_TYPE 1
	#define SPOT_LIGHT_TYPE 2
	#define DIR_LIGHT_TYPE 3
	#define POINT_LIGHT_TYPE 4

	struct LightsInfo {

		sampler2D tex;
		uint count;

	};

	struct Light {

		vec3 position;
		int type;

		vec3 color;
		float intensity;

		vec3 u;
		vec3 v;
		float area;

		// spot light fields
		float radius;
		float near;
		float decay;
		float distance;
		float coneCos;
		float penumbraCos;
		int iesProfile;

	};

	Light readLightInfo( sampler2D tex, uint index ) {

		uint i = index * 6u;

		vec4 s0 = texelFetch1D( tex, i + 0u );
		vec4 s1 = texelFetch1D( tex, i + 1u );
		vec4 s2 = texelFetch1D( tex, i + 2u );
		vec4 s3 = texelFetch1D( tex, i + 3u );

		Light l;
		l.position = s0.rgb;
		l.type = int( round( s0.a ) );

		l.color = s1.rgb;
		l.intensity = s1.a;

		l.u = s2.rgb;
		l.v = s3.rgb;
		l.area = s3.a;

		if ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {

			vec4 s4 = texelFetch1D( tex, i + 4u );
			vec4 s5 = texelFetch1D( tex, i + 5u );
			l.radius = s4.r;
			l.near = s4.g;
			l.decay = s4.b;
			l.distance = s4.a;

			l.coneCos = s5.r;
			l.penumbraCos = s5.g;
			l.iesProfile = int( round ( s5.b ) );

		}

		return l;

	}

`,gW=`

	struct Material {

		vec3 color;
		int map;

		float metalness;
		int metalnessMap;

		float roughness;
		int roughnessMap;

		float ior;
		float transmission;
		int transmissionMap;

		float emissiveIntensity;
		vec3 emissive;
		int emissiveMap;

		int normalMap;
		vec2 normalScale;

		float clearcoat;
		int clearcoatMap;
		int clearcoatNormalMap;
		vec2 clearcoatNormalScale;
		float clearcoatRoughness;
		int clearcoatRoughnessMap;

		int iridescenceMap;
		int iridescenceThicknessMap;
		float iridescence;
		float iridescenceIor;
		float iridescenceThicknessMinimum;
		float iridescenceThicknessMaximum;

		vec3 specularColor;
		int specularColorMap;

		float specularIntensity;
		int specularIntensityMap;
		bool thinFilm;

		vec3 attenuationColor;
		float attenuationDistance;

		int alphaMap;

		bool castShadow;
		float opacity;
		float alphaTest;

		float side;
		bool matte;

		float sheen;
		vec3 sheenColor;
		int sheenColorMap;
		float sheenRoughness;
		int sheenRoughnessMap;

		bool vertexColors;
		bool flatShading;
		bool transparent;
		bool fogVolume;

		mat3 mapTransform;
		mat3 metalnessMapTransform;
		mat3 roughnessMapTransform;
		mat3 transmissionMapTransform;
		mat3 emissiveMapTransform;
		mat3 normalMapTransform;
		mat3 clearcoatMapTransform;
		mat3 clearcoatNormalMapTransform;
		mat3 clearcoatRoughnessMapTransform;
		mat3 sheenColorMapTransform;
		mat3 sheenRoughnessMapTransform;
		mat3 iridescenceMapTransform;
		mat3 iridescenceThicknessMapTransform;
		mat3 specularColorMapTransform;
		mat3 specularIntensityMapTransform;

	};

	mat3 readTextureTransform( sampler2D tex, uint index ) {

		mat3 textureTransform;

		vec4 row1 = texelFetch1D( tex, index );
		vec4 row2 = texelFetch1D( tex, index + 1u );

		textureTransform[0] = vec3(row1.r, row2.r, 0.0);
		textureTransform[1] = vec3(row1.g, row2.g, 0.0);
		textureTransform[2] = vec3(row1.b, row2.b, 1.0);

		return textureTransform;

	}

	Material readMaterialInfo( sampler2D tex, uint index ) {

		uint i = index * 45u;

		vec4 s0 = texelFetch1D( tex, i + 0u );
		vec4 s1 = texelFetch1D( tex, i + 1u );
		vec4 s2 = texelFetch1D( tex, i + 2u );
		vec4 s3 = texelFetch1D( tex, i + 3u );
		vec4 s4 = texelFetch1D( tex, i + 4u );
		vec4 s5 = texelFetch1D( tex, i + 5u );
		vec4 s6 = texelFetch1D( tex, i + 6u );
		vec4 s7 = texelFetch1D( tex, i + 7u );
		vec4 s8 = texelFetch1D( tex, i + 8u );
		vec4 s9 = texelFetch1D( tex, i + 9u );
		vec4 s10 = texelFetch1D( tex, i + 10u );
		vec4 s11 = texelFetch1D( tex, i + 11u );
		vec4 s12 = texelFetch1D( tex, i + 12u );
		vec4 s13 = texelFetch1D( tex, i + 13u );
		vec4 s14 = texelFetch1D( tex, i + 14u );

		Material m;
		m.color = s0.rgb;
		m.map = int( round( s0.a ) );

		m.metalness = s1.r;
		m.metalnessMap = int( round( s1.g ) );
		m.roughness = s1.b;
		m.roughnessMap = int( round( s1.a ) );

		m.ior = s2.r;
		m.transmission = s2.g;
		m.transmissionMap = int( round( s2.b ) );
		m.emissiveIntensity = s2.a;

		m.emissive = s3.rgb;
		m.emissiveMap = int( round( s3.a ) );

		m.normalMap = int( round( s4.r ) );
		m.normalScale = s4.gb;

		m.clearcoat = s4.a;
		m.clearcoatMap = int( round( s5.r ) );
		m.clearcoatRoughness = s5.g;
		m.clearcoatRoughnessMap = int( round( s5.b ) );
		m.clearcoatNormalMap = int( round( s5.a ) );
		m.clearcoatNormalScale = s6.rg;

		m.sheen = s6.a;
		m.sheenColor = s7.rgb;
		m.sheenColorMap = int( round( s7.a ) );
		m.sheenRoughness = s8.r;
		m.sheenRoughnessMap = int( round( s8.g ) );

		m.iridescenceMap = int( round( s8.b ) );
		m.iridescenceThicknessMap = int( round( s8.a ) );
		m.iridescence = s9.r;
		m.iridescenceIor = s9.g;
		m.iridescenceThicknessMinimum = s9.b;
		m.iridescenceThicknessMaximum = s9.a;

		m.specularColor = s10.rgb;
		m.specularColorMap = int( round( s10.a ) );

		m.specularIntensity = s11.r;
		m.specularIntensityMap = int( round( s11.g ) );
		m.thinFilm = bool( s11.b );

		m.attenuationColor = s12.rgb;
		m.attenuationDistance = s12.a;

		m.alphaMap = int( round( s13.r ) );

		m.opacity = s13.g;
		m.alphaTest = s13.b;
		m.side = s13.a;

		m.matte = bool( s14.r );
		m.castShadow = ! bool( s14.g );
		m.vertexColors = bool( int( s14.b ) & 1 );
		m.flatShading = bool( int( s14.b ) & 2 );
		m.fogVolume = bool( int( s14.b ) & 4 );
		m.transparent = bool( s14.a );

		uint firstTextureTransformIdx = i + 15u;

		m.mapTransform = m.map == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx );
		m.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );
		m.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );
		m.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );
		m.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );
		m.normalMapTransform = m.normalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );
		m.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );
		m.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );
		m.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );
		m.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );
		m.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );
		m.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );
		m.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );
		m.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );
		m.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );

		return m;

	}

`,vW=`

#ifndef FOG_CHECK_ITERATIONS
#define FOG_CHECK_ITERATIONS 30
#endif

// returns whether the given material is a fog material or not
bool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {

	uint i = materialIndex * 45u;
	vec4 s14 = texelFetch1D( materials, i + 14u );
	return bool( int( s14.b ) & 4 );

}

// returns true if we're within the first fog volume we hit
bool bvhIntersectFogVolumeHit(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection,
	usampler2D materialIndexAttribute, sampler2D materials,
	out Material material
) {

	material.fogVolume = false;

	for ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {

		// find nearest hit
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		if ( hit ) {

			// if it's a fog volume return whether we hit the front or back face
			uint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;
			if ( isMaterialFogVolume( materials, materialIndex ) ) {

				material = readMaterialInfo( materials, materialIndex );
				return side == - 1.0;

			} else {

				// move the ray forward
				rayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );

			}

		} else {

			return false;

		}

	}

	return false;

}

`,yW=`

	// The GGX functions provide sampling and distribution information for normals as output so
	// in order to get probability of scatter direction the half vector must be computed and provided.
	// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
	// [1] https://hal.archives-ouvertes.fr/hal-01509746/document
	// [2] http://jcgt.org/published/0007/04/01/
	// [4] http://jcgt.org/published/0003/02/03/

	// trowbridge-reitz === GGX === GTR

	vec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {

		// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution
		// function below, as well

		// Implementation from reference [1]
		// stretch view
		vec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );

		// orthonormal basis
		vec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );
		vec3 T2 = cross( T1, V );

		// sample point with polar coordinates (r, phi)
		float a = 1.0 / ( 1.0 + V.z );
		float r = sqrt( uv.x );
		float phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;
		float P1 = r * cos( phi );
		float P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );

		// compute normal
		vec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );

		// unstretch
		N = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );

		return N;

	}

	// Below are PDF and related functions for use in a Monte Carlo path tracer
	// as specified in Appendix B of the following paper
	// See equation (34) from reference [0]
	float ggxLamda( float theta, float roughness ) {

		float tanTheta = tan( theta );
		float tanTheta2 = tanTheta * tanTheta;
		float alpha2 = roughness * roughness;

		float numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );
		return numerator / 2.0;

	}

	// See equation (34) from reference [0]
	float ggxShadowMaskG1( float theta, float roughness ) {

		return 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );

	}

	// See equation (125) from reference [4]
	float ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {

		float incidentTheta = acos( wi.z );
		float scatterTheta = acos( wo.z );
		return 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );

	}

	// See equation (33) from reference [0]
	float ggxDistribution( vec3 halfVector, float roughness ) {

		float a2 = roughness * roughness;
		a2 = max( EPSILON, a2 );
		float cosTheta = halfVector.z;
		float cosTheta4 = pow( cosTheta, 4.0 );

		if ( cosTheta == 0.0 ) return 0.0;

		float theta = acosSafe( halfVector.z );
		float tanTheta = tan( theta );
		float tanTheta2 = pow( tanTheta, 2.0 );

		float denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );
		return ( a2 / denom );

	}

	// See equation (3) from reference [2]
	float ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {

		float incidentTheta = acos( wi.z );
		float D = ggxDistribution( halfVector, roughness );
		float G1 = ggxShadowMaskG1( incidentTheta, roughness );

		return D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;

	}

`,bW=`

	// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
	float velvetD( float cosThetaH, float roughness ) {

		float alpha = max( roughness, 0.07 );
		alpha = alpha * alpha;

		float invAlpha = 1.0 / alpha;

		float sqrCosThetaH = cosThetaH * cosThetaH;
		float sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );

		return ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );

	}

	float velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {

		const float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );
		const float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );

		return mix( p1[i], p0[i], oneMinusAlphaSquared );

	}

	float velvetL( float x, float alpha ) {

		float oneMinusAlpha = 1.0 - alpha;
		float oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;

		float a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );
		float b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );
		float c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );
		float d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );
		float e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );

		return a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;

	}

	// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
	float velvetLambda( float cosTheta, float alpha ) {

		return abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );

	}

	// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
	float velvetG( float cosThetaO, float cosThetaI, float roughness ) {

		float alpha = max( roughness, 0.07 );
		alpha = alpha * alpha;

		return 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );

	}

	float directionalAlbedoSheen( float cosTheta, float alpha ) {

		cosTheta = saturate( cosTheta );

		float c = 1.0 - cosTheta;
		float c3 = c * c * c;

		return 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );

	}

	float sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {

		float alpha = max( surf.sheenRoughness, 0.07 );
		alpha = alpha * alpha;

		float maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );

		float eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );
		float eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );

		return min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );

	}

	// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
	float sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {

		float alpha = max( surf.sheenRoughness, 0.07 );
		alpha = alpha * alpha;

		float maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );

		float eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );

		return 1.0 - maxSheenColor * eWo;

	}

`,xW=`

	// XYZ to sRGB color space
	const mat3 XYZ_TO_REC709 = mat3(
		3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);

	vec3 fresnel0ToIor( vec3 fresnel0 ) {

		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );

	}

	// Conversion FO/IOR
	vec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {

		return square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );

	}

	// ior is a value between 1.0 and 3.0. 1.0 is air interface
	float iorToFresnel0( float transmittedIor, float incidentIor ) {

		return square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );

	}

	// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
	vec3 evalSensitivity( float OPD, vec3 shift ) {

		float phase = 2.0 * PI * OPD * 1.0e-9;

		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );
		xyz /= 1.0685e-7;

		vec3 srgb = XYZ_TO_REC709 * xyz;
		return srgb;

	}

	// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {

		vec3 I;

		// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
		float iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );

		// Evaluate the cosTheta on the base layer (Snell law)
		float sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );

		// Handle TIR:
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {

			return vec3( 1.0 );

		}

		float cosTheta2 = sqrt( cosTheta2Sq );

		// First interface
		float R0 = iorToFresnel0( iridescenceIor, outsideIOR );
		float R12 = schlickFresnel( cosTheta1, R0 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIor < outsideIOR ) {

			phi12 = PI;

		}

		float phi21 = PI - phi12;

		// Second interface
		vec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0
		vec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );
		vec3 R23 = schlickFresnel( cosTheta2, R1 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[0] < iridescenceIor ) {

			phi23[ 0 ] = PI;

		}

		if ( baseIOR[1] < iridescenceIor ) {

			phi23[ 1 ] = PI;

		}

		if ( baseIOR[2] < iridescenceIor ) {

			phi23[ 2 ] = PI;

		}

		// Phase shift
		float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;

		// Compound terms
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );

		// Reflectance term for m = 0 (DC term amplitude)
		vec3 C0 = R12 + Rs;
		I = C0;

		// Reflectance term for m > 0 (pairs of diracs)
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {

			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;

		}

		// Since out of gamut colors might be produced, negative color values are clamped to 0.
		return max( I, vec3( 0.0 ) );

	}

`,_W=`

	struct SurfaceRecord {

		// surface type
		bool volumeParticle;

		// geometry
		vec3 faceNormal;
		bool frontFace;
		vec3 normal;

		// cached properties
		float eta;
		float f0;

		// material
		float roughness;
		float filteredRoughness;
		float metalness;
		vec3 color;
		vec3 emission;

		// transmission
		float ior;
		float transmission;
		bool thinFilm;
		vec3 attenuationColor;
		float attenuationDistance;

		// clearcoat
		vec3 clearcoatNormal;
		float clearcoat;
		float clearcoatRoughness;
		float filteredClearcoatRoughness;

		// sheen
		float sheen;
		vec3 sheenColor;
		float sheenRoughness;

		// iridescence
		float iridescence;
		float iridescenceIor;
		float iridescenceThickness;

		// specular
		vec3 specularColor;
		float specularIntensity;
	};

	struct ScatterRecord {
		float specularPdf;
		float pdf;

		vec3 direction;
		vec3 clearcoatDirection;

		vec3 color;
	};

	${yW}
	${bW}
	${xW}

	// diffuse
	float diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {

		// https://schuttejoe.github.io/post/disneybsdf/
		float fl = schlickFresnel( wi.z, 0.0 );
		float fv = schlickFresnel( wo.z, 0.0 );

		float metalFactor = ( 1.0 - surf.metalness );
		float transFactor = ( 1.0 - surf.transmission );
		float rr = 0.5 + 2.0 * surf.roughness * fl * fl;
		float retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );
		float lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );

		// TODO: subsurface approx?

		float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );
		color = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;
		return wi.z / PI;

	}

	vec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {

		vec3 lightDirection = sampleSphere( sobol2( 11 ) );
		lightDirection.z += 1.0;
		lightDirection = normalize( lightDirection );

		return lightDirection;

	}

	// specular
	float specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {

		// if roughness is set to 0 then D === NaN which results in black pixels
		float metalness = surf.metalness;
		float roughness = surf.filteredRoughness;

		float eta = surf.eta;
		float f0 = surf.f0;

		vec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );
		vec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );
		vec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );

		vec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );
		F = mix( F, iridescenceF,  surf.iridescence );

		// PDF
		// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/
		float incidentTheta = acos( wo.z );
		float G = ggxShadowMaskG2( wi, wo, roughness );
		float D = ggxDistribution( wh, roughness );
		float G1 = ggxShadowMaskG1( incidentTheta, roughness );
		float ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );

		color = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );
		return ggxPdf / ( 4.0 * dot( wo, wh ) );

	}

	vec3 specularDirection( vec3 wo, SurfaceRecord surf ) {

		// sample ggx vndf distribution which gives a new normal
		float roughness = surf.filteredRoughness;
		vec3 halfVector = ggxDirection(
			wo,
			vec2( roughness ),
			sobol2( 12 )
		);

		// apply to new ray by reflecting off the new normal
		return - reflect( wo, halfVector );

	}


	// transmission
	/*
	float transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {

		// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf

		float filteredRoughness = surf.filteredRoughness;
		float eta = surf.eta;
		bool frontFace = surf.frontFace;
		bool thinFilm = surf.thinFilm;

		color = surf.transmission * surf.color;

		float denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );
		return ggxPDF( wo, wh, filteredRoughness ) / denom;

	}

	vec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {

		float filteredRoughness = surf.filteredRoughness;
		float eta = surf.eta;
		bool frontFace = surf.frontFace;

		// sample ggx vndf distribution which gives a new normal
		vec3 halfVector = ggxDirection(
			wo,
			vec2( filteredRoughness ),
			sobol2( 13 )
		);

		vec3 lightDirection = refract( normalize( - wo ), halfVector, eta );
		if ( surf.thinFilm ) {

			lightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );

		}

		return normalize( lightDirection );

	}
	*/

	// TODO: This is just using a basic cosine-weighted specular distribution with an
	// incorrect PDF value at the moment. Update it to correctly use a GGX distribution
	float transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {

		color = surf.transmission * surf.color;

		// PDF
		float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );
		if ( F >= 1.0 ) {

			return 0.0;

		}

		return 1.0 / ( 1.0 - F );

	}

	vec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {

		float roughness = surf.filteredRoughness;
		float eta = surf.eta;
		vec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( sobol2( 13 ) ) * roughness );
		vec3 lightDirection = refract( normalize( - wo ), halfVector, eta );

		if ( surf.thinFilm ) {

			lightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );

		}
		return normalize( lightDirection );

	}

	// clearcoat
	float clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {

		float ior = 1.5;
		float f0 = iorRatioToF0( ior );
		bool frontFace = surf.frontFace;
		float roughness = surf.filteredClearcoatRoughness;

		float eta = frontFace ? 1.0 / ior : ior;
		float G = ggxShadowMaskG2( wi, wo, roughness );
		float D = ggxDistribution( wh, roughness );
		float F = schlickFresnel( dot( wi, wh ), f0 );

		float fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );
		color = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;

		// PDF
		// See equation (27) in http://jcgt.org/published/0003/02/03/
		return ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );

	}

	vec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {

		// sample ggx vndf distribution which gives a new normal
		float roughness = surf.filteredClearcoatRoughness;
		vec3 halfVector = ggxDirection(
			wo,
			vec2( roughness ),
			sobol2( 14 )
		);

		// apply to new ray by reflecting off the new normal
		return - reflect( wo, halfVector );

	}

	// sheen
	vec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {

		float cosThetaO = saturateCos( wo.z );
		float cosThetaI = saturateCos( wi.z );
		float cosThetaH = wh.z;

		float D = velvetD( cosThetaH, surf.sheenRoughness );
		float G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );

		// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
		vec3 color = surf.sheenColor;
		color *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );
		color *= wi.z;

		return color;

	}

	// bsdf
	void getLobeWeights(
		vec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,
		out float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight
	) {

		float metalness = surf.metalness;
		float transmission = surf.transmission;
		float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );

		float transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );
		float diffSpecularProb = 0.5 + 0.5 * metalness;

		diffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );
		specularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;
		transmissionWeight = transmission * ( 1.0 - transSpecularProb );
		clearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );

		float totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;
		diffuseWeight /= totalWeight;
		specularWeight /= totalWeight;
		transmissionWeight /= totalWeight;
		clearcoatWeight /= totalWeight;
	}

	float bsdfEval(
		vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,
		float diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, out float specularPdf, out vec3 color
	) {

		float metalness = surf.metalness;
		float transmission = surf.transmission;

		float spdf = 0.0;
		float dpdf = 0.0;
		float tpdf = 0.0;
		float cpdf = 0.0;
		color = vec3( 0.0 );

		vec3 halfVector = getHalfVector( wi, wo, surf.eta );

		// diffuse
		if ( diffuseWeight > 0.0 && wi.z > 0.0 ) {

			dpdf = diffuseEval( wo, wi, halfVector, surf, color );
			color *= 1.0 - surf.transmission;

		}

		// ggx specular
		if ( specularWeight > 0.0 && wi.z > 0.0 ) {

			vec3 outColor;
			spdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );
			color += outColor;

		}

		// transmission
		if ( transmissionWeight > 0.0 && wi.z < 0.0 ) {

			tpdf = transmissionEval( wo, wi, halfVector, surf, color );

		}

		// sheen
		color *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );
		color += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;

		// clearcoat
		if ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {

			vec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );
			cpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );

		}

		float pdf =
			dpdf * diffuseWeight
			+ spdf * specularWeight
			+ tpdf * transmissionWeight
			+ cpdf * clearcoatWeight;

		// retrieve specular rays for the shadows flag
		specularPdf = spdf * specularWeight + cpdf * clearcoatWeight;

		return pdf;

	}

	float bsdfResult( vec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf, out vec3 color ) {

		if ( surf.volumeParticle ) {

			color = surf.color / ( 4.0 * PI );
			return 1.0 / ( 4.0 * PI );

		}

		vec3 wh = getHalfVector( wo, wi, surf.eta );
		float diffuseWeight;
		float specularWeight;
		float transmissionWeight;
		float clearcoatWeight;
		getLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );

		float specularPdf;
		return bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );

	}

	ScatterRecord bsdfSample( vec3 wo, vec3 clearcoatWo, mat3 normalBasis, mat3 invBasis, mat3 clearcoatNormalBasis, mat3 clearcoatInvBasis, SurfaceRecord surf ) {

		if ( surf.volumeParticle ) {

			vec3 wi = sampleSphere( sobol2( 16 ) );
			vec3 wh = normalize( wo + wi );

			ScatterRecord sampleRec;
			sampleRec.specularPdf = 0.0;
			sampleRec.pdf = 1.0 / ( 4.0 * PI );
			sampleRec.direction = wi;
			sampleRec.clearcoatDirection = wi;
			sampleRec.color = surf.color / ( 4.0 * PI );
			return sampleRec;

		}

		float diffuseWeight;
		float specularWeight;
		float transmissionWeight;
		float clearcoatWeight;
		// using normal and basically-reflected ray since we don't have proper half vector here
		getLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );

		float pdf[4];
		pdf[0] = diffuseWeight;
		pdf[1] = specularWeight;
		pdf[2] = transmissionWeight;
		pdf[3] = clearcoatWeight;

		float cdf[4];
		cdf[0] = pdf[0];
		cdf[1] = pdf[1] + cdf[0];
		cdf[2] = pdf[2] + cdf[1];
		cdf[3] = pdf[3] + cdf[2];

		if( cdf[3] != 0.0 ) {

			float invMaxCdf = 1.0 / cdf[3];
			cdf[0] *= invMaxCdf;
			cdf[1] *= invMaxCdf;
			cdf[2] *= invMaxCdf;
			cdf[3] *= invMaxCdf;

		} else {

			cdf[0] = 1.0;
			cdf[1] = 0.0;
			cdf[2] = 0.0;
			cdf[3] = 0.0;

		}

		vec3 wi;
		vec3 clearcoatWi;

		float r = sobol( 15 );
		if ( r <= cdf[0] ) { // diffuse

			wi = diffuseDirection( wo, surf );
			clearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );

		} else if ( r <= cdf[1] ) { // specular

			wi = specularDirection( wo, surf );
			clearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );

		} else if ( r <= cdf[2] ) { // transmission / refraction

			wi = transmissionDirection( wo, surf );
			clearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );

		} else if ( r <= cdf[3] ) { // clearcoat

			clearcoatWi = clearcoatDirection( clearcoatWo, surf );
			wi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );

		}

		ScatterRecord result;
		result.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );
		result.direction = wi;
		result.clearcoatDirection = clearcoatWi;

		return result;

	}

`,wW=`

	// returns the hit distance given the material density
	float intersectFogVolume( Material material, float u ) {

		// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums
		return material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );

	}

	ScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {

		ScatterRecord sampleRec;
		sampleRec.specularPdf = 0.0;
		sampleRec.pdf = 1.0 / ( 2.0 * PI );
		sampleRec.direction = sampleSphere( uv );
		sampleRec.clearcoatDirection = sampleRec.direction;
		sampleRec.color = surf.color;
		return sampleRec;

	}

`,AW=`

	// samples the the given environment map in the given direction
	vec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {

		return texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;

	}

	// gets the pdf of the given direction to sample
	float equirectDirectionPdf( vec3 direction ) {

		vec2 uv = equirectDirectionToUv( direction );
		float theta = uv.y * PI;
		float sinTheta = sin( theta );
		if ( sinTheta == 0.0 ) {

			return 0.0;

		}

		return 1.0 / ( 2.0 * PI * PI * sinTheta );

	}

	// samples the color given env map with CDF and returns the pdf of the direction
	float sampleEquirect( EquirectHdrInfo info, vec3 direction, out vec3 color ) {

		vec2 uv = equirectDirectionToUv( direction );
		color = texture2D( info.map, uv ).rgb;

		float totalSum = info.totalSumWhole + info.totalSumDecimal;
		float lum = luminance( color );
		ivec2 resolution = textureSize( info.map, 0 );
		float pdf = lum / totalSum;

		return float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );

	}

	// samples a direction of the envmap with color and retrieves pdf
	float sampleEquirectProbability( EquirectHdrInfo info, vec2 r, out vec3 color, out vec3 direction ) {

		// sample env map cdf
		float v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;
		float u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;
		vec2 uv = vec2( u, v );

		vec3 derivedDirection = equirectUvToDirection( uv );
		direction = derivedDirection;
		color = texture2D( info.map, uv ).rgb;

		float totalSum = info.totalSumWhole + info.totalSumDecimal;
		float lum = luminance( color );
		ivec2 resolution = textureSize( info.map, 0 );
		float pdf = lum / totalSum;

		return float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );

	}

`,MW=`

	float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

		return smoothstep( coneCosine, penumbraCosine, angleCosine );

	}

	float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );

		if ( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	}

	float getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {

		float cosTheta = dot( posToLight, lightDir );
		float angle = acos( cosTheta ) * ( 1.0 / PI );

		return texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;

	}

	struct LightSampleRecord {

		float dist;
		vec3 direction;
		float pdf;
		vec3 emission;
		int type;

	};

	bool lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection, out LightSampleRecord lightSampleRec ) {

		bool didHit = false;
		uint l;
		for ( l = 0u; l < lightCount; l ++ ) {

			Light light = readLightInfo( lights, l );

			vec3 u = light.u;
			vec3 v = light.v;

			// check for backface
			vec3 normal = normalize( cross( u, v ) );
			if ( dot( normal, rayDirection ) < 0.0 ) {

				continue;

			}

			u *= 1.0 / dot( u, u );
			v *= 1.0 / dot( v, v );

			float dist;

			// MIS / light intersection is not supported for punctual lights.
			if(
				( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||
				( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )
			) {

				if ( ! didHit || dist < lightSampleRec.dist ) {

					float cosTheta = dot( rayDirection, normal );
					didHit = true;
					lightSampleRec.dist = dist;
					lightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );
					lightSampleRec.emission = light.color * light.intensity;
					lightSampleRec.direction = rayDirection;
					lightSampleRec.type = light.type;

				}

			}

		}

		return didHit;

	}

	LightSampleRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {

		LightSampleRecord lightSampleRec;
		lightSampleRec.type = light.type;

		lightSampleRec.emission = light.color * light.intensity;

		vec3 randomPos;
		if( light.type == RECT_AREA_LIGHT_TYPE ) {

			// rectangular area light
			randomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );

		} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {

			// circular area light
			float r = 0.5 * sqrt( ruv.x );
			float theta = ruv.y * 2.0 * PI;
			float x = r * cos( theta );
			float y = r * sin( theta );

			randomPos = light.position + light.u * x + light.v * y;

		}

		vec3 toLight = randomPos - rayOrigin;
		float lightDistSq = dot( toLight, toLight );
		lightSampleRec.dist = sqrt( lightDistSq );

		vec3 direction = toLight / lightSampleRec.dist;
		lightSampleRec.direction = direction;

		vec3 lightNormal = normalize( cross( light.u, light.v ) );
		lightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );

		return lightSampleRec;

	}

	LightSampleRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {

		float radius = light.radius * sqrt( ruv.x );
		float theta = ruv.y * 2.0 * PI;
		float x = radius * cos( theta );
		float y = radius * sin( theta );

		vec3 u = light.u;
		vec3 v = light.v;
		vec3 normal = normalize( cross( u, v ) );

		float angle = acos( light.coneCos );
		float angleTan = tan( angle );
		float startDistance = light.radius / max( angleTan, EPSILON );

		vec3 randomPos = light.position - normal * startDistance + u * x + v * y;
		vec3 toLight = randomPos - rayOrigin;
		float lightDistSq = dot( toLight, toLight );
		float dist = sqrt( lightDistSq );

		vec3 direction = toLight / max( dist, EPSILON );
		float cosTheta = dot( direction, normal );

		float spotAttenuation = light.iesProfile != - 1 ?
			getPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :
			getSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );

		float distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );
		LightSampleRecord lightSampleRec;
		lightSampleRec.type = light.type;
		lightSampleRec.dist = dist;
		lightSampleRec.direction = direction;
		lightSampleRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;
		lightSampleRec.pdf = 1.0;

		return lightSampleRec;

	}

	LightSampleRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {

		// pick a random light
		uint l = uint( ruv.x * float( lightCount ) );
		Light light = readLightInfo( lights, l );

		if ( light.type == SPOT_LIGHT_TYPE ) {

			return randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );

		} else if ( light.type == POINT_LIGHT_TYPE ) {

			vec3 lightRay = light.u - rayOrigin;
			float lightDist = length( lightRay );
			float cutoffDistance = light.distance;
			float distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );
			if ( cutoffDistance > 0.0 ) {

				distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );

			}

			LightSampleRecord rec;
			rec.direction = normalize( lightRay );
			rec.dist = length( lightRay );
			rec.pdf = 1.0;
			rec.emission = light.color * light.intensity * distanceFalloff;
			rec.type = light.type;
			return rec;

		} else if ( light.type == DIR_LIGHT_TYPE ) {

			LightSampleRecord rec;
			rec.dist = 1e10;
			rec.direction = light.u;
			rec.pdf = 1.0;
			rec.emission = light.color * light.intensity;
			rec.type = light.type;

			return rec;

		} else {

			// sample the light
			return randomAreaLightSample( light, rayOrigin, ruv.yz );

		}

	}

`,SW=`

	vec3 sampleHemisphere( vec3 n, vec2 uv ) {

		// https://www.rorydriscoll.com/2009/01/07/better-sampling/
		// https://graphics.pixar.com/library/OrthonormalB/paper.pdf
		float sign = n.z == 0.0 ? 1.0 : sign( n.z );
		float a = - 1.0 / ( sign + n.z );
		float b = n.x * n.y * a;
		vec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );
		vec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );

		float r = sqrt( uv.x );
		float theta = 2.0 * PI * uv.y;
		float x = r * cos( theta );
		float y = r * sin( theta );
		return x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;

	}

	vec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {

		// get the edges of the triangle and the diagonal across the
		// center of the parallelogram
		vec2 e1 = a - b;
		vec2 e2 = c - b;
		vec2 diag = normalize( e1 + e2 );

		// pick the point in the parallelogram
		if ( r.x + r.y > 1.0 ) {

			r = vec2( 1.0 ) - r;

		}

		return e1 * r.x + e2 * r.y;

	}

	vec2 sampleCircle( vec2 uv ) {

		float angle = 2.0 * PI * uv.x;
		float radius = sqrt( uv.y );
		return vec2( cos( angle ), sin( angle ) ) * radius;

	}

	vec3 sampleSphere( vec2 uv ) {

		float u = ( uv.x - 0.5 ) * 2.0;
		float t = uv.y * PI * 2.0;
		float f = sqrt( 1.0 - u * u );

		return vec3( f * cos( t ), f * sin( t ), u );

	}

	vec2 sampleRegularPolygon( int sides, vec3 uvw ) {

		sides = max( sides, 3 );

		vec3 r = uvw;
		float anglePerSegment = 2.0 * PI / float( sides );
		float segment = floor( float( sides ) * r.x );

		float angle1 = anglePerSegment * segment;
		float angle2 = angle1 + anglePerSegment;
		vec2 a = vec2( sin( angle1 ), cos( angle1 ) );
		vec2 b = vec2( 0.0, 0.0 );
		vec2 c = vec2( sin( angle2 ), cos( angle2 ) );

		return sampleTriangle( a, b, c, r.yz );

	}

	// samples an aperture shape with the given number of sides. 0 means circle
	vec2 sampleAperture( int blades, vec3 uvw ) {

		return blades == 0 ?
			sampleCircle( uvw.xy ) :
			sampleRegularPolygon( blades, uvw );

	}


`,TW=`

	// Finds the point where the ray intersects the plane defined by u and v and checks if this point
	// falls in the bounds of the rectangle on that same plane.
	// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/
	bool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {

		float t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );

		if ( t > EPSILON ) {

			vec3 p = rayOrigin + rayDirection * t;
			vec3 vi = p - center;

			// check if p falls inside the rectangle
			float a1 = dot( u, vi );
			if ( abs( a1 ) <= 0.5 ) {

				float a2 = dot( v, vi );
				if ( abs( a2 ) <= 0.5 ) {

					dist = t;
					return true;

				}

			}

		}

		return false;

	}

	// Finds the point where the ray intersects the plane defined by u and v and checks if this point
	// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.
	bool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {

		float t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );

		if ( t > EPSILON ) {

			vec3 hit = rayOrigin + rayDirection * t;
			vec3 vi = hit - position;

			float a1 = dot( u, vi );
			float a2 = dot( v, vi );

			if( length( vec2( a1, a2 ) ) <= 0.5 ) {

				dist = t;
				return true;

			}

		}

		return false;

	}

`,CW=`

	// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.
	// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].
	// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248
	float acosApprox( float x ) {

		x = clamp( x, -1.0, 1.0 );
		return ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;

	}

	// An acos with input values bound to the range [-1, 1].
	float acosSafe( float x ) {

		return acos( clamp( x, -1.0, 1.0 ) );

	}

	float saturateCos( float val ) {

		return clamp( val, 0.001, 1.0 );

	}

	float square( float t ) {

		return t * t;

	}

	vec2 square( vec2 t ) {

		return t * t;

	}

	vec3 square( vec3 t ) {

		return t * t;

	}

	vec4 square( vec4 t ) {

		return t * t;

	}

	vec2 rotateVector( vec2 v, float t ) {

		float ac = cos( t );
		float as = sin( t );
		return vec2(
			v.x * ac - v.y * as,
			v.x * as + v.y * ac
		);

	}

	// forms a basis with the normal vector as Z
	mat3 getBasisFromNormal( vec3 normal ) {

		vec3 other;
		if ( abs( normal.x ) > 0.5 ) {

			other = vec3( 0.0, 1.0, 0.0 );

		} else {

			other = vec3( 1.0, 0.0, 0.0 );

		}

		vec3 ortho = normalize( cross( normal, other ) );
		vec3 ortho2 = normalize( cross( normal, ortho ) );
		return mat3( ortho2, ortho, normal );

	}

`,EW=`

	bool totalInternalReflection( float cosTheta, float eta ) {

		float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );
		return eta * sinTheta > 1.0;

	}

	// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf
	float schlickFresnel( float cosine, float f0 ) {

		return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );

	}

	vec3 schlickFresnel( float cosine, vec3 f0 ) {

		return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );

	}

	vec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {

		return f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );

	}

	float dielectricFresnel( float cosThetaI, float eta ) {

		// https://schuttejoe.github.io/post/disneybsdf/
		float ni = eta;
		float nt = 1.0;

		// Check for total internal reflection
		float sinThetaISq = 1.0f - cosThetaI * cosThetaI;
		float sinThetaTSq = eta * eta * sinThetaISq;
		if( sinThetaTSq >= 1.0 ) {

			return 1.0;

		}

		float sinThetaT = sqrt( sinThetaTSq );

		float cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );
		float rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );
		float rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );
		return ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;

	}

	// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation
	float iorRatioToF0( float eta ) {

		return pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );

	}

	vec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {

		if ( totalInternalReflection( cosTheta, eta ) ) {

			return f90;

		}

		return schlickFresnel( cosTheta, f0, f90 );

	}

	float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {

		if ( totalInternalReflection( cosTheta, eta ) ) {

			return 1.0;

		}

		return schlickFresnel( cosTheta, f0 );

	}

	/*
	// https://schuttejoe.github.io/post/disneybsdf/
	float disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {

		float dotHV = dot( wo, wh );
		float dotHL = dot( wi, wh );

		float dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );
		float metallicFresnel = schlickFresnel( dotHL, f0 );

		return mix( dielectricFresnel, metallicFresnel, metalness );

	}
	*/
`,PW=`

	// add texel fetch functions for texture arrays
	vec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {

		uint width = uint( textureSize( tex, 0 ).x );
		uvec2 uv;
		uv.x = index % width;
		uv.y = index / width;

		return texelFetch( tex, ivec3( uv, layer ), 0 );

	}

	vec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {

		return
			barycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +
			barycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +
			barycoord.z * texelFetch1D( tex, layer, faceIndices.z );

	}

`,RW=`

	// https://www.shadertoy.com/view/wltcRS
	uvec4 WHITE_NOISE_SEED;

	void rng_initialize( vec2 p, int frame ) {

		// white noise seed
		WHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );

	}

	// https://www.pcg-random.org/
	void pcg4d( inout uvec4 v ) {

		v = v * 1664525u + 1013904223u;
		v.x += v.y * v.w;
		v.y += v.z * v.x;
		v.z += v.x * v.y;
		v.w += v.y * v.z;
		v = v ^ ( v >> 16u );
		v.x += v.y*v.w;
		v.y += v.z*v.x;
		v.z += v.x*v.y;
		v.w += v.y*v.z;

	}

	// returns [ 0, 1 ]
	float rand() {

		pcg4d( WHITE_NOISE_SEED );
		return float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );

	}

	vec2 rand2() {

		pcg4d( WHITE_NOISE_SEED );
		return vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);

	}

	vec3 rand3() {

		pcg4d( WHITE_NOISE_SEED );
		return vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );

	}

	vec4 rand4() {

		pcg4d( WHITE_NOISE_SEED );
		return vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );

	}
`,IW=`

	vec3 ndcToRayOrigin( vec2 coord ) {

		vec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );
		return rayOrigin4.xyz / rayOrigin4.w;
	}

	void getCameraRay( out vec3 rayDirection, out vec3 rayOrigin ) {

		vec2 ssd = vec2( 1.0 ) / resolution;

		// Jitter the camera ray by finding a uv coordinate at a random sample
		// around this pixel's UV coordinate for AA
		vec2 ruv = sobol2( 0 );
		vec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );

		#if CAMERA_TYPE == 2

			// Equirectangular projection
			vec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );
			vec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );

			rayDirection4 = cameraWorldMatrix * rayDirection4;
			rayOrigin4 = cameraWorldMatrix * rayOrigin4;

			rayDirection = normalize( rayDirection4.xyz );
			rayOrigin = rayOrigin4.xyz / rayOrigin4.w;

		#else

			// get [- 1, 1] normalized device coordinates
			vec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );
			rayOrigin = ndcToRayOrigin( ndc );

			#if CAMERA_TYPE == 1

				// Orthographic projection
				rayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;
				rayDirection = normalize( rayDirection );

			#else

				// Perspective projection
				rayDirection = normalize( mat3(cameraWorldMatrix) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );

			#endif

		#endif

		#if FEATURE_DOF
		{

			// depth of field
			vec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;

			// get the aperture sample
			// if blades === 0 then we assume a circle
			vec3 shapeUVW= sobol3( 1 );
			int blades = physicalCamera.apertureBlades;
			float anamorphicRatio = physicalCamera.anamorphicRatio;
			vec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );
			apertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;

			// rotate the aperture shape
			apertureSample =
				rotateVector( apertureSample, physicalCamera.apertureRotation ) *
				saturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );

			// create the new ray
			rayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;
			rayDirection = focalPoint - rayOrigin;

		}
		#endif

		rayDirection = normalize( rayDirection );

	}

`,DW=`

	// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces
	// returns true if a solid surface was hit
	bool attenuateHit(
		BVH bvh, vec3 rayOrigin, vec3 rayDirection, float rayDist,
		int traversals, int transmissiveTraversals, bool isShadowRay,
		Material fogMaterial,
		out vec3 color
	) {

		vec3 ogRayOrigin = rayOrigin;

		// hit results
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		LightSampleRecord lightSampleRec;

		color = vec3( 1.0 );

		// TODO: we should be using sobol sampling here instead of rand but the sobol bounce and path indices need to be incremented
		// and then reset.
		for ( int i = 0; i < traversals; i ++ ) {

			int hitType = traceScene(
				rayOrigin, rayDirection,
				bvh, lights, fogMaterial,
				faceIndices, faceNormal, barycoord, side, dist,
				lightSampleRec
			);

			if ( hitType == FOG_HIT ) {

				return true;

			} else if ( hitType == LIGHT_HIT ) {

				float totalDist = distance( ogRayOrigin, rayOrigin + rayDirection * lightSampleRec.dist );
				return totalDist < rayDist - max( totalDist, rayDist ) * 1e-4;

			} else if ( hitType == SURFACE_HIT ) {

				float totalDist = distance( ogRayOrigin, rayOrigin + rayDirection * dist );
				if ( totalDist > rayDist ) {

					return false;

				}

				// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values
				// Should be able to work using the material BSDF functions which will take into account specularity, etc.
				// TODO: should we account for emissive surfaces here?

				uint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;
				Material material = readMaterialInfo( materials, materialIndex );

				// adjust the ray to the new surface
				bool isEntering = side == 1.0;
				rayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );

				#if FEATURE_FOG

				if ( material.fogVolume ) {

					fogMaterial = material;
					fogMaterial.fogVolume = side == 1.0;
					i -= sign( transmissiveTraversals );
					transmissiveTraversals --;
					continue;

				}

				#endif

				if ( ! material.castShadow && isShadowRay ) {

					continue;

				}

				vec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;
				vec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );

				// albedo
				vec4 albedo = vec4( material.color, material.opacity );
				if ( material.map != - 1 ) {

					vec3 uvPrime = material.mapTransform * vec3( uv, 1 );
					albedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );

				}

				if ( material.vertexColors ) {

					albedo *= vertexColor;

				}

				// alphaMap
				if ( material.alphaMap != - 1 ) {

					albedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;

				}

				// transmission
				float transmission = material.transmission;
				if ( material.transmissionMap != - 1 ) {

					vec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );
					transmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;

				}

				// metalness
				float metalness = material.metalness;
				if ( material.metalnessMap != - 1 ) {

					vec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );
					metalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;

				}

				float alphaTest = material.alphaTest;
				bool useAlphaTest = alphaTest != 0.0;
				float transmissionFactor = ( 1.0 - metalness ) * transmission;
				if (
					transmissionFactor < rand() && ! (
						// material sidedness
						material.side != 0.0 && side == material.side

						// alpha test
						|| useAlphaTest && albedo.a < alphaTest

						// opacity
						|| material.transparent && ! useAlphaTest && albedo.a < rand()
					)
				) {

					return true;

				}

				if ( side == 1.0 && isEntering ) {

					// only attenuate by surface color on the way in
					color *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );

				} else if ( side == - 1.0 ) {

					// attenuate by medium once we hit the opposite side of the model
					color *= transmissionAttenuation( dist, material.attenuationColor, material.attenuationDistance );

				}

				bool isTransmissiveRay = dot( rayDirection, faceNormal * side ) < 0.0;
				if ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {

					i -= sign( transmissiveTraversals );
					transmissiveTraversals --;

				}

			} else {

				return false;

			}

		}

		return true;

	}

`,LW=`

	#define NO_HIT 0
	#define SURFACE_HIT 1
	#define LIGHT_HIT 2
	#define FOG_HIT 3

	int traceScene(

		vec3 rayOrigin, vec3 rayDirection,
		BVH bvh, LightsInfo lights, Material fogMaterial,
		out uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord, out float side, out float dist,
		out LightSampleRecord lightSampleRec

	) {

		bool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		bool lightHit = lightsClosestHit( lights.tex, lights.count, rayOrigin, rayDirection, lightSampleRec );

		#if FEATURE_FOG

		if ( fogMaterial.fogVolume ) {

			float particleDist = intersectFogVolume( fogMaterial, sobol( 1 ) );
			if ( particleDist + 1e-4 < dist && ( particleDist + 1e-4 < lightSampleRec.dist || ! lightHit ) ) {

				side = 1.0;
				faceNormal = normalize( - rayDirection );
				dist = particleDist;
				return FOG_HIT;

			}

		}

		#endif

		if ( lightHit && ( lightSampleRec.dist < dist || ! hit ) ) {

			return LIGHT_HIT;

		}

		if ( hit ) {

			return SURFACE_HIT;

		}

		return NO_HIT;

	}

`,OW=`

	#define SKIP_SURFACE 0
	#define HIT_SURFACE 1
	int getSurfaceRecord(
		Material material, sampler2DArray attributesArray,
		float side, vec3 barycoord, uvec4 faceIndices, vec3 faceNormal, float accumulatedRoughness,

		out SurfaceRecord surf
	) {

		if ( material.fogVolume ) {

			vec3 normal = vec3( 0, 0, 1 );

			SurfaceRecord fogSurface;
			fogSurface.volumeParticle = true;
			fogSurface.color = material.color;
			fogSurface.emission = material.emissiveIntensity * material.emissive;
			fogSurface.normal = normal;
			fogSurface.faceNormal = normal;
			fogSurface.clearcoatNormal = normal;

			surf = fogSurface;
			return HIT_SURFACE;

		}

		// uv coord for textures
		vec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, barycoord, faceIndices.xyz ).xy;
		vec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, barycoord, faceIndices.xyz );

		// albedo
		vec4 albedo = vec4( material.color, material.opacity );
		if ( material.map != - 1 ) {

			vec3 uvPrime = material.mapTransform * vec3( uv, 1 );
			albedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );
		}

		if ( material.vertexColors ) {

			albedo *= vertexColor;

		}

		// alphaMap
		if ( material.alphaMap != - 1 ) {

			albedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;

		}

		// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side
		// and it's single sided.
		// - alpha test is disabled when it === 0
		// - the material sidedness test is complicated because we want light to pass through the back side but still
		// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray
		// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.
		float alphaTest = material.alphaTest;
		bool useAlphaTest = alphaTest != 0.0;
		if (
			// material sidedness
			material.side != 0.0 && side != material.side

			// alpha test
			|| useAlphaTest && albedo.a < alphaTest

			// opacity
			|| material.transparent && ! useAlphaTest && albedo.a < sobol( 3 )
		) {

			return SKIP_SURFACE;

		}

		// fetch the interpolated smooth normal
		vec3 normal = normalize( textureSampleBarycoord(
			attributesArray,
			ATTR_NORMAL,
			barycoord,
			faceIndices.xyz
		).xyz );

		// roughness
		float roughness = material.roughness;
		if ( material.roughnessMap != - 1 ) {

			vec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );
			roughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;

		}

		// metalness
		float metalness = material.metalness;
		if ( material.metalnessMap != - 1 ) {

			vec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );
			metalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;

		}

		// emission
		vec3 emission = material.emissiveIntensity * material.emissive;
		if ( material.emissiveMap != - 1 ) {

			vec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );
			emission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;

		}

		// transmission
		float transmission = material.transmission;
		if ( material.transmissionMap != - 1 ) {

			vec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );
			transmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;

		}

		// normal
		if ( material.flatShading ) {

			// if we're rendering a flat shaded object then use the face normals - the face normal
			// is provided based on the side the ray hits the mesh so flip it to align with the
			// interpolated vertex normals.
			normal = faceNormal * side;

		}

		vec3 baseNormal = normal;
		if ( material.normalMap != - 1 ) {

			vec4 tangentSample = textureSampleBarycoord(
				attributesArray,
				ATTR_TANGENT,
				barycoord,
				faceIndices.xyz
			);

			// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate
			// resulting in NaNs and slow path tracing.
			if ( length( tangentSample.xyz ) > 0.0 ) {

				vec3 tangent = normalize( tangentSample.xyz );
				vec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );
				mat3 vTBN = mat3( tangent, bitangent, normal );

				vec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );
				vec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;
				texNormal.xy *= material.normalScale;
				normal = vTBN * texNormal;

			}

		}

		normal *= side;

		// clearcoat
		float clearcoat = material.clearcoat;
		if ( material.clearcoatMap != - 1 ) {

			vec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );
			clearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;

		}

		// clearcoatRoughness
		float clearcoatRoughness = material.clearcoatRoughness;
		if ( material.clearcoatRoughnessMap != - 1 ) {

			vec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );
			clearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;

		}

		// clearcoatNormal
		vec3 clearcoatNormal = baseNormal;
		if ( material.clearcoatNormalMap != - 1 ) {

			vec4 tangentSample = textureSampleBarycoord(
				attributesArray,
				ATTR_TANGENT,
				barycoord,
				faceIndices.xyz
			);

			// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate
			// resulting in NaNs and slow path tracing.
			if ( length( tangentSample.xyz ) > 0.0 ) {

				vec3 tangent = normalize( tangentSample.xyz );
				vec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );
				mat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );

				vec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );
				vec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;
				texNormal.xy *= material.clearcoatNormalScale;
				clearcoatNormal = vTBN * texNormal;

			}

		}

		clearcoatNormal *= side;

		// sheenColor
		vec3 sheenColor = material.sheenColor;
		if ( material.sheenColorMap != - 1 ) {

			vec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );
			sheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;

		}

		// sheenRoughness
		float sheenRoughness = material.sheenRoughness;
		if ( material.sheenRoughnessMap != - 1 ) {

			vec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );
			sheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;

		}

		// iridescence
		float iridescence = material.iridescence;
		if ( material.iridescenceMap != - 1 ) {

			vec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );
			iridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;

		}

		// iridescence thickness
		float iridescenceThickness = material.iridescenceThicknessMaximum;
		if ( material.iridescenceThicknessMap != - 1 ) {

			vec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );
			float iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;
			iridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );

		}

		iridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;

		// specular color
		vec3 specularColor = material.specularColor;
		if ( material.specularColorMap != - 1 ) {

			vec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );
			specularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;

		}

		// specular intensity
		float specularIntensity = material.specularIntensity;
		if ( material.specularIntensityMap != - 1 ) {

			vec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );
			specularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;

		}

		surf.volumeParticle = false;

		surf.faceNormal = faceNormal;
		surf.normal = normal;

		surf.metalness = metalness;
		surf.color = albedo.rgb;
		surf.emission = emission;

		surf.ior = material.ior;
		surf.transmission = transmission;
		surf.thinFilm = material.thinFilm;
		surf.attenuationColor = material.attenuationColor;
		surf.attenuationDistance = material.attenuationDistance;

		surf.clearcoatNormal = clearcoatNormal;
		surf.clearcoat = clearcoat;

		surf.sheen = material.sheen;
		surf.sheenColor = sheenColor;

		surf.iridescence = iridescence;
		surf.iridescenceIor = material.iridescenceIor;
		surf.iridescenceThickness = iridescenceThickness;

		surf.specularColor = specularColor;
		surf.specularIntensity = specularIntensity;

		// apply perceptual roughness factor from gltf. sheen perceptual roughness is
		// applied by its brdf function
		// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces
		surf.roughness = roughness * roughness;
		surf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;
		surf.sheenRoughness = sheenRoughness;

		// frontFace is used to determine transmissive properties and PDF. If no transmission is used
		// then we can just always assume this is a front face.
		surf.frontFace = side == 1.0 || transmission == 0.0;
		surf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;
		surf.f0 = iorRatioToF0( surf.eta );

		// Compute the filtered roughness value to use during specular reflection computations.
		// The accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.
		// If we're exiting something transmissive then scale the factor down significantly so we can retain
		// sharp internal reflections
		surf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );
		surf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );

		return HIT_SURFACE;

	}
`;class AD extends H1{onBeforeRender(){this.setDefine("FEATURE_DOF",this.physicalCamera.bokehSize===0?0:1),this.setDefine("FEATURE_BACKGROUND_MAP",this.backgroundMap?1:0),this.setDefine("FEATURE_FOG",this.materials.features.isUsed("FOG")?1:0)}constructor(e){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_RUSSIAN_ROULETTE:1,FEATURE_DOF:1,FEATURE_BACKGROUND_MAP:0,FEATURE_FOG:1,CAMERA_TYPE:0,ATTR_NORMAL:0,ATTR_TANGENT:1,ATTR_UV:2,ATTR_COLOR:3},uniforms:{resolution:{value:new Ie},bounces:{value:10},transmissiveBounces:{value:10},physicalCamera:{value:new vD},bvh:{value:new oD},attributesArray:{value:new wD},materialIndexAttribute:{value:new tw},materials:{value:new pD},textures:{value:new mD().texture},lights:{value:new yD},iesProfiles:{value:new xD().texture},cameraWorldMatrix:{value:new me},invProjectionMatrix:{value:new me},backgroundBlur:{value:0},environmentIntensity:{value:1},environmentRotation:{value:new me},envMapInfo:{value:new gD},backgroundMap:{value:null},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},backgroundAlpha:{value:1},sobolTexture:{value:null}},vertexShader:`

				varying vec2 vUv;
				void main() {

					vec4 mvPosition = vec4( position, 1.0 );
					mvPosition = modelViewMatrix * mvPosition;
					gl_Position = projectionMatrix * mvPosition;

					vUv = uv;

				}

			`,fragmentShader:`
				#define RAY_OFFSET 1e-4
				#define INFINITY 1e20

				precision highp isampler2D;
				precision highp usampler2D;
				precision highp sampler2DArray;
				vec4 envMapTexelToLinear( vec4 a ) { return a; }
				#include <common>

				// bvh intersection
				${KG}
				${QG}

				// random
				${RW}
				${JI}
				${xG}

				// common
				${PW}
				${EW}
				${fW}
				${CW}
				${TW}

				// uniform structs
				${dW}
				${mW}
				${pW}
				${gW}
				${vW}

				// sampling
				${SW}
				${_W}
				${AW}
				${MW}
				${wW}

				// environment
				uniform EquirectHdrInfo envMapInfo;
				uniform mat4 environmentRotation;
				uniform float environmentIntensity;

				// lighting
				uniform sampler2DArray iesProfiles;
				uniform LightsInfo lights;

				// background
				uniform float backgroundBlur;
				uniform float backgroundAlpha;
				#if FEATURE_BACKGROUND_MAP

				uniform sampler2D backgroundMap;

				#endif

				// camera
				uniform mat4 cameraWorldMatrix;
				uniform mat4 invProjectionMatrix;
				#if FEATURE_DOF

				uniform PhysicalCamera physicalCamera;

				#endif

				// geometry
				uniform sampler2DArray attributesArray;
				uniform usampler2D materialIndexAttribute;
				uniform sampler2D materials;
				uniform sampler2DArray textures;
				uniform BVH bvh;

				// path tracer
				uniform int bounces;
				uniform int transmissiveBounces;
				uniform float filterGlossyFactor;
				uniform int seed;

				// image
				uniform vec2 resolution;
				uniform float opacity;

				varying vec2 vUv;

				${IW}
				${LW}
				${DW}

				float applyFilteredGlossy( float roughness, float accumulatedRoughness ) {

					return clamp(
						max(
							roughness,
							accumulatedRoughness * filterGlossyFactor * 5.0 ),
						0.0,
						1.0
					);

				}

				vec3 sampleBackground( vec3 direction, vec2 uv ) {

					vec3 sampleDir = normalize( direction + sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur );

					#if FEATURE_BACKGROUND_MAP

					return sampleEquirectColor( backgroundMap, sampleDir );

					#else

					return environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );

					#endif

				}

				${OW}

				void main() {

					// init
					rng_initialize( gl_FragCoord.xy, seed );
					sobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) |  uint( gl_FragCoord.y );
					sobolPathIndex = uint( seed );

					// get camera ray
					vec3 rayDirection, rayOrigin;
					getCameraRay( rayDirection, rayOrigin );

					// inverse environment rotation
					mat3 envRotation3x3 = mat3( environmentRotation );
					mat3 invEnvRotation3x3 = inverse( envRotation3x3 );
					float lightsDenom = environmentIntensity == 0.0 && lights.count != 0u ? float( lights.count ) : float( lights.count + 1u );

					// final color
					gl_FragColor = vec4( 0.0 );
					gl_FragColor.a = 1.0;

					// hit results
					uvec4 faceIndices = uvec4( 0u );
					vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
					vec3 barycoord = vec3( 0.0 );
					float side = 1.0;
					float dist = 0.0;

					// path tracing state
					float accumulatedRoughness = 0.0;
					bool transmissiveRay = true;
					bool isShadowRay = false;
					int transmissiveTraversals = transmissiveBounces;
					vec3 throughputColor = vec3( 1.0 );
					ScatterRecord sampleRec;
					int i;

					Material fogMaterial;
					#if FEATURE_FOG

					fogMaterial.fogVolume = bvhIntersectFogVolumeHit(
						bvh, rayOrigin, - rayDirection,
						materialIndexAttribute, materials,
						fogMaterial
					);

					#endif

					for ( i = 0; i < bounces; i ++ ) {

						sobolBounceIndex ++;

						bool firstRay = i == 0 && transmissiveTraversals == transmissiveBounces;

						LightSampleRecord lightSampleRec;
						int hitType = traceScene(
							rayOrigin, rayDirection,
							bvh, lights, fogMaterial,
							faceIndices, faceNormal, barycoord, side, dist,
							lightSampleRec
						);

						if ( hitType == LIGHT_HIT ) {

							if ( firstRay || transmissiveRay ) {

								gl_FragColor.rgb += lightSampleRec.emission * throughputColor;

							} else {

								#if FEATURE_MIS

								// NOTE: we skip MIS for punctual lights since they are not supported in forward PT case
								if ( lightSampleRec.type == SPOT_LIGHT_TYPE || lightSampleRec.type == DIR_LIGHT_TYPE || lightSampleRec.type == POINT_LIGHT_TYPE ) {

									gl_FragColor.rgb += lightSampleRec.emission * throughputColor;

								} else {

									// weight the contribution
									float misWeight = misHeuristic( sampleRec.pdf, lightSampleRec.pdf / lightsDenom );
									gl_FragColor.rgb += lightSampleRec.emission * throughputColor * misWeight;

								}

								#else

								gl_FragColor.rgb += lightSampleRec.emission * throughputColor;

								#endif

							}
							break;

						} else if ( hitType == NO_HIT ) {

							if ( firstRay || transmissiveRay ) {

								gl_FragColor.rgb += sampleBackground( envRotation3x3 * rayDirection, sobol2( 2 ) ) * throughputColor;
								gl_FragColor.a = backgroundAlpha;

							} else {

								#if FEATURE_MIS

								// get the PDF of the hit envmap point
								vec3 envColor;
								float envPdf = sampleEquirect( envMapInfo, envRotation3x3 * rayDirection, envColor );
								envPdf /= lightsDenom;

								// and weight the contribution
								float misWeight = misHeuristic( sampleRec.pdf, envPdf );
								gl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;

								#else

								gl_FragColor.rgb +=
									environmentIntensity *
									sampleEquirectColor( envMapInfo.map, envRotation3x3 * rayDirection ) *
									throughputColor;

								#endif

							}
							break;

						}

						uint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;
						Material material = readMaterialInfo( materials, materialIndex );

						#if FEATURE_FOG

						if ( hitType == FOG_HIT ) {

							material = fogMaterial;
							accumulatedRoughness += 0.2;

						} else if ( material.fogVolume ) {

							fogMaterial = material;
							fogMaterial.fogVolume = side == 1.0;

							rayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );

							i -= sign( transmissiveTraversals );
							transmissiveTraversals -= sign( transmissiveTraversals );
							continue;

						}

						#endif

						if ( material.matte && firstRay ) {

							gl_FragColor = vec4( 0.0 );
							break;

						}

						// if we've determined that this is a shadow ray and we've hit an item with no shadow casting
						// then skip it
						if ( ! material.castShadow && isShadowRay ) {

							rayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );
							continue;

						}

						SurfaceRecord surf;
						if (
							getSurfaceRecord(
								material, attributesArray, side, barycoord, faceIndices,
								faceNormal, accumulatedRoughness,
								surf
							) == SKIP_SURFACE
						) {

							// only allow a limited number of transparency discards otherwise we could
							// crash the context with too long a loop.
							i -= sign( transmissiveTraversals );
							transmissiveTraversals -= sign( transmissiveTraversals );

							rayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );
							continue;

						}

						faceNormal = surf.faceNormal;

						mat3 normalBasis = getBasisFromNormal( surf.normal );
						mat3 invBasis = inverse( normalBasis );

						mat3 clearcoatNormalBasis = getBasisFromNormal( surf.clearcoatNormal );
						mat3 clearcoatInvBasis = inverse( clearcoatNormalBasis );

						vec3 outgoing = - normalize( invBasis * rayDirection );
						vec3 clearcoatOutgoing = - normalize( clearcoatInvBasis * rayDirection );
						sampleRec = bsdfSample( outgoing, clearcoatOutgoing, normalBasis, invBasis, clearcoatNormalBasis, clearcoatInvBasis, surf );

						bool wasBelowSurface = ! surf.volumeParticle && dot( rayDirection, faceNormal ) > 0.0;
						isShadowRay = sampleRec.specularPdf < sobol( 4 );

						vec3 prevRayDirection = rayDirection;
						rayDirection = normalize( normalBasis * sampleRec.direction );

						bool isBelowSurface = ! surf.volumeParticle && dot( rayDirection, faceNormal ) < 0.0;
						rayOrigin = stepRayOrigin( rayOrigin, prevRayDirection, isBelowSurface ? - faceNormal : faceNormal, dist );

						// direct env map sampling
						#if FEATURE_MIS

						// uniformly pick a light or environment map
						if( lightsDenom != 0.0 && sobol( 5 ) < float( lights.count ) / lightsDenom ) {

							// sample a light or environment
							LightSampleRecord lightSampleRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, sobol3( 6 ) );

							bool isSampleBelowSurface = ! surf.volumeParticle && dot( faceNormal, lightSampleRec.direction ) < 0.0;
							if ( isSampleBelowSurface ) {

								lightSampleRec.pdf = 0.0;

							}

							// check if a ray could even reach the light area
							vec3 attenuatedColor;
							if (
								lightSampleRec.pdf > 0.0 &&
								isDirectionValid( lightSampleRec.direction, surf.normal, faceNormal ) &&
								! attenuateHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist, bounces - i, transmissiveTraversals, isShadowRay, fogMaterial, attenuatedColor )
							) {

								// get the material pdf
								vec3 sampleColor;
								float lightMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * lightSampleRec.direction ), normalize( clearcoatInvBasis * lightSampleRec.direction ), surf, sampleColor );
								bool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );
								if ( lightMaterialPdf > 0.0 && isValidSampleColor ) {

									// weight the direct light contribution
									float lightPdf = lightSampleRec.pdf / lightsDenom;
									float misWeight = lightSampleRec.type == SPOT_LIGHT_TYPE || lightSampleRec.type == DIR_LIGHT_TYPE || lightSampleRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );
									gl_FragColor.rgb += attenuatedColor * lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;

								}

							}

						} else {

							// find a sample in the environment map to include in the contribution
							vec3 envColor, envDirection;
							float envPdf = sampleEquirectProbability( envMapInfo, sobol2( 7 ), envColor, envDirection );
							envDirection = invEnvRotation3x3 * envDirection;

							// this env sampling is not set up for transmissive sampling and yields overly bright
							// results so we ignore the sample in this case.
							// TODO: this should be improved but how? The env samples could traverse a few layers?
							bool isSampleBelowSurface = ! surf.volumeParticle && dot( faceNormal, envDirection ) < 0.0;
							if ( isSampleBelowSurface ) {

								envPdf = 0.0;

							}

							// check if a ray could even reach the surface
							vec3 attenuatedColor;
							if (
								envPdf > 0.0 &&
								isDirectionValid( envDirection, surf.normal, faceNormal ) &&
								! attenuateHit( bvh, rayOrigin, envDirection, INFINITY, bounces - i, transmissiveTraversals, isShadowRay, fogMaterial, attenuatedColor )
							) {

								// get the material pdf
								vec3 sampleColor;
								float envMaterialPdf = bsdfResult( outgoing, clearcoatOutgoing, normalize( invBasis * envDirection ), normalize( clearcoatInvBasis * envDirection ), surf, sampleColor );
								bool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );
								if ( envMaterialPdf > 0.0 && isValidSampleColor ) {

									// weight the direct light contribution
									envPdf /= lightsDenom;
									float misWeight = misHeuristic( envPdf, envMaterialPdf );
									gl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;

								}

							}

						}
						#endif

						// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution
						// to a single pixel resulting in fireflies
						if ( ! surf.volumeParticle && ! isBelowSurface ) {

							// determine if this is a rough normal or not by checking how far off straight up it is
							vec3 halfVector = normalize( outgoing + sampleRec.direction );
							vec3 clearcoatHalfVector = normalize( clearcoatOutgoing + sampleRec.clearcoatDirection );
							accumulatedRoughness += max( sin( acosApprox( halfVector.z ) ), sin( acosApprox( clearcoatHalfVector.z ) ) );

							transmissiveRay = false;

						}

						// if we're bouncing around the inside a transmissive material then decrement
						// perform this separate from a bounce
						bool isTransmissiveRay = ! surf.volumeParticle && dot( rayDirection, faceNormal * side ) < 0.0;
						if ( ( isTransmissiveRay || isBelowSurface ) && transmissiveTraversals > 0 ) {

							transmissiveTraversals --;
							i --;

						}

						#if FEATURE_FOG
						if ( material.fogVolume ) {

							transmissiveTraversals --;
							i --;

						}
						#endif

						// accumulate color
						gl_FragColor.rgb += ( surf.emission * throughputColor );

						// skip the sample if our PDF or ray is impossible
						if ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, surf.normal, faceNormal ) ) {

							break;

						}

						#if FEATURE_RUSSIAN_ROULETTE

						// russian roulette path termination
						// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf
						uint minBounces = 3u;
						float depthProb = float( sobolBounceIndex < minBounces );

						float rrProb = luminance( throughputColor * sampleRec.color / sampleRec.pdf );
						rrProb /= luminance( throughputColor );
						rrProb = sqrt( rrProb );
						rrProb = max( rrProb, depthProb );
						rrProb = min( rrProb, 1.0 );
						if ( sobol( 8 ) > rrProb ) {

							break;

						}

						// perform sample clamping here to avoid bright pixels
						throughputColor *= min( 1.0 / rrProb, 20.0 );

						#endif

						throughputColor *= sampleRec.color / sampleRec.pdf;

						// attenuate the throughput color by the medium color
						if ( side == - 1.0 ) {

							throughputColor *= transmissionAttenuation( dist, surf.attenuationColor, surf.attenuationDistance );

						}

						// discard the sample if there are any NaNs
						if ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {

							break;

						}


					}

					gl_FragColor.a *= opacity;

				}

			`}),this.setValues(e)}}u(AD,"PhysicalPathTracingMaterial");const q0={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class Nx extends $h{constructor(e,t){super(),this.textureID=t!==void 0?t:"tDiffuse",e instanceof Ci?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=I1.clone(e.uniforms),this.material=new Ci({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new Ka(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}u(Nx,"ShaderPass");class kx extends $h{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const s=e.getContext(),r=e.state;r.buffers.color.setMask(!1),r.buffers.depth.setMask(!1),r.buffers.color.setLocked(!0),r.buffers.depth.setLocked(!0);let o,a;this.inverse?(o=0,a=1):(o=1,a=0),r.buffers.stencil.setTest(!0),r.buffers.stencil.setOp(s.REPLACE,s.REPLACE,s.REPLACE),r.buffers.stencil.setFunc(s.ALWAYS,o,4294967295),r.buffers.stencil.setClear(a),r.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),r.buffers.color.setLocked(!1),r.buffers.depth.setLocked(!1),r.buffers.stencil.setLocked(!1),r.buffers.stencil.setFunc(s.EQUAL,1,4294967295),r.buffers.stencil.setOp(s.KEEP,s.KEEP,s.KEEP),r.buffers.stencil.setLocked(!0)}}u(kx,"MaskPass");class MD extends $h{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}u(MD,"ClearMaskPass");class SD{constructor(e,t){if(this.renderer=e,t===void 0){const i=e.getSize(new Ie);this._pixelRatio=e.getPixelRatio(),this._width=i.width,this._height=i.height,t=new Ln(this._width*this._pixelRatio,this._height*this._pixelRatio),t.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],q0===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),Nx===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new Nx(q0),this.clock=new HI}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);t!==-1&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let s=0,r=this.passes.length;s<r;s++){const o=this.passes[s];if(o.enabled!==!1){if(o.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(s),o.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),o.needsSwap){if(i){const a=this.renderer.getContext(),l=this.renderer.state.buffers.stencil;l.setFunc(a.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),l.setFunc(a.EQUAL,1,4294967295)}this.swapBuffers()}kx!==void 0&&(o instanceof kx?i=!0:o instanceof MD&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(e===void 0){const t=this.renderer.getSize(new Ie);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,e=this.renderTarget1.clone(),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,s=this._height*this._pixelRatio;this.renderTarget1.setSize(i,s),this.renderTarget2.setSize(i,s);for(let r=0;r<this.passes.length;r++)this.passes[r].setSize(i,s)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}u(SD,"EffectComposer");const FW=new rl(-1,1,1,-1,0,1),iw=new Je;iw.setAttribute("position",new Ve([-1,3,0,-1,-1,0,3,-1,0],3));iw.setAttribute("uv",new Ve([0,2,0,0,2,0],2));class TD{constructor(e){this._mesh=new We(iw,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,FW)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}u(TD,"FullScreenQuad");class Zr extends $h{constructor(e,t,i,s){super(),this.renderScene=t,this.renderCamera=i,this.selectedObjects=s!==void 0?s:[],this.visibleEdgeColor=new Ce(1,1,1),this.hiddenEdgeColor=new Ce(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=e!==void 0?new Ie(e.x,e.y):new Ie(256,256);const r=Math.round(this.resolution.x/this.downSampleRatio),o=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new Ln(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new $_,this.depthMaterial.side=Ki,this.depthMaterial.depthPacking=sI,this.depthMaterial.blending=Ns,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=Ki,this.prepareMaskMaterial.fragmentShader=h(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new Ln(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new Ln(r,o),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new Ln(r,o),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new Ln(Math.round(r/2),Math.round(o/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new Ln(r,o),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new Ln(Math.round(r/2),Math.round(o/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;const a=4,l=4;this.separableBlurMaterial1=this.getSeperableBlurMaterial(a),this.separableBlurMaterial1.uniforms.texSize.value.set(r,o),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(l),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(r/2),Math.round(o/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=l,this.overlayMaterial=this.getOverlayMaterial(),q0===void 0&&console.error("THREE.OutlinePass relies on CopyShader");const c=q0;this.copyUniforms=I1.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new Ci({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:Ns,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new Ce,this.oldClearAlpha=1,this.fsQuad=new Ka(null),this.tempPulseColor1=new Ce,this.tempPulseColor2=new Ce,this.textureMatrix=new me;function h(f,d){const p=d.isPerspectiveCamera?"perspective":"orthographic";return f.replace(/DEPTH_TO_VIEW_Z/g,p+"DepthToViewZ")}u(h,"replaceDepthToViewZ")}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose(),this.depthMaterial.dispose(),this.prepareMaskMaterial.dispose(),this.edgeDetectionMaterial.dispose(),this.separableBlurMaterial1.dispose(),this.separableBlurMaterial2.dispose(),this.overlayMaterial.dispose(),this.materialCopy.dispose(),this.fsQuad.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let i=Math.round(e/this.downSampleRatio),s=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(i,s),this.renderTargetBlurBuffer1.setSize(i,s),this.renderTargetEdgeBuffer1.setSize(i,s),this.separableBlurMaterial1.uniforms.texSize.value.set(i,s),i=Math.round(i/2),s=Math.round(s/2),this.renderTargetBlurBuffer2.setSize(i,s),this.renderTargetEdgeBuffer2.setSize(i,s),this.separableBlurMaterial2.uniforms.texSize.value.set(i,s)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function i(s){s.isMesh&&(e===!0?s.visible=t.get(s):(t.set(s,s.visible),s.visible=e))}u(i,"gatherSelectedMeshesCallBack");for(let s=0;s<this.selectedObjects.length;s++)this.selectedObjects[s].traverse(i)}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,i=[];function s(o){o.isMesh&&i.push(o)}u(s,"gatherSelectedMeshesCallBack");for(let o=0;o<this.selectedObjects.length;o++)this.selectedObjects[o].traverse(s);function r(o){if(o.isMesh||o.isSprite){let a=!1;for(let l=0;l<i.length;l++)if(i[l].id===o.id){a=!0;break}if(a===!1){const l=o.visible;(e===!1||t.get(o)===!0)&&(o.visible=e),t.set(o,l)}}else(o.isPoints||o.isLine)&&(e===!0?o.visible=t.get(o):(t.set(o,o.visible),o.visible=e))}u(r,"VisibilityChangeCallBack"),this.renderScene.traverse(r)}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,i,s,r){if(this.selectedObjects.length>0){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const o=e.autoClear;e.autoClear=!1,r&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const a=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=a,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const l=.625+Math.cos(performance.now()*.01/this.pulsePeriod)*.75/2;this.tempPulseColor1.multiplyScalar(l),this.tempPulseColor2.multiplyScalar(l)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=Zr.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=Zr.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=Zr.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=Zr.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,r&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(i),this.fsQuad.render(e),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=o}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=i.texture,e.setRenderTarget(null),this.fsQuad.render(e))}getPrepareMaskMaterial(){return new Ci({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new Ie(.5,.5)},textureMatrix:{value:null}},vertexShader:`#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`,fragmentShader:`#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`})}getEdgeDetectionMaterial(){return new Ci({uniforms:{maskTexture:{value:null},texSize:{value:new Ie(.5,.5)},visibleEdgeColor:{value:new P(1,1,1)},hiddenEdgeColor:{value:new P(1,1,1)}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`})}getSeperableBlurMaterial(e){return new Ci({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new Ie(.5,.5)},direction:{value:new Ie(.5,.5)},kernelRadius:{value:1}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`})}getOverlayMaterial(){return new Ci({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,blending:yx,depthTest:!1,depthWrite:!1,transparent:!0})}}u(Zr,"OutlinePass");Zr.BlurDirectionX=new Ie(1,0);Zr.BlurDirectionY=new Ie(0,1);class CD extends $h{constructor(e,t,i,s,r){super(),this.scene=e,this.camera=t,this.overrideMaterial=i,this.clearColor=s,this.clearAlpha=r!==void 0?r:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new Ce}render(e,t,i){const s=e.autoClear;e.autoClear=!1;let r,o;this.overrideMaterial!==void 0&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),r=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:i),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,r),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=o),e.autoClear=s}}u(CD,"RenderPass");var NW=Object.defineProperty,kW=u((n,e)=>NW(n,"name",{value:e,configurable:!0}),"__name$3g");class sw{constructor(){T(this,"shadingMode","solid");T(this,"enablePressure",!0);T(this,"remeshVoxelSize",.003);T(this,"paintColor",[1,0,1]);T(this,"allowSelectingInvisibleObjectByClicking",!0);T(this,"keepTransformUnchangedWhileMoving",!0);T(this,"useLocalSpaceForTransformControl",!0);T(this,"allowModifyingBoneLengthWhenBindingIk",!0);T(this,"keepInternalTransformWhenBindingIk",!0);T(this,"keepBothEndsOfClayNodesWhenStretching",!0);T(this,"quadView",!1);T(this,"outlineSelected",!0);T(this,"showGrids",!0);T(this,"showLightHelpers",!1);T(this,"showIkBones",!1);T(this,"tools",{})}}u(sw,"EditorOptions");kW(sw,"EditorOptions");var zW=Object.defineProperty,BW=u((n,e)=>zW(n,"name",{value:e,configurable:!0}),"__name$3f");const k3=new ht,UW=new P,My=new je;class rw{constructor(){T(this,"perspective",!0);T(this,"perspectiveCamera",new li(45,1,.1,2e3));T(this,"orthographicCamera",new rl(-1,1,-1,1,0,2e3));T(this,"target",new P);T(this,"distance",1);T(this,"alpha",0);T(this,"beta",0);T(this,"_position",new P);T(this,"_up",new P);T(this,"_dir",new P)}get(){return this.perspective?this.perspectiveCamera:this.orthographicCamera}update(e,t){k3.set(0,this.beta,-this.alpha),My.setFromEuler(k3),this._position.set(this.distance,0,0),this._position.applyQuaternion(My),this._position.add(this.target);const i=this.get();if(i.position.copy(this._position),this._up.set(0,1,0),this._dir.subVectors(this._position,this.target).normalize(),UW.crossVectors(this._up,this._dir).lengthSq()<1e-8&&this._up.applyQuaternion(My),i.up.copy(this._up),i.lookAt(this.target),this.perspective)this.perspectiveCamera.aspect=e/t;else{const s=this.distance/850,r=e/2*s,o=t/2*s;this.orthographicCamera.left=-r,this.orthographicCamera.right=+r,this.orthographicCamera.bottom=-o,this.orthographicCamera.top=+o}i.updateProjectionMatrix()}}u(rw,"ArcRotateCamera");BW(rw,"ArcRotateCamera");var $W=Object.defineProperty,zs=u((n,e)=>$W(n,"name",{value:e,configurable:!0}),"__name$3e");const Gt=function(){const n=new P,e=new P;return function(t,i,s,r,o){n.subVectors(s,i);const a=n.length();if(a<1e-8)return!1;n.divideScalar(a);const l=n.dot(o);if(Math.abs(l)<1e-8)return!1;e.subVectors(r,i);const c=e.dot(o)/l;return t.copy(i),t.addScaledVector(n,c),!0}}();function zx(n,e,t,i,s){let r=t.x-e.x,o=t.y-e.y,a=t.z-e.z;const l=e.x-i.x,c=e.y-i.y,h=e.z-i.z,f=r**2+o**2+a**2,d=2*(r*l+o*c+a*h),p=l**2+c**2+h**2-s**2,g=d**2-4*f*p;if(g<0)return!1;const m=Math.sqrt(g),v=(-d+m)/(2*f),y=(-d-m)/(2*f),b=Math.min(v,y);return n.x=e.x+r*b,n.y=e.y+o*b,n.z=e.z+a*b,!0}u(zx,"raySphereIntersect");zs(zx,"raySphereIntersect");const lp=new P,cp=new je,fh=new P;function dh(n,e){return e.decompose(lp,cp,fh),n.copy(lp),n}u(dh,"getTranslation");zs(dh,"getTranslation");function ED(n,e){return e.decompose(lp,cp,fh),n.copy(cp),n}u(ED,"getRotation");zs(ED,"getRotation");function PD(n,e){return e.decompose(lp,cp,fh),n.copy(fh),n}u(PD,"getScale");zs(PD,"getScale");function ac(n){return n.decompose(lp,cp,fh),fh.x}u(ac,"getScaleScalar");zs(ac,"getScaleScalar");function No(n,e,t,i,s,r){let o=t.x,a=t.y,l=t.z,c=i.x,h=i.y,f=i.z,d=s.x,p=s.y,g=s.z,m=r.x,v=r.y,y=r.z,b=c**2*v**2+c**2*y**2-2*c*h*m*v-2*c*f*m*y+h**2*m**2+h**2*y**2-2*h*f*v*y+f**2*m**2+f**2*v**2,x=!1,w=(c*m*v*a-c*m*v*p+c*m*y*l-c*m*y*g-c*v**2*o+c*v**2*d-c*y**2*o+c*y**2*d-h*m**2*a+h*m**2*p+h*m*v*o-h*m*v*d+h*v*y*l-h*v*y*g-h*y**2*a+h*y**2*p-f*m**2*l+f*m**2*g+f*m*y*o-f*m*y*d-f*v**2*l+f*v**2*g+f*v*y*a-f*v*y*p)/b;isFinite(w)||(x=!0,w=0);let _=o+c*w,A=a+h*w,S=l+f*w;if(n&&(n.x=_,n.y=A,n.z=S),e){let M=(-c*v*l+c*v*g+c*y*a-c*y*p+h*m*l-h*m*g-h*y*o+h*y*d-f*m*a+f*m*p+f*v*o-f*v*d)/b;if(isFinite(M)){let C=h*y-f*v,I=-c*y+f*m,F=c*v-h*m;e.x=_+C*M,e.y=A+I*M,e.z=S+F*M}else{x=!0;let C=h*(l-g)-f*(a-p),I=-c*(l-g)+f*(o-d),F=c*(a-p)-h*(o-d);e.x=_+h*F-f*I,e.y=A+-c*F+f*C,e.z=S+c*I-h*C}}return x}u(No,"closestPointsBetweenTwoLines");zs(No,"closestPointsBetweenTwoLines");const Qa=function(){const n=new P,e=new P,t=new me;return function(i,s,r){return n.crossVectors(r,s).normalize(),e.crossVectors(s,n).normalize(),t.set(n.x,n.y,n.z,0,e.x,e.y,e.z,0,s.x,s.y,s.z,0,0,0,0,1).transpose(),i.setFromRotationMatrix(t)}}();function Xu(n,e){return n.x=Math.round(n.x/e)*e,n.y=Math.round(n.y/e)*e,n.z=Math.round(n.z/e)*e,n}u(Xu,"snapPoint");zs(Xu,"snapPoint");function Ir(n,e){return Math.abs(n.x-e.x)<1e-8&&Math.abs(n.y-e.y)<1e-8&&Math.abs(n.z-e.z)<1e-8}u(Ir,"vectorsEqual");zs(Ir,"vectorsEqual");function RD(n,e,t){const i=Math.min(e.x,t.x),s=Math.max(e.x,t.x),r=Math.min(e.y,t.y),o=Math.max(e.y,t.y),a=n.x,l=n.y;return!(a<i||a>s||l<r||l>o)}u(RD,"intersectPointRect");zs(RD,"intersectPointRect");const VW=function(){const n=new P,e=new P,t=new P;return function(i,s,r,o,a,l,c,h){n.subVectors(s,r);const f=l.dot(n),d=c.dot(n);if(f<=0&&d<=0)return i.copy(r);e.subVectors(s,o);const p=l.dot(e),g=c.dot(e);if(p>=0&&g<=p)return i.copy(o);t.subVectors(s,a);const m=l.dot(t),v=c.dot(t);if(v>=0&&m<=v)return i.copy(a);const y=f*g-p*d;if(y<=0&&f>=0&&p<=0){const S=f/(f-p);return i.copy(r).addScaledVector(l,S)}const b=m*d-f*v;if(b<=0&&d>=0&&v<=0){const S=d/(d-v);return i.copy(r).addScaledVector(c,S)}const x=p*v-m*g;if(x<=0&&g-p>=0&&m-v>=0){const S=(g-p)/(g-p+(m-v));return i.copy(o).addScaledVector(h,S)}const w=1/(x+b+y),_=b*w,A=y*w;return i.copy(r).addScaledVector(l,_).addScaledVector(c,A)}}(),HW=function(){const n=new P,e=new P,t=new P,i=new P;return function(s,r,o,a,l){e.crossVectors(a,l);let c=r.dot(e),h;if(c>0)h=1;else if(c<0)h=-1,c=-c;else return-1;n.subVectors(s,o);const f=h*r.dot(i.crossVectors(n,l));if(f<0)return-1;const d=h*r.dot(t.crossVectors(a,n));if(d<0||d+f>c)return-1;const p=-h*n.dot(e);return p<0?-1:p/c}}(),ID=function(){const n=new P;return function(e,t,i,s){return e.copy(t).addScaledVector(i,n.subVectors(s,t).dot(i))}}(),ql=function(){const n=new P;return function(e,t,i){return Math.atan2(n.crossVectors(t,i).dot(e),t.dot(i))}}();function Go(n,e){const t=Math.acos(e.w)*2,i=Math.sin(t/2);return i>1e-6?n.set(e.x,e.y,e.z).multiplyScalar(1/i):n.set(1,0,0),t}u(Go,"getAxisAngle");zs(Go,"getAxisAngle");function Ou(n){return n=n%(Math.PI*2),n<0&&(n+=Math.PI*2),n}u(Ou,"simplifyAngle");zs(Ou,"simplifyAngle");function Bx(n,e){return Math.PI-Math.abs(Math.abs(e-n)%(Math.PI*2)-Math.PI)}u(Bx,"absAngleDiff");zs(Bx,"absAngleDiff");function ow(n,e,t){if(n=Ou(n),t-e>1e-8&&Ou(t-e)<1e-8)return n;if(e=Ou(e),t=Ou(t),t<e){if(n>=0&&n<=t||n>=e)return n}else if(n>=e&&n<=t)return n;const i=Bx(n,e),s=Bx(n,t);return i<=s?e:t}u(ow,"clampAngle");zs(ow,"clampAngle");var GW=Object.defineProperty,WW=u((n,e)=>GW(n,"name",{value:e,configurable:!0}),"__name$3d");const jW=16135762,XW=7316763,qW=3113955,os=new xi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0,opacity:.5}),aw=new xi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),Ad=aw.clone();Ad.color.setHex(jW);const Md=aw.clone();Md.color.setHex(XW);const Sd=aw.clone();Sd.color.setHex(qW);const mr=.035,Sy=.5+.04,_s=.1+mr,Fu=.5-.04,YW=Fu-.02,z3=.5,ba=.06,vf=Fu-.06,xa=.08,po=new P,mo=new P,go=new P,vn=new P,gi=new P,Ty=new P,yf=new P,B3=new me,Ii=new P,as=new je,bf=new P,xf=new P,jm=new P,Xm=new P;class lw extends _i{constructor(){super();T(this,"translateArrowX");T(this,"translateArrowY");T(this,"translateArrowZ");T(this,"translatePickerX");T(this,"translatePickerY");T(this,"translatePickerZ");T(this,"translateArrowXN");T(this,"translateArrowYN");T(this,"translateArrowZN");T(this,"translatePickerXN");T(this,"translatePickerYN");T(this,"translatePickerZN");T(this,"freeTranslateHandler");T(this,"freeTranslatePicker");T(this,"rotateCircleX");T(this,"rotateCircleY");T(this,"rotateCircleZ");T(this,"rotatePickerX");T(this,"rotatePickerY");T(this,"rotatePickerZ");T(this,"rotateHandlerX");T(this,"rotateHandlerY");T(this,"rotateHandlerZ");T(this,"freeRotatePicker");T(this,"viewRotateCircle");T(this,"viewRotatePicker");T(this,"scaleHandlers");T(this,"scaleCubeX");T(this,"scaleCubeY");T(this,"scaleCubeZ");T(this,"scaleAxisX");T(this,"scaleAxisY");T(this,"scaleAxisZ");T(this,"scalePickerX");T(this,"scalePickerY");T(this,"scalePickerZ");T(this,"scalePickerYZ");T(this,"scalePickerXZ");T(this,"scalePickerXY");T(this,"pickers");T(this,"size",.25);T(this,"orientation","local");T(this,"forcePositiveScale",!0);T(this,"translateSnap",.1);T(this,"rotateSnap",45/180*Math.PI);T(this,"enableTranslate",!0);T(this,"enableRotate",!0);T(this,"enableScale",!0);T(this,"dragStart",!1);T(this,"dragging",!1);T(this,"mode");T(this,"handler");T(this,"position0",new P);T(this,"rotation0",new je);T(this,"scale0",new P);T(this,"position1",new P);T(this,"rotation1",new je);T(this,"scale1",new P);T(this,"detTranslation",new P);T(this,"detRotation",new je);T(this,"detScale",new P);T(this,"mouse0",new P);T(this,"axis",new P);T(this,"raycastPanel",!1);this.renderOrder=1;const t=new lh(0,.04,.1,12);t.translate(0,.1/2,0),this.translateArrowX=new We(t,Ad.clone()),this.translateArrowY=new We(t,Md.clone()),this.translateArrowZ=new We(t,Sd.clone()),this.translateArrowX.position.set(Sy,0,0),this.translateArrowX.rotation.set(0,0,-Math.PI/2),this.translateArrowY.position.set(0,Sy,0),this.translateArrowY.rotation.set(0,0,0),this.translateArrowZ.position.set(0,0,Sy),this.translateArrowZ.rotation.set(Math.PI/2,0,0),this.add(this.translateArrowX),this.add(this.translateArrowY),this.add(this.translateArrowZ),this.translateArrowXN=this.translateArrowX.clone(),this.translateArrowYN=this.translateArrowY.clone(),this.translateArrowZN=this.translateArrowZ.clone(),this.translateArrowXN.position.negate(),this.translateArrowYN.position.negate(),this.translateArrowZN.position.negate(),this.translateArrowXN.rotation.set(0,0,Math.PI/2),this.translateArrowYN.rotation.set(Math.PI,0,0),this.translateArrowZN.rotation.set(-Math.PI/2,0,0),this.add(this.translateArrowXN),this.add(this.translateArrowYN),this.add(this.translateArrowZN);const i=new lh(mr,.04+mr,.1+mr,12);i.translate(0,.1/2,0),this.translatePickerX=new We(i,os),this.translatePickerY=new We(i,os),this.translatePickerZ=new We(i,os),this.translatePickerX.position.copy(this.translateArrowX.position),this.translatePickerX.rotation.copy(this.translateArrowX.rotation),this.translatePickerY.position.copy(this.translateArrowY.position),this.translatePickerY.rotation.copy(this.translateArrowY.rotation),this.translatePickerZ.position.copy(this.translateArrowZ.position),this.translatePickerZ.rotation.copy(this.translateArrowZ.rotation),this.add(this.translatePickerX),this.add(this.translatePickerY),this.add(this.translatePickerZ),this.translatePickerX.visible=!1,this.translatePickerY.visible=!1,this.translatePickerZ.visible=!1,this.translatePickerX.userData.name="translate-x",this.translatePickerY.userData.name="translate-y",this.translatePickerZ.userData.name="translate-z",this.translatePickerXN=this.translatePickerX.clone(),this.translatePickerYN=this.translatePickerY.clone(),this.translatePickerZN=this.translatePickerZ.clone(),this.translatePickerXN.position.negate(),this.translatePickerYN.position.negate(),this.translatePickerZN.position.negate(),this.translatePickerXN.rotation.set(0,0,Math.PI/2),this.translatePickerYN.rotation.set(Math.PI,0,0),this.translatePickerZN.rotation.set(-Math.PI/2,0,0),this.add(this.translatePickerXN),this.add(this.translatePickerYN),this.add(this.translatePickerZN),this.translatePickerXN.userData.name="translate-x",this.translatePickerYN.userData.name="translate-y",this.translatePickerZN.userData.name="translate-z",this.freeTranslateHandler=new We(new Ua(_s,.0075,3,64,Math.PI*2),os.clone()),this.add(this.freeTranslateHandler),this.freeTranslatePicker=new We(new ah(_s,64),os.clone()),this.add(this.freeTranslatePicker),this.freeTranslatePicker.visible=!1,this.freeTranslatePicker.userData.name="translate-free",this.scaleHandlers=new _i,this.add(this.scaleHandlers);const s=new br(ba,ba,ba);this.scaleCubeX=new We(s,Ad.clone()),this.scaleCubeY=new We(s,Md.clone()),this.scaleCubeZ=new We(s,Sd.clone()),this.scaleCubeX.position.set(vf,0,0),this.scaleCubeY.position.set(0,vf,0),this.scaleCubeZ.position.set(0,0,vf),this.scaleHandlers.add(this.scaleCubeX),this.scaleHandlers.add(this.scaleCubeY),this.scaleHandlers.add(this.scaleCubeZ);const r=new br(vf-_s-ba/2,.01,.01);r.translate((vf-_s-ba/2)/2,0,0),this.scaleAxisX=new We(r,this.scaleCubeX.material),this.scaleAxisY=new We(r,this.scaleCubeY.material),this.scaleAxisZ=new We(r,this.scaleCubeZ.material),this.scaleAxisX.position.set(_s,0,0),this.scaleAxisY.position.set(0,_s,0),this.scaleAxisZ.position.set(0,0,_s),this.scaleAxisX.rotation.set(0,0,0),this.scaleAxisY.rotation.set(0,0,Math.PI/2),this.scaleAxisZ.rotation.set(0,-Math.PI/2,0),this.scaleHandlers.add(this.scaleAxisX),this.scaleHandlers.add(this.scaleAxisY),this.scaleHandlers.add(this.scaleAxisZ);const o=new br(ba+mr,ba+mr,ba+mr);this.scalePickerX=new We(o,os),this.scalePickerY=new We(o,os),this.scalePickerZ=new We(o,os),this.scalePickerX.position.copy(this.scaleCubeX.position),this.scalePickerY.position.copy(this.scaleCubeY.position),this.scalePickerZ.position.copy(this.scaleCubeZ.position),this.scaleHandlers.add(this.scalePickerX),this.scaleHandlers.add(this.scalePickerY),this.scaleHandlers.add(this.scalePickerZ),this.scalePickerX.visible=!1,this.scalePickerY.visible=!1,this.scalePickerZ.visible=!1,this.scalePickerX.userData.name="scale-x",this.scalePickerY.userData.name="scale-y",this.scalePickerZ.userData.name="scale-z";const a=new br(1e-7,xa,xa);this.scalePickerYZ=new We(a,Ad.clone()),this.scalePickerXZ=new We(a,Md.clone()),this.scalePickerXY=new We(a,Sd.clone()),this.scalePickerYZ.rotation.set(0,0,0),this.scalePickerYZ.position.set(0,_s+xa/2,_s+xa/2),this.scalePickerXZ.rotation.set(0,0,Math.PI/2),this.scalePickerXZ.position.set(_s+xa/2,0,_s+xa/2),this.scalePickerXY.rotation.set(0,Math.PI/2,0),this.scalePickerXY.position.set(_s+xa/2,_s+xa/2,0),this.scaleHandlers.add(this.scalePickerYZ),this.scaleHandlers.add(this.scalePickerXZ),this.scaleHandlers.add(this.scalePickerXY),this.scalePickerYZ.userData.name="scale-yz",this.scalePickerXZ.userData.name="scale-xz",this.scalePickerXY.userData.name="scale-xy",this.viewRotateCircle=new We(new Ua(z3,.0075,3,64,Math.PI*2),os),this.add(this.viewRotateCircle),this.viewRotatePicker=new We(new Ua(z3-mr,.0075+mr,3,64,Math.PI*2),os),this.add(this.viewRotatePicker),this.viewRotatePicker.visible=!1,this.viewRotatePicker.userData.name="rotate-view",this.freeRotatePicker=new We(new ah(YW,64),os.clone()),this.freeRotatePicker.material.opacity=.2,this.add(this.freeRotatePicker),this.freeRotatePicker.visible=!1,this.freeRotatePicker.userData.name="rotate-free",this.rotateHandlerX=new It,this.rotateHandlerY=new It,this.rotateHandlerZ=new It,this.add(this.rotateHandlerX),this.add(this.rotateHandlerY),this.add(this.rotateHandlerZ);const l=new Ua(Fu,.0075,3,64,Math.PI);l.rotateY(Math.PI/2),l.rotateX(Math.PI/2),this.rotateCircleX=new We(l,Ad.clone()),this.rotateCircleY=new We(l,Md.clone()),this.rotateCircleZ=new We(l,Sd.clone()),this.rotateCircleX.rotation.set(0,0,0),this.rotateCircleY.rotation.set(0,0,-Math.PI/2),this.rotateCircleZ.rotation.set(0,Math.PI/2,0),this.rotateHandlerX.add(this.rotateCircleX),this.rotateHandlerY.add(this.rotateCircleY),this.rotateHandlerZ.add(this.rotateCircleZ);const c=new Ua(.45-mr,.0075+mr,3,64,Math.PI);c.rotateY(Math.PI/2),c.rotateX(Math.PI/2),this.rotatePickerX=new We(c,os),this.rotatePickerY=new We(c,os),this.rotatePickerZ=new We(c,os),this.rotatePickerY.rotation.copy(this.rotateCircleY.rotation),this.rotatePickerX.rotation.copy(this.rotateCircleX.rotation),this.rotatePickerZ.rotation.copy(this.rotateCircleZ.rotation),this.rotateHandlerX.add(this.rotatePickerX),this.rotateHandlerY.add(this.rotatePickerY),this.rotateHandlerZ.add(this.rotatePickerZ),this.rotatePickerX.visible=!1,this.rotatePickerY.visible=!1,this.rotatePickerZ.visible=!1,this.rotatePickerX.userData.name="rotate-x",this.rotatePickerY.userData.name="rotate-y",this.rotatePickerZ.userData.name="rotate-z",this.pickers=[this.translatePickerX,this.translatePickerY,this.translatePickerZ,this.translatePickerXN,this.translatePickerYN,this.translatePickerZN,this.freeTranslatePicker,this.rotatePickerX,this.rotatePickerY,this.rotatePickerZ,this.freeRotatePicker,this.viewRotatePicker,this.scalePickerX,this.scalePickerY,this.scalePickerZ,this.scalePickerYZ,this.scalePickerXZ,this.scalePickerXY]}setTargetTransform(t,i,s){this.dragging||(this.position0.copy(t),this.rotation0.copy(i),this.scale0.copy(s))}setTargetTransformFromMatrix(t){this.dragging||(t.decompose(this.position0,this.rotation0,this.scale0),this.rotation0.normalize())}update(t,i,s,r,o,a){if(!this.visible)return;this.position.copy(this.dragging?this.position1:this.position0),this.orientation==="local"?(this.quaternion.copy(this.dragging?this.rotation1:this.rotation0),this.scaleHandlers.quaternion.set(0,0,0,1)):(this.quaternion.set(0,0,0,1),this.scaleHandlers.quaternion.copy(this.dragging?this.rotation1:this.rotation0)),this.updateWorldMatrix(!1,!1),po.set(1,0,0).transformDirection(this.matrixWorld),mo.set(0,1,0).transformDirection(this.matrixWorld),go.set(0,0,1).transformDirection(this.matrixWorld),B3.copy(this.matrixWorld).invert(),yf.copy(t._dir).transformDirection(B3);let l;if(t.perspective){const d=t.perspectiveCamera;l=this.position.distanceTo(d.position)*Math.min(1.9*Math.tan(Math.PI*d.fov/360)/d.zoom,7)}else{const d=t.orthographicCamera;l=(d.top-d.bottom)/d.zoom}this.scale.setScalar(l*this.size),vn.set(1,0,0),gi.set(0,0,1),this.rotateHandlerX.quaternion.setFromAxisAngle(vn,ql(vn,gi,yf)),vn.set(0,1,0),gi.set(0,0,1),this.rotateHandlerY.quaternion.setFromAxisAngle(vn,ql(vn,gi,yf)),vn.set(0,0,1),gi.set(1,0,0),this.rotateHandlerZ.quaternion.setFromAxisAngle(vn,ql(vn,gi,yf)),vn.set(0,0,1),this.viewRotateCircle.quaternion.setFromUnitVectors(vn,yf),this.viewRotatePicker.quaternion.copy(this.viewRotateCircle.quaternion),this.freeTranslateHandler.quaternion.copy(this.viewRotateCircle.quaternion),this.freeTranslatePicker.quaternion.copy(this.freeTranslateHandler.quaternion),this.freeRotatePicker.quaternion.copy(this.viewRotateCircle.quaternion);for(let d of this.children)d.updateWorldMatrix(!1,!0);const c=Ty.crossVectors(t._dir,po).lengthSq()>1e-6,h=Ty.crossVectors(t._dir,mo).lengthSq()>1e-6,f=Ty.crossVectors(t._dir,go).lengthSq()>1e-6;if(this.dragStart=!1,this.dragging)if(this.translateArrowX.visible=this.translateArrowXN.visible=this.handler==="translate-x",this.translateArrowY.visible=this.translateArrowYN.visible=this.handler==="translate-y",this.translateArrowZ.visible=this.translateArrowZN.visible=this.handler==="translate-z",this.freeTranslateHandler.visible=!0,this.rotateCircleX.visible=this.handler==="rotate-x",this.rotateCircleY.visible=this.handler==="rotate-y",this.rotateCircleZ.visible=this.handler==="rotate-z",this.scaleCubeX.visible=this.scaleAxisX.visible=this.handler==="scale-x",this.scaleCubeY.visible=this.scaleAxisY.visible=this.handler==="scale-y",this.scaleCubeZ.visible=this.scaleAxisZ.visible=this.handler==="scale-z",this.scalePickerYZ.visible=this.handler==="scale-yz",this.scalePickerXZ.visible=this.handler==="scale-xz",this.scalePickerXY.visible=this.handler==="scale-xy",this.viewRotateCircle.visible=!0,this.freeRotatePicker.visible=!1,s.mouseLeft)switch(this.mode){case"translate":this.handler==="translate-free"?Gt(Ii,r,o,this.position0,a):No(Ii,null,this.position0,this.axis,r,a),this.detTranslation.subVectors(Ii,this.mouse0),s.isKeyPressed("Shift")&&Xu(this.detTranslation,this.translateSnap),this.position1.addVectors(this.position0,this.detTranslation),this.position.copy(this.position1),this.updateMatrix();break;case"rotate":switch(this.handler){case"rotate-free":zx(Ii,r,o,this.position0,Fu*l*this.size)||Gt(Ii,r,o,this.position0,t._dir),vn.subVectors(this.mouse0,this.position0).normalize(),gi.subVectors(Ii,this.position0).normalize(),as.setFromUnitVectors(vn,gi),this.detRotation.copy(as),jm.set(0,0,1).applyQuaternion(this.rotation0).applyQuaternion(as),Xm.set(0,1,0).applyQuaternion(this.rotation0).applyQuaternion(as),Qa(this.rotation1,jm,Xm);break;case"rotate-view":{Gt(Ii,r,o,this.position0,a),vn.subVectors(this.mouse0,this.position0),gi.subVectors(Ii,this.position0);const d=t._dir;let p=ql(d,vn,gi);s.isKeyPressed("Shift")&&(p=Math.round(p/this.rotateSnap)*this.rotateSnap),as.setFromAxisAngle(d,p),this.detRotation.copy(as),jm.set(0,0,1).applyQuaternion(this.rotation0).applyQuaternion(as),Xm.set(0,1,0).applyQuaternion(this.rotation0).applyQuaternion(as),Qa(this.rotation1,jm,Xm)}break;default:{switch(this.handler){case"rotate-x":bf.set(1,0,0);break;case"rotate-y":bf.set(0,1,0);break;case"rotate-z":bf.set(0,0,1);break}if(this.raycastPanel){Gt(Ii,r,o,this.position0,a),vn.subVectors(this.mouse0,this.position0),gi.subVectors(Ii,this.position0);let d=ql(this.axis,vn,gi)||0;s.isKeyPressed("Shift")&&(d=Math.round(d/this.rotateSnap)*this.rotateSnap),as.setFromAxisAngle(bf,d),this.detRotation.copy(as),this.rotation1.multiplyQuaternions(this.rotation0,as)}else{const d=Fu*l*this.size;xf.crossVectors(this.axis,t._dir).normalize(),No(Ii,null,this.position0,xf,r,a);const p=.25;let g=vn.subVectors(Ii,this.mouse0).dot(xf)/d*Math.PI/2*p;s.isKeyPressed("Shift")&&(g=Math.round(g/this.rotateSnap)*this.rotateSnap),as.setFromAxisAngle(bf,g),this.detRotation.copy(as),this.rotation1.multiplyQuaternions(this.rotation0,as)}}break}break;case"scale":if(this.raycastPanel){Gt(Ii,r,o,this.position0,this.axis);let d=1,p=1,g=1;switch(vn.subVectors(this.mouse0,this.position0).negate(),gi.subVectors(Ii,this.position0).negate(),s.isKeyPressed("Shift")?d=p=g=gi.length()/vn.length():(po.set(1,0,0).applyQuaternion(this.scaleHandlers.quaternion),mo.set(0,1,0).applyQuaternion(this.scaleHandlers.quaternion),go.set(0,0,1).applyQuaternion(this.scaleHandlers.quaternion),d=gi.dot(po)/vn.dot(po),p=gi.dot(mo)/vn.dot(mo),g=gi.dot(go)/vn.dot(go),this.forcePositiveScale&&(d=Math.abs(d),p=Math.abs(p),g=Math.abs(g))),this.handler){case"scale-yz":d=1;break;case"scale-xz":p=1;break;case"scale-xy":g=1;break}this.detScale.set(d,p,g),this.scale1.copy(this.scale0).multiply(this.detScale)}else{No(Ii,null,this.position0,this.axis,r,a);const d=-vn.subVectors(this.mouse0,this.position0).dot(this.axis);let g=-gi.subVectors(Ii,this.position0).dot(this.axis)/d;if(this.forcePositiveScale&&(g=Math.abs(g)),s.isKeyPressed("Shift"))this.detScale.setScalar(g),this.scale1.copy(this.scale0).multiplyScalar(g);else switch(this.scale1.copy(this.scale0),this.handler){case"scale-x":this.detScale.set(g,1,1),this.scale1.x*=g;break;case"scale-y":this.detScale.set(1,g,1),this.scale1.y*=g;break;case"scale-z":this.detScale.set(1,1,g),this.scale1.z*=g;break}}break}else this.dragging=!1,this.mode=void 0,this.position0.copy(this.position1),this.rotation0.copy(this.rotation1),this.scale0.copy(this.scale1);else{let d=!1,p=!1,g=!1,m,v;for(let y of i.intersectObjects(this.pickers))switch(y.object.userData.name){case"translate-x":!m&&c&&this.enableTranslate&&(m="translate-x");break;case"translate-y":!m&&h&&this.enableTranslate&&(m="translate-y");break;case"translate-z":!m&&f&&this.enableTranslate&&(m="translate-z");break;case"translate-free":this.enableTranslate&&(d=!0);break;case"rotate-x":!v&&this.enableRotate&&(v="rotate-x");break;case"rotate-y":!v&&this.enableRotate&&(v="rotate-y");break;case"rotate-z":!v&&this.enableRotate&&(v="rotate-z");break;case"rotate-view":this.enableRotate&&(g=!0);break;case"rotate-free":this.enableRotate&&(p=!0);break;case"scale-x":!m&&c&&this.enableScale&&(m="scale-x");break;case"scale-y":!m&&h&&this.enableScale&&(m="scale-y");break;case"scale-z":!m&&f&&this.enableScale&&(m="scale-z");break;case"scale-yz":!m&&h&&f&&this.enableScale&&(m="scale-yz");break;case"scale-xz":!m&&c&&f&&this.enableScale&&(m="scale-xz");break;case"scale-xy":!m&&c&&h&&this.enableScale&&(m="scale-xy");break}if(this.handler=void 0,m?this.handler=m:v?this.handler=v:d?this.handler="translate-free":p?this.handler="rotate-free":g&&(this.handler="rotate-view"),this.updateOpacity(this.translateArrowX,this.handler==="translate-x"||!this.handler),this.updateOpacity(this.translateArrowY,this.handler==="translate-y"||!this.handler),this.updateOpacity(this.translateArrowZ,this.handler==="translate-z"||!this.handler),this.updateOpacity(this.rotateCircleX,this.handler==="rotate-x"||!this.handler),this.updateOpacity(this.rotateCircleY,this.handler==="rotate-y"||!this.handler),this.updateOpacity(this.rotateCircleZ,this.handler==="rotate-z"||!this.handler),this.updateOpacity(this.scaleCubeX,this.handler==="scale-x"||!this.handler),this.updateOpacity(this.scaleCubeY,this.handler==="scale-y"||!this.handler),this.updateOpacity(this.scaleCubeZ,this.handler==="scale-z"||!this.handler),this.updateOpacity(this.scaleAxisX,this.handler==="scale-x"||!this.handler),this.updateOpacity(this.scaleAxisY,this.handler==="scale-y"||!this.handler),this.updateOpacity(this.scaleAxisZ,this.handler==="scale-z"||!this.handler),this.updateOpacity(this.scalePickerYZ,this.handler==="scale-yz"||!this.handler),this.updateOpacity(this.scalePickerXZ,this.handler==="scale-xz"||!this.handler),this.updateOpacity(this.scalePickerXY,this.handler==="scale-xy"||!this.handler),this.updateOpacity(this.viewRotateCircle,this.handler==="rotate-view"||!this.handler),this.updateOpacity(this.freeTranslateHandler,this.handler==="translate-free"||!this.handler),this.freeRotatePicker.visible=this.handler==="rotate-free"&&this.enableRotate,this.translateArrowX.visible=this.translateArrowXN.visible=c&&this.enableTranslate,this.translateArrowY.visible=this.translateArrowYN.visible=h&&this.enableTranslate,this.translateArrowZ.visible=this.translateArrowZN.visible=f&&this.enableTranslate,this.rotateCircleX.visible=this.enableRotate,this.rotateCircleY.visible=this.enableRotate,this.rotateCircleZ.visible=this.enableRotate,this.scaleCubeX.visible=this.scaleAxisX.visible=c&&this.enableScale,this.scaleCubeY.visible=this.scaleAxisY.visible=h&&this.enableScale,this.scaleCubeZ.visible=this.scaleAxisZ.visible=f&&this.enableScale,this.scalePickerYZ.visible=h&&f&&this.enableScale,this.scalePickerXZ.visible=c&&f&&this.enableScale,this.scalePickerXY.visible=c&&h&&this.enableScale,this.viewRotateCircle.visible=!0,this.freeTranslateHandler.visible=!0,s.mouseLeftDownThisFrame&&this.handler){switch(this.dragStart=!0,this.dragging=!0,this.handler){case"translate-x":case"translate-y":case"translate-z":this.mode="translate",this.axis.copy(this.handler==="translate-x"?po:this.handler==="translate-y"?mo:go),No(this.mouse0,null,this.position0,this.axis,r,a);break;case"translate-free":this.mode="translate",Gt(this.mouse0,r,o,this.position0,a);break;case"rotate-x":case"rotate-y":case"rotate-z":{this.mode="rotate",this.axis.copy(this.handler==="rotate-x"?po:this.handler==="rotate-y"?mo:go);let y=Ou(Math.abs(a.angleTo(this.axis)));y=y/Math.PI*180,this.raycastPanel=Math.abs(y-90)>15,this.raycastPanel?Gt(this.mouse0,r,o,this.position0,a):(xf.crossVectors(this.axis,t._dir).normalize(),No(this.mouse0,null,this.position0,xf,r,a))}break;case"rotate-free":this.mode="rotate",zx(this.mouse0,r,o,this.position0,Fu*l*this.size)||Gt(this.mouse0,r,o,this.position0,t._dir);break;case"rotate-view":this.mode="rotate",Gt(this.mouse0,r,o,this.position0,a);break;case"scale-x":case"scale-y":case"scale-z":{switch(this.mode="scale",this.raycastPanel=!1,this.handler){case"scale-x":this.axis.copy(po);break;case"scale-y":this.axis.copy(mo);break;case"scale-z":this.axis.copy(go);break}this.axis.applyQuaternion(this.scaleHandlers.quaternion),No(this.mouse0,null,this.position0,this.axis,r,a)}break;case"scale-yz":case"scale-xz":case"scale-xy":{switch(this.mode="scale",this.raycastPanel=!0,this.handler){case"scale-yz":this.axis.copy(po);break;case"scale-xz":this.axis.copy(mo);break;case"scale-xy":this.axis.copy(go);break}this.axis.applyQuaternion(this.scaleHandlers.quaternion),Gt(this.mouse0,r,o,this.position0,this.axis)}break}this.position1.copy(this.position0),this.rotation1.copy(this.rotation0),this.scale1.copy(this.scale0)}}}updateOpacity(t,i,s=.35,r=1){const o=t.material;o.opacity=i?r:s}}u(lw,"Gizmo");WW(lw,"Gizmo");var ZW=Object.defineProperty,KW=u((n,e)=>ZW(n,"name",{value:e,configurable:!0}),"__name$3c");class cw{constructor(){T(this,"element");T(this,"pointerOver",!1);T(this,"pointerX",0);T(this,"pointerY",0);T(this,"pressure",0);T(this,"mouseLeft",!1);T(this,"mouseLeftDownThisFrame",!1);T(this,"mouseRight",!1);T(this,"mouseRightDownThisFrame",!1);T(this,"mouseMiddle",!1);T(this,"mouseMiddleDownThisFrame",!1);T(this,"doubleClick",!1);T(this,"wheelDetX",0);T(this,"wheelDetY",0);T(this,"onContextmenu");T(this,"onPointerMove");T(this,"onPointerDown");T(this,"onPointerUp");T(this,"onPointerLeave");T(this,"onPointerOut");T(this,"onDblClick");T(this,"onWheel");T(this,"onKeyDown");T(this,"onKeyUp");T(this,"onBlur");T(this,"keyMap",new Map);T(this,"timestamp",0);this.onContextmenu=e=>{e.target===this.element&&e.preventDefault()},this.onPointerMove=e=>{e.target===this.element&&(this.pressure=e.pressure,this.pointerOver=!0,this.pointerX=e.offsetX,this.pointerY=e.offsetY)},this.onPointerDown=e=>{if(e.target===this.element)switch(this.pressure=e.pressure,e.button){case 0:this.mouseLeft=!0,this.mouseLeftDownThisFrame=!0;break;case 1:this.mouseMiddle=!0,this.mouseMiddleDownThisFrame=!0;break;case 2:this.mouseRight=!0,this.mouseRightDownThisFrame=!0;break}},this.onPointerUp=e=>{switch(this.pressure=e.pressure,e.button){case 0:this.mouseLeft=!1,this.mouseLeftDownThisFrame=!1;break;case 1:this.mouseMiddle=!1,this.mouseMiddleDownThisFrame=!1;break;case 2:this.mouseRight=!1,this.mouseLeftDownThisFrame=!1;break}},this.onPointerLeave=()=>{this.pressure=0,this.pointerOver=!1},this.onPointerOut=e=>{(e.clientY<=0||e.clientX<=0||e.clientX>=window.innerWidth||e.clientY>=window.innerHeight)&&(this.pressure=0,this.mouseLeft=!1,this.mouseLeftDownThisFrame=!1,this.mouseRight=!1,this.mouseLeftDownThisFrame=!1)},this.onDblClick=e=>{this.doubleClick=!0},this.onWheel=e=>{e.preventDefault(),this.wheelDetX+=e.deltaX/100,this.wheelDetY+=e.deltaY/100},this.onKeyDown=e=>{const t=e.target;t&&"tagName"in t&&t.tagName==="INPUT"||((e.altKey||e.ctrlKey||e.key==="Tab")&&e.preventDefault(),this.keyMap.has(e.key)||this.keyMap.set(e.key,this.timestamp))},this.onKeyUp=e=>{const t=e.target;t&&"tagName"in t&&t.tagName==="INPUT"||this.keyMap.delete(e.key)},this.onBlur=()=>{this.keyMap.clear()}}setup(e){this.unload(),this.element=e,e.addEventListener("contextmenu",this.onContextmenu),e.addEventListener("pointermove",this.onPointerMove),e.addEventListener("pointerdown",this.onPointerDown),e.addEventListener("pointerleave",this.onPointerLeave),document.addEventListener("pointerup",this.onPointerUp),document.addEventListener("pointerout",this.onPointerOut),e.addEventListener("dblclick",this.onDblClick),e.addEventListener("wheel",this.onWheel),window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),window.addEventListener("blur",this.onBlur)}unload(){const e=this.element;!e||(e.removeEventListener("contextmenu",this.onContextmenu),e.removeEventListener("pointermove",this.onPointerMove),e.removeEventListener("pointerdown",this.onPointerDown),e.removeEventListener("pointerleave",this.onPointerLeave),document.removeEventListener("pointerup",this.onPointerUp),document.removeEventListener("pointerout",this.onPointerOut),e.removeEventListener("dblclick",this.onDblClick),e.removeEventListener("wheel",this.onWheel),window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp),window.removeEventListener("blur",this.onBlur),this.element=void 0)}update(){this.mouseLeftDownThisFrame=!1,this.mouseRightDownThisFrame=!1,this.mouseMiddleDownThisFrame=!1,this.doubleClick=!1,this.wheelDetX=0,this.wheelDetY=0,this.timestamp=Date.now()}isKeyPressed(e){return this.keyMap.has(e)}isKeyPressedThisFrame(e){return this.keyMap.get(e)===this.timestamp}isKeyRepeated(e,t=150){const i=this.keyMap.get(e);if(i==null)return!1;const s=this.timestamp-i;return s>=t||s===0?(this.keyMap.set(e,this.timestamp),!0):!1}}u(cw,"Input");KW(cw,"Input");var QW=Object.defineProperty,DD=u((n,e)=>QW(n,"name",{value:e,configurable:!0}),"__name$3b");class Nu{constructor(e,t,i,s,r,o){T(this,"ctx");T(this,"index");T(this,"enabled",!0);T(this,"element");T(this,"camera",new rw);T(this,"zoomLevel",0);T(this,"left",0);T(this,"bottom",0);T(this,"width",0);T(this,"height",0);T(this,"input",new cw);T(this,"mouseScr",new Ie);T(this,"mouseNdc",new P);T(this,"mouseRay0",new P);T(this,"mouseRay1",new P);T(this,"mouseRayN",new P);T(this,"raycaster",new WI);T(this,"gizmo",new lw);T(this,"gizmoEnabled",!1);T(this,"defaultLight");this.ctx=e,this.index=t,this.element=i,this.input.setup(i),this.camera.alpha=s,this.camera.beta=r,this.camera.perspective=o,e.scene.add(this.gizmo),this.gizmo.visible=!1,this.defaultLight=new Fp,e.scene.add(this.defaultLight)}update(){const e=this.element.getBoundingClientRect();this.left=e.left,this.bottom=e.bottom,this.width=e.width,this.height=e.height,this.width&&this.height?this.camera.update(this.width,this.height):this.enabled=!1}dispose(){this.defaultLight.dispose(),this.input.unload()}mousePick(e){return this.raycaster.intersectObjects(this.ctx.readonlyRef().scene.children.filter(t=>{if(!t.visible)return!1;const i=t.userData.node;return i!=null&&i.visible?!e||i.type===e:!1})).filter(t=>{const i=t.object.userData.node;return i==null?void 0:i.visible})}mousePickVisible(){const e=this.ctx.readonlyRef().scene.children.filter(s=>{if(!s.visible)return!1;const r=s.userData.node;return r==null?void 0:r.visible}),t=DD((s,r,o)=>{if(!!s.visible){s.layers.test(r.layers)&&s.raycast(r,o);for(let a of s.children)t(a,r,o)}},"intersectObjects"),i=[];for(let s of e)t(s,this.raycaster,i);return i.sort((s,r)=>s.distance-r.distance)}}u(Nu,"EditorView");DD(Nu,"EditorView");var JW=Object.defineProperty,G1=u((n,e)=>JW(n,"name",{value:e,configurable:!0}),"__name$3a");async function up(n){return new Promise(e=>{const t=new FileReader;t.onload=()=>e(t.result),t.readAsDataURL(new Blob([n]))})}u(up,"bufferToDataUrl");G1(up,"bufferToDataUrl");async function uw(n){return(await fetch(n)).arrayBuffer()}u(uw,"dataUrlToArrayBuffer");G1(uw,"dataUrlToArrayBuffer");const Y0=new DataView(new ArrayBuffer(4));function hw(n){const e=new Uint8Array(n.length*4);for(let t=0,i=n.length;t<i;++t){Y0.setFloat32(0,n[t]);const s=t*4;for(let r=0;r<4;++r)e[s+r]=Y0.getUint8(r)}return e}u(hw,"float32ArrayToBytes");G1(hw,"float32ArrayToBytes");function fw(n){const e=new Float32Array(n.length/4);for(let t=0,i=e.length;t<i;++t){const s=t*4;for(let r=0;r<4;++r)Y0.setUint8(r,n[s+r]);e[t]=Y0.getFloat32(0)}return e}u(fw,"bytesToFloat32Array");G1(fw,"bytesToFloat32Array");var e7=Object.defineProperty,t7=u((n,e)=>e7(n,"name",{value:e,configurable:!0}),"__name$39");class Fe{onRemoved(){}}u(Fe,"ModelNodeComponent");t7(Fe,"ModelNodeComponent");var n7=Object.defineProperty,dw=u((n,e)=>n7(n,"name",{value:e,configurable:!0}),"__name$38"),De=(n=>(n[n.NUMBER=1]="NUMBER",n[n.STRING=2]="STRING",n[n.BOOLEAN=3]="BOOLEAN",n[n.NUMBER_ARRAY=4]="NUMBER_ARRAY",n[n.BYTES=5]="BYTES",n))(De||{});const pw={};function ke(n){return function(e){if(!e.name.startsWith("C"))throw new Error('Component class name should be prefixed with "C"');if(n.storable&&n.dataType==null)throw new Error(`Component [${e.name}] missing data type`);pw[e.name]=Object.assign({constructor:e},n)}}u(ke,"registerModelComponent");dw(ke,"registerModelComponent");function LD(n){return!!pw[n]}u(LD,"isModelNodeComponentDefExists");dw(LD,"isModelNodeComponentDefExists");function is(n){const e=pw[n];if(!e)throw new Error(`Component def [${n}] not found`);return e}u(is,"getModelNodeComponentDef");dw(is,"getModelNodeComponentDef");var OD=Object.defineProperty,i7=Object.getOwnPropertyDescriptor,s7=u((n,e)=>OD(n,"name",{value:e,configurable:!0}),"__name$37"),r7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?i7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&OD(e,t,s),s},"__decorateClass$1a");let Pr=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Float32Array);T(this,"dirty",!0);T(this,"partialUpdate",!1)}},"CColors");s7(Pr,"CColors");Pr=r7([ke({storable:!0,dataType:De.BYTES,clone(n){return new Float32Array(n)},serialize:hw,deserialize:fw})],Pr);var FD=Object.defineProperty,o7=Object.getOwnPropertyDescriptor,a7=u((n,e)=>FD(n,"name",{value:e,configurable:!0}),"__name$36"),l7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?o7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&FD(e,t,s),s},"__decorateClass$19");let jn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P)}},"CFlipDirection");a7(jn,"CFlipDirection");jn=l7([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal:Ir,clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],jn);var ND=Object.defineProperty,c7=Object.getOwnPropertyDescriptor,u7=u((n,e)=>ND(n,"name",{value:e,configurable:!0}),"__name$35"),h7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?c7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&ND(e,t,s),s},"__decorateClass$18");let Ge=u(class extends Fe{constructor(){super(...arguments);T(this,"value",null);T(this,"dirty",!0);T(this,"matrix",new me);T(this,"matDirty",!0);T(this,"placeholder");T(this,"useTempMat",!1);T(this,"tempMat",new me)}onRemoved(){this.placeholder&&this.placeholder.removeFromParent()}},"CGeom3");u7(Ge,"CGeom3");Ge=h7([ke({})],Ge);var kD=Object.defineProperty,f7=Object.getOwnPropertyDescriptor,mw=u((n,e)=>kD(n,"name",{value:e,configurable:!0}),"__name$34"),d7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?f7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&kD(e,t,s),s},"__decorateClass$17");let Me=u(class extends Fe{constructor(){super(...arguments);T(this,"value",null);T(this,"parentChanged",!0);T(this,"localTransformChanged",!0);T(this,"worldTransformChanged",!0);T(this,"mesh");T(this,"instance",!1);T(this,"usePlainMaterial",!1)}onRemoved(){this.dispose()}dispose(){this.value&&(this.instance||pc(this.value),this.value.removeFromParent(),this.value=null)}},"CObject3D");mw(Me,"CObject3D");Me=d7([ke({})],Me);function pc(n){for(let t of n.children)pc(t);if(n.isInstancedMesh)return;if("geometry"in n){const t=n.geometry;t&&t.dispose()}if("material"in n){const t=n.material;t&&(t instanceof Array?t.forEach(Tu):Tu(t))}const e=n;e.__originalMaterial&&(e.__originalMaterial instanceof Array?e.__originalMaterial.forEach(Tu):Tu(e.__originalMaterial)),e.__plainMaterial&&Tu(e.__plainMaterial)}u(pc,"disposeObject3D");mw(pc,"disposeObject3D");function Tu(n){Object.keys(n).forEach(e=>{const t=n[e];t&&typeof t=="object"&&typeof t.dispose=="function"&&t.dispose()}),n.dispose()}u(Tu,"disposeMaterial");mw(Tu,"disposeMaterial");var zD=Object.defineProperty,p7=Object.getOwnPropertyDescriptor,m7=u((n,e)=>zD(n,"name",{value:e,configurable:!0}),"__name$33"),g7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?p7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&zD(e,t,s),s},"__decorateClass$16");let Fn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Float32Array);T(this,"dirty",!0);T(this,"partialUpdate",!1)}},"CVertices");m7(Fn,"CVertices");Fn=g7([ke({storable:!0,dataType:De.BYTES,clone(n){return new Float32Array(n)},serialize:hw,deserialize:fw})],Fn);var v7=Object.defineProperty,_f=u((n,e)=>v7(n,"name",{value:e,configurable:!0}),"__name$32"),y7=zt({components:{InputNumber:si},props:{value:{type:Array,required:!0},min:{type:Number,required:!0},max:{type:Number,required:!0},maxDet:{type:Number,required:!0},step:{type:Number,default:1}},emits:["input"],setup(n,e){const t=He(),i=st(function(){let d=n.min,p=n.max;return{left:(n.value[0]-d)/(p-d)*100+"%"}}),s=st(function(){let d=n.min,p=n.max;return{left:(n.value[1]-d)/(p-d)*100+"%"}}),r=st(function(){let d=n.min,p=n.max;return{left:(n.value[0]-d)/(p-d)*100+"%",width:(n.value[1]-n.value[0])/(p-d)*100+"%"}});function o(d){let p=Math.min(n.max,Math.max(n.min,Math.round(d/n.step)*n.step)),g=n.value[1];g<p&&(g=p),g-p>n.maxDet&&(g=Math.min(n.max,Math.max(n.min,p+n.maxDet))),e.emit("input",[p,g])}u(o,"inputValue1"),_f(o,"inputValue1");function a(d){let p=n.value[0],g=Math.min(n.max,Math.max(n.min,Math.round(d/n.step)*n.step));p>g&&(p=g),g-p>n.maxDet&&(p=Math.min(n.max,Math.max(n.min,g-n.maxDet))),e.emit("input",[p,g])}u(a,"inputValue2"),_f(a,"inputValue2");let l="bar";function c(){switch(l){case"bar":let d=Math.min(n.max,Math.max(n.min,Math.round((n.value[0]-n.step)/n.step)*n.step));if(d>=n.min){let p=Math.min(n.max,Math.max(n.min,Math.round((n.value[1]+(d-n.value[0]))/n.step)*n.step));e.emit("input",[d,p])}break;case"val1":o(n.value[0]-n.step);break;case"val2":a(n.value[1]-n.step);break}}u(c,"moveLeft"),_f(c,"moveLeft");function h(){switch(l){case"bar":let d=Math.min(n.max,Math.max(n.min,Math.round((n.value[1]+n.step)/n.step)*n.step));if(d<=n.max){let p=Math.min(n.max,Math.max(n.min,Math.round((n.value[0]+(d-n.value[1]))/n.step)*n.step));e.emit("input",[p,d])}break;case"val1":o(n.value[0]+n.step);break;case"val2":a(n.value[1]+n.step);break}}u(h,"moveRight"),_f(h,"moveRight");function f(d){const g=t.value.getBoundingClientRect(),m=d.clientX-g.left,v=n.value[0],y=n.value[1],b=n.min,x=n.max;l="bar",m<=(n.value[0]-b)/(x-b)*g.width+2&&(l="val1"),m>=(n.value[1]-b)/(x-b)*g.width-2&&(l="val2"),dc(d,w=>{const A=t.value.getBoundingClientRect(),S=w.clientX-A.left,M=Math.min(1,Math.max(0,S/A.width)),C=(n.max-n.min)*M+n.min;switch(l){case"bar":const I=(S-m)/A.width*(n.max-n.min);if(I<0){let F=Math.min(n.max,Math.max(n.min,Math.round((v+I)/n.step)*n.step));if(F>=n.min){let O=Math.min(n.max,Math.max(n.min,Math.round((y+(F-v))/n.step)*n.step));e.emit("input",[F,O])}}else{let F=Math.min(n.max,Math.max(n.min,Math.round((y+I)/n.step)*n.step));if(F<=n.max){let O=Math.min(n.max,Math.max(n.min,Math.round((v+(F-y))/n.step)*n.step));e.emit("input",[O,F])}}break;case"val1":C<=n.value[1]&&n.value[1]-C<=n.maxDet&&o(C);break;case"val2":C>=n.value[0]&&C-n.value[0]<=n.maxDet&&a(C);break}})}return u(f,"onPointerDown"),_f(f,"onPointerDown"),{bar:t,slider1Style:i,slider2Style:s,sliderBarStyle:r,inputValue1:o,inputValue2:a,moveLeft:c,moveRight:h,onPointerDown:f}}});const b7={class:"input-double-range"},x7={class:"input-double-range__slider-container",ref:"bar"};function _7(n,e,t,i,s,r){const o=xn("input-number");return Te(),Be("div",b7,[Pe(o,{value:n.value[0],onInput:n.inputValue1},null,8,["value","onInput"]),ue("div",{class:"input-double-range__bar",tabindex:"0",onKeydown:[e[0]||(e[0]=Dn((...a)=>n.moveLeft&&n.moveLeft(...a),["left"])),e[1]||(e[1]=Dn((...a)=>n.moveRight&&n.moveRight(...a),["right"]))],onPointerdown:e[2]||(e[2]=(...a)=>n.onPointerDown&&n.onPointerDown(...a))},[ue("div",x7,[ue("div",{class:"input-double-range__slider-bar",style:ci(n.sliderBarStyle)},null,4),ue("div",{class:"input-double-range__slider",style:ci(n.slider1Style)},null,4),ue("div",{class:"input-double-range__slider",style:ci(n.slider2Style)},null,4)],512)],32),Pe(o,{value:n.value[1],onInput:n.inputValue2},null,8,["value","onInput"])])}u(_7,"_sfc_render$n");var BD=jt(y7,[["render",_7],["__scopeId","data-v-5aca574d"]]),UD=Object.defineProperty,w7=Object.getOwnPropertyDescriptor,A7=u((n,e)=>UD(n,"name",{value:e,configurable:!0}),"__name$31"),M7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?w7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&UD(e,t,s),s},"__decorateClass$15");let ph=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[0,360])}},"CAngleRange");A7(ph,"CAngleRange");ph=M7([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,label:"Angle",inputComponent:BD,inputComponentProps:{min:0,max:360,maxDet:360}})],ph);var S7=Object.defineProperty,wf=u((n,e)=>S7(n,"name",{value:e,configurable:!0}),"__name$30"),T7=zt({props:{value:{type:P,required:!0},readonly:Boolean,disabled:Boolean,resettable:Boolean,defaultValue:P},emits:["input"],setup(n,e){const t=He(),i=He(),s=He();let r=!1;function o(){r&&(c(),document.removeEventListener("mousedown",o))}u(o,"postOnMouseDown"),wf(o,"postOnMouseDown");function a(f){return Number(f.toFixed(3))}u(a,"format"),wf(a,"format");function l(){r||(r=!0,document.addEventListener("mousedown",o))}u(l,"onChange"),wf(l,"onChange"),il(function(){document.removeEventListener("mousedown",o)});function c(){var f,d,p;if(r){r=!1;let g=Number(((f=t.value)==null?void 0:f.value)||"0")||0,m=Number(((d=i.value)==null?void 0:d.value)||"0")||0,v=Number(((p=s.value)==null?void 0:p.value)||"0")||0;e.emit("input",new P(g,m,v))}}u(c,"onPost"),wf(c,"onPost");function h(){const f=new P;n.defaultValue&&f.copy(n.defaultValue),e.emit("input",f)}return u(h,"onReset"),wf(h,"onReset"),{input0:t,input1:i,input2:s,format:a,onChange:l,onPost:c,onReset:h}}});const C7=u(n=>(tl("data-v-792b48dc"),n=n(),nl(),n),"_withScopeId$3"),E7={class:"input-vec3"},P7=["value","readonly","disabled"],R7=["value","readonly","disabled"],I7=["value","readonly","disabled"],D7=C7(()=>ue("img",{src:V1,alt:""},null,-1)),L7=[D7];function O7(n,e,t,i,s,r){return Te(),Be("div",E7,[ue("input",{type:"text",placeholder:"x",value:n.format(n.value.x),readonly:n.readonly,disabled:n.disabled,onInput:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[1]||(e[1]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[2]||(e[2]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input0"},null,40,P7),ue("input",{type:"text",placeholder:"y",value:n.format(n.value.y),readonly:n.readonly,disabled:n.disabled,onInput:e[3]||(e[3]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[4]||(e[4]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[5]||(e[5]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input1"},null,40,R7),ue("input",{type:"text",placeholder:"z",value:n.format(n.value.z),readonly:n.readonly,disabled:n.disabled,onInput:e[6]||(e[6]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[7]||(e[7]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[8]||(e[8]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input2"},null,40,I7),n.resettable?(Te(),Be("button",{key:0,class:"normal-button",onClick:e[9]||(e[9]=(...o)=>n.onReset&&n.onReset(...o))},L7)):nt("",!0)])}u(O7,"_sfc_render$m");var Np=jt(T7,[["render",O7],["__scopeId","data-v-792b48dc"]]),$D=Object.defineProperty,F7=Object.getOwnPropertyDescriptor,N7=u((n,e)=>$D(n,"name",{value:e,configurable:!0}),"__name$2$"),k7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?F7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&$D(e,t,s),s},"__decorateClass$14");let Zs=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P(1,1,1));T(this,"dirty",!0)}},"CBoxSize");N7(Zs,"CBoxSize");Zs=k7([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:Ir,label:"Size",inputComponent:Np,clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],Zs);var VD=Object.defineProperty,z7=Object.getOwnPropertyDescriptor,B7=u((n,e)=>VD(n,"name",{value:e,configurable:!0}),"__name$2_"),U7=u((n,e,t,i)=>{for(var s=i>1?void 0:i?z7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&VD(e,t,s),s},"__decorateClass$13");let Vn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!0)}},"CCastShadow");B7(Vn,"CCastShadow");Vn=U7([ke({storable:!0,dataType:De.BOOLEAN,instanceable:!0,label:"Cast Shadow",inlineLabel:!0,inputComponent:sa})],Vn);var $7=Object.defineProperty,V7=u((n,e)=>$7(n,"name",{value:e,configurable:!0}),"__name$2Z");class gw{constructor(e,t){T(this,"root");T(this,"zIndex",1e3);T(this,"show");T(this,"hide");T(this,"currentVisibleSubMenu");this.show=e,this.hide=t}handleMenuItemMouseOver(e,t){var i,s,r;(s=(i=this.currentVisibleSubMenu)==null?void 0:i.subMenu)==null||s.hide(),this.currentVisibleSubMenu=e,(r=e.subMenu)==null||r.show(t,"right")}hideAll(){this.root?this.root.hide():this.hide()}}u(gw,"PopupMenuContext");V7(gw,"PopupMenuContext");var H7=Object.defineProperty,Af=u((n,e)=>H7(n,"name",{value:e,configurable:!0}),"__name$2Y");let qm=[];var G7=zt({props:{title:String,triggerBy:{type:String,default:"mousedown"},position:{type:String,default:"bottom"},disabled:Boolean,className:String,dynamicSize:Boolean},setup(n){const e=He(),t=He(),i=He({left:0,top:0,width:"auto",height:"auto"}),s=He(!1),r=He(!1),o=new gw(f,d),a=zi("popupMenuItemContext",null);a&&(a.parent&&(o.root=a.parent.root||a.parent,o.zIndex=a.parent.zIndex+1),a.subMenu=o),Gu("popupMenuContext",o),x1(function(){o.root||qm.push(o)}),_1(function(){o.root||(qm=qm.filter(p=>p!==o)),document.body.removeEventListener("mousedown",d)});function l(p){n.triggerBy==="mousedown"&&(r.value?d():f(e.value,n.position))}u(l,"onTriggerMouseDown"),Af(l,"onTriggerMouseDown");function c(){if(n.triggerBy==="hover"||n.triggerBy==="mouseover")return f(e.value,n.position)}u(c,"onTriggerMouseOver"),Af(c,"onTriggerMouseOver");function h(p){p.key==="Escape"&&(o.root?o.hide():d())}u(h,"onKeyDown"),Af(h,"onKeyDown");async function f(p,g){if(n.disabled)return;o.root||qm.forEach(C=>C.hideAll());const m=document.body.getBoundingClientRect(),v=p.getBoundingClientRect(),y=m.width,b=m.height;r.value=!0,s.value=!1,i.value={left:0,top:0,width:"auto",height:"auto"},await qs(),document.body.addEventListener("mousedown",d),t.value.focus();const x=t.value.getBoundingClientRect();let w,_;const A=x.right-x.left,S=x.bottom-x.top;if(typeof g=="object")w=g.x,_=g.y;else switch(g){case"bottom":w=v.left,_=v.bottom;break;default:w=v.right,_=v.top;break}const M={"z-index":o.zIndex};if(n.dynamicSize?(M.width="auto",M.height="auto",s.value=!1):(M.width=Math.floor(A)+"px",M.height=Math.floor(S)+"px",M.overflow="hidden",s.value=!0),w+A>y?M.right=0:M.left=Math.floor(w)+"px",_+S>b){const C=Math.floor(Math.max(0,b-S));M.top=C+"px",M.height=Math.floor(b-C)+"px"}else M.top=Math.floor(_)+"px";i.value=M}u(f,"show"),Af(f,"show");function d(){var p,g;document.body.removeEventListener("mousedown",d),r.value=!1,(g=(p=o.currentVisibleSubMenu)==null?void 0:p.subMenu)==null||g.hide(),o.currentVisibleSubMenu=void 0}return u(d,"hide"),Af(d,"hide"),{trigger:e,menu:t,onTriggerMouseDown:l,onTriggerMouseOver:c,onKeyDown:h,style:i,scrollable:s,visible:r,show:f,hide:d}}});const W7=["disabled"],j7={class:"scroll"};function X7(n,e,t,i,s,r){return Te(),Be(kt,null,[n.title?(Te(),Be("button",{key:0,class:Mn(["popup-menu-trigger",n.className]),disabled:n.disabled,onMousedown:e[0]||(e[0]=Hn((...o)=>n.onTriggerMouseDown&&n.onTriggerMouseDown(...o),["stop"])),onMouseover:e[1]||(e[1]=(...o)=>n.onTriggerMouseOver&&n.onTriggerMouseOver(...o)),ref:"trigger"},On(n.title),43,W7)):nt("",!0),(Te(),cn(C_,{to:"body"},[n.visible?(Te(),Be("div",{key:0,class:Mn(["popup-menu",{scrollable:n.scrollable}]),style:ci(n.style),ref:"menu",tabindex:"0",onMousedown:e[2]||(e[2]=Hn(()=>{},["stop"])),onContextmenu:e[3]||(e[3]=Hn(()=>{},["prevent"])),onKeydown:e[4]||(e[4]=(...o)=>n.onKeyDown&&n.onKeyDown(...o))},[ue("div",j7,[Kd(n.$slots,"default",{},void 0,!0)])],38)):nt("",!0)]))],64)}u(X7,"_sfc_render$l");var vw=jt(G7,[["render",X7],["__scopeId","data-v-e883b650"]]),q7=Object.defineProperty,Y7=u((n,e)=>q7(n,"name",{value:e,configurable:!0}),"__name$2X"),Z7=zt({components:{ColorPicker:KI,PopupMenu:vw},props:{value:Array},emits:["input"],setup(n,e){const t=st(function(){const s=n.value||[1,1,1];return{"background-color":`#${new Ce().setRGB(s[0],s[1],s[2]).getHexString()}`}});function i(s){e.emit("input",s)}return u(i,"onInput"),Y7(i,"onInput"),{style:t,onInput:i}}});const K7={style:{padding:"8px 8px 0 8px"}};function Q7(n,e,t,i,s,r){const o=xn("color-picker"),a=xn("popup-menu");return Te(),Be("div",{class:"input-color",style:ci(n.style)},[Pe(a,{title:" "},{default:dn(()=>[ue("div",K7,[Pe(o,{value:n.value,"onUpdate:value":n.onInput},null,8,["value","onUpdate:value"])])]),_:1})],4)}u(Q7,"_sfc_render$k");var W1=jt(Z7,[["render",Q7],["__scopeId","data-v-1ea277a0"]]),HD=Object.defineProperty,J7=Object.getOwnPropertyDescriptor,e9=u((n,e)=>HD(n,"name",{value:e,configurable:!0}),"__name$2W"),t9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?J7(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&HD(e,t,s),s},"__decorateClass$12");let Ft=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[1,1,1])}},"CColor");e9(Ft,"CColor");Ft=t9([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:(n,e)=>new Ce().setRGB(n[0],n[1],n[2]).getHex()===new Ce().setRGB(e[0],e[1],e[2]).getHex(),label:"Color",inlineLabel:!0,inputComponent:W1,clone(n){return[...n]}})],Ft);var n9=zt({props:{value:Object},setup(){}});const i9={key:0,class:"credit-info"},s9=["href"],r9=["href"],o9=["href"];function a9(n,e,t,i,s,r){return n.value?(Te(),Be("div",i9,[Bo(" This work is based on "),ue("a",{href:n.value.url,target:"_blank"},On(n.value.name),9,s9),Bo(" by "),ue("a",{href:n.value.user.url,target:"_blank"},On(n.value.user.name),9,r9),Bo(" licensed under "),ue("a",{href:n.value.license.url,target:"_blank"},On(n.value.license.name),9,o9),Bo(". ")])):nt("",!0)}u(a9,"_sfc_render$j");var l9=jt(n9,[["render",a9],["__scopeId","data-v-64ad5277"]]),c9=Object.defineProperty,u9=u((n,e)=>c9(n,"name",{value:e,configurable:!0}),"__name$2V");function Vd(n){if(typeof n!="object"||!n)return n;if(Array.isArray(n))return n.map(Vd);const e={};for(let t in n)if(n.hasOwnProperty(t)){const i=n[t];typeof i=="object"?ArrayBuffer.isView(i)?e[t]=i:Array.isArray(i)?e[t]=i.map(Vd):e[t]=Vd(i):e[t]=i}return e}u(Vd,"deepClone");u9(Vd,"deepClone");var GD=Object.defineProperty,h9=Object.getOwnPropertyDescriptor,f9=u((n,e)=>GD(n,"name",{value:e,configurable:!0}),"__name$2U"),d9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?h9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&GD(e,t,s),s},"__decorateClass$11");let hp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",null)}},"CCredit");f9(hp,"CCredit");hp=d9([ke({storable:!0,dataType:De.STRING,clone:Vd,label:"Credit",inputComponent:l9,serialize(n){return n?JSON.stringify(n):""},deserialize(n){return n?JSON.parse(n):null}})],hp);var WD=Object.defineProperty,p9=Object.getOwnPropertyDescriptor,m9=u((n,e)=>WD(n,"name",{value:e,configurable:!0}),"__name$2T"),g9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?p9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&WD(e,t,s),s},"__decorateClass$10");let Pn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[0,0,0])}},"CEmissive");m9(Pn,"CEmissive");Pn=g9([ke({storable:!0,dataType:De.NUMBER_ARRAY,equal:(n,e)=>new Ce().setRGB(n[0],n[1],n[2]).getHex()===new Ce().setRGB(e[0],e[1],e[2]).getHex(),label:"Emissive",inlineLabel:!0,inputComponent:W1,clone(n){return[...n]}})],Pn);var v9=Object.defineProperty,Mf=u((n,e)=>v9(n,"name",{value:e,configurable:!0}),"__name$2S"),y9=zt({props:{value:{type:Ie,required:!0},readonly:Boolean,disabled:Boolean,resettable:Boolean,defaultValue:Ie},emits:["input"],setup(n,e){const t=He(),i=He();let s=!1;function r(){s&&(l(),document.removeEventListener("mousedown",r))}u(r,"postOnMouseDown"),Mf(r,"postOnMouseDown");function o(h){return Number(h.toFixed(3))}u(o,"format"),Mf(o,"format");function a(){s||(s=!0,document.addEventListener("mousedown",r))}u(a,"onChange"),Mf(a,"onChange"),il(function(){document.removeEventListener("mousedown",r)});function l(){var h,f;if(s){s=!1;let d=Number(((h=t.value)==null?void 0:h.value)||"0")||0,p=Number(((f=i.value)==null?void 0:f.value)||"0")||0;e.emit("input",new Ie(d,p))}}u(l,"onPost"),Mf(l,"onPost");function c(){const h=new Ie;n.defaultValue&&h.copy(n.defaultValue),e.emit("input",h)}return u(c,"onReset"),Mf(c,"onReset"),{input0:t,input1:i,format:o,onChange:a,onPost:l,onReset:c}}});const b9=u(n=>(tl("data-v-24b0778d"),n=n(),nl(),n),"_withScopeId$2"),x9={class:"input-vec2"},_9=["value","readonly","disabled"],w9=["value","readonly","disabled"],A9=b9(()=>ue("img",{src:V1,alt:""},null,-1)),M9=[A9];function S9(n,e,t,i,s,r){return Te(),Be("div",x9,[ue("input",{type:"text",placeholder:"x",value:n.format(n.value.x),readonly:n.readonly,disabled:n.disabled,onInput:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[1]||(e[1]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[2]||(e[2]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input0"},null,40,_9),ue("input",{type:"text",placeholder:"y",value:n.format(n.value.y),readonly:n.readonly,disabled:n.disabled,onInput:e[3]||(e[3]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[4]||(e[4]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[5]||(e[5]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input1"},null,40,w9),n.resettable?(Te(),Be("button",{key:0,class:"normal-button",onClick:e[6]||(e[6]=(...o)=>n.onReset&&n.onReset(...o))},M9)):nt("",!0)])}u(S9,"_sfc_render$i");var j1=jt(y9,[["render",S9],["__scopeId","data-v-24b0778d"]]),jD=Object.defineProperty,T9=Object.getOwnPropertyDescriptor,C9=u((n,e)=>jD(n,"name",{value:e,configurable:!0}),"__name$2R"),E9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?T9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&jD(e,t,s),s},"__decorateClass$$");let mc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Ie(.5,.5))}},"CEndRadius2");C9(mc,"CEndRadius2");mc=E9([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal:Ir,label:"End Radius",inputComponent:j1,clone(n){return new Ie().copy(n)},serialize(n){return[n.x,n.y]},deserialize(n){return new Ie(n[0],n[1])}})],mc);var XD=Object.defineProperty,P9=Object.getOwnPropertyDescriptor,R9=u((n,e)=>XD(n,"name",{value:e,configurable:!0}),"__name$2Q"),I9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?P9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&XD(e,t,s),s},"__decorateClass$_");let fp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[1,1,1])}},"CGroundColor");R9(fp,"CGroundColor");fp=I9([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:(n,e)=>new Ce().setRGB(n[0],n[1],n[2]).getHex()===new Ce().setRGB(e[0],e[1],e[2]).getHex(),label:"Ground Color",inputComponent:W1,clone(n){return[...n]}})],fp);var qD=Object.defineProperty,D9=Object.getOwnPropertyDescriptor,L9=u((n,e)=>qD(n,"name",{value:e,configurable:!0}),"__name$2P"),O9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?D9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&qD(e,t,s),s},"__decorateClass$Z");let ln=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.5)}},"CHeight");L9(ln,"CHeight");ln=O9([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Height",inputComponent:si,inputComponentProps:{min:0,step:.001}})],ln);var YD=Object.defineProperty,F9=Object.getOwnPropertyDescriptor,N9=u((n,e)=>YD(n,"name",{value:e,configurable:!0}),"__name$2O"),k9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?F9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&YD(e,t,s),s},"__decorateClass$Y");let Ja=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[-180,180])}},"CHingeAngleRange");N9(Ja,"CHingeAngleRange");Ja=k9([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,label:"Hinge Limit",inputComponent:BD,inputComponentProps:{min:-360,max:360,maxDet:360}})],Ja);var z9=Object.defineProperty,B9=u((n,e)=>z9(n,"name",{value:e,configurable:!0}),"__name$2N"),U9=zt({props:{value:String,disabled:Boolean,options:Array},emits:["input"],setup(n,e){const t=He();function i(){const s=t.value;s&&e.emit("input",s.value)}return u(i,"onChange"),B9(i,"onChange"),{selectDom:t,onChange:i}}});const $9=["value","disabled"],V9=["value"];function H9(n,e,t,i,s,r){return Te(),Be("select",{class:"input-select",value:n.value,disabled:n.disabled,onChange:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),ref:"selectDom"},[(Te(!0),Be(kt,null,Ga(n.options,o=>(Te(),Be("option",{key:o,value:o},On(o),9,V9))),128))],40,$9)}u(H9,"_sfc_render$h");var Ec=jt(U9,[["render",H9],["__scopeId","data-v-f534510c"]]),ZD=Object.defineProperty,G9=Object.getOwnPropertyDescriptor,W9=u((n,e)=>ZD(n,"name",{value:e,configurable:!0}),"__name$2M"),j9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?G9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&ZD(e,t,s),s},"__decorateClass$X");let gs=u(class extends Fe{constructor(){super(...arguments);T(this,"value","none")}},"CHingeAxis");W9(gs,"CHingeAxis");gs=j9([ke({storable:!0,dataType:De.STRING,autoCopy:!0,label:"Hinge",inputComponent:Ec,inputComponentProps:{options:["none","horizontal","vertical"]}})],gs);var KD=Object.defineProperty,X9=Object.getOwnPropertyDescriptor,q9=u((n,e)=>KD(n,"name",{value:e,configurable:!0}),"__name$2L"),Y9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?X9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&KD(e,t,s),s},"__decorateClass$W");const Cy=24,Di=new P;let At=u(class extends Fe{constructor(){super(...arguments);T(this,"value");T(this,"dirty",!0);T(this,"start",new P);T(this,"end",new P);T(this,"quaternion",new je);T(this,"boneMesh");T(this,"hingeIndicator");T(this,"moveHandler");T(this,"rotateHandler");T(this,"moveHandlerHovered",!1);T(this,"moveHandlerZ",0);T(this,"rotateHandlerHovered",!1);T(this,"rotateHandlerZ",0);T(this,"hingeEnabled",!1)}onRemoved(){var e,t;this.boneMesh&&(pc(this.boneMesh),this.boneMesh.removeFromParent()),this.hingeIndicator&&(pc(this.hingeIndicator),this.hingeIndicator.removeFromParent()),this.moveHandler&&(this.moveHandler.geometry.dispose(),(e=this.moveHandler.material)==null||e.dispose(),this.moveHandler.removeFromParent()),this.rotateHandler&&(this.rotateHandler.geometry.dispose(),(t=this.rotateHandler.material)==null||t.dispose(),this.rotateHandler.removeFromParent())}updateHandlersHoverState(e,t){var i,s;(i=this.moveHandler)!=null&&i.visible&&(Di.copy(this.start).applyMatrix4(e.getParentWorldMatrix()).project(t.camera.get()),Di.x+=1,Di.y+=1,Di.x*=t.width/2,Di.y*=t.height/2,this.moveHandlerZ=Di.z,Math.abs(t.mouseScr.x-Di.x)<=Cy/2&&Math.abs(t.mouseScr.y-Di.y)<=Cy/2&&(this.moveHandlerHovered=!0)),(s=this.rotateHandler)!=null&&s.visible&&(Di.copy(this.end).applyMatrix4(e.getParentWorldMatrix()).project(t.camera.get()),Di.x+=1,Di.y+=1,Di.x*=t.width/2,Di.y*=t.height/2,this.rotateHandlerZ=Di.z,Math.sqrt((t.mouseScr.x-Di.x)**2+(t.mouseScr.y-Di.y)**2)<=Cy/2&&(this.rotateHandlerHovered=!0)),this.moveHandlerHovered&&this.rotateHandlerHovered&&(this.moveHandlerZ<this.rotateHandlerZ?this.rotateHandlerHovered=!1:this.moveHandlerHovered=!1)}resetHandlers(e){this.moveHandlerHovered=!1,this.rotateHandlerHovered=!1,this.boneMesh&&(this.boneMesh.visible=e.options.showIkBones),this.hingeIndicator&&(this.hingeIndicator.visible=e.options.showIkBones&&this.hingeEnabled),this.moveHandler&&(this.moveHandler.visible=!1),this.rotateHandler&&(this.rotateHandler.visible=!1)}},"CIkNode");q9(At,"CIkNode");At=Y9([ke({})],At);var QD=Object.defineProperty,Z9=Object.getOwnPropertyDescriptor,K9=u((n,e)=>QD(n,"name",{value:e,configurable:!0}),"__name$2K"),Q9=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Z9(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&QD(e,t,s),s},"__decorateClass$V");let Ji=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.2)}},"CIkNodeLength");K9(Ji,"CIkNodeLength");Ji=Q9([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,equal(n,e){return Math.abs(n-e)<1e-8},label:"Length",inputComponent:si,inputComponentProps:{min:0}})],Ji);var J9=Object.defineProperty,Sf=u((n,e)=>J9(n,"name",{value:e,configurable:!0}),"__name$2J"),ej=zt({props:{value:{type:ht,required:!0},readonly:Boolean,disabled:Boolean,resettable:Boolean},emits:["input"],setup(n,e){const t=He(),i=He(),s=He();let r=!1;function o(){r&&(c(),document.removeEventListener("mousedown",o))}u(o,"postOnMouseDown"),Sf(o,"postOnMouseDown");function a(f){return Number((f/Math.PI*180).toFixed(1))}u(a,"format"),Sf(a,"format");function l(){r||(r=!0,document.addEventListener("mousedown",o))}u(l,"onChange"),Sf(l,"onChange"),il(function(){document.removeEventListener("mousedown",o)});function c(){var f,d,p;if(r){r=!1;let g=Number(((f=t.value)==null?void 0:f.value)||"0")||0,m=Number(((d=i.value)==null?void 0:d.value)||"0")||0,v=Number(((p=s.value)==null?void 0:p.value)||"0")||0;e.emit("input",new ht(g/180*Math.PI,m/180*Math.PI,v/180*Math.PI))}}u(c,"onPost"),Sf(c,"onPost");function h(){e.emit("input",new ht)}return u(h,"onReset"),Sf(h,"onReset"),{input0:t,input1:i,input2:s,format:a,onChange:l,onPost:c,onReset:h}}});const tj=u(n=>(tl("data-v-6ff85571"),n=n(),nl(),n),"_withScopeId$1"),nj={class:"input-euler"},ij=["value","readonly","disabled"],sj=["value","readonly","disabled"],rj=["value","readonly","disabled"],oj=tj(()=>ue("img",{src:V1,alt:""},null,-1)),aj=[oj];function lj(n,e,t,i,s,r){return Te(),Be("div",nj,[ue("input",{type:"text",placeholder:"x",value:n.format(n.value.x),readonly:n.readonly,disabled:n.disabled,onInput:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[1]||(e[1]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[2]||(e[2]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input0"},null,40,ij),ue("input",{type:"text",placeholder:"y",value:n.format(n.value.y),readonly:n.readonly,disabled:n.disabled,onInput:e[3]||(e[3]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[4]||(e[4]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[5]||(e[5]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input1"},null,40,sj),ue("input",{type:"text",placeholder:"z",value:n.format(n.value.z),readonly:n.readonly,disabled:n.disabled,onInput:e[6]||(e[6]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[7]||(e[7]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[8]||(e[8]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"input2"},null,40,rj),n.resettable?(Te(),Be("button",{key:0,class:"normal-button",onClick:e[9]||(e[9]=(...o)=>n.onReset&&n.onReset(...o))},aj)):nt("",!0)])}u(lj,"_sfc_render$g");var JD=jt(ej,[["render",lj],["__scopeId","data-v-6ff85571"]]),eL=Object.defineProperty,cj=Object.getOwnPropertyDescriptor,uj=u((n,e)=>eL(n,"name",{value:e,configurable:!0}),"__name$2I"),hj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?cj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&eL(e,t,s),s},"__decorateClass$U");let Sn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new ht)}},"CIkNodeRotation");uj(Sn,"CIkNodeRotation");Sn=hj([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal(n,e){return Math.abs(n.x-e.x)<1e-8&&Math.abs(n.y-e.y)<1e-8&&Math.abs(n.z-e.z)<1e-8},label:"Rotation",inputComponent:JD,inputComponentProps:{resettable:!0},clone(n){return new ht().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new ht(n[0],n[1],n[2])}})],Sn);var fj=Object.defineProperty,dj=u((n,e)=>fj(n,"name",{value:e,configurable:!0}),"__name$2H"),pj=zt({props:{value:String,accept:String},emits:["input"],setup(n,e){const t=He();async function i(){var o;if(!((o=t.value)!=null&&o.files))return;const s=t.value.files[0];if(!s)return;const r=await new Promise(function(a,l){const c=new FileReader;c.onload=function(){a(c.result)},c.onerror=l,c.readAsDataURL(s)});t.value.value="",e.emit("input",r)}return u(i,"onChange"),dj(i,"onChange"),{input:t,onChange:i}}});const mj={class:"input-file normal-button"},gj=["accept"];function vj(n,e,t,i,s,r){return Te(),Be("div",null,[ue("label",mj,[ue("input",{type:"file",ref:"input",onChange:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),accept:n.accept},null,40,gj),Bo(" ... ")])])}u(vj,"_sfc_render$f");var tL=jt(pj,[["render",vj],["__scopeId","data-v-cd0c5822"]]),nL=Object.defineProperty,yj=Object.getOwnPropertyDescriptor,bj=u((n,e)=>nL(n,"name",{value:e,configurable:!0}),"__name$2G"),xj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?yj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&nL(e,t,s),s},"__decorateClass$T");let io=u(class extends Fe{constructor(){super(...arguments);T(this,"value","");T(this,"dirty",!0);T(this,"texture")}onRemoved(){this.texture&&this.texture.dispose()}},"CImage");bj(io,"CImage");io=xj([ke({storable:!0,dataType:De.STRING,label:"Image File",inputComponent:tL,inputComponentProps:{accept:"image/png, image/jpeg, image/webp"}})],io);var iL=Object.defineProperty,_j=Object.getOwnPropertyDescriptor,wj=u((n,e)=>iL(n,"name",{value:e,configurable:!0}),"__name$2F"),Aj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?_j(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&iL(e,t,s),s},"__decorateClass$S");let Yo=u(class extends Fe{constructor(){super(...arguments);T(this,"value","");T(this,"dirty",!0)}},"CImportFbx");wj(Yo,"CImportFbx");Yo=Aj([ke({storable:!0,dataType:De.STRING,label:".fbx File",inputComponent:tL,inputComponentProps:{accept:".fbx"}})],Yo);var Mj=Object.defineProperty,Sj=u((n,e)=>Mj(n,"name",{value:e,configurable:!0}),"__name$2E"),Tj=zt({props:{value:String,accept:String},emits:["input"],setup(n,e){const t=He();async function i(){var o;if(!((o=t.value)!=null&&o.files))return;const s=t.value.files[0];if(!s)return;const r=await new Promise(function(a,l){const c=new FileReader;c.onload=function(){a(c.result)},c.onerror=l,c.readAsText(s)});t.value.value="",e.emit("input",r)}return u(i,"onChange"),Sj(i,"onChange"),{input:t,onChange:i}}});const Cj={class:"input-file normal-button"},Ej=["accept"];function Pj(n,e,t,i,s,r){return Te(),Be("div",null,[ue("label",Cj,[ue("input",{type:"file",ref:"input",onChange:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),accept:n.accept},null,40,Ej),Bo(" ... ")])])}u(Pj,"_sfc_render$e");var Rj=jt(Tj,[["render",Pj],["__scopeId","data-v-51992a25"]]),sL=Object.defineProperty,Ij=Object.getOwnPropertyDescriptor,Dj=u((n,e)=>sL(n,"name",{value:e,configurable:!0}),"__name$2D"),Lj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Ij(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&sL(e,t,s),s},"__decorateClass$R");let Zo=u(class extends Fe{constructor(){super(...arguments);T(this,"value","");T(this,"dirty",!0)}},"CImportObj");Dj(Zo,"CImportObj");Zo=Lj([ke({storable:!0,dataType:De.STRING,label:".obj File",inputComponent:Rj,inputComponentProps:{accept:".obj"}})],Zo);var rL=Object.defineProperty,Oj=Object.getOwnPropertyDescriptor,Fj=u((n,e)=>rL(n,"name",{value:e,configurable:!0}),"__name$2C"),Nj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Oj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&rL(e,t,s),s},"__decorateClass$Q");let Ko=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Uint8Array);T(this,"dirty",!0)}},"CImportReadonlyGltf");Fj(Ko,"CImportReadonlyGltf");Ko=Nj([ke({storable:!0,dataType:De.BYTES})],Ko);var oL=Object.defineProperty,kj=Object.getOwnPropertyDescriptor,zj=u((n,e)=>oL(n,"name",{value:e,configurable:!0}),"__name$2B"),Bj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?kj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&oL(e,t,s),s},"__decorateClass$P");let gc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.25)}},"CInnerRadius");zj(gc,"CInnerRadius");gc=Bj([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Section Radius",inputComponent:si,inputComponentProps:{min:0,step:.001}})],gc);var Uj=Object.defineProperty,Ym=u((n,e)=>Uj(n,"name",{value:e,configurable:!0}),"__name$2A"),$j=zt({props:{value:Number,min:{type:Number,required:!0},max:{type:Number,required:!0},step:Number},emits:["input"],setup(n,e){const t=st(function(){return n.step?Math.round(n.min/n.step):n.min}),i=st(function(){return n.step?Math.round(n.max/n.step):n.max}),s=st(function(){const d=n.value==null?0:n.value;return n.step?Math.round(d/n.step):d}),r=st(function(){const d=n.value==null?0:n.value;return n.step?d.toFixed(-Math.log10(n.step)):d});function o(d){let p=Number(d.target.value);n.step&&(p*=n.step),e.emit("input",p)}u(o,"onRangeInput"),Ym(o,"onRangeInput");const a=He();let l=!1;function c(){l&&(f(),document.removeEventListener("mousedown",c))}u(c,"postOnMouseDown"),Ym(c,"postOnMouseDown");function h(){l||(l=!0,document.addEventListener("mousedown",c))}u(h,"onChange"),Ym(h,"onChange"),il(function(){document.removeEventListener("mousedown",c)});function f(){if(l){l=!1;const d=a.value;if(d){const p=d.value;let g=Number(p);isFinite(g)||(g=0),n.step!=null&&(g=Math.round(g/n.step)*n.step),n.min!=null&&(g=Math.max(n.min,g)),n.max!=null&&(g=Math.min(n.max,g)),e.emit("input",g)}}}return u(f,"onPost"),Ym(f,"onPost"),{inputDom:a,onChange:h,onPost:f,iMin:t,iMax:i,iValue:s,text:r,onRangeInput:o}}});const Vj={class:"input-range"},Hj=["value","min","max"],Gj=["value"];function Wj(n,e,t,i,s,r){return Te(),Be("div",Vj,[ue("input",{class:"range",type:"range",value:n.iValue,min:n.iMin,max:n.iMax,onInput:e[0]||(e[0]=(...o)=>n.onRangeInput&&n.onRangeInput(...o))},null,40,Hj),ue("input",{class:"num",type:"text",value:n.text,onInput:e[1]||(e[1]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[2]||(e[2]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[3]||(e[3]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"inputDom"},null,40,Gj)])}u(Wj,"_sfc_render$d");var al=jt($j,[["render",Wj],["__scopeId","data-v-63841fa7"]]),aL=Object.defineProperty,jj=Object.getOwnPropertyDescriptor,Xj=u((n,e)=>aL(n,"name",{value:e,configurable:!0}),"__name$2z"),qj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?jj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&aL(e,t,s),s},"__decorateClass$O");let mh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",0)}},"CInnerRotation");Xj(mh,"CInnerRotation");mh=qj([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Section Rotation",inputComponent:al,inputComponentProps:{min:0,max:360,step:.1}})],mh);var lL=Object.defineProperty,Yj=Object.getOwnPropertyDescriptor,Zj=u((n,e)=>lL(n,"name",{value:e,configurable:!0}),"__name$2y"),Kj=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Yj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&lL(e,t,s),s},"__decorateClass$N");let gh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",32)}},"CInnerSegments");Zj(gh,"CInnerSegments");gh=Kj([ke({storable:!0,dataType:De.NUMBER,label:"Section Segments",inlineLabel:!0,inputComponent:si})],gh);var cL=Object.defineProperty,Qj=Object.getOwnPropertyDescriptor,Jj=u((n,e)=>cL(n,"name",{value:e,configurable:!0}),"__name$2x"),eX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Qj(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&cL(e,t,s),s},"__decorateClass$M");let qi=u(class extends Fe{constructor(){super(...arguments);T(this,"value",1)}},"CIntensity");Jj(qi,"CIntensity");qi=eX([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,equal(n,e){return Math.abs(n-e)<1e-8},label:"Intensity",inputComponent:si,inputComponentProps:{min:0,step:.001}})],qi);var uL=Object.defineProperty,tX=Object.getOwnPropertyDescriptor,nX=u((n,e)=>uL(n,"name",{value:e,configurable:!0}),"__name$2w"),iX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?tX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&uL(e,t,s),s},"__decorateClass$L");let es=u(class extends Fe{constructor(){super(...arguments);T(this,"value",null);T(this,"camera",null)}onRemoved(){this.value&&(pc(this.value),this.value.removeFromParent(),this.value=null),this.camera&&(pc(this.camera),this.camera.removeFromParent(),this.camera=null)}},"CLightHelper");nX(es,"CLightHelper");es=iX([ke({})],es);var hL=Object.defineProperty,sX=Object.getOwnPropertyDescriptor,rX=u((n,e)=>hL(n,"name",{value:e,configurable:!0}),"__name$2v"),oX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?sX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&hL(e,t,s),s},"__decorateClass$K");let dp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!1)}},"CLockEnd");rX(dp,"CLockEnd");dp=oX([ke({storable:!0,dataType:De.BOOLEAN,autoCopy:!0,label:"Lock End",inlineLabel:!0,inputComponent:sa})],dp);var fL=Object.defineProperty,aX=Object.getOwnPropertyDescriptor,lX=u((n,e)=>fL(n,"name",{value:e,configurable:!0}),"__name$2u"),cX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?aX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&fL(e,t,s),s},"__decorateClass$J");let Wo=u(class extends Fe{constructor(){super(...arguments);T(this,"value","512")}},"CMapSize");lX(Wo,"CMapSize");Wo=cX([ke({storable:!0,dataType:De.STRING,autoCopy:!0,label:"Shadow Quality",inputComponent:Ec,inputComponentProps:{options:["128","256","512","1024","2048"]}})],Wo);var dL=Object.defineProperty,uX=Object.getOwnPropertyDescriptor,hX=u((n,e)=>dL(n,"name",{value:e,configurable:!0}),"__name$2t"),fX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?uX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&dL(e,t,s),s},"__decorateClass$I");let Rn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",0)}},"CMetalness");hX(Rn,"CMetalness");Rn=fX([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Metalness",inputComponent:al,inputComponentProps:{min:0,max:1,step:.01}})],Rn);var dX=Object.defineProperty,Ey=u((n,e)=>dX(n,"name",{value:e,configurable:!0}),"__name$2s"),pX=zt({props:{value:String,readonly:Boolean,disabled:Boolean},emits:["input"],setup(n,e){const t=He();let i=!1;function s(){i&&(o(),document.removeEventListener("mousedown",s))}u(s,"postOnMouseDown"),Ey(s,"postOnMouseDown");function r(){i||(i=!0,document.addEventListener("mousedown",s))}u(r,"onChange"),Ey(r,"onChange"),il(function(){document.removeEventListener("mousedown",s)});function o(){if(i){i=!1;const a=t.value;a&&e.emit("input",a.value)}}return u(o,"onPost"),Ey(o,"onPost"),{inputDom:t,onChange:r,onPost:o}}});const mX=["value","readonly","disabled"];function gX(n,e,t,i,s,r){return Te(),Be("input",{class:"input-string",type:"text",value:n.value,readonly:n.readonly,disabled:n.disabled,onInput:e[0]||(e[0]=(...o)=>n.onChange&&n.onChange(...o)),onBlur:e[1]||(e[1]=(...o)=>n.onPost&&n.onPost(...o)),onKeydown:e[2]||(e[2]=Dn((...o)=>n.onPost&&n.onPost(...o),["enter"])),ref:"inputDom"},null,40,mX)}u(gX,"_sfc_render$c");var vX=jt(pX,[["render",gX],["__scopeId","data-v-07fa832a"]]),pL=Object.defineProperty,yX=Object.getOwnPropertyDescriptor,bX=u((n,e)=>pL(n,"name",{value:e,configurable:!0}),"__name$2r"),xX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?yX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&pL(e,t,s),s},"__decorateClass$H");let Dt=u(class extends Fe{constructor(){super(...arguments);T(this,"value","")}},"CName");bX(Dt,"CName");Dt=xX([ke({storable:!0,dataType:De.STRING,instanceable:!0,label:"Name",inputComponent:vX})],Dt);var mL=Object.defineProperty,_X=Object.getOwnPropertyDescriptor,wX=u((n,e)=>mL(n,"name",{value:e,configurable:!0}),"__name$2q"),AX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?_X(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&mL(e,t,s),s},"__decorateClass$G");let vh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",30)}},"CNumOfSlices");wX(vh,"CNumOfSlices");vh=AX([ke({storable:!0,dataType:De.NUMBER,label:"Curve Segments",inlineLabel:!0,inputComponent:si})],vh);var gL=Object.defineProperty,MX=Object.getOwnPropertyDescriptor,SX=u((n,e)=>gL(n,"name",{value:e,configurable:!0}),"__name$2p"),TX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?MX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&gL(e,t,s),s},"__decorateClass$F");let nn=u(class extends Fe{constructor(){super(...arguments);T(this,"value",1)}},"COpacity");SX(nn,"COpacity");nn=TX([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Opacity",inputComponent:al,inputComponentProps:{min:0,max:1,step:.01}})],nn);var vL=Object.defineProperty,CX=Object.getOwnPropertyDescriptor,EX=u((n,e)=>vL(n,"name",{value:e,configurable:!0}),"__name$2o"),PX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?CX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&vL(e,t,s),s},"__decorateClass$E");let vc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.5)}},"COuterRadius");EX(vc,"COuterRadius");vc=PX([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Radius",inputComponent:si,inputComponentProps:{min:0,step:.001}})],vc);var yL=Object.defineProperty,RX=Object.getOwnPropertyDescriptor,IX=u((n,e)=>yL(n,"name",{value:e,configurable:!0}),"__name$2n"),DX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?RX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&yL(e,t,s),s},"__decorateClass$D");let yh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",360)}},"COuterRotation");IX(yh,"COuterRotation");yh=DX([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Angle",inputComponent:al,inputComponentProps:{min:0,max:360,step:.1}})],yh);var bL=Object.defineProperty,LX=Object.getOwnPropertyDescriptor,OX=u((n,e)=>bL(n,"name",{value:e,configurable:!0}),"__name$2m"),FX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?LX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&bL(e,t,s),s},"__decorateClass$C");let bh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",32)}},"COuterSegments");OX(bh,"COuterSegments");bh=FX([ke({storable:!0,dataType:De.NUMBER,label:"Segments",inlineLabel:!0,inputComponent:si})],bh);var xL=Object.defineProperty,NX=Object.getOwnPropertyDescriptor,kX=u((n,e)=>xL(n,"name",{value:e,configurable:!0}),"__name$2l"),zX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?NX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&xL(e,t,s),s},"__decorateClass$B");let pp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",0)}},"CPenumbra");kX(pp,"CPenumbra");pp=zX([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Edge Softness",inputComponent:al,inputComponentProps:{min:0,max:1,step:.01}})],pp);var _L=Object.defineProperty,BX=Object.getOwnPropertyDescriptor,UX=u((n,e)=>_L(n,"name",{value:e,configurable:!0}),"__name$2k"),$X=u((n,e,t,i)=>{for(var s=i>1?void 0:i?BX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&_L(e,t,s),s},"__decorateClass$A");let ze=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P)}},"CPosition");UX(ze,"CPosition");ze=$X([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal:Ir,label:"Position",inputComponent:Np,inputComponentProps:{resettable:!0},clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],ze);var wL=Object.defineProperty,VX=Object.getOwnPropertyDescriptor,HX=u((n,e)=>wL(n,"name",{value:e,configurable:!0}),"__name$2j"),GX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?VX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&wL(e,t,s),s},"__decorateClass$z");let ds=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.5)}},"CRadius");HX(ds,"CRadius");ds=GX([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,equal(n,e){return Math.abs(n-e)<1e-8},label:"Radius",inputComponent:si,inputComponentProps:{min:0,step:.001}})],ds);var AL=Object.defineProperty,WX=Object.getOwnPropertyDescriptor,jX=u((n,e)=>AL(n,"name",{value:e,configurable:!0}),"__name$2i"),XX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?WX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&AL(e,t,s),s},"__decorateClass$y");let xr=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P(.5,.5,.5))}},"CRadius3");jX(xr,"CRadius3");xr=XX([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:Ir,label:"Radius",inputComponent:Np,clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],xr);var ML=Object.defineProperty,qX=Object.getOwnPropertyDescriptor,YX=u((n,e)=>ML(n,"name",{value:e,configurable:!0}),"__name$2h"),ZX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?qX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&ML(e,t,s),s},"__decorateClass$x");let Xi=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!0)}},"CReceiveShadow");YX(Xi,"CReceiveShadow");Xi=ZX([ke({storable:!0,dataType:De.BOOLEAN,instanceable:!0,label:"Receive Shadow",inlineLabel:!0,inputComponent:sa})],Xi);var SL=Object.defineProperty,KX=Object.getOwnPropertyDescriptor,QX=u((n,e)=>SL(n,"name",{value:e,configurable:!0}),"__name$2g"),JX=u((n,e,t,i)=>{for(var s=i>1?void 0:i?KX(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&SL(e,t,s),s},"__decorateClass$w");let tt=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new ht)}},"CRotation");QX(tt,"CRotation");tt=JX([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal(n,e){return Math.abs(n.x-e.x)<1e-8&&Math.abs(n.y-e.y)<1e-8&&Math.abs(n.z-e.z)<1e-8},label:"Rotation",inputComponent:JD,inputComponentProps:{resettable:!0},clone(n){return new ht().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new ht(n[0],n[1],n[2])}})],tt);var TL=Object.defineProperty,eq=Object.getOwnPropertyDescriptor,tq=u((n,e)=>TL(n,"name",{value:e,configurable:!0}),"__name$2f"),nq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?eq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&TL(e,t,s),s},"__decorateClass$v");let In=u(class extends Fe{constructor(){super(...arguments);T(this,"value",1)}},"CRoughness");tq(In,"CRoughness");In=nq([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Roughness",inputComponent:al,inputComponentProps:{min:0,max:1,step:.01}})],In);var CL=Object.defineProperty,iq=Object.getOwnPropertyDescriptor,sq=u((n,e)=>CL(n,"name",{value:e,configurable:!0}),"__name$2e"),rq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?iq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&CL(e,t,s),s},"__decorateClass$u");let Os=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.05)}},"CRoundRadius");sq(Os,"CRoundRadius");Os=rq([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Round Radius",inputComponent:si,inputComponentProps:{min:0,step:.001}})],Os);var EL=Object.defineProperty,oq=Object.getOwnPropertyDescriptor,aq=u((n,e)=>EL(n,"name",{value:e,configurable:!0}),"__name$2d"),lq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?oq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&EL(e,t,s),s},"__decorateClass$t");let Wt=u(class extends Fe{constructor(){super(...arguments);T(this,"value",1)}},"CScale");aq(Wt,"CScale");Wt=lq([ke({storable:!0,dataType:De.NUMBER,instanceable:!0,equal(n,e){return Math.abs(n-e)<1e-8},label:"Scale",inputComponent:si,inputComponentProps:{resettable:!0,defaultValue:1}})],Wt);var PL=Object.defineProperty,cq=Object.getOwnPropertyDescriptor,uq=u((n,e)=>PL(n,"name",{value:e,configurable:!0}),"__name$2c"),hq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?cq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&PL(e,t,s),s},"__decorateClass$s");let Et=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P(1,1,1))}},"CScale3");uq(Et,"CScale3");Et=hq([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal:Ir,label:"Scale",inputComponent:Np,inputComponentProps:{resettable:!0,defaultValue:new P(1,1,1)},clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],Et);var RL=Object.defineProperty,fq=Object.getOwnPropertyDescriptor,dq=u((n,e)=>RL(n,"name",{value:e,configurable:!0}),"__name$2b"),pq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?fq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&RL(e,t,s),s},"__decorateClass$r");let Ds=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!0);T(this,"throttleHash","")}},"CSdfDirty");dq(Ds,"CSdfDirty");Ds=pq([ke({})],Ds);var IL=Object.defineProperty,mq=Object.getOwnPropertyDescriptor,gq=u((n,e)=>IL(n,"name",{value:e,configurable:!0}),"__name$2a"),vq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?mq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&IL(e,t,s),s},"__decorateClass$q");let xh=u(class extends Fe{constructor(){super(...arguments);T(this,"value","add")}},"CSdfOperator");gq(xh,"CSdfOperator");xh=vq([ke({storable:!0,dataType:De.STRING,label:"Operator",inputComponent:Ec,inputComponentProps:{options:["add","subtract"]}})],xh);var DL=Object.defineProperty,yq=Object.getOwnPropertyDescriptor,bq=u((n,e)=>DL(n,"name",{value:e,configurable:!0}),"__name$29"),xq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?yq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&DL(e,t,s),s},"__decorateClass$p");let ni=u(class extends Fe{constructor(){super(...arguments);T(this,"value",32)}},"CSegments");bq(ni,"CSegments");ni=xq([ke({storable:!0,dataType:De.NUMBER,label:"Segments",inlineLabel:!0,inputComponent:si})],ni);var LL=Object.defineProperty,_q=Object.getOwnPropertyDescriptor,wq=u((n,e)=>LL(n,"name",{value:e,configurable:!0}),"__name$28"),Aq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?_q(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&LL(e,t,s),s},"__decorateClass$o");let mp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",10)}},"CShadowMappingRange");wq(mp,"CShadowMappingRange");mp=Aq([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Shadow Mapping Range",inputComponent:si,inputComponentProps:{min:0}})],mp);var OL=Object.defineProperty,Mq=Object.getOwnPropertyDescriptor,Sq=u((n,e)=>OL(n,"name",{value:e,configurable:!0}),"__name$27"),Tq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Mq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&OL(e,t,s),s},"__decorateClass$n");let _h=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!1)}},"CShowMoveHandler");Sq(_h,"CShowMoveHandler");_h=Tq([ke({storable:!0,dataType:De.BOOLEAN,autoCopy:!0,label:"Move Handler",inlineLabel:!0,inputComponent:sa})],_h);var FL=Object.defineProperty,Cq=Object.getOwnPropertyDescriptor,Eq=u((n,e)=>FL(n,"name",{value:e,configurable:!0}),"__name$26"),Pq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Cq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&FL(e,t,s),s},"__decorateClass$m");let wh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!0)}},"CShowRotateHandler");Eq(wh,"CShowRotateHandler");wh=Pq([ke({storable:!0,dataType:De.BOOLEAN,autoCopy:!0,label:"Rotate Handler",inlineLabel:!0,inputComponent:sa})],wh);var NL=Object.defineProperty,Rq=Object.getOwnPropertyDescriptor,Iq=u((n,e)=>NL(n,"name",{value:e,configurable:!0}),"__name$25"),Dq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Rq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&NL(e,t,s),s},"__decorateClass$l");let Mi=u(class extends Fe{constructor(){super(...arguments);T(this,"value","positive")}},"CSign");Iq(Mi,"CSign");Mi=Dq([ke({storable:!0,dataType:De.STRING,instanceable:!0,label:"Sign",inlineLabel:!0,inputComponent:Ec,inputComponentProps:{options:["positive","negative"]}})],Mi);var kL=Object.defineProperty,Lq=Object.getOwnPropertyDescriptor,Oq=u((n,e)=>kL(n,"name",{value:e,configurable:!0}),"__name$24"),Fq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Lq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&kL(e,t,s),s},"__decorateClass$k");let Ks=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P(1,1,1))}},"CSize3");Oq(Ks,"CSize3");Ks=Fq([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:Ir,label:"Size",inputComponent:Np,inputComponentProps:{resettable:!0},clone(n){return new P().copy(n)},serialize(n){return[n.x,n.y,n.z]},deserialize(n){return new P(n[0],n[1],n[2])}})],Ks);var zL=Object.defineProperty,Nq=Object.getOwnPropertyDescriptor,kq=u((n,e)=>zL(n,"name",{value:e,configurable:!0}),"__name$23"),zq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Nq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&zL(e,t,s),s},"__decorateClass$j");let gp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",[1,1,1])}},"CSkyColor");kq(gp,"CSkyColor");gp=zq([ke({storable:!0,dataType:De.NUMBER_ARRAY,autoCopy:!0,equal:(n,e)=>new Ce().setRGB(n[0],n[1],n[2]).getHex()===new Ce().setRGB(e[0],e[1],e[2]).getHex(),label:"Sky Color",inputComponent:W1,clone(n){return[...n]}})],gp);var BL=Object.defineProperty,Bq=Object.getOwnPropertyDescriptor,Uq=u((n,e)=>BL(n,"name",{value:e,configurable:!0}),"__name$22"),$q=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Bq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&BL(e,t,s),s},"__decorateClass$i");let Ah=u(class extends Fe{constructor(){super(...arguments);T(this,"value",0)}},"CSliceAngleEnd");Uq(Ah,"CSliceAngleEnd");Ah=$q([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Angle End",inlineLabel:!0,inputComponent:si})],Ah);var UL=Object.defineProperty,Vq=Object.getOwnPropertyDescriptor,Hq=u((n,e)=>UL(n,"name",{value:e,configurable:!0}),"__name$21"),Gq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Vq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&UL(e,t,s),s},"__decorateClass$h");let Mh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",0)}},"CSliceAngleStart");Hq(Mh,"CSliceAngleStart");Mh=Gq([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Angle Start",inlineLabel:!0,inputComponent:si})],Mh);var $L=Object.defineProperty,Wq=Object.getOwnPropertyDescriptor,jq=u((n,e)=>$L(n,"name",{value:e,configurable:!0}),"__name$20"),Xq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Wq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&$L(e,t,s),s},"__decorateClass$g");let Sh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.5)}},"CSliceInnerRadius");jq(Sh,"CSliceInnerRadius");Sh=Xq([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Star Inner Radius",inputComponent:al,inputComponentProps:{min:0,max:1,step:.001}})],Sh);var VL=Object.defineProperty,qq=Object.getOwnPropertyDescriptor,Yq=u((n,e)=>VL(n,"name",{value:e,configurable:!0}),"__name$1$"),Zq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?qq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&VL(e,t,s),s},"__decorateClass$f");let Th=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!1)}},"CSlicePreventTwisting");Yq(Th,"CSlicePreventTwisting");Th=Zq([ke({storable:!0,dataType:De.BOOLEAN,label:"Prevent Twisting",inlineLabel:!0,inputComponent:sa})],Th);var HL=Object.defineProperty,Kq=Object.getOwnPropertyDescriptor,Qq=u((n,e)=>HL(n,"name",{value:e,configurable:!0}),"__name$1_"),Jq=u((n,e,t,i)=>{for(var s=i>1?void 0:i?Kq(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&HL(e,t,s),s},"__decorateClass$e");let Ch=u(class extends Fe{constructor(){super(...arguments);T(this,"value","ellipse")}},"CSliceShape");Qq(Ch,"CSliceShape");Ch=Jq([ke({storable:!0,dataType:De.STRING,label:"Shape",inlineLabel:!0,inputComponent:Ec,inputComponentProps:{options:["ellipse","rectangle","star"]}})],Ch);var GL=Object.defineProperty,eY=Object.getOwnPropertyDescriptor,tY=u((n,e)=>GL(n,"name",{value:e,configurable:!0}),"__name$1Z"),nY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?eY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&GL(e,t,s),s},"__decorateClass$d");let yc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Ie(.1,.1))}},"CSliceSize2End");tY(yc,"CSliceSize2End");yc=nY([ke({storable:!0,dataType:De.NUMBER_ARRAY,equal(n,e){return n.equals(e)},label:"End Size",inputComponent:j1,clone(n){return new Ie().copy(n)},serialize(n){return[n.x,n.y]},deserialize(n){return new Ie(n[0],n[1])}})],yc);var WL=Object.defineProperty,iY=Object.getOwnPropertyDescriptor,sY=u((n,e)=>WL(n,"name",{value:e,configurable:!0}),"__name$1Y"),rY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?iY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&WL(e,t,s),s},"__decorateClass$c");let bc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Ie(.1,.1))}},"CSliceSize2Start");sY(bc,"CSliceSize2Start");bc=rY([ke({storable:!0,dataType:De.NUMBER_ARRAY,equal(n,e){return n.equals(e)},label:"Start Size",inputComponent:j1,clone(n){return new Ie().copy(n)},serialize(n){return[n.x,n.y]},deserialize(n){return new Ie(n[0],n[1])}})],bc);var jL=Object.defineProperty,oY=Object.getOwnPropertyDescriptor,aY=u((n,e)=>jL(n,"name",{value:e,configurable:!0}),"__name$1X"),lY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?oY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&jL(e,t,s),s},"__decorateClass$b");let Eh=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.006)}},"CSmooth");aY(Eh,"CSmooth");Eh=lY([ke({storable:!0,dataType:De.NUMBER,equal(n,e){return Math.abs(n-e)<1e-8},label:"Smooth",inputComponent:si,inputComponentProps:{min:0}})],Eh);var XL=Object.defineProperty,cY=Object.getOwnPropertyDescriptor,uY=u((n,e)=>XL(n,"name",{value:e,configurable:!0}),"__name$1W"),hY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?cY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&XL(e,t,s),s},"__decorateClass$a");let vp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",30)}},"CSpotLightAngle");uY(vp,"CSpotLightAngle");vp=hY([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Angle",inputComponent:al,inputComponentProps:{min:0,max:90,step:.1}})],vp);var qL=Object.defineProperty,fY=Object.getOwnPropertyDescriptor,dY=u((n,e)=>qL(n,"name",{value:e,configurable:!0}),"__name$1V"),pY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?fY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&qL(e,t,s),s},"__decorateClass$9");let xc=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new Ie(.5,.5))}},"CStartRadius2");dY(xc,"CStartRadius2");xc=pY([ke({storable:!0,dataType:De.NUMBER_ARRAY,instanceable:!0,equal:Ir,label:"Start Radius",inputComponent:j1,clone(n){return new Ie().copy(n)},serialize(n){return[n.x,n.y]},deserialize(n){return new Ie(n[0],n[1])}})],xc);var YL=Object.defineProperty,mY=Object.getOwnPropertyDescriptor,gY=u((n,e)=>YL(n,"name",{value:e,configurable:!0}),"__name$1U"),vY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?mY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&YL(e,t,s),s},"__decorateClass$8");let Ph=u(class extends Fe{constructor(){super(...arguments);T(this,"value",5)}},"CStarVertices");gY(Ph,"CStarVertices");Ph=vY([ke({storable:!0,dataType:De.NUMBER,label:"Star Vertices",inputComponent:si})],Ph);var ZL=Object.defineProperty,yY=Object.getOwnPropertyDescriptor,bY=u((n,e)=>ZL(n,"name",{value:e,configurable:!0}),"__name$1T"),xY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?yY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&ZL(e,t,s),s},"__decorateClass$7");let Ui=u(class extends Fe{constructor(){super(...arguments);T(this,"value","none")}},"CSymmetry");bY(Ui,"CSymmetry");Ui=xY([ke({storable:!0,dataType:De.STRING,label:"Symmetry",inputComponent:Ec,inputComponentProps:{options:["none","x","y","z"]}})],Ui);var KL=Object.defineProperty,_Y=Object.getOwnPropertyDescriptor,wY=u((n,e)=>KL(n,"name",{value:e,configurable:!0}),"__name$1S"),AY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?_Y(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&KL(e,t,s),s},"__decorateClass$6");let Qo=u(class extends Fe{constructor(){super(...arguments);T(this,"value",new P(1,1,1))}},"CTemporaryScale");wY(Qo,"CTemporaryScale");Qo=AY([ke({autoCopy:!0,clone(n){return new P().copy(n)}})],Qo);var QL=Object.defineProperty,MY=Object.getOwnPropertyDescriptor,SY=u((n,e)=>QL(n,"name",{value:e,configurable:!0}),"__name$1R"),TY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?MY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&QL(e,t,s),s},"__decorateClass$5");let yp=u(class extends Fe{constructor(){super(...arguments);T(this,"value","512")}},"CTextureSize");SY(yp,"CTextureSize");yp=TY([ke({storable:!0,dataType:De.STRING,autoCopy:!0,label:"Texture Quality",inputComponent:Ec,inputComponentProps:{options:["128","256","512","1024","2048"]}})],yp);var JL=Object.defineProperty,CY=Object.getOwnPropertyDescriptor,eO=u((n,e)=>JL(n,"name",{value:e,configurable:!0}),"__name$1Q"),EY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?CY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&JL(e,t,s),s},"__decorateClass$4");function yw(n){return n.map(e=>({radius:e.radius,position:new P().copy(e.position)}))}u(yw,"cloneTube");eO(yw,"cloneTube");const Hd=new Bi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0,color:2273612,opacity:.75}),Z0=Hd.clone();Z0.color.setHex(16776960);Z0.opacity=1;const Gd=Hd.clone();Gd.color.setHex(15964205);Gd.opacity=1;var gd;let dt=u((gd=class extends Fe{constructor(){super(...arguments);T(this,"value",[]);T(this,"dirty",!0);T(this,"group");T(this,"pickers",[]);T(this,"circles",[]);T(this,"lines",[]);T(this,"hovered",-1);T(this,"selected",[]);T(this,"draggingStartValue");T(this,"draggingStartMatrix");T(this,"draggingStartInvMatrix");T(this,"draggingStartNodeIndex",-1)}onRemoved(){var e;(e=this.group)==null||e.removeFromParent()}updateColor(){for(let e=0,t=this.circles.length;e<t;++e){const i=this.circles[e];if(this.selected.includes(e)||e===this.draggingStartNodeIndex?i.material=Gd:e===this.hovered?i.material=Z0:i.material=Hd,e<t-1){const s=this.lines[e];this.selected.includes(e)&&this.selected.includes(e+1)?s.material=Gd:s.material=Hd}}}addSelection(e){this.selected.includes(e)||this.selected.push(e)}clone(e=this.value){return yw(e)}},T(gd,"normalMaterial",Hd),T(gd,"hoveredMaterial",Z0),T(gd,"selectedMaterial",Gd),gd),"CTube");eO(dt,"CTube");dt=EY([ke({storable:!0,dataType:De.NUMBER_ARRAY,equal(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;++t){const s=n[t],r=e[t];if(Math.abs(s.radius-r.radius)>1e-8||!Ir(s.position,r.position))return!1}return!0},clone:yw,serialize(n){const e=[];for(let t of n)e.push(t.radius,t.position.x,t.position.y,t.position.z);return e},deserialize(n){const e=[];for(let t=0,i=n.length;t<i;t+=4)e.push({radius:n[t],position:new P(n[t+1],n[t+2],n[t+3])});return e}})],dt);var tO=Object.defineProperty,PY=Object.getOwnPropertyDescriptor,RY=u((n,e)=>tO(n,"name",{value:e,configurable:!0}),"__name$1P"),IY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?PY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&tO(e,t,s),s},"__decorateClass$3");let tr=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!1)}},"CUsePlainMaterial");RY(tr,"CUsePlainMaterial");tr=IY([ke({storable:!0,dataType:De.BOOLEAN,label:"Use Plain Material",inlineLabel:!0,inputComponent:sa})],tr);var nO=Object.defineProperty,DY=Object.getOwnPropertyDescriptor,LY=u((n,e)=>nO(n,"name",{value:e,configurable:!0}),"__name$1O"),OY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?DY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&nO(e,t,s),s},"__decorateClass$2");let ft=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!0)}},"CVisible");LY(ft,"CVisible");ft=OY([ke({storable:!0,dataType:De.BOOLEAN,instanceable:!0})],ft);var iO=Object.defineProperty,FY=Object.getOwnPropertyDescriptor,NY=u((n,e)=>iO(n,"name",{value:e,configurable:!0}),"__name$1N"),kY=u((n,e,t,i)=>{for(var s=i>1?void 0:i?FY(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&iO(e,t,s),s},"__decorateClass$1");let bp=u(class extends Fe{constructor(){super(...arguments);T(this,"value",.5)}},"CWidth");NY(bp,"CWidth");bp=kY([ke({storable:!0,dataType:De.NUMBER,autoCopy:!0,label:"Width",inputComponent:si,inputComponentProps:{min:0,step:.001}})],bp);var zY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFRJREFUSIntlDEOACEIBMH4/y/PNVqK6xEbw9TLbDQEs6LI4koIQJK5S75jOYNr8ijb/w5Odt+yLFCGlRe2XSBLFTxSALDauHRBJDcLbtHV+1O8xQcgdTP9QsaHuQAAAABJRU5ErkJggg==",BY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGJJREFUSIntlMEOwCAMQsX4/7/cXU1cIwM9rRyb8tBIbK1UcgVmKSJiMQKY5wAoFgV/m2d7EvzIvnIi2iNd93ZA5hlfQRk4a1F3A3b1tANkse+gFoIyW/AdhIVbfxHjLf1ADzNkU8v8yWLDAAAAAElFTkSuQmCC",UY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGlJREFUSIntk8EOwCAIQ8X//+futEQZSgnsRi8m+KCKOEarlZUwEAC4hUSoWmbxm8G7xxwinKzjFne8VrQtAEC3yWuLZhh+S1xXljvxUwei0+DxH4NqlRjcHjht4E1PyoAZzbJ/0Gr9pwf7m2fK2pb3HwAAAABJRU5ErkJggg==",$Y="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGJJREFUSIntlEsOABAMRFXc/8pjg1gYoZ+NeDsJr60JKX2eRyyHAWCIREyurXy17mTXql6sumUTFI3U9b7ROC1+LffcFyI/zoCJVXmwrjChbYwWMEt3Mos8/CXTgEI/ss9bVP0SW8Od0GmxAAAAAElFTkSuQmCC",VY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAEVJREFUSIljYBgFo2AUMJKi+P/////hGhkZSdJLkuHY+FQ1nKqWEDKEkDwTxS4gAGhuAVGApnGAyzBiDR88+WAUjIKBAwBuly/fa4hrDAAAAABJRU5ErkJggg==",HY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFRJREFUSIntlDEOACEIBMH4/y/PNVqK6xEbw9TLbDQEs6LI4koIQJK5S75jOYNr8ijb/w5Odt+yLFCGlRe2XSBLFTxSALDauHRBJDcLbtHV+1O8xQcgdTP9QsaHuQAAAABJRU5ErkJggg==",GY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFJJREFUSIljYBgFwx4wEqPo/////7FqZmQkSj9eg3EZTow8QcOpoZaFGI24goIYR+C1AGYwoTgg2wfoBpEDmMjVOGrBqAXEAWoUFQNb2I2C4QEA1pU/86LVRNwAAAAASUVORK5CYII=",WY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFpJREFUSIljYBgFwx4wEqvw/////1E0MjISrZdkw3GJYQMslFhCFYDPYGIsZaKucwbAAryAmCAgpGboB9HAxQEp6R6f2oFPRYQyGiGfElVg4TKEqgXeKBi6AABeBzvf6MK7nQAAAABJRU5ErkJggg==",jY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFJJREFUSIljYBgFwx4wEqvw/////1E0MjISrZegweiG4xMn2XBqqKFYIz61TGTZTikgx9u49NDcB0PfApxgaKciGKBpRkM2gJKiYuALu1Ew9AEAikNPxTqns+wAAAAASUVORK5CYII=",XY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGVJREFUSIntk0sOABAMRI24/5VrJREZMagF8TaiUdNvCJ/nATOamUnOAPUfogioQcSlCCY4LkBp0y93dtYsC8wE0SKViDmrEyQJsM9cp+hIBnXzAKDXaBd2Fu/+RUvqQ9eaf94iA4BHZ8IWGlTXAAAAAElFTkSuQmCC",qY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGRJREFUSIntlEEKACEMA63//3O9iQetTcyyCM5NbDKiYCmPv7Fo0929D5qFszBj+WwtLZdLoiKJZFdyLMkUHEmyYVqCBCkJGoIlzKmgDHu3s1xlihA+FyxRPXT6N90h/20f99AAFR1frx4A45oAAAAASUVORK5CYII=",YY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFdJREFUSIljYBgFAw0Y8Un+////P1whIyNetSQDZMOx8alqOCWWMFHunFELBrsFLKRqwJWSSMon5CRHkvSQm6mw6Rv6kYwTkBpMOCOfWpZQvbQdBUMHAADHwTPtL/6pwwAAAABJRU5ErkJggg==",ZY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFtJREFUSIntlEsOABAQQ9X971xbkRkpIoh5m9n1k4aUgn8hSeUuiR/lmgZYMQQAkqyv5NoKWgZqy+wlk5IIhqbBzAZeqO0NTKF2uN7Io0GmueZdnAmx9eML3qcABu5vvYZpbJgAAAAASUVORK5CYII=",KY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGVJREFUSIntk8EOwCAIQ63Z//8yO5kYB1iCiTvwjkhbotJaUfweME0iIqoYoPSusWXOnG/NNTPNNBwyC6wp1zodEhXt+juVmuDxDgFgTLX+GKtO4d259ybpkBO9H2F2D+5uclFQvCsPj41FND51AAAAAElFTkSuQmCC",QY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGVJREFUSIntkcEKwCAMQxvx/3+5ngo63KK2wg59pyIkMa1IkvwezB5VVY/MgKlfSMCbpjCRCfu5N2Sf+QwQGWsDwG47GuCFBjzXYo2sDTvs8YrM3H0DL1sBKytZNorS1MiQJLlDA/9ET+yIPaCNAAAAAElFTkSuQmCC",JY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHBJREFUSIntlMEOwCAIQ2X//8/dZVuMoZt0eNDYG4J9hBBK2VpexhIA8BSZ0TpJtbkXp5r3QHDJyx0KrK0JjfCrUxaHxtgzJtm8/uR99N5/LUFryKAygIGGABTz1zWNwtIA6afjlrI94U6GHsGtOXUCrECLjc6LLwMAAAAASUVORK5CYII=",eZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFRJREFUSIntkkEKACAIBLP//9lOhgdJSlc6ODdhmYFojKaJQt6AmXmPidz9FVpu3any18iMxEKcpGnBsoglS3+2sgj061pSSEDEIodFtBwegQaav1kXY2ucLK26fgAAAABJRU5ErkJggg==",tZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAF9JREFUSIntk0EOwCAIBN2m///y9m4WLIKJB+ZiRN0hRsdomuuBKpLkVhgg80oE1pknGhRlKdi9rl8CkgSArEQGz6HR+VLg1eexTKDWlCwlsPYffabeB3u9rirkTZPnA+JpX7qX66AGAAAAAElFTkSuQmCC",nZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFtJREFUSIntk0EKACAIBN3o/1+2a5iVqEQH5yJI7oopUVF8D7QkM7NLDFD1Ugx2Nd1SCABzlG9OnTeLuCYmo8sgg7DB7b9MBieRv0c0bw+R/z4WntxBWrdFEWYA0ho4CpvAbnEAAAAASUVORK5CYII=",Tf="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGNJREFUSIljYBgFAw0YiVX4/////ygaGRmJ1kvQYHTD8YmTbDilapgocgElgBTv41NLtA+QDaE47HEZiByxVLFwaEcyDNA0HyAbRowYNjDwQQQD5KYaFnItGTRg4IvrUUBzAAC2uXOjDxKDVAAAAABJRU5ErkJggg==",iZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGZJREFUSIntk8EKACEIRDP2/3959hRI4DqNnRbfLQqfNjVG83ss2gAAuohZWCeEFWTnHkXoO866pwWn4sWsCjLoCaQgTwRqBtQV7S/Fr+GQBYr4ioCBykANOBV8/VJWGgoqXTfNXV4/VTgWLIRfCQAAAABJRU5ErkJggg==",sZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAF1JREFUSIntkkkKACEMBO1h/v/l8jIDIlGJC3hInVzoVCKmFATXI+sQYKqYZNbbImhlHk+QD08zXQGAJJVF6v2I4QSruAX/VMcE1z2RSf1zynXvbkqwmnl3SoLgDBnHw1PSkFB0SwAAAABJRU5ErkJggg==",rZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAE5JREFUSIljYBgFwx4w4pP8////fxTFjIx41ZME0A3HJUY1w6lqCSFDKLaEGAMosoRYzaOWDC5LaJ6yaJ4/aJrL8RlOVuFF00JwFAw9AACJKmejS/9FQQAAAABJRU5ErkJggg==",oZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFdJREFUSIljYBgFo4BSwEiswv/////H0MzISLR+og3HxaaK4cTwKTKcFDGyDCdHnIlkm0kEOFMBOd4mKVUNmSDCC2iainBppmo+wGYIqTl5cJRFo2BoAwCKVWuoeE0X9QAAAABJRU5ErkJggg==",aZ="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAEVJREFUSIljYBgFo2AUMJKi+P/////hGhkZSdJLkuHY+FQ1nKqWEDKEkDwTxS4gAGhuAVGApnGAyzBiDR88+WAUjIKBAwBuly/fa4hrDAAAAABJRU5ErkJggg==",sO=Object.defineProperty,lZ=Object.getOwnPropertyDescriptor,cZ=u((n,e)=>sO(n,"name",{value:e,configurable:!0}),"__name$1M"),uZ=u((n,e,t,i)=>{for(var s=i>1?void 0:i?lZ(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(s=(i?o(e,t,s):o(s))||s);return i&&s&&sO(e,t,s),s},"__decorateClass");let Qt=u(class extends Fe{constructor(){super(...arguments);T(this,"value",!1)}},"CDisableFlip");cZ(Qt,"CDisableFlip");Qt=uZ([ke({storable:!0,dataType:De.BOOLEAN,instanceable:!0,label:"Disable Flip",inlineLabel:!0,inputComponent:sa})],Qt);var hZ=Object.defineProperty,rO=u((n,e)=>hZ(n,"name",{value:e,configurable:!0}),"__name$1L");const oO=[{name:"Container",label:"Container",icon:UY,showInList:!0,instanceable:!0,components:[Dt,ft,Qt,ze,tt,Wt,nn,Me],canBeRoot:!0,validChildTypes:["Container","IKChain","Image","CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier","ObjModel","FbxModel","ImportModel","Box","Shape","Clay","Mirror","AmbientLight","HemisphereLight","DirectionalLight","PointLight","SpotLight"]},{name:"IKChain",label:"IK Chain",icon:JY,showInList:!0,instanceable:!0,components:[Dt,ft,Qt,ze,tt,Wt,nn,Me,_h,dp],canBeRoot:!0,validChildTypes:["IKNode"]},{name:"IKNode",label:"IK Node",icon:eZ,showInList:!0,instanceable:!0,components:[Dt,ft,Qt,nn,Me,At,Ji,Sn,wh,gs,Ja],canBeRoot:!1,validChildTypes:["Container","IKChain","Image","CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier","ObjModel","FbxModel","ImportModel","Box","Shape","Clay","Mirror","AmbientLight","HemisphereLight","DirectionalLight","PointLight","SpotLight"]},{name:"CsgGroup",label:"Union",icon:XY,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,Ui],canBeRoot:!0,validChildTypes:["CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier"]},{name:"CsgIntersect",label:"Intersect",icon:ZY,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi],canBeRoot:!0,validChildTypes:["CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier"]},{name:"CsgHull",label:"Hull",icon:qY,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi],canBeRoot:!0,validChildTypes:["CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier"]},{name:"CsgHullChain",label:"Hull Chain",icon:YY,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi],canBeRoot:!0,validChildTypes:["CsgGroup","CsgIntersect","CsgHull","CsgHullChain","CsgCuboid","CsgEllipsoid","CsgCylinder","CsgCylinderElliptic","CsgTorus","CsgBezier"]},{name:"CsgCuboid",label:"Cuboid",icon:HY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,Ks,Os,ni],canBeRoot:!0,validChildTypes:[],defaultData:{[Os.name]:0,[Ks.name]:new P(.2,.2,.2)}},{name:"CsgEllipsoid",label:"Ellipsoid",icon:jY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,xr,ni],canBeRoot:!0,validChildTypes:[],defaultData:{[xr.name]:new P(.1,.1,.1)}},{name:"CsgCylinder",label:"Cylinder",icon:GY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,ln,ds,Os,ni],canBeRoot:!0,validChildTypes:[],defaultData:{[Os.name]:0,[ln.name]:.2,[ds.name]:.1}},{name:"CsgCylinderElliptic",label:"Cylinder Elliptic",icon:WY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,ln,xc,mc,ph,ni],canBeRoot:!0,validChildTypes:[],defaultData:{[ln.name]:.2,[xc.name]:new Ie(.1,.1),[mc.name]:new Ie(0,0)}},{name:"CsgTorus",label:"Torus",icon:KY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,vc,bh,yh,gc,gh,mh],canBeRoot:!0,validChildTypes:[],defaultData:{[vc.name]:.1,[gc.name]:.05}},{name:"CsgBezier",label:"Curve",icon:$Y,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,ze,tt,Et,nn,Me,In,Rn,Ft,Pn,Ge,Mi,Ch,bc,yc,Ph,Sh,Mh,Ah,vh,ni,Th],canBeRoot:!0,validChildTypes:["CsgBezierControlPoint"],defaultData:{[bc.name]:new Ie(.05,.05),[yc.name]:new Ie(.05,.05)},defaultChildren:[{type:"CsgBezierControlPoint",data:{[ze.name]:new P(0,0,0)}},{type:"CsgBezierControlPoint",data:{[ze.name]:new P(.2,0,0)}}]},{name:"CsgBezierControlPoint",label:"Control Point",icon:VY,showInList:!0,instanceable:!1,components:[ze,Me,Ge],canBeRoot:!1,validChildTypes:[]},{name:"Box",label:"Box",icon:zY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,Ft,Pn,In,Rn,nn,Me,Zs],canBeRoot:!0,validChildTypes:[],defaultData:{[Zs.name]:new P(.2,.2,.2)}},{name:"Shape",label:"Tube",icon:rZ,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,Ft,Pn,In,Rn,nn,Me,Ds,Eh,Ui],canBeRoot:!0,validChildTypes:["Tube"]},{name:"Tube",label:"Tube Node",icon:aZ,showInList:!0,components:[Dt,Me,xh,dt],canBeRoot:!1,validChildTypes:[]},{name:"Clay",label:"Clay",icon:BY,showInList:!0,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,In,Rn,Ft,Pn,nn,Me,Fn,Pr,Ui,Qo],canBeRoot:!0,validChildTypes:[]},{name:"Image",label:"Image",icon:tZ,showInList:!1,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,nn,Me,io],canBeRoot:!0,defaultData:{[Vn.name]:!1,[Xi.name]:!1},validChildTypes:[]},{name:"ObjModel",label:"Obj Model",icon:sZ,showInList:!1,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,tr,In,Rn,Ft,Pn,nn,Me,Zo],canBeRoot:!0,validChildTypes:[]},{name:"FbxModel",label:"Fbx Model",icon:QY,showInList:!1,instanceable:!0,mesh:!0,components:[Dt,ft,Qt,Vn,Xi,ze,tt,Wt,tr,In,Rn,Ft,Pn,nn,Me,Yo],canBeRoot:!0,validChildTypes:[]},{name:"ImportModel",label:"Import Model",icon:nZ,showInList:!1,instanceable:!0,mesh:!0,components:[hp,Dt,ft,Qt,Vn,Xi,ze,tt,Wt,tr,In,Rn,Ft,Pn,nn,Me,Ko],canBeRoot:!0,validChildTypes:[]},{name:"Mirror",label:"Mirror",icon:iZ,showInList:!0,mesh:!0,components:[Dt,ft,Qt,yp,ze,tt,Wt,Me,bp,ln,Ft],canBeRoot:!0,validChildTypes:[]},{name:"Target",label:"Target",icon:oZ,showInList:!1,instanceable:!0,fixed:!0,unique:!0,components:[ze,Me],canBeRoot:!1,validChildTypes:[]},{name:"AmbientLight",label:"Ambient Light",icon:Tf,showInList:!0,instanceable:!0,light:!0,components:[Dt,ft,Me,qi,Ft],canBeRoot:!0,defaultData:{[qi.name]:.2},validChildTypes:[]},{name:"HemisphereLight",label:"Hemisphere Light",icon:Tf,showInList:!0,instanceable:!0,light:!0,components:[Dt,ft,ze,Me,es,qi,gp,fp],canBeRoot:!0,validChildTypes:[],defaultData:{[qi.name]:.2,[ze.name]:new P(0,1,0)}},{name:"DirectionalLight",label:"Directional Light",icon:Tf,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,light:!0,components:[Dt,ft,Vn,Wo,mp,ze,Me,es,qi,Ft],canBeRoot:!0,validChildTypes:["Target"],defaultData:{[ze.name]:new P(0,1,0)},defaultChildren:[{type:"Target",selected:!1}]},{name:"PointLight",label:"Point Light",icon:Tf,showInList:!0,instanceable:!0,light:!0,components:[Dt,ft,Vn,Wo,ze,Me,es,qi,Ft],canBeRoot:!0,validChildTypes:[],defaultData:{[ze.name]:new P(0,1,0)}},{name:"SpotLight",label:"Spot Light",icon:Tf,showInList:!0,instanceable:!0,preventCreatingInstanceChild:!0,light:!0,components:[Dt,ft,Vn,Wo,pp,vp,ze,Me,es,qi,Ft],canBeRoot:!0,validChildTypes:["Target"],defaultData:{[ze.name]:new P(0,1,0)},defaultChildren:[{type:"Target",selected:!1}]}],aO={};for(let n of oO)aO[n.name]=n;function ii(n){const e=aO[n];if(!e)throw new Error(`Node def [${n}] not found`);return e}u(ii,"getModelNodeDef");rO(ii,"getModelNodeDef");function bw(n){return ii(n.type).validChildTypes.map(ii).filter(t=>t.unique?!n.children.find(i=>i.type===t.name):!0)}u(bw,"getValidChildNodeDefs");rO(bw,"getValidChildNodeDefs");var fZ=Object.defineProperty,dZ=u((n,e)=>fZ(n,"name",{value:e,configurable:!0}),"__name$1K");const Zm=new me;class lc{constructor(){T(this,"id",0);T(this,"type","");T(this,"expanded",!0);T(this,"components",{});T(this,"parent",null);T(this,"children",[]);T(this,"dirty",!0);T(this,"deleted",!1);T(this,"opacity",1);T(this,"visible",!0);T(this,"instanceId",0);T(this,"instanceMeshDirty",!0);T(this,"instanceMeshRebuild",!0);T(this,"mirrorGeometry",{})}get(e){const t=this.components[e.name];if(!t)throw new Error(`Component [${e.name}] not found`);return t}has(e){return this.components[e.name]!=null}value(e){return this.get(e).value}cloneValue(e){const t=this.get(e).value,i=is(e.name);return i.clone?i.clone(t):t}forEach(e){const t=[this];for(;;){const i=t.pop();if(!i)break;if(e(i)===!1)return!1;for(let s=i.children.length;s--;)t.push(i.children[s])}}getLocalMatrix(){if(this.has(Me)){const e=this.value(Me);if(e)return e.matrix}return this.parent?this.parent.getLocalMatrix():Zm}getWorldMatrix(){if(this.has(Me)){const e=this.value(Me);if(e)return e.matrixWorld}return this.parent?this.parent.getWorldMatrix():Zm}getParentWorldMatrix(){return this.type==="Target"?Zm:this.parent?this.parent.getWorldMatrix():Zm}async toJson(){var t;const e=[];for(let i of this.children)e.push(await i.toJson());return{type:this.type,expanded:this.expanded,parentId:(t=this.parent)==null?void 0:t.id,instanceId:this.instanceId,data:await this.getComponentsDataJson(),children:e}}getComponentData(e){const t={};for(let i in this.components){const s=is(i);if(!(e&&!(s.instanceable||s.autoCopy))&&s.storable){let o=this.components[i].value;s.clone&&(o=s.clone(o)),t[i]=o}}return t}async getComponentsDataJson(){const e={};for(let t in this.components){const i=is(t);if(i.storable){let r=this.components[t].value;i.serialize&&(r=i.serialize(r)),r&&i.dataType===De.BYTES&&(r=await up(r)),e[t]=r}}return e}isValidChild(e){return!!bw(this).find(t=>t.name===e)}}u(lc,"ModelNode");dZ(lc,"ModelNode");var pZ=Object.defineProperty,mZ=u((n,e)=>pZ(n,"name",{value:e,configurable:!0}),"__name$1J");class xw{onValueChanged(e,t,i){i===Zs&&(t.get(Zs).dirty=!0)}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}onMoved(e,t,i,s){}}u(xw,"BoxWatcher");mZ(xw,"BoxWatcher");var gZ=Object.defineProperty,vZ=u((n,e)=>gZ(n,"name",{value:e,configurable:!0}),"__name$1I");class _w{onValueChanged(e,t,i){i===Fn?t.get(Fn).dirty=!0:i===Pr&&(t.get(Pr).dirty=!0)}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}onMoved(e,t,i,s){}}u(_w,"ClayWatcher");vZ(_w,"ClayWatcher");var yZ=Object.defineProperty,bZ=u((n,e)=>yZ(n,"name",{value:e,configurable:!0}),"__name$1H");const xZ={CsgGroup:[Ui],CsgCuboid:[Ks,Os,ni],CsgEllipsoid:[xr,ni],CsgCylinder:[ln,ds,Os,ni],CsgCylinderElliptic:[ln,xc,mc,ph,ni],CsgRoundedCuboid:[Ks,Os,ni],CsgRoundedCylinder:[ln,ds,Os,ni],CsgTorus:[gc,vc,gh,bh,mh,yh],CsgBezier:[Ch,bc,yc,Ph,Sh,Mh,Ah,vh,ni,Th],CsgBezierControlPoint:[ze]};class ww{onValueChanged(e,t,i){var s;if(!!t.has(Ge)){if([ze,tt,Wt,Et].includes(i)){const r=t.get(Ge);r.matDirty=!0,this.markCsgNodeDirty(t.parent);return}if([ft,Mi].includes(i)){this.markCsgNodeDirty(t.parent);return}(s=xZ[t.type])!=null&&s.includes(i)&&this.markCsgNodeDirty(t)}}onChildAdded(e,t,i){this.markCsgNodeDirty(t)}onBeforeChildRemoved(e,t,i){this.markCsgNodeDirty(t)}onMoved(e,t,i,s){this.markCsgNodeDirty(i),this.markCsgNodeDirty(s)}markCsgNodeDirty(e){for(;e&&e.has(Ge);){e.dirty=!0;const t=e.get(Ge);t.dirty=!0,e=e.parent}}}u(ww,"CsgWatcher");bZ(ww,"CsgWatcher");var _Z=Object.defineProperty,lO=u((n,e)=>_Z(n,"name",{value:e,configurable:!0}),"__name$1G");const wZ=[Ji,Sn,gs,Ja];function Cu(n,e){if(!n)return;n.dirty=!0;let t=Math.max(0,e?n.children.indexOf(e):0);for(let i=n.children.length;t<i;++t){const s=n.children[t],r=s.get(At);r&&(s.dirty=!0,r.dirty=!0);const o=s.get(Me);o&&(o.localTransformChanged=!0,o.worldTransformChanged=!0)}}u(Cu,"markIkChainDirty");lO(Cu,"markIkChainDirty");class Aw{onValueChanged(e,t,i){wZ.includes(i)&&Cu(t.parent,t)}onMoved(e,t,i,s){t.has(At)&&(Cu(i),Cu(s,t))}onChildAdded(e,t,i){i.has(At)&&Cu(t,i)}onBeforeChildRemoved(e,t,i){i.has(At)&&Cu(t,i)}}u(Aw,"IkNodeWatcher");lO(Aw,"IkNodeWatcher");var AZ=Object.defineProperty,MZ=u((n,e)=>AZ(n,"name",{value:e,configurable:!0}),"__name$1F");class Mw{onValueChanged(e,t,i){i===io&&(t.get(io).dirty=!0)}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}onMoved(e,t,i,s){}}u(Mw,"ImageWatcher");MZ(Mw,"ImageWatcher");var SZ=Object.defineProperty,TZ=u((n,e)=>SZ(n,"name",{value:e,configurable:!0}),"__name$1E");class Sw{onValueChanged(e,t,i){i===Zo?t.get(Zo).dirty=!0:i===Yo?t.get(Yo).dirty=!0:i===Ko&&(t.get(Ko).dirty=!0)}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}onMoved(e,t,i,s){}}u(Sw,"ImportModelWatcher");TZ(Sw,"ImportModelWatcher");var CZ=Object.defineProperty,EZ=u((n,e)=>CZ(n,"name",{value:e,configurable:!0}),"__name$1D");class Tw{onValueChanged(e,t,i){i===tr&&!t.instanceId&&e.instanceMeshUpdated(t.id,!1)}onMoved(e,t,i,s){}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}}u(Tw,"MaterialWatcher");EZ(Tw,"MaterialWatcher");var PZ=Object.defineProperty,RZ=u((n,e)=>PZ(n,"name",{value:e,configurable:!0}),"__name$1C");class Cw{onValueChanged(e,t,i){i===nn&&t.forEach(s=>s.dirty=!0)}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}onMoved(e,t,i,s){t.forEach(r=>r.dirty=!0)}}u(Cw,"OpacityWatcher");RZ(Cw,"OpacityWatcher");var IZ=Object.defineProperty,DZ=u((n,e)=>IZ(n,"name",{value:e,configurable:!0}),"__name$1B");class Ew{onValueChanged(e,t,i){i===dt?(t.get(dt).dirty=!0,t.parent&&(t.parent.dirty=!0,t.parent.get(Ds).value=!0)):i===xh?t.parent&&(t.parent.dirty=!0,t.parent.get(Ds).value=!0):(i===Ui||i===Eh)&&t.type==="Shape"&&(t.get(Ds).value=!0)}onChildAdded(e,t,i){t.type==="Shape"&&(t.dirty=!0,t.get(Ds).value=!0)}onBeforeChildRemoved(e,t,i){t.type==="Shape"&&(t.dirty=!0,t.get(Ds).value=!0)}onMoved(e,t,i,s){(i==null?void 0:i.type)==="Shape"&&(i.dirty=!0,i.get(Ds).value=!0),(s==null?void 0:s.type)==="Shape"&&(s.dirty=!0,s.get(Ds).value=!0)}}u(Ew,"SdfShapeWatcher");DZ(Ew,"SdfShapeWatcher");var LZ=Object.defineProperty,OZ=u((n,e)=>LZ(n,"name",{value:e,configurable:!0}),"__name$1A");const FZ=[ze,tt,Wt,Et,Qo];class Pw{onValueChanged(e,t,i){if(FZ.includes(i)){if(t.has(Me)){const s=t.get(Me);s.localTransformChanged=!0,s.worldTransformChanged=!0}if(t.has(Ge)){const s=t.get(Ge);s.matDirty=!0}}t.type==="Target"&&t.parent&&(t.parent.dirty=!0)}onMoved(e,t,i,s){if(t.has(Me)){t.dirty=!0;const r=t.get(Me);r.parentChanged=!0,r.worldTransformChanged=!0}}onChildAdded(e,t,i){}onBeforeChildRemoved(e,t,i){}}u(Pw,"TransformWatcher");OZ(Pw,"TransformWatcher");var NZ=Object.defineProperty,kZ=u((n,e)=>NZ(n,"name",{value:e,configurable:!0}),"__name$1z");class kp{constructor(){T(this,"nodesMap",new Map);T(this,"nodes",[]);T(this,"cameraFov",45);T(this,"cameraPerspective",!0);T(this,"cameras",[]);T(this,"watchers",[new Pw,new Aw,new Cw,new Mw,new Sw,new xw,new Ew,new ww,new _w,new Tw]);T(this,"dirty",!0);T(this,"instanceDirty",!0);T(this,"referenceMap",new Map);T(this,"selected",[])}reset(){this.selected=[],this.dirty=!1,this.instanceDirty=!1,this.referenceMap.clear();for(let e of this.nodes.map(t=>t.id))this.removeNode(e);this.cameras=[]}addSelection(e){this.selected.includes(e)||this.selected.push(e)}isNodeExists(e,t){if(t){const i=this.nodesMap.get(e);return(i==null?void 0:i.type)===t}return this.nodesMap.has(e)}forEach(e){for(let t of this.nodes)if(t.forEach(e)===!1)return!1}getNode(e){const t=this.nodesMap.get(e);if(!t)throw new Error(`Node #${e} does not exist`);return t}getSelectedNodes(){return this.selected.map(e=>this.getNode(e))}getTopmostSelectedNodes(){const e=[];for(let t of this.selected){const i=this.getNode(t);let s=!0;for(let r=i.parent;r;r=r.parent)if(this.selected.includes(r.id)){s=!1;break}s&&e.push(i)}return e}createNode(e,t,i=null,s=null,r,o){if(this.isNodeExists(e))throw new Error(`Node #${e} already exists`);const a=ii(t),l=new lc;l.id=e,l.type=t;for(let h of a.components)l.components[h.name]=new h;if(l.parent=it(i),this.instanceMeshUpdated(e,!0),o&&(l.instanceId=o,this.referenceMap.has(o)?this.referenceMap.get(o).push(e):this.referenceMap.set(o,[e]),this.instanceDirty=!0),r)for(let h in r){let f=l.components[h];if(!f&&o&&h===jn.name&&(f=l.components[h]=new jn),f){const d=is(h);f.value=d.clone?d.clone(r[h]):r[h]}}const c=i?i.children:this.nodes;if(s!=null?c.splice(s,0,l):c.push(l),this.nodesMap.set(e,l),i)for(let h of this.watchers)h.onChildAdded(this,i,l);return this.dirty=!0,l}removeNode(e){var r;if(!this.isNodeExists(e))return;const t=this.getNode(e);if(t.parent)for(let o of this.watchers)o.onBeforeChildRemoved(this,t.parent,t);t.deleted=!0,this.instanceMeshUpdated(e,!0),t.forEach(o=>{if(o.instanceId){const a=this.referenceMap.get(o.instanceId);a&&this.referenceMap.set(o.instanceId,a.filter(l=>l!==o.id)),this.instanceDirty=!0}});for(let o in t.mirrorGeometry)(r=t.mirrorGeometry[o])==null||r.dispose(),delete t.mirrorGeometry[o];t.forEach(o=>{this.nodesMap.delete(o.id);const a=this.selected.indexOf(o.id);a>=0&&this.selected.splice(a,1)});const i=t.parent?t.parent.children:this.nodes,s=i.indexOf(t);s>=0&&i.splice(s,1),t.forEach(o=>{for(let a in o.components)o.components[a].onRemoved()}),this.dirty=!0}moveNode(e,t,i,s){const r=e.parent,o=r?r.children:this.nodes;o.splice(o.indexOf(e),1);const a=t?t.children:this.nodes;if(e.parent=t,i){const l=a.indexOf(i);s?a.splice(l+1,0,e):a.splice(l,0,e)}else s?a.push(e):a.unshift(e);e.dirty=!0,this.dirty=!0;for(let l of this.watchers)l.onMoved(this,e,r,t)}setValue(e,t,i){e.get(t).value=i,e.dirty=!0,this.dirty=!0;for(let r of this.watchers)r.onValueChanged(this,e,t);if(is(t.name).autoCopy){const r=this.referenceMap.get(e.id);if(r)for(let o of r){const a=this.getNode(o);a.get(t).value=i,a.dirty=!0;for(let l of this.watchers)l.onValueChanged(this,a,t)}}}updateVertices(e,t,i,s){const r=e.get(t),o=r.value,a=e.get(Me);if(a.mesh){const l=a.mesh;if(t===Fn){l.updateVertices(i,s);for(let c=0,h=o.length;c<h;++c)o[c]=l.aPosition[c]}else if(t===Pr){l.updateColors(i,s);for(let c=0,h=o.length;c<h;++c)o[c]=l.aColor[c]}}for(let l=0,c=i.length;l<c;++l){const h=i[l];for(let f=0;f<3;++f)o[h*3+f]=s[l*3+f]}e.dirty=!0,this.dirty=!0,r.partialUpdate=!0;for(let l of this.watchers)l.onValueChanged(this,e,t)}instanceMeshUpdated(e,t){var s;const i=this.referenceMap.get(e);if(i){this.instanceDirty=!0;for(let r of i)if(this.isNodeExists(r)){const o=this.getNode(r);if(o.instanceMeshDirty=!0,o.instanceMeshRebuild=t,o.has(Ge)){let a=o.parent;for(;a&&(!a.instanceId&&a.has(Ge));){this.dirty=!0,a.dirty=!0;const l=a.get(Ge);l.dirty=!0,a=a.parent}}}}if(this.isNodeExists(e)){const r=this.getNode(e);for(let o in r.mirrorGeometry)t&&((s=r.mirrorGeometry[o])==null||s.dispose()),delete r.mirrorGeometry[o]}}}u(kp,"Model");kZ(kp,"Model");var zZ=Object.defineProperty,M0=u((n,e)=>zZ(n,"name",{value:e,configurable:!0}),"__name$1y");const BZ=200;class Rw{constructor(e){T(this,"model");T(this,"enableMerge",!0);T(this,"currentFrameRecords",[]);T(this,"redoStack",[]);T(this,"undoStack",[]);T(this,"nextNodeId",0);T(this,"deletedNodes",new Set);T(this,"dirty",!1);T(this,"lastEventTarget",null);T(this,"onPointerDown",u(e=>{this.lastEventTarget=e.target,this.enableMerge=!1},"onPointerDown"));T(this,"onKeyDown",u(e=>{this.lastEventTarget!==e.target&&(this.lastEventTarget=e.target,this.enableMerge=!1)},"onKeyDown"));this.model=e}setup(){window.addEventListener("pointerdown",this.onPointerDown),window.addEventListener("keydown",this.onKeyDown)}unload(){window.removeEventListener("pointerdown",this.onPointerDown),window.removeEventListener("keydown",this.onKeyDown)}clear(){this.dirty=!1,this.currentFrameRecords.length=0,this.redoStack.length=0,this.undoStack.length=0}save(){this.dirty=!1}update(){if(this.nextNodeId=0,!this.currentFrameRecords.length)return;if(!this.currentFrameRecords.find(l=>!l.empty)){this.currentFrameRecords.length=0;return}this.redoStack.length=0;const e=[],t=[];let i,s;for(let l of this.currentFrameRecords)e.push(l.redo),t.push(l.undo),i=i||l.getCtx,s=s||l.setCtx;let r=M0(()=>{for(let l of e)l()},"redo"),o=M0(()=>{for(let l of t)l()},"undo");r();const a=this.currentFrameRecords.map(l=>l.hash).sort().join("@");if(this.enableMerge)for(;this.undoStack.length;){const l=this.undoStack[this.undoStack.length-1];if(l.hash===a)s&&l.getCtx?s(l.getCtx()):o=l.undo,this.undoStack.pop();else break}else{const l=this.undoStack[this.undoStack.length-1];l&&!l.hash.endsWith("!")&&(l.hash+="!")}this.enableMerge=!0,this.undoStack.push({hash:a,redo:r,undo:o,getCtx:i,setCtx:s}),this.undoStack.length>=BZ&&this.undoStack.shift(),this.deletedNodes.clear(),this.currentFrameRecords.length=0,this.dirty=!0}undo(){const e=this.undoStack.pop();!e||(this.redoStack.push(e),this.model.selected=[],e.undo(),this.dirty=!0)}redo(){const e=this.redoStack.pop();!e||(this.undoStack.push(e),e.redo(),this.dirty=!0)}getNextNodeId(){if(this.nextNodeId)return this.nextNodeId;let e=0;return this.model.forEach(t=>{e=Math.max(e,t.id)}),e}createNode(e){const t=this.getNextNodeId()+1;if(this.currentFrameRecords.push({hash:"$createNode",redo:()=>{let i=t;if(e.parentId){let r=this.model.getNode(e.parentId);for(;r;r=r.parent)r.expanded=!0}const s=this.model.createNode(i++,e.type,e.parentId?this.model.getNode(e.parentId):null,null,e.data,e.instanceId);if(e.expanded!=null&&(s.expanded=e.expanded),(e.selected==null||e.selected)&&this.model.addSelection(s.id),e.children){const r=[];for(let o of e.children)r.push([s,o]);for(;r.length;){const o=r.shift();if(!o)break;const a=o[0],l=o[1],c=this.model.createNode(i++,l.type,a,null,l.data,l.instanceId);if(l.expanded!=null&&(c.expanded=l.expanded),(l.selected==null||l.selected)&&this.model.addSelection(c.id),l.children){const h=[];for(let f of l.children)h.push([c,f]);r.unshift(...h)}}}},undo:()=>{this.model.removeNode(t)}}),this.enableMerge=!1,this.nextNodeId=t,e.children){const i=[...e.children];for(;;){const s=i.pop();if(!s)break;this.nextNodeId+=1,s.children&&i.push(...s.children)}}return t}removeNode(e){if(!this.model.isNodeExists(e)||this.deletedNodes.has(e))return;class t{constructor(a,l){T(this,"id");T(this,"type");T(this,"expanded");T(this,"parentId",0);T(this,"instanceId",0);T(this,"index",0);T(this,"data");T(this,"children");this.id=a.id,this.type=a.type,this.expanded=a.expanded,a.parent&&(this.parentId=a.parent.id),this.instanceId=a.instanceId;const c=a.parent?a.parent.children:l.nodes;this.index=c.indexOf(a),this.data=a.getComponentData(),this.children=a.children.map(h=>new t(h,l))}}u(t,"NodeRecord"),M0(t,"NodeRecord");const i=new t(this.model.getNode(e),this.model),s=[i];for(;s.length;){const o=s.pop();if(!o)break;this.deletedNodes.add(o.id),s.push(...o.children)}this.currentFrameRecords.push({hash:"$removeNode",redo:()=>{this.model.removeNode(e)},undo:()=>{const o=this.model.createNode(i.id,i.type,i.parentId?this.model.getNode(i.parentId):null,i.index,i.data,i.instanceId);this.model.addSelection(o.id);const a=[[o,i.children]];for(;;){const l=a.pop();if(!l)break;const c=l[0],h=l[1];for(let f of h){const d=this.model.createNode(f.id,f.type,c,null,f.data,f.instanceId);d.expanded=f.expanded,this.model.addSelection(d.id),f.children.length&&a.push([d,f.children])}}}}),this.enableMerge=!1;const r=this.model.referenceMap.get(e);if(r)for(let o of r)this.removeNode(o)}moveNode(e,t,i,s,r){const o=e.id,a=t?t.id:0,l=i?i.id:0,c=s,h=e.parent?e.parent.id:0;let f=0,d=!1;const p=e.parent?e.parent.children:this.model.nodes,g=p.indexOf(e);if(g>0&&(f=p[g-1].id,d=!0),this.currentFrameRecords.push({hash:"$moveNode",redo:()=>{this.model.moveNode(this.model.getNode(o),a?this.model.getNode(a):null,l?this.model.getNode(l):null,c)},undo:()=>{this.model.moveNode(this.model.getNode(o),h?this.model.getNode(h):null,f?this.model.getNode(f):null,d),this.model.addSelection(o)}}),this.enableMerge=!1,r&&h!==a){if(e.has(ze)||e.has(tt)||e.has(Wt)||e.has(Et)){let m=e.getWorldMatrix();t&&(m=new me().copy(t.getWorldMatrix()).invert().multiply(m));const v=new P,y=new je,b=new P;m.decompose(v,y,b),e.has(ze)&&this.setValue(e,ze,v),e.has(tt)&&this.setValue(e,tt,new ht().setFromQuaternion(y)),e.has(Wt)&&this.setValue(e,Wt,b.x),e.has(Et)&&this.setValue(e,Et,b)}else if(e.has(dt)){let m=e.getWorldMatrix();t&&(m=new me().copy(t.getWorldMatrix()).invert().multiply(m));const v=ac(m),y=e.get(dt).clone();for(let b of y)b.position.applyMatrix4(m),b.radius*=v;this.setValue(e,dt,y)}}}setValue(e,t,i,s){const r=e.id,o=e.value(t),a=r+"#"+(s||t.name),l=is(t.name);return(l.equal?l.equal(o,i):o===i)?(this.currentFrameRecords.push({hash:a,empty:!0,redo(){},undo:()=>{this.model.setValue(this.model.getNode(r),t,o),this.model.addSelection(r)}}),!1):(this.currentFrameRecords=this.currentFrameRecords.filter(c=>c.hash!==a),this.currentFrameRecords.push({hash:a,redo:()=>{this.model.setValue(this.model.getNode(r),t,i)},undo:()=>{this.model.setValue(this.model.getNode(r),t,o),this.model.addSelection(r)}}),!0)}mergeLastRecord(e){const t=this.undoStack[this.undoStack.length-1];if(!t)return;const i=[];for(let o of e)i.push(o.node.id+"#"+(o.hashName||o.componentClass.name));let s=i.sort().join("@"),r=t.hash;r.endsWith("!")&&(r=r.substring(0,r.length-1)),s===r&&(this.undoStack.pop(),t.hash=r,this.currentFrameRecords.push(t))}updateVertices(e,t,i,s){if(!i.length)return!1;const r=e.id,o=e.value(t);let a=new Float32Array(s.length);for(let d=0,p=i.length;d<p;++d){const g=i[d];for(let m=0;m<3;++m)a[d*3+m]=o[g*3+m]}let l=i,c=i,h=s;const f=r+"#"+t.name;return this.currentFrameRecords=this.currentFrameRecords.filter(d=>d.hash!==f),this.currentFrameRecords.push({hash:f,redo:()=>{this.model.updateVertices(this.model.getNode(r),t,c,h)},undo:()=>{this.model.updateVertices(this.model.getNode(r),t,l,a),this.model.addSelection(r)},setCtx:([d,p,g,m])=>{{const v=new Set([...d,...l]),y=new Float32Array(v.size*3);for(let _=0,A=p.length;_<A;++_)y[_]=p[_];const b=[...d],x=new Set(d);let w=p.length;for(let _=0,A=l.length;_<A;++_){const S=l[_];if(!x.has(S)){b.push(S);for(let M=0;M<3;++M)y[w+M]=a[_*3+M];w+=3}}l=b,a=y}{const v=new Set([...c,...g]),y=new Float32Array(v.size*3);for(let _=0,A=h.length;_<A;++_)y[_]=h[_];const b=[...c],x=new Set(c);let w=h.length;for(let _=0,A=g.length;_<A;++_){const S=g[_];if(!x.has(S)){b.push(S);for(let M=0;M<3;++M)y[w+M]=m[_*3+M];w+=3}}c=b,h=y}},getCtx:()=>[l,a,c,h]}),!0}}u(Rw,"ModelHistory");M0(Rw,"ModelHistory");var UZ=Object.defineProperty,$Z=u((n,e)=>UZ(n,"name",{value:e,configurable:!0}),"__name$1x");class Bs{constructor(){T(this,"subSystems",[])}setup(e){}dispose(){}sub(...e){return this.subSystems.push(...e),this}update(e){this.begin(e);for(let t of this.subSystems)t.update(e);this.end(e)}}u(Bs,"UpdateSystem");$Z(Bs,"UpdateSystem");var VZ=Object.defineProperty,HZ=u((n,e)=>VZ(n,"name",{value:e,configurable:!0}),"__name$1w");class Iw extends Bs{begin(e){for(let i of e.nextFrameCallbacks)i();e.nextFrameCallbacks.length=0;const t=Date.now();for(let i of e.throttleTasks.entries())i[1].time<=t&&(i[1].callback(),e.throttleTasks.delete(i[0]))}end(e){}}u(Iw,"CallbackFireSystem");HZ(Iw,"CallbackFireSystem");var GZ=Object.defineProperty,cO=u((n,e)=>GZ(n,"name",{value:e,configurable:!0}),"__name$1v");class ku{constructor(){T(this,"mouseNdc0",new P);T(this,"rotating",!1);T(this,"eulerX0",0);T(this,"eulerY0",0);T(this,"moving",!1);T(this,"target0",new P);T(this,"mouseRayN0",new P)}}u(ku,"CameraDraggingState");cO(ku,"CameraDraggingState");const Km=new P,Qm=new P,U3=new P,$3=new P,V3=new P,WZ=40,H3=-20,Py=2.5;class Dw extends Bs{constructor(){super(...arguments);T(this,"states",[new ku,new ku,new ku,new ku])}begin(t){if(t.disableCameraDraggingThisFrame){t.disableCameraDraggingThisFrame=!1;return}let i=-1;for(let s of t.views){const r=this.states[s.index];if(!s.enabled){r.rotating=!1,r.moving=!1;continue}const o=s.input;if(s.index===t.mainViewIndex)if(o.mouseRight)if(r.rotating){const a=s.mouseNdc.x-r.mouseNdc0.x,l=s.mouseNdc.y-r.mouseNdc0.y;s.camera.alpha=Math.max(-Math.PI/2,Math.min(Math.PI/2,r.eulerX0+l*Math.PI/2)),s.camera.beta=(r.eulerY0-a*Math.PI/2)%(Math.PI*2)}else o.pointerOver&&o.mouseRightDownThisFrame&&(r.rotating=!0,r.mouseNdc0.copy(s.mouseNdc),r.eulerX0=s.camera.alpha,r.eulerY0=s.camera.beta);else r.rotating=!1;o.mouseMiddle?r.moving?(Km.copy(r.mouseNdc0),Km.z=-1,Km.unproject(s.camera.get()),Qm.copy(r.mouseNdc0),Qm.z=1,Qm.unproject(s.camera.get()),Gt(U3,Km,Qm,r.target0,r.mouseRayN0),Gt($3,s.mouseRay0,s.mouseRay1,r.target0,r.mouseRayN0),V3.subVectors($3,U3),s.camera.target.subVectors(r.target0,V3),i=s.index):o.pointerOver&&o.mouseMiddleDownThisFrame&&(r.moving=!0,r.target0.copy(s.camera.target),r.mouseNdc0.copy(s.mouseNdc),r.mouseRayN0.copy(s.mouseRayN)):r.moving=!1,o.wheelDetY&&o.pointerOver&&(s.zoomLevel=Math.max(H3,Math.min(WZ,s.zoomLevel+o.wheelDetY)),i=s.index)}if(i>=0){const s=t.views[i];for(let r of t.views)r.index!==i&&r.enabled&&(r.camera.target.copy(s.camera.target),r.zoomLevel=s.zoomLevel)}for(let s of t.views)s.enabled&&(s.camera.distance=s.zoomLevel>=0?Py+s.zoomLevel:Py-s.zoomLevel/H3*Py)}end(t){}}u(Dw,"CameraDraggingSystem");cO(Dw,"CameraDraggingSystem");var Jm=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function eg(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}u(eg,"commonjsRequire");const jZ=u(n=>{if(!Array.isArray(n))throw new Error("Bezier points must be a valid array/");if(n.length<2)throw new Error("Bezier points must contain at least 2 values.");const e=XZ(n);return{points:n,pointType:e,dimensions:e==="float_single"?0:n[0].length,permutations:G3(n.length-1),tangentPermutations:G3(n.length-2)}},"create$I"),XZ=u(function(n){let e=null;return n.forEach(t=>{let i="";if(Number.isFinite(t))i="float_single";else if(Array.isArray(t))t.forEach(s=>{if(!Number.isFinite(s))throw new Error("Bezier point values must all be numbers.")}),i="float_"+t.length;else throw new Error("Bezier points must all be numbers or arrays of number.");if(e==null)e=i;else if(e!==i)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")}),e},"getPointType"),G3=u(function(n){const e=[];for(let t=0;t<=n;t++)e.push(Ry(n)/(Ry(t)*Ry(n-t)));return e},"getPermutations"),Ry=u(function(n){let e=1;for(let t=2;t<=n;t++)e*=t;return e},"factorial");var qZ=jZ;const YZ=u((n,e)=>{if(n<0||n>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if(e.pointType==="float_single")return W3(e,e.points,n);{const t=[];for(let i=0;i<e.dimensions;i++){const s=[];for(let r=0;r<e.points.length;r++)s.push(e.points[r][i]);t.push(W3(e,s,n))}return t}},"valueAt"),W3=u(function(n,e,t){const i=e.length-1;let s=0;for(let r=0;r<=i;r++)s+=n.permutations[r]*Math.pow(1-t,i-r)*Math.pow(t,r)*e[r];return s},"bezierFunction");var ZZ=YZ;const KZ=u((n,e)=>{if(n<0||n>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if(e.pointType==="float_single")return j3(e,e.points,n);{const t=[];for(let i=0;i<e.dimensions;i++){const s=[];for(let r=0;r<e.points.length;r++)s.push(e.points[r][i]);t.push(j3(e,s,n))}return t}},"tangentAt"),j3=u(function(n,e,t){const i=e.length-1;let s=0;for(let r=0;r<i;r++){const o=i*(e[r+1]-e[r]);s+=n.tangentPermutations[r]*Math.pow(1-t,i-1-r)*Math.pow(t,r)*o}return s},"bezierTangent");var QZ=KZ,Iy={create:qZ,valueAt:ZZ,tangentAt:QZ};const JZ=1e5,eK=1e-5,tK=1e-13,nK=Math.PI*2;var at={EPS:eK,NEPS:tK,TAU:nK,spatialResolution:JZ};const uO=u(n=>n.reduce((e,t)=>Array.isArray(t)?e.concat(uO(t)):e.concat(t),[]),"flatten$t");var Xt=uO;const iK=u(n=>Object.assign({},n),"clone$b");var sK=iK;const rK=u((n,e,t)=>(n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n[3]=e[3]+t[3],n[4]=e[4]+t[4],n[5]=e[5]+t[5],n[6]=e[6]+t[6],n[7]=e[7]+t[7],n[8]=e[8]+t[8],n[9]=e[9]+t[9],n[10]=e[10]+t[10],n[11]=e[11]+t[11],n[12]=e[12]+t[12],n[13]=e[13]+t[13],n[14]=e[14]+t[14],n[15]=e[15]+t[15],n),"add$3");var oK=rK;const aK=u(()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],"create$H");var Lw=aK;const lK=Lw,cK=u(n=>{const e=lK();return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],e},"clone$a");var uK=cK;const hK=u((n,e)=>(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n),"copy$7");var hO=hK;const fK=u((n,e)=>{const t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],f=e[9],d=e[10],p=e[11],g=e[12],m=e[13],v=e[14],y=e[15],b=t*a-i*o,x=t*l-s*o,w=t*c-r*o,_=i*l-s*a,A=i*c-r*a,S=s*c-r*l,M=h*m-f*g,C=h*v-d*g,I=h*y-p*g,F=f*v-d*m,O=f*y-p*m,N=d*y-p*v;let E=b*N-x*O+w*F+_*I-A*C+S*M;return E?(E=1/E,n[0]=(a*N-l*O+c*F)*E,n[1]=(s*O-i*N-r*F)*E,n[2]=(m*S-v*A+y*_)*E,n[3]=(d*A-f*S-p*_)*E,n[4]=(l*I-o*N-c*C)*E,n[5]=(t*N-s*I+r*C)*E,n[6]=(v*w-g*S-y*x)*E,n[7]=(h*S-d*w+p*x)*E,n[8]=(o*O-a*I+c*M)*E,n[9]=(i*I-t*O-r*M)*E,n[10]=(g*A-m*w+y*b)*E,n[11]=(f*w-h*A-p*b)*E,n[12]=(a*C-o*F-l*M)*E,n[13]=(t*F-i*C+s*M)*E,n[14]=(m*x-g*_-v*b)*E,n[15]=(h*_-f*x+d*b)*E,n):null},"invert$2");var dK=fK;const pK=u((n,e)=>n[0]===e[0]&&n[1]===e[1]&&n[2]===e[2]&&n[3]===e[3]&&n[4]===e[4]&&n[5]===e[5]&&n[6]===e[6]&&n[7]===e[7]&&n[8]===e[8]&&n[9]===e[9]&&n[10]===e[10]&&n[11]===e[11]&&n[12]===e[12]&&n[13]===e[13]&&n[14]===e[14]&&n[15]===e[15],"equals$8");var mK=pK;const{NEPS:gK}=at,fO=u(n=>Math.abs(n)<gK?0:n,"rezero"),vK=u(n=>fO(Math.sin(n)),"sin$f"),yK=u(n=>fO(Math.cos(n)),"cos$f");var Ei={sin:vK,cos:yK};const bK=u(n=>(n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n),"identity$1");var dO=bK;const{EPS:xK}=at,{sin:_K,cos:wK}=Ei,AK=dO,MK=u((n,e,t)=>{let[i,s,r]=t;const o=i*i+s*s+r*r;if(Math.abs(o)<xK)return AK(n);const a=1/Math.sqrt(o);i*=a,s*=a,r*=a;const l=_K(e),c=wK(e),h=1-c;return n[0]=i*i*h+c,n[1]=s*i*h+r*l,n[2]=r*i*h-s*l,n[3]=0,n[4]=i*s*h-r*l,n[5]=s*s*h+c,n[6]=r*s*h+i*l,n[7]=0,n[8]=i*r*h+s*l,n[9]=s*r*h-i*l,n[10]=r*r*h+c,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromRotation$1");var pO=MK;const SK=u((n,e)=>(n[0]=e[0],n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=e[1],n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=e[2],n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n),"fromScaling");var TK=SK;const{sin:Dy,cos:Ly}=Ei,CK=u((n,e,t,i)=>{const s=Dy(e),r=Ly(e),o=Dy(t),a=Ly(t),l=Dy(i),c=Ly(i);return n[0]=a*r,n[1]=a*s,n[2]=-o,n[3]=0,n[4]=l*o*r-c*s,n[5]=c*r+l*o*s,n[6]=l*a,n[7]=0,n[8]=l*s+c*o*r,n[9]=c*o*s-l*r,n[10]=c*a,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromTaitBryanRotation");var EK=CK;const PK=u((n,e)=>(n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=e[0],n[13]=e[1],n[14]=e[2],n[15]=1,n),"fromTranslation");var RK=PK;const IK=Lw,DK=u((n,e,t,i,s,r,o,a,l,c,h,f,d,p,g,m)=>{const v=IK();return v[0]=n,v[1]=e,v[2]=t,v[3]=i,v[4]=s,v[5]=r,v[6]=o,v[7]=a,v[8]=l,v[9]=c,v[10]=h,v[11]=f,v[12]=d,v[13]=p,v[14]=g,v[15]=m,v},"fromValues$5");var LK=DK;const OK=u((n,e)=>(n[0]=Math.abs(e[0]),n[1]=Math.abs(e[1]),n[2]=Math.abs(e[2]),n),"abs$2");var mO=OK;const FK=u((n,e,t)=>(n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n),"add$2");var gO=FK;const NK=u((n,e)=>n[0]*e[0]+n[1]*e[1]+n[2]*e[2],"dot$5");var X1=NK;const kK=X1,zK=u((n,e)=>{const t=n[0],i=n[1],s=n[2],r=e[0],o=e[1],a=e[2],l=Math.sqrt(t*t+i*i+s*s),c=Math.sqrt(r*r+o*o+a*a),h=l*c,f=h&&kK(n,e)/h;return Math.acos(Math.min(Math.max(f,-1),1))},"angle$1");var BK=zK;const UK=u(()=>[0,0,0],"create$E");var q1=UK;const $K=q1,VK=u(n=>{const e=$K();return e[0]=n[0],e[1]=n[1],e[2]=n[2],e},"clone$9");var HK=VK;const GK=u((n,e)=>(n[0]=e[0],n[1]=e[1],n[2]=e[2],n),"copy$6");var vO=GK;const WK=u((n,e,t)=>{const i=e[0],s=e[1],r=e[2],o=t[0],a=t[1],l=t[2];return n[0]=s*l-r*a,n[1]=r*o-i*l,n[2]=i*a-s*o,n},"cross$5");var zp=WK;const jK=u((n,e)=>{const t=e[0]-n[0],i=e[1]-n[1],s=e[2]-n[2];return Math.sqrt(t*t+i*i+s*s)},"distance$2");var yO=jK;const XK=u((n,e,t)=>(n[0]=e[0]/t[0],n[1]=e[1]/t[1],n[2]=e[2]/t[2],n),"divide$1");var qK=XK;const YK=u((n,e)=>n[0]===e[0]&&n[1]===e[1]&&n[2]===e[2],"equals$7");var ZK=YK;const KK=u((n,e)=>(n[0]=e,n[1]=e,n[2]=e,n),"fromScalar$2");var QK=KK;const JK=q1,eQ=u((n,e,t)=>{const i=JK();return i[0]=n,i[1]=e,i[2]=t,i},"fromValues$4");var tQ=eQ;const nQ=u((n,e,t=0)=>(n[0]=e[0],n[1]=e[1],n[2]=t,n),"fromVector2");var iQ=nQ;const sQ=u(n=>{const e=n[0],t=n[1],i=n[2];return Math.sqrt(e*e+t*t+i*i)},"length$2");var bO=sQ;const rQ=u((n,e,t,i)=>(n[0]=e[0]+i*(t[0]-e[0]),n[1]=e[1]+i*(t[1]-e[1]),n[2]=e[2]+i*(t[2]-e[2]),n),"lerp$1");var oQ=rQ;const aQ=u((n,e,t)=>(n[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n[2]=Math.max(e[2],t[2]),n),"max$2");var xO=aQ;const lQ=u((n,e,t)=>(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n[2]=Math.min(e[2],t[2]),n),"min$1");var _O=lQ;const cQ=u((n,e,t)=>(n[0]=e[0]*t[0],n[1]=e[1]*t[1],n[2]=e[2]*t[2],n),"multiply$2");var uQ=cQ;const hQ=u((n,e)=>(n[0]=-e[0],n[1]=-e[1],n[2]=-e[2],n),"negate$1");var fQ=hQ;const dQ=u((n,e)=>{const t=e[0],i=e[1],s=e[2];let r=t*t+i*i+s*s;return r>0&&(r=1/Math.sqrt(r)),n[0]=t*r,n[1]=i*r,n[2]=s*r,n},"normalize$3");var Ow=dQ;const pQ=mO,mQ=q1,gQ=zp,vQ=u((n,e)=>{const t=pQ(mQ(),e),i=0+(t[0]<t[1]&&t[0]<t[2]),s=0+(t[1]<=t[0]&&t[1]<t[2]),r=0+(t[2]<=t[0]&&t[2]<=t[1]);return gQ(n,e,[i,s,r])},"orthogonal");var yQ=vQ;const bQ=u((n,e,t,i)=>{const s=[],r=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],r[0]=s[0],r[1]=s[1]*Math.cos(i)-s[2]*Math.sin(i),r[2]=s[1]*Math.sin(i)+s[2]*Math.cos(i),n[0]=r[0]+t[0],n[1]=r[1]+t[1],n[2]=r[2]+t[2],n},"rotateX$2");var xQ=bQ;const _Q=u((n,e,t,i)=>{const s=[],r=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],r[0]=s[2]*Math.sin(i)+s[0]*Math.cos(i),r[1]=s[1],r[2]=s[2]*Math.cos(i)-s[0]*Math.sin(i),n[0]=r[0]+t[0],n[1]=r[1]+t[1],n[2]=r[2]+t[2],n},"rotateY$2");var wQ=_Q;const AQ=u((n,e,t,i)=>{const s=[],r=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],r[0]=s[0]*Math.cos(i)-s[1]*Math.sin(i),r[1]=s[0]*Math.sin(i)+s[1]*Math.cos(i),n[0]=r[0]+t[0],n[1]=r[1]+t[1],n[2]=e[2],n},"rotateZ$2");var MQ=AQ;const SQ=u((n,e,t)=>(n[0]=e[0]*t,n[1]=e[1]*t,n[2]=e[2]*t,n),"scale$4");var wO=SQ;const TQ=u((n,e,t)=>(n[0]=Math.round(e[0]/t)*t+0,n[1]=Math.round(e[1]/t)*t+0,n[2]=Math.round(e[2]/t)*t+0,n),"snap$1");var CQ=TQ;const EQ=u((n,e)=>{const t=e[0]-n[0],i=e[1]-n[1],s=e[2]-n[2];return t*t+i*i+s*s},"squaredDistance$2");var AO=EQ;const PQ=u(n=>{const e=n[0],t=n[1],i=n[2];return e*e+t*t+i*i},"squaredLength$2");var MO=PQ;const RQ=u((n,e,t)=>(n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n),"subtract$9");var Y1=RQ;const IQ=u(n=>`[${n[0].toFixed(7)}, ${n[1].toFixed(7)}, ${n[2].toFixed(7)}]`,"toString$9");var DQ=IQ;const LQ=u((n,e,t)=>{const i=e[0],s=e[1],r=e[2];let o=t[3]*i+t[7]*s+t[11]*r+t[15];return o=o||1,n[0]=(t[0]*i+t[4]*s+t[8]*r+t[12])/o,n[1]=(t[1]*i+t[5]*s+t[9]*r+t[13])/o,n[2]=(t[2]*i+t[6]*s+t[10]*r+t[14])/o,n},"transform$a");var OQ=LQ,mt={abs:mO,add:gO,angle:BK,clone:HK,copy:vO,create:q1,cross:zp,distance:yO,divide:qK,dot:X1,equals:ZK,fromScalar:QK,fromValues:tQ,fromVec2:iQ,length:bO,lerp:oQ,max:xO,min:_O,multiply:uQ,negate:fQ,normalize:Ow,orthogonal:yQ,rotateX:xQ,rotateY:wQ,rotateZ:MQ,scale:wO,snap:CQ,squaredDistance:AO,squaredLength:MO,subtract:Y1,toString:DQ,transform:OQ};const _a=mt,FQ=pO,NQ=u((n,e,t)=>{const i=_a.normalize(_a.create(),e),s=_a.normalize(_a.create(),t),r=_a.cross(_a.create(),s,i),o=_a.dot(s,i);if(o===-1)return FQ(n,Math.PI,_a.orthogonal(r,i));const a=1/(1+o);return n[0]=r[0]*r[0]*a+o,n[1]=r[1]*r[0]*a-r[2],n[2]=r[2]*r[0]*a+r[1],n[3]=0,n[4]=r[0]*r[1]*a+r[2],n[5]=r[1]*r[1]*a+o,n[6]=r[2]*r[1]*a-r[0],n[7]=0,n[8]=r[0]*r[2]*a-r[1],n[9]=r[1]*r[2]*a+r[0],n[10]=r[2]*r[2]*a+o,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromVectorRotation");var kQ=NQ;const{sin:zQ,cos:BQ}=Ei,UQ=u((n,e)=>{const t=zQ(e),i=BQ(e);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=i,n[6]=t,n[7]=0,n[8]=0,n[9]=-t,n[10]=i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromXRotation");var $Q=UQ;const{sin:VQ,cos:HQ}=Ei,GQ=u((n,e)=>{const t=VQ(e),i=HQ(e);return n[0]=i,n[1]=0,n[2]=-t,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=t,n[9]=0,n[10]=i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromYRotation");var WQ=GQ;const{sin:jQ,cos:XQ}=Ei,qQ=u((n,e)=>{const t=jQ(e),i=XQ(e);return n[0]=i,n[1]=t,n[2]=0,n[3]=0,n[4]=-t,n[5]=i,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n},"fromZRotation");var YQ=qQ;const ZQ=u(n=>n[0]===1&&n[1]===0&&n[2]===0&&n[3]===0&&n[4]===0&&n[5]===1&&n[6]===0&&n[7]===0&&n[8]===0&&n[9]===0&&n[10]===1&&n[11]===0&&n[12]===0&&n[13]===0&&n[14]===0&&n[15]===1,"isIdentity");var KQ=ZQ;const QQ=u(n=>vo(n[1])&&vo(n[2])&&vo(n[3])&&vo(n[4])&&vo(n[6])&&vo(n[7])&&vo(n[8])&&vo(n[9])&&vo(n[11])&&n[15]===1,"isOnlyTransformScale"),vo=u(n=>Math.abs(n)<Number.EPSILON,"isZero");var JQ=QQ;const eJ=u(n=>{const e=n[4]*n[9]-n[8]*n[5],t=n[8]*n[1]-n[0]*n[9],i=n[0]*n[5]-n[4]*n[1];return e*n[2]+t*n[6]+i*n[10]<0},"isMirroring");var tJ=eJ;const nJ=u((n,e)=>{const[t,i,s,r]=e;return n[0]=1-2*t*t,n[1]=-2*i*t,n[2]=-2*s*t,n[3]=0,n[4]=-2*t*i,n[5]=1-2*i*i,n[6]=-2*s*i,n[7]=0,n[8]=-2*t*s,n[9]=-2*i*s,n[10]=1-2*s*s,n[11]=0,n[12]=2*t*r,n[13]=2*i*r,n[14]=2*s*r,n[15]=1,n},"mirrorByPlane");var iJ=nJ;const sJ=u((n,e,t)=>{const i=e[0],s=e[1],r=e[2],o=e[3],a=e[4],l=e[5],c=e[6],h=e[7],f=e[8],d=e[9],p=e[10],g=e[11],m=e[12],v=e[13],y=e[14],b=e[15];let x=t[0],w=t[1],_=t[2],A=t[3];return n[0]=x*i+w*a+_*f+A*m,n[1]=x*s+w*l+_*d+A*v,n[2]=x*r+w*c+_*p+A*y,n[3]=x*o+w*h+_*g+A*b,x=t[4],w=t[5],_=t[6],A=t[7],n[4]=x*i+w*a+_*f+A*m,n[5]=x*s+w*l+_*d+A*v,n[6]=x*r+w*c+_*p+A*y,n[7]=x*o+w*h+_*g+A*b,x=t[8],w=t[9],_=t[10],A=t[11],n[8]=x*i+w*a+_*f+A*m,n[9]=x*s+w*l+_*d+A*v,n[10]=x*r+w*c+_*p+A*y,n[11]=x*o+w*h+_*g+A*b,x=t[12],w=t[13],_=t[14],A=t[15],n[12]=x*i+w*a+_*f+A*m,n[13]=x*s+w*l+_*d+A*v,n[14]=x*r+w*c+_*p+A*y,n[15]=x*o+w*h+_*g+A*b,n},"multiply$1");var rJ=sJ;const{EPS:oJ}=at,{sin:aJ,cos:lJ}=Ei,cJ=hO,uJ=u((n,e,t,i)=>{let[s,r,o]=i;const a=s*s+r*r+o*o;if(Math.abs(a)<oJ)return cJ(n,e);const l=1/Math.sqrt(a);s*=l,r*=l,o*=l;const c=aJ(t),h=lJ(t),f=1-h,d=e[0],p=e[1],g=e[2],m=e[3],v=e[4],y=e[5],b=e[6],x=e[7],w=e[8],_=e[9],A=e[10],S=e[11],M=s*s*f+h,C=r*s*f+o*c,I=o*s*f-r*c,F=s*r*f-o*c,O=r*r*f+h,N=o*r*f+s*c,E=s*o*f+r*c,k=r*o*f-s*c,G=o*o*f+h;return n[0]=d*M+v*C+w*I,n[1]=p*M+y*C+_*I,n[2]=g*M+b*C+A*I,n[3]=m*M+x*C+S*I,n[4]=d*F+v*O+w*N,n[5]=p*F+y*O+_*N,n[6]=g*F+b*O+A*N,n[7]=m*F+x*O+S*N,n[8]=d*E+v*k+w*G,n[9]=p*E+y*k+_*G,n[10]=g*E+b*k+A*G,n[11]=m*E+x*k+S*G,e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n},"rotate$4");var hJ=uJ;const{sin:fJ,cos:dJ}=Ei,pJ=u((n,e,t)=>{const i=fJ(t),s=dJ(t),r=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=e[9],f=e[10],d=e[11];return e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[4]=r*s+c*i,n[5]=o*s+h*i,n[6]=a*s+f*i,n[7]=l*s+d*i,n[8]=c*s-r*i,n[9]=h*s-o*i,n[10]=f*s-a*i,n[11]=d*s-l*i,n},"rotateX$1");var mJ=pJ;const{sin:gJ,cos:vJ}=Ei,yJ=u((n,e,t)=>{const i=gJ(t),s=vJ(t),r=e[0],o=e[1],a=e[2],l=e[3],c=e[8],h=e[9],f=e[10],d=e[11];return e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[0]=r*s-c*i,n[1]=o*s-h*i,n[2]=a*s-f*i,n[3]=l*s-d*i,n[8]=r*i+c*s,n[9]=o*i+h*s,n[10]=a*i+f*s,n[11]=l*i+d*s,n},"rotateY$1");var bJ=yJ;const{sin:xJ,cos:_J}=Ei,wJ=u((n,e,t)=>{const i=xJ(t),s=_J(t),r=e[0],o=e[1],a=e[2],l=e[3],c=e[4],h=e[5],f=e[6],d=e[7];return e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[0]=r*s+c*i,n[1]=o*s+h*i,n[2]=a*s+f*i,n[3]=l*s+d*i,n[4]=c*s-r*i,n[5]=h*s-o*i,n[6]=f*s-a*i,n[7]=d*s-l*i,n},"rotateZ$1");var AJ=wJ;const MJ=u((n,e,t)=>{const i=t[0],s=t[1],r=t[2];return n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i,n[3]=e[3]*i,n[4]=e[4]*s,n[5]=e[5]*s,n[6]=e[6]*s,n[7]=e[7]*s,n[8]=e[8]*r,n[9]=e[9]*r,n[10]=e[10]*r,n[11]=e[11]*r,n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n},"scale$3");var SJ=MJ;const TJ=u((n,e,t)=>(n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n[3]=e[3]-t[3],n[4]=e[4]-t[4],n[5]=e[5]-t[5],n[6]=e[6]-t[6],n[7]=e[7]-t[7],n[8]=e[8]-t[8],n[9]=e[9]-t[9],n[10]=e[10]-t[10],n[11]=e[11]-t[11],n[12]=e[12]-t[12],n[13]=e[13]-t[13],n[14]=e[14]-t[14],n[15]=e[15]-t[15],n),"subtract$8");var CJ=TJ;const EJ=u(n=>n.map(e=>e.toFixed(7)).toString(),"toString$8");var PJ=EJ;const RJ=u((n,e,t)=>{const i=t[0],s=t[1],r=t[2];let o,a,l,c,h,f,d,p,g,m,v,y;return e===n?(n[12]=e[0]*i+e[4]*s+e[8]*r+e[12],n[13]=e[1]*i+e[5]*s+e[9]*r+e[13],n[14]=e[2]*i+e[6]*s+e[10]*r+e[14],n[15]=e[3]*i+e[7]*s+e[11]*r+e[15]):(o=e[0],a=e[1],l=e[2],c=e[3],h=e[4],f=e[5],d=e[6],p=e[7],g=e[8],m=e[9],v=e[10],y=e[11],n[0]=o,n[1]=a,n[2]=l,n[3]=c,n[4]=h,n[5]=f,n[6]=d,n[7]=p,n[8]=g,n[9]=m,n[10]=v,n[11]=y,n[12]=o*i+h*s+g*r+e[12],n[13]=a*i+f*s+m*r+e[13],n[14]=l*i+d*s+v*r+e[14],n[15]=c*i+p*s+y*r+e[15]),n},"translate$4");var IJ=RJ,an={add:oK,clone:uK,copy:hO,create:Lw,invert:dK,equals:mK,fromRotation:pO,fromScaling:TK,fromTaitBryanRotation:EK,fromTranslation:RK,fromValues:LK,fromVectorRotation:kQ,fromXRotation:$Q,fromYRotation:WQ,fromZRotation:YQ,identity:dO,isIdentity:KQ,isOnlyTransformScale:JQ,isMirroring:tJ,mirrorByPlane:iJ,multiply:rJ,rotate:hJ,rotateX:mJ,rotateY:bJ,rotateZ:AJ,scale:SJ,subtract:CJ,toString:PJ,translate:IJ};const DJ=an,LJ=u(n=>(n===void 0&&(n=[]),{sides:n,transforms:DJ.create()}),"create$A");var Z1=LJ;const OJ=u((n,e)=>(n[0]=Math.abs(e[0]),n[1]=Math.abs(e[1]),n),"abs");var FJ=OJ;const NJ=u((n,e,t)=>(n[0]=e[0]+t[0],n[1]=e[1]+t[1],n),"add$1");var kJ=NJ;const zJ=u(n=>Math.atan2(n[1],n[0]),"angleRadians$1");var Fw=zJ,BJ=Fw;const UJ=Fw,$J=u(n=>UJ(n)*57.29577951308232,"angleDegrees");var VJ=$J;const HJ=u(()=>[0,0],"create$z");var K1=HJ;const GJ=K1,WJ=u(n=>{const e=GJ();return e[0]=n[0],e[1]=n[1],e},"clone$8");var jJ=WJ;const XJ=u((n,e)=>(n[0]=e[0],n[1]=e[1],n),"copy$4");var qJ=XJ;const YJ=u((n,e,t)=>(n[0]=0,n[1]=0,n[2]=e[0]*t[1]-e[1]*t[0],n),"cross$3");var ZJ=YJ;const KJ=u((n,e)=>{const t=e[0]-n[0],i=e[1]-n[1];return Math.sqrt(t*t+i*i)},"distance$1");var QJ=KJ;const JJ=u((n,e,t)=>(n[0]=e[0]/t[0],n[1]=e[1]/t[1],n),"divide");var eee=JJ;const tee=u((n,e)=>n[0]*e[0]+n[1]*e[1],"dot$3");var nee=tee;const iee=u((n,e)=>n[0]===e[0]&&n[1]===e[1],"equals$6");var see=iee;const{sin:ree,cos:oee}=Ei,aee=u((n,e)=>(n[0]=oee(e),n[1]=ree(e),n),"fromAngleRadians$1");var SO=aee;const lee=SO,cee=u((n,e)=>lee(n,e*.017453292519943295),"fromAngleDegrees");var uee=cee;const hee=u((n,e)=>(n[0]=e,n[1]=e,n),"fromScalar$1");var fee=hee;const dee=K1,pee=u((n,e)=>{const t=dee();return t[0]=n,t[1]=e,t},"fromValues$3");var mee=pee;const gee=u(n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),"length$1");var vee=gee;const yee=u((n,e,t,i)=>{const s=e[0],r=e[1];return n[0]=s+i*(t[0]-s),n[1]=r+i*(t[1]-r),n},"lerp");var bee=yee;const xee=u((n,e,t)=>(n[0]=Math.max(e[0],t[0]),n[1]=Math.max(e[1],t[1]),n),"max$1");var _ee=xee;const wee=u((n,e,t)=>(n[0]=Math.min(e[0],t[0]),n[1]=Math.min(e[1],t[1]),n),"min");var Aee=wee;const Mee=u((n,e,t)=>(n[0]=e[0]*t[0],n[1]=e[1]*t[1],n),"multiply");var See=Mee;const Tee=u((n,e)=>(n[0]=-e[0],n[1]=-e[1],n),"negate");var Cee=Tee;const Eee=u((n,e,t,i)=>{const s=e[0]-t[0],r=e[1]-t[1],o=Math.cos(i),a=Math.sin(i);return n[0]=s*o-r*a+t[0],n[1]=s*a+r*o+t[1],n},"rotate$3");var TO=Eee;const{TAU:Pee}=at,Ree=K1,Iee=TO,Dee=u((n,e)=>Iee(n,e,Ree(),Pee/4),"normal");var Lee=Dee;const Oee=u((n,e)=>{const t=e[0],i=e[1];let s=t*t+i*i;return s>0&&(s=1/Math.sqrt(s)),n[0]=t*s,n[1]=i*s,n},"normalize$2");var Fee=Oee;const Nee=u((n,e,t)=>(n[0]=e[0]*t,n[1]=e[1]*t,n),"scale$2");var kee=Nee;const zee=u((n,e,t)=>(n[0]=Math.round(e[0]/t)*t+0,n[1]=Math.round(e[1]/t)*t+0,n),"snap");var Bee=zee;const Uee=u((n,e)=>{const t=e[0]-n[0],i=e[1]-n[1];return t*t+i*i},"squaredDistance$1");var $ee=Uee;const Vee=u(n=>{const e=n[0],t=n[1];return e*e+t*t},"squaredLength$1");var Hee=Vee;const Gee=u((n,e,t)=>(n[0]=e[0]-t[0],n[1]=e[1]-t[1],n),"subtract$7");var Wee=Gee;const jee=u(n=>`[${n[0].toFixed(7)}, ${n[1].toFixed(7)}]`,"toString$7");var Xee=jee;const qee=u((n,e,t)=>{const i=e[0],s=e[1];return n[0]=t[0]*i+t[4]*s+t[12],n[1]=t[1]*i+t[5]*s+t[13],n},"transform$9");var Yee=qee,vt={abs:FJ,add:kJ,angle:BJ,angleDegrees:VJ,angleRadians:Fw,clone:jJ,copy:qJ,create:K1,cross:ZJ,distance:QJ,divide:eee,dot:nee,equals:see,fromAngleDegrees:uee,fromAngleRadians:SO,fromScalar:fee,fromValues:mee,length:vee,lerp:bee,max:_ee,min:Aee,multiply:See,negate:Cee,normal:Lee,normalize:Fee,rotate:TO,scale:kee,snap:Bee,squaredDistance:$ee,squaredLength:Hee,subtract:Wee,toString:Xee,transform:Yee};const Oy=vt,Zee=Z1,Kee=u(n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");let e=n.length;if(e<3)throw new Error("the given points must define a closed geometry with three or more points");Oy.equals(n[0],n[e-1])&&--e;const t=[];let i=n[e-1];for(let s=0;s<e;s++){const r=n[s];t.push([Oy.clone(i),Oy.clone(r)]),i=r}return Zee(t)},"fromPoints$a");var Qee=Kee;const Jee=an,X3=vt,ete=Z1,tte=u(n=>{if(n[0]!==0)throw new Error("invalid compact binary data");const e=ete();e.transforms=Jee.clone(n.slice(1,17));for(let t=21;t<n.length;t+=4){const i=X3.fromValues(n[t+0],n[t+1]),s=X3.fromValues(n[t+2],n[t+3]);e.sides.push([i,s])}return n[17]>=0&&(e.color=[n[17],n[18],n[19],n[20]]),e},"fromCompactBinary$2");var nte=tte;const ite=u(n=>!!(n&&typeof n=="object"&&"sides"in n&&"transforms"in n&&Array.isArray(n.sides)&&"length"in n.transforms),"isA$8");var CO=ite;const q3=an,tg=vt,ste=u(n=>(q3.isIdentity(n.transforms)||(n.sides=n.sides.map(e=>{const t=tg.transform(tg.create(),e[0],n.transforms),i=tg.transform(tg.create(),e[1],n.transforms);return[t,i]}),n.transforms=q3.create()),n),"applyTransforms$5");var rte=ste;const ote=rte,ate=u(n=>ote(n).sides,"toSides$4");var Bp=ate;const lte=Z1,cte=Bp,ute=u(n=>{const t=cte(n).map(i=>[i[1],i[0]]);return t.reverse(),lte(t)},"reverse$3");var hte=ute;const Cf=vt,fte=Bp,dte=u(n=>{const e=new Map,t=u(i=>{const s=i.toString();return e.has(s)?e.get(s):(e.set(s,i),i)},"getUniqueVertex");return n.map(i=>i.map(t))},"toSharedVertices"),pte=u(n=>{const e=new Map;return dte(n).forEach(i=>{e.has(i[0])?e.get(i[0]).push(i):e.set(i[0],[i])}),e},"toVertexMap"),mte=u(n=>{const e=pte(fte(n)),t=[];for(;;){let i;for(const[o,a]of e){if(i=a.shift(),!i){e.delete(o);continue}break}if(i===void 0)break;const s=[],r=i[0];for(;;){s.push(i[0]);const o=i[1];if(o===r)break;const a=e.get(o);if(!a)throw new Error(`geometry is not closed at vertex ${o}`);const l=gte(i,a);a.length===0&&e.delete(o),i=l}s.length>0&&s.push(s.shift()),t.push(s)}return e.clear(),t},"toOutlines$2"),gte=u((n,e)=>{if(e.length===1)return e.pop();const t=Cf.create(),i=Cf.angleDegrees(Cf.subtract(t,n[1],n[0]));let s,r;e.forEach((a,l)=>{let h=Cf.angleDegrees(Cf.subtract(t,a[1],a[0]))-i;h<-180&&(h+=360),h>=180&&(h-=360),(r===void 0||h>s)&&(r=l,s=h)});const o=e[r];return e.splice(r,1),o},"popNextSide");var EO=mte;const vte=Bp,yte=u(n=>{const t=vte(n).map(i=>i[0]);return t.length>0&&t.push(t.shift()),t},"toPoints$8");var bte=yte;const Y3=vt,xte=Bp,_te=u(n=>{const e=xte(n);let t="geom2 ("+e.length+` sides):
[
`;return e.forEach(i=>{t+="  ["+Y3.toString(i[0])+", "+Y3.toString(i[1])+`]
`}),t+=`]
`,t},"toString$6");var wte=_te;const Ate=u(n=>{const e=n.sides,t=n.transforms;let i=[-1,-1,-1,-1];n.color&&(i=n.color);const s=new Float32Array(1+16+4+e.length*4);s[0]=0,s[1]=t[0],s[2]=t[1],s[3]=t[2],s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=t[6],s[8]=t[7],s[9]=t[8],s[10]=t[9],s[11]=t[10],s[12]=t[11],s[13]=t[12],s[14]=t[13],s[15]=t[14],s[16]=t[15],s[17]=i[0],s[18]=i[1],s[19]=i[2],s[20]=i[3];for(let r=0;r<e.length;r++){const o=r*4+21,a=e[r][0],l=e[r][1];s[o+0]=a[0],s[o+1]=a[1],s[o+2]=l[0],s[o+3]=l[1]}return s},"toCompactBinary$2");var Mte=Ate;const Z3=an,Ste=u((n,e)=>{const t=Z3.multiply(Z3.create(),n,e.transforms);return Object.assign({},e,{transforms:t})},"transform$8");var Tte=Ste;const Cte=vt,Ete=CO,Pte=EO,Rte=u(n=>{if(!Ete(n))throw new Error("invalid geom2 structure");if(Pte(n),n.sides.forEach(e=>{if(Cte.equals(e[0],e[1]))throw new Error(`geom2 self-edge ${e[0]}`)}),!n.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${n.transforms}`)},"validate$3");var Ite=Rte,Tt={clone:sK,create:Z1,fromPoints:Qee,fromCompactBinary:nte,isA:CO,reverse:hte,toOutlines:EO,toPoints:bte,toSides:Bp,toString:wte,toCompactBinary:Mte,transform:Tte,validate:Ite};const Dte=u(n=>Object.assign({},n),"clone$7");var Lte=Dte;const Ote=an,Fte=u(n=>(n===void 0&&(n=[]),{polygons:n,transforms:Ote.create()}),"create$s");var Q1=Fte;const Nte=u(n=>((n===void 0||n.length<3)&&(n=[]),{vertices:n}),"create$r");var Hh=Nte;const kte=Hh,zte=mt,Bte=u((...n)=>{let e,t;return n.length===1?(e=kte(),t=n[0]):(e=n[0],t=n[1]),e.vertices=t.vertices.map(i=>zte.clone(i)),e},"clone$6");var Ute=Bte;const $te=mt,Vte=Hh,Hte=u(n=>{const e=n.map(t=>$te.clone(t));return Vte(e)},"fromPoints$9");var Gte=Hte;const Wte=Hh,jte=u((n,e)=>{const t=Wte(n);return t.plane=e,t},"fromPointsAndPlane");var Xte=jte;const qte=u(()=>[0,0,0,0],"create$n");var J1=qte;const Yte=J1,Zte=u(n=>{const e=Yte();return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e},"clone$5");var PO=Zte;const Kte=u((n,e)=>(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n),"copy$3");var RO=Kte;const Qte=u((n,e)=>n[0]===e[0]&&n[1]===e[1]&&n[2]===e[2]&&n[3]===e[3],"equals$5");var IO=Qte;const Jte=u((n,e)=>(n[0]=-e[0],n[1]=-e[1],n[2]=-e[2],n[3]=-e[3],n),"flip$3");var DO=Jte;const Fy=mt,ene=u((n,e,t)=>{const i=Fy.normalize(Fy.create(),e),s=Fy.dot(t,i);return n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s,n},"fromNormalAndPoint");var tne=ene;const nne=J1,ine=u((n,e,t,i)=>{const s=nne();return s[0]=n,s[1]=e,s[2]=t,s[3]=i,s},"fromValues$2");var LO=ine;const Fr=mt,sne=u((n,...e)=>{const t=e.length,i=Fr.create(),s=Fr.create(),r=u(o=>{const a=e[o],l=e[(o+1)%t],c=e[(o+2)%t];return Fr.subtract(i,l,a),Fr.subtract(s,c,a),Fr.cross(i,i,s),Fr.normalize(i,i),i},"vertexNormal");return n[0]=0,n[1]=0,n[2]=0,t===3?Fr.copy(n,r(0)):(e.forEach((o,a)=>{Fr.add(n,n,r(a))}),Fr.normalize(n,n)),n[3]=Fr.dot(n,e[0]),n},"fromPoints$8");var OO=sne;const{EPS:Ny}=at,Hi=mt,rne=u((n,e,t,i)=>{let s=Hi.subtract(Hi.create(),t,e),r=Hi.subtract(Hi.create(),i,e);Hi.length(s)<Ny&&(s=Hi.orthogonal(s,r)),Hi.length(r)<Ny&&(r=Hi.orthogonal(r,s));let o=Hi.cross(Hi.create(),s,r);Hi.length(o)<Ny&&(r=Hi.orthogonal(r,s),o=Hi.cross(o,s,r)),o=Hi.normalize(o,o);const a=Hi.dot(o,e);return n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=a,n},"fromPointsRandom");var one=rne;const ane=mt,lne=u((n,e)=>{const t=e[0]*n[0]+e[1]*n[1]+e[2]*n[2]-n[3],i=e[0]-t*n[0],s=e[1]-t*n[1],r=e[2]-t*n[2];return ane.fromValues(i,s,r)},"projectionOfPoint");var cne=lne;const une=mt,hne=u((n,e)=>une.dot(n,e)-n[3],"signedDistanceToPoint$1");var FO=hne;const fne=u(n=>`(${n[0].toFixed(9)}, ${n[1].toFixed(9)}, ${n[2].toFixed(9)}, ${n[3].toFixed(9)})`,"toString$5");var NO=fne;const dne=an,Gi=mt,pne=OO,mne=DO,gne=u((n,e,t)=>{const i=dne.isMirroring(t),s=Gi.orthogonal(Gi.create(),e),r=Gi.cross(s,e,s),o=Gi.cross(Gi.create(),e,r);let a=Gi.fromScalar(Gi.create(),e[3]);Gi.multiply(a,a,e);let l=Gi.add(Gi.create(),a,r),c=Gi.add(Gi.create(),a,o);return a=Gi.transform(a,a,t),l=Gi.transform(l,l,t),c=Gi.transform(c,c,t),pne(n,a,l,c),i&&mne(n,n),n},"transform$7");var vne=gne,ra={clone:PO,copy:RO,create:J1,equals:IO,flip:DO,fromNormalAndPoint:tne,fromValues:LO,fromPoints:OO,fromPointsRandom:one,projectionOfPoint:cne,signedDistanceToPoint:FO,toString:NO,transform:vne};const K3=ra,yne=Hh,bne=u(n=>{const e=n.vertices.slice().reverse(),t=yne(e);return n.plane&&(t.plane=K3.flip(K3.create(),n.plane)),t},"invert$1");var xne=bne;const _ne=u(n=>!!(n&&typeof n=="object"&&"vertices"in n&&Array.isArray(n.vertices)),"isA$6");var kO=_ne;const Q3=ra,wl=mt,wne=u(n=>Ane(n.vertices),"isConvex$1"),Ane=u(n=>{const e=n.length;if(e>2){const t=Q3.fromPoints(Q3.create(),...n);let i=n[e-2],s=n[e-1];for(let r=0;r<e;r++){const o=n[r];if(!Mne(i,s,o,t))return!1;i=s,s=o}}return!0},"areVerticesConvex"),Mne=u((n,e,t,i)=>{const s=wl.cross(wl.create(),wl.subtract(wl.create(),e,n),wl.subtract(wl.create(),t,e));return wl.dot(s,i)>=0},"isConvexPoint");var zO=wne;const J3=ra,Sne=u(n=>(n.plane||(n.plane=J3.fromPoints(J3.create(),...n.vertices)),n.plane),"plane$8");var Nw=Sne;const Tne=Nw,Cne=u(n=>{const e=n.vertices.length;if(e<3)return 0;const t=n.vertices,i=Tne(n),s=Math.abs(i[0]),r=Math.abs(i[1]),o=Math.abs(i[2]);if(s+r+o===0)return 0;let a=3;s>r&&s>o?a=1:r>o&&(a=2);let l=0,c=0,h=1,f=2;switch(a){case 1:for(h=1;h<e;h++)c=h-1,f=(h+1)%e,l+=t[h][1]*(t[f][2]-t[c][2]);l+=t[0][1]*(t[1][2]-t[e-1][2]),l/=2*i[0];break;case 2:for(h=1;h<e;h++)c=h-1,f=(h+1)%e,l+=t[h][2]*(t[f][0]-t[c][0]);l+=t[0][2]*(t[1][0]-t[e-1][0]),l/=2*i[1];break;case 3:default:for(h=1;h<e;h++)c=h-1,f=(h+1)%e,l+=t[h][0]*(t[f][1]-t[c][1]);l+=t[0][0]*(t[1][1]-t[e-1][1]),l/=2*i[2];break}return l},"measureArea$3");var BO=Cne;const Ef=mt,Ene=u(n=>{const e=n.vertices,t=e.length,i=t===0?Ef.create():Ef.clone(e[0]),s=Ef.clone(i);for(let r=1;r<t;r++)Ef.min(i,i,e[r]),Ef.max(s,s,e[r]);return[i,s]},"measureBoundingBox$5");var Pne=Ene;const Rne=u((n,e)=>n[0]*e[0]+n[1]*e[1]+n[2]*e[2]+n[3]*e[3],"dot$2");var Ine=Rne;const Dne=u((n,e)=>(n[0]=e,n[1]=e,n[2]=e,n[3]=e,n),"fromScalar");var Lne=Dne;const One=u((n,e,t)=>{const[i,s,r,o]=e;return n[0]=t[0]*i+t[4]*s+t[8]*r+t[12]*o,n[1]=t[1]*i+t[5]*s+t[9]*r+t[13]*o,n[2]=t[2]*i+t[6]*s+t[10]*r+t[14]*o,n[3]=t[3]*i+t[7]*s+t[11]*r+t[15]*o,n},"transform$6");var Fne=One,Nne={clone:PO,copy:RO,create:J1,dot:Ine,equals:IO,fromScalar:Lne,fromValues:LO,toString:NO,transform:Fne};const kne=Nne,eT=new WeakMap,zne=u(n=>{let e=eT.get(n);if(e)return e;const t=n.vertices,i=kne.create();if(t.length===0)return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i;let s=t[0],r=s,o=s,a=s,l=s,c=s;t.forEach(p=>{s[0]>p[0]&&(s=p),r[1]>p[1]&&(r=p),o[2]>p[2]&&(o=p),a[0]<p[0]&&(a=p),l[1]<p[1]&&(l=p),c[2]<p[2]&&(c=p)}),i[0]=(s[0]+a[0])*.5,i[1]=(r[1]+l[1])*.5,i[2]=(o[2]+c[2])*.5;const h=i[0]-a[0],f=i[1]-l[1],d=i[2]-c[2];return i[3]=Math.sqrt(h*h+f*f+d*d),eT.set(n,i),i},"measureBoundingSphere");var Bne=zne;const ky=mt,Une=u(n=>{let e=0;const t=n.vertices,i=ky.create();for(let s=0;s<t.length-2;s++)ky.cross(i,t[s+1],t[s+2]),e+=ky.dot(t[0],i);return e/=6,e},"measureSignedVolume");var $ne=Une;const Vne=u(n=>n.vertices,"toPoints$7");var Hne=Vne;const Gne=mt,Wne=u(n=>{let e="poly3: vertices: [";return n.vertices.forEach(t=>{e+=`${Gne.toString(t)}, `}),e+="]",e},"toString$4");var jne=Wne;const Xne=an,tT=mt,qne=Hh,Yne=u((n,e)=>{const t=e.vertices.map(i=>tT.transform(tT.create(),i,n));return Xne.isMirroring(n)&&t.reverse(),qne(t)},"transform$5");var Zne=Yne;const Kne=FO,{NEPS:Qne}=at,Jne=mt,eie=kO,tie=zO,nie=BO,iie=Nw,sie=u(n=>{if(!eie(n))throw new Error("invalid poly3 structure");if(n.vertices.length<3)throw new Error(`poly3 not enough vertices ${n.vertices.length}`);if(nie(n)<=0)throw new Error("poly3 area must be greater than zero");for(let e=0;e<n.vertices.length;e++)if(Jne.equals(n.vertices[e],n.vertices[(e+1)%n.vertices.length]))throw new Error(`poly3 duplicate vertex ${n.vertices[e]}`);if(!tie(n))throw new Error("poly3 must be convex");if(n.vertices.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${e}`)}),n.vertices.length>3){const e=iie(n);n.vertices.forEach(t=>{const i=Math.abs(Kne(e,t));if(i>Qne)throw new Error(`poly3 must be coplanar: vertex ${t} distance ${i}`)})}},"validate$2");var rie=sie,Kt={clone:Ute,create:Hh,fromPoints:Gte,fromPointsAndPlane:Xte,invert:xne,isA:kO,isConvex:zO,measureArea:BO,measureBoundingBox:Pne,measureBoundingSphere:Bne,measureSignedVolume:$ne,plane:Nw,toPoints:Hne,toString:jne,transform:Zne,validate:rie};const oie=Kt,aie=Q1,lie=u(n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");const e=n.map((i,s)=>oie.create(i));return aie(e)},"fromPoints$6");var cie=lie;const uie=mt,hie=an,fie=Kt,die=Q1,pie=u(n=>{if(n[0]!==1)throw new Error("invalid compact binary data");const e=die();e.transforms=hie.clone(n.slice(1,17));const t=n[21];let i=22,s=n.length-t*3;for(;s<n.length;){const r=n[i];i++;const o=[];for(let a=0;a<r;a++)o.push(uie.fromValues(n[s],n[s+1],n[s+2])),s+=3;e.polygons.push(fie.create(o))}return n[17]>=0&&(e.color=[n[17],n[18],n[19],n[20]]),e},"fromCompactBinary$1");var mie=pie;const nT=an,gie=Kt,vie=u(n=>(nT.isIdentity(n.transforms)||(n.polygons=n.polygons.map(e=>gie.transform(n.transforms,e)),n.transforms=nT.create()),n),"applyTransforms$3");var yie=vie;const bie=yie,xie=u(n=>bie(n).polygons,"toPolygons$4");var ev=xie;const _ie=Kt,wie=Q1,Aie=ev,Mie=u(n=>{const t=Aie(n).map(i=>_ie.invert(i));return wie(t)},"invert");var Sie=Mie;const Tie=u(n=>!!(n&&typeof n=="object"&&"polygons"in n&&"transforms"in n&&Array.isArray(n.polygons)&&"length"in n.transforms),"isA$4");var UO=Tie;const Cie=Kt,Eie=ev,Pie=u(n=>Eie(n).map(i=>Cie.toPoints(i)),"toPoints$6");var Rie=Pie;const Iie=Kt,Die=ev,Lie=u(n=>{const e=Die(n);let t="geom3 ("+e.length+` polygons):
`;return e.forEach(i=>{t+="  "+Iie.toString(i)+`
`}),t},"toString$3");var Oie=Lie;const Fie=Kt,Nie=u(n=>{const e=n.polygons,t=n.transforms,i=e.length,s=e.reduce((c,h)=>c+h.vertices.length,0);let r=[-1,-1,-1,-1];n.color&&(r=n.color);const o=new Float32Array(1+16+4+1+i+s*3);o[0]=1,o[1]=t[0],o[2]=t[1],o[3]=t[2],o[4]=t[3],o[5]=t[4],o[6]=t[5],o[7]=t[6],o[8]=t[7],o[9]=t[8],o[10]=t[9],o[11]=t[10],o[12]=t[11],o[13]=t[12],o[14]=t[13],o[15]=t[14],o[16]=t[15],o[17]=r[0],o[18]=r[1],o[19]=r[2],o[20]=r[3],o[21]=s;let a=22,l=a+i;return e.forEach(c=>{const h=Fie.toPoints(c);o[a]=h.length,a++;for(let f=0;f<h.length;f++){const d=h[f];o[l+0]=d[0],o[l+1]=d[1],o[l+2]=d[2],l+=3}}),o},"toCompactBinary$1");var kie=Nie;const iT=an,zie=u((n,e)=>{const t=iT.multiply(iT.create(),n,e.transforms);return Object.assign({},e,{transforms:t})},"transform$4");var Bie=zie;const Uie=Kt,$ie=UO,Vie=u(n=>{if(!$ie(n))throw new Error("invalid geom3 structure");if(n.polygons.forEach(Uie.validate),Hie(n),!n.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${n.transforms}`)},"validate$1"),Hie=u(n=>{const e=new Map;n.polygons.forEach(({vertices:i})=>{i.forEach((s,r)=>{const o=`${s}`,a=`${i[(r+1)%i.length]}`,l=`${o}/${a}`,c=e.has(l)?e.get(l):0;e.set(l,c+1)})});const t=[];if(e.forEach((i,s)=>{const r=s.split("/").reverse().join("/"),o=e.get(r);i!==o&&t.push(s.replace("/"," -> "))}),t.length>0)throw new Error(`non-manifold edges ${t.length}
${t.join(`
`)}`)},"validateManifold");var Gie=Vie,Mt={clone:Lte,create:Q1,fromPoints:cie,fromCompactBinary:mie,invert:Sie,isA:UO,toPoints:Rie,toPolygons:ev,toString:Oie,toCompactBinary:kie,transform:Bie,validate:Gie};const Wie=u(n=>Object.assign({},n),"clone$4");var kw=Wie;const{EPS:sT}=at,jie=vt,Xie=kw,qie=u(n=>{if(n.isClosed)return n;const e=Xie(n);if(e.isClosed=!0,e.points.length>1){const t=e.points,i=t[0];let s=t[t.length-1];for(;jie.distance(i,s)<sT*sT&&(t.pop(),t.length!==1);)s=t[t.length-1]}return e},"close$1");var $O=qie;const Yie=an,Zie=u(n=>(n===void 0&&(n=[]),{points:n,isClosed:!1,transforms:Yie.create()}),"create$f");var tv=Zie;const{EPS:rT}=at,oT=vt,Kie=$O,Qie=tv,Jie=u((n,e)=>{const t={closed:!1};let{closed:i}=Object.assign({},t,n),s=Qie();if(s.points=e.map(r=>oT.clone(r)),s.points.length>1){const r=s.points[0],o=s.points[s.points.length-1];oT.distance(r,o)<rT*rT&&(i=!0)}return i===!0&&(s=Kie(s)),s},"fromPoints$5");var zw=Jie;const aT=an,lT=vt,ese=u(n=>(aT.isIdentity(n.transforms)||(n.points=n.points.map(e=>lT.transform(lT.create(),e,n.transforms)),n.transforms=aT.create()),n),"applyTransforms$1");var tse=ese;const nse=tse,ise=u(n=>nse(n).points,"toPoints$5");var Gh=ise;const{TAU:ng}=at,Qn=vt,sse=zw,rse=Gh,ose=u((n,e)=>{const t={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:i,radius:s,xaxisrotation:r,clockwise:o,large:a,segments:l}=Object.assign({},t,n);if(!Array.isArray(i))throw new Error("endpoint must be an array of X and Y values");if(i.length<2)throw new Error("endpoint must contain X and Y values");if(i=Qn.clone(i),!Array.isArray(s))throw new Error("radius must be an array of X and Y values");if(s.length<2)throw new Error("radius must contain X and Y values");if(l<4)throw new Error("segments must be four or more");const c=1e5;if(e.isClosed)throw new Error("the given path cannot be closed");const h=rse(e);if(h.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let f=s[0],d=s[1];const p=h[h.length-1];f=Math.round(f*c)/c,d=Math.round(d*c)/c,i=Qn.fromValues(Math.round(i[0]*c)/c,Math.round(i[1]*c)/c);const g=!o;let m=[];if(f===0||d===0)m.push(i);else{f=Math.abs(f),d=Math.abs(d);const y=r,b=Math.cos(y),x=Math.sin(y),w=Qn.subtract(Qn.create(),p,i);Qn.scale(w,w,.5);const _=Math.round((b*w[0]+x*w[1])*c)/c,A=Math.round((-x*w[0]+b*w[1])*c)/c,S=Qn.fromValues(_,A),M=S[0]*S[0]/(f*f)+S[1]*S[1]/(d*d);if(M>1){const te=Math.sqrt(M);f*=te,d*=te,f=Math.round(f*c)/c,d=Math.round(d*c)/c}let C=Math.sqrt((f*f*d*d-f*f*S[1]*S[1]-d*d*S[0]*S[0])/(f*f*S[1]*S[1]+d*d*S[0]*S[0]));g===a&&(C=-C);const I=Qn.fromValues(f*S[1]/d,-d*S[0]/f);Qn.scale(I,I,C);let F=Qn.fromValues(b*I[0]-x*I[1],x*I[0]+b*I[1]);F=Qn.add(F,F,Qn.scale(Qn.create(),Qn.add(Qn.create(),p,i),.5));const O=Qn.fromValues((S[0]-I[0])/f,(S[1]-I[1])/d),N=Qn.fromValues((-S[0]-I[0])/f,(-S[1]-I[1])/d),E=Qn.angleRadians(O);let G=Qn.angleRadians(N)-E;G=G%ng,!g&&G>0?G-=ng:g&&G<0&&(G+=ng);let X=Math.ceil(Math.abs(G)/ng*l)+1;X<1&&(X=1);for(let te=1;te<X;te++){const j=E+te/X*G,ie=Math.cos(j),K=Math.sin(j),$=Qn.fromValues(b*f*ie-x*d*K,x*f*ie+b*d*K);Qn.add($,$,F),m.push($)}X&&m.push(n.endpoint)}return m=h.concat(m),sse({},m)},"appendArc");var ase=ose;const lse=zw,cse=Gh,{equals:use}=vt,hse=u((...n)=>{let e=!1,t=[];return n.forEach((i,s)=>{const r=cse(i).slice();if(t.length>0&&r.length>0&&use(r[0],t[t.length-1])&&r.shift(),r.length>0&&e)throw new Error(`Cannot concatenate to a closed path; check the ${s}th path`);e=i.isClosed,t=t.concat(r)}),lse({closed:e},t)},"concat$1");var VO=hse;const fse=VO,dse=tv,pse=u((n,e)=>fse(e,dse(n)),"appendPoints$1");var HO=pse;const{TAU:mse}=at,ws=vt,gse=vt,vse=HO,yse=Gh,bse=u((n,e)=>{const t={segments:16};let{controlPoints:i,segments:s}=Object.assign({},t,n);if(!Array.isArray(i))throw new Error("controlPoints must be an array of one or more points");if(i.length<1)throw new Error("controlPoints must be an array of one or more points");if(s<4)throw new Error("segments must be four or more");if(e.isClosed)throw new Error("the given geometry cannot be closed");const r=yse(e);if(r.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(i=i.slice(),i[0]===null){if(i.length<2)throw new Error("a null control point must be passed with one more control points");let A=r[r.length-2];if("lastBezierControlPoint"in e&&(A=e.lastBezierControlPoint),!Array.isArray(A))throw new Error("the given path must contain TWO or more points if given a null control point");const S=ws.scale(ws.create(),r[r.length-1],2);ws.subtract(S,S,A),i[0]=S}i.unshift(r[r.length-1]);const a=i.length-1,l=[];let c=1;for(let A=0;A<=a;++A)A>0&&(c*=A),l.push(c);const h=[];for(let A=0;A<=a;++A){const S=l[a]/(l[A]*l[a-A]);h.push(S)}const f=ws.create(),d=ws.create(),p=gse.create(),g=u(A=>{let S=1,M=Math.pow(1-A,a);const C=A!==1?1/(1-A):1,I=ws.create();for(let F=0;F<=a;++F){F===a&&(M=1);const O=h[F]*S*M,N=ws.scale(f,i[F],O);ws.add(I,I,N),S*=A,M*=C}return I},"getPointForT"),m=[],v=[],y=a+1;for(let A=0;A<y;++A){const S=A/(y-1),M=g(S);m.push(M),v.push(S)}let b=1;const x=mse/s,w=Math.sin(x);for(;b<m.length-1;){const A=ws.subtract(f,m[b],m[b-1]);ws.normalize(A,A);const S=ws.subtract(d,m[b+1],m[b]);ws.normalize(S,S);const M=ws.cross(p,A,S);if(Math.abs(M[2])>w){const C=v[b-1],I=v[b+1],F=C+(I-C)*1/3,O=C+(I-C)*2/3,N=g(F),E=g(O);m.splice(b,1,N,E),v.splice(b,1,F,O),b--,b<1&&(b=1)}else++b}m.shift();const _=vse(m,e);return _.lastBezierControlPoint=i[i.length-2],_},"appendBezier");var xse=bse;const _se=vt,cT=Gh,wse=u((n,e)=>{if(n.isClosed!==e.isClosed||n.points.length!==e.points.length)return!1;const t=cT(n),i=cT(e),s=t.length;let r=0;do{let o=!1;for(let a=0;a<s;a++)if(!_se.equals(t[a],i[(a+r)%s])){o=!0;break}if(o===!1)return!0;if(!n.isClosed)return!1}while(++r<s);return!1},"equals$3");var Ase=wse;const Mse=an,Sse=vt,Tse=tv,Cse=u(n=>{if(n[0]!==2)throw new Error("invalid compact binary data");const e=Tse();e.transforms=Mse.clone(n.slice(1,17)),e.isClosed=!!n[17];for(let t=22;t<n.length;t+=2){const i=Sse.fromValues(n[t],n[t+1]);e.points.push(i)}return n[18]>=0&&(e.color=[n[18],n[19],n[20],n[21]]),e},"fromCompactBinary");var Ese=Cse;const Pse=u(n=>!!(n&&typeof n=="object"&&"points"in n&&"transforms"in n&&"isClosed"in n&&Array.isArray(n.points)&&"length"in n.transforms),"isA$2");var GO=Pse;const Rse=kw,Ise=u(n=>{const e=Rse(n);return e.points=n.points.slice().reverse(),e},"reverse$2");var Dse=Ise;const Lse=vt,Ose=Gh,Fse=u(n=>{const e=Ose(n);let t="path ("+e.length+" points, "+n.isClosed+`):
[
`;return e.forEach(i=>{t+="  "+Lse.toString(i)+`,
`}),t+=`]
`,t},"toString$2");var Nse=Fse;const kse=u(n=>{const e=n.points,t=n.transforms;let i=[-1,-1,-1,-1];n.color&&(i=n.color);const s=new Float32Array(1+16+1+4+e.length*2);s[0]=2,s[1]=t[0],s[2]=t[1],s[3]=t[2],s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=t[6],s[8]=t[7],s[9]=t[8],s[10]=t[9],s[11]=t[10],s[12]=t[11],s[13]=t[12],s[14]=t[13],s[15]=t[14],s[16]=t[15],s[17]=n.isClosed?1:0,s[18]=i[0],s[19]=i[1],s[20]=i[2],s[21]=i[3];for(let r=0;r<e.length;r++){const o=r*2+22,a=e[r];s[o]=a[0],s[o+1]=a[1]}return s},"toCompactBinary");var zse=kse;const uT=an,Bse=u((n,e)=>{const t=uT.multiply(uT.create(),n,e.transforms);return Object.assign({},e,{transforms:t})},"transform$3");var Use=Bse;const $se=vt,Vse=GO,Hse=u(n=>{if(!Vse(n))throw new Error("invalid path2 structure");if(n.points.length>1){for(let e=0;e<n.points.length;e++)if($se.equals(n.points[e],n.points[(e+1)%n.points.length]))throw new Error(`path2 duplicate points ${n.points[e]}`)}if(n.points.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`path2 invalid point ${e}`)}),!n.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${n.transforms}`)},"validate");var Gse=Hse,qn={appendArc:ase,appendBezier:xse,appendPoints:HO,clone:kw,close:$O,concat:VO,create:tv,equals:Ase,fromPoints:zw,fromCompactBinary:Ese,isA:GO,reverse:Dse,toPoints:Gh,toString:Nse,toCompactBinary:zse,transform:Use,validate:Gse};const Wse=Tt,jse=Mt,Xse=qn,qse=u(n=>{let e;for(const t of n){let i=0;if(Wse.isA(t)&&(i=1),jse.isA(t)&&(i=2),Xse.isA(t)&&(i=3),e&&i!==e)return!1;e=i}return!0},"areAllShapesTheSameType$4");var Up=qse;const Yse=u(n=>{let e=0;for(let t=0;t<n.length;t++){const i=(t+1)%n.length;e+=n[t][0]*n[i][1],e-=n[i][0]*n[t][1]}return e/2},"area$9");var nv=Yse;const Zse=nv,Kse=u(n=>Zse(n.vertices),"measureArea$1");var WO=Kse;const Qse=u(n=>((n===void 0||n.length<3)&&(n=[]),{vertices:n}),"create$b");var jO=Qse;const Jse=jO,ere=u(n=>{const e=n.vertices.slice().reverse();return Jse(e)},"flip$1");var XO=ere;const tre=WO,nre=XO,ire=u((n,e)=>{if(n.length===0)return 0;const t=e.vertices;return t.length<3?0:(tre(e)<0&&(e=nre(e)),n.reduce((s,r)=>s+sre(r,t),0)===n.length?1:0)},"arePointsInside$1"),sre=u((n,e)=>{const t=e.length,i=n[0],s=n[1];let r=e[t-1],o=e[0],a=r[1]>s,l=0,c=0;for(let h=t+1;--h;){const f=o[1]>s;if(a!==f){const d=r[0]>i,p=o[0]>i;(d&&p||o[0]-(o[1]-s)*(r[0]-o[0])/(r[1]-o[1])>=i)&&(l=!l)}a=f,r=o,o=e[++c]}return l},"isPointInside");var rre=ire,qO={arePointsInside:rre,create:jO,flip:XO,measureArea:WO},ore={geom2:Tt,geom3:Mt,path2:qn,poly2:qO,poly3:Kt};const{EPS:are}=at,lre=u((n,e)=>{let t=0;for(let i=0;i<e;i++)t+=n[1][i]-n[0][i];return are*t/e},"calculateEpsilonFromBounds$1");var cre=lre;const ure=Xt,Xr=vt,Pf=mt,YO=Tt,ZO=Mt,KO=qn,hT=Kt,Rh=new WeakMap,hre=u(n=>{let e=Rh.get(n);if(e)return e;const t=KO.toPoints(n);let i;t.length===0?i=Xr.create():i=Xr.clone(t[0]);let s=Xr.clone(i);return t.forEach(r=>{Xr.min(i,i,r),Xr.max(s,s,r)}),i=[i[0],i[1],0],s=[s[0],s[1],0],e=[i,s],Rh.set(n,e),e},"measureBoundingBoxOfPath2"),fre=u(n=>{let e=Rh.get(n);if(e)return e;const t=YO.toPoints(n);let i;t.length===0?i=Xr.create():i=Xr.clone(t[0]);let s=Xr.clone(i);return t.forEach(r=>{Xr.min(i,i,r),Xr.max(s,s,r)}),i=[i[0],i[1],0],s=[s[0],s[1],0],e=[i,s],Rh.set(n,e),e},"measureBoundingBoxOfGeom2"),dre=u(n=>{let e=Rh.get(n);if(e)return e;const t=ZO.toPolygons(n);let i=Pf.create();if(t.length>0){const r=hT.toPoints(t[0]);Pf.copy(i,r[0])}let s=Pf.clone(i);return t.forEach(r=>{hT.toPoints(r).forEach(o=>{Pf.min(i,i,o),Pf.max(s,s,o)})}),i=[i[0],i[1],i[2]],s=[s[0],s[1],s[2]],e=[i,s],Rh.set(n,e),e},"measureBoundingBoxOfGeom3"),pre=u((...n)=>{if(n=ure(n),n.length===0)throw new Error("wrong number of arguments");const e=n.map(t=>KO.isA(t)?hre(t):YO.isA(t)?fre(t):ZO.isA(t)?dre(t):[[0,0,0],[0,0,0]]);return e.length===1?e[0]:e},"measureBoundingBox$4");var iv=pre;const mre=Xt,{geom2:gre,geom3:vre,path2:yre}=ore,Bw=cre,Uw=iv,bre=u(n=>Bw(Uw(n),2),"measureEpsilonOfPath2"),xre=u(n=>Bw(Uw(n),2),"measureEpsilonOfGeom2"),_re=u(n=>Bw(Uw(n),3),"measureEpsilonOfGeom3"),wre=u((...n)=>{if(n=mre(n),n.length===0)throw new Error("wrong number of arguments");const e=n.map(t=>yre.isA(t)?bre(t):gre.isA(t)?xre(t):vre.isA(t)?_re(t):0);return e.length===1?e[0]:e},"measureEpsilon$5");var $p=wre;const fT=vt,Are=Tt,Mre=u((n,e)=>{if(e.vertices.length<4)return null;const t=[],i=e.vertices.filter((o,a)=>o[2]>0?(t.push(a),!0):!1);if(i.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const s=i.map(o=>{const a=Math.round(o[0]/n)*n+0,l=Math.round(o[1]/n)*n+0;return fT.fromValues(a,l)});if(fT.equals(s[0],s[1]))return null;const r=t[1]-t[0];if(r===1||r===3)r===1&&s.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return s},"fromFakePolygon"),Sre=u((n,e)=>{const t=e.map(i=>Mre(n,i)).filter(i=>i!==null);return Are.create(t)},"fromFakePolygons$3");var $w=Sre;const wa=mt,Tre=Tt,Cre=Mt,Ere=Kt,Pre=u((n,e,t)=>{const i=[wa.fromVec2(wa.create(),t[0],n),wa.fromVec2(wa.create(),t[1],n),wa.fromVec2(wa.create(),t[1],e),wa.fromVec2(wa.create(),t[0],e)];return Ere.create(i)},"to3DWall"),Rre=u((n,e)=>{const i=Tre.toSides(e).map(r=>Pre(n.z0,n.z1,r));return Cre.create(i)},"to3DWalls$3");var Vw=Rre;const{NEPS:zy}=at,Ire=u((n,e)=>Math.abs(n[0]-e[0])<=zy&&Math.abs(n[1]-e[1])<=zy&&Math.abs(n[2]-e[2])<=zy,"aboutEqualNormals$2");var Hw=Ire;const Dre=u(()=>[0,1,0],"create$9");var Gw=Dre;const Lre=Gw,Ore=u(n=>{const e=Lre();return e[0]=n[0],e[1]=n[1],e[2]=n[2],e},"clone$1");var Fre=Ore;const By=vt,Nre=u(n=>{const e=By.normal(By.create(),n);return By.negate(e,e),e},"direction$2");var Ww=Nre;const dT=vt,kre=u(n=>dT.scale(dT.create(),n,n[2]),"origin$3");var sv=kre;const zre=vt,Bre=Ww,Ure=sv,$re=u((n,e)=>{const t=Ure(n),i=Bre(n),s=(i[1]-t[1])/(i[0]-t[0]),r=t[1]-s*t[0],o=-1/s,l=(e[1]-o*e[0]-r)/(s-o),c=s*l+r;return zre.fromValues(l,c)},"closestPoint");var Vre=$re;const Hre=u((n,e)=>(n[0]=e[0],n[1]=e[1],n[2]=e[2],n),"copy$2");var QO=Hre;const Gre=vt,Wre=u((n,e)=>{let t=Gre.dot(e,n);return t=Math.abs(t-n[2]),t},"distanceToPoint");var jre=Wre;const Xre=u((n,e)=>n[0]===e[0]&&n[1]===e[1]&&n[2]===e[2],"equals$2");var qre=Xre;const Rf=vt,Yre=u((n,e,t)=>{const i=Rf.subtract(Rf.create(),t,e);Rf.normal(i,i),Rf.normalize(i,i);const s=Rf.dot(e,i);return n[0]=i[0],n[1]=i[1],n[2]=s,n},"fromPoints$2");var JO=Yre;const Zre=Gw,Kre=u((n,e,t)=>{const i=Zre();return i[0]=n,i[1]=e,i[2]=t,i},"fromValues$1");var e4=Kre;const Qre=u((n,e,t)=>{let i=t-n[1],s=e[1]-n[1];s<0&&(i=-i,s=-s);let r;return i<=0?r=0:i>=s?r=1:s<1e-10?r=.5:r=i/s,n[0]+r*(e[0]-n[0])},"interpolateBetween2DPointsForY$1");var t4=Qre;const Jre=u((n,e,t,i)=>{if(n[0]===e[0]&&n[1]===e[1]||t[0]===i[0]&&t[1]===i[1])return;const s=(i[1]-t[1])*(e[0]-n[0])-(i[0]-t[0])*(e[1]-n[1]);if(Math.abs(s)<Number.MIN_VALUE)return;const r=((i[0]-t[0])*(n[1]-t[1])-(i[1]-t[1])*(n[0]-t[0]))/s,o=((e[0]-n[0])*(n[1]-t[1])-(e[1]-n[1])*(n[0]-t[0]))/s;if(r<0||r>1||o<0||o>1)return;const a=n[0]+r*(e[0]-n[0]),l=n[1]+r*(e[1]-n[1]);return[a,l]},"intersect$5");var n4=Jre;const eoe=u((n,e,t,i,s,r)=>{const o=n*i-e*t,a=1/o;let l=s*i-e*r,c=-s*t+n*r;return l*=a,c*=a,[l,c]},"solve2Linear$1");var toe=eoe,jw={aboutEqualNormals:Hw,area:nv,cos:Ei.cos,interpolateBetween2DPointsForY:t4,intersect:n4,sin:Ei.sin,solve2Linear:toe};const noe=vt,{solve2Linear:ioe}=jw,soe=u((n,e)=>{const t=ioe(n[0],n[1],e[0],e[1],n[2],e[2]);return noe.clone(t)},"intersectToLine");var roe=soe;const pT=vt,ooe=QO,aoe=e4,loe=u((n,e)=>{const t=pT.negate(pT.create(),e),i=-e[2];return ooe(n,aoe(t[0],t[1],i))},"reverse$1");var coe=loe;const uoe=u(n=>`line2: (${n[0].toFixed(7)}, ${n[1].toFixed(7)}, ${n[2].toFixed(7)})`,"toString$1");var hoe=uoe;const mT=vt,foe=JO,doe=sv,poe=Ww,moe=u((n,e,t)=>{const i=doe(e),s=poe(e);return mT.transform(i,i,t),mT.transform(s,s,t),foe(n,i,s)},"transform$2");var goe=moe;const voe=sv,yoe=u((n,e)=>{let t=(n[2]-n[1]*e)/n[0];return Number.isNaN(t)&&(t=voe(n)[0]),t},"xAtY");var boe=yoe,i4={clone:Fre,closestPoint:Vre,copy:QO,create:Gw,direction:Ww,distanceToPoint:jre,equals:qre,fromPoints:JO,fromValues:e4,intersectPointOfLines:roe,origin:sv,reverse:coe,toString:hoe,transform:goe,xAtY:boe};const gT=an,xoe=vt,ei=mt,_c=u(function(n,e){arguments.length<2&&(e=ei.orthogonal(ei.create(),n)),this.v=ei.normalize(ei.create(),ei.cross(ei.create(),n,e)),this.u=ei.cross(ei.create(),this.v,n),this.plane=n,this.planeorigin=ei.scale(ei.create(),n,n[3])},"OrthoNormalBasis$1");_c.GetCartesian=function(n,e){const t=n+"/"+e;let i,s;if(t==="X/Y")i=[0,0,1],s=[1,0,0];else if(t==="Y/-X")i=[0,0,1],s=[0,1,0];else if(t==="-X/-Y")i=[0,0,1],s=[-1,0,0];else if(t==="-Y/X")i=[0,0,1],s=[0,-1,0];else if(t==="-X/Y")i=[0,0,-1],s=[-1,0,0];else if(t==="-Y/-X")i=[0,0,-1],s=[0,-1,0];else if(t==="X/-Y")i=[0,0,-1],s=[1,0,0];else if(t==="Y/X")i=[0,0,-1],s=[0,1,0];else if(t==="X/Z")i=[0,-1,0],s=[1,0,0];else if(t==="Z/-X")i=[0,-1,0],s=[0,0,1];else if(t==="-X/-Z")i=[0,-1,0],s=[-1,0,0];else if(t==="-Z/X")i=[0,-1,0],s=[0,0,-1];else if(t==="-X/Z")i=[0,1,0],s=[-1,0,0];else if(t==="-Z/-X")i=[0,1,0],s=[0,0,-1];else if(t==="X/-Z")i=[0,1,0],s=[1,0,0];else if(t==="Z/X")i=[0,1,0],s=[0,0,1];else if(t==="Y/Z")i=[1,0,0],s=[0,1,0];else if(t==="Z/-Y")i=[1,0,0],s=[0,0,1];else if(t==="-Y/-Z")i=[1,0,0],s=[0,-1,0];else if(t==="-Z/Y")i=[1,0,0],s=[0,0,-1];else if(t==="-Y/Z")i=[-1,0,0],s=[0,-1,0];else if(t==="-Z/-Y")i=[-1,0,0],s=[0,0,-1];else if(t==="Y/-Z")i=[-1,0,0],s=[0,1,0];else if(t==="Z/Y")i=[-1,0,0],s=[0,0,1];else throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");return new _c(new Plane(new Vector3D(i),0),new Vector3D(s))};_c.Z0Plane=function(){const n=new Plane(new Vector3D([0,0,1]),0);return new _c(n,new Vector3D([1,0,0]))};_c.prototype={getProjectionMatrix:function(){return gT.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const n=ei.scale(ei.create(),this.plane,this.plane[3]);return gT.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,n[0],n[1],n[2],1)},to2D:function(n){return xoe.fromValues(ei.dot(n,this.u),ei.dot(n,this.v))},to3D:function(n){const e=ei.scale(ei.create(),this.u,n[0]),t=ei.scale(ei.create(),this.v,n[1]),i=ei.add(e,e,this.planeorigin);return ei.add(t,t,i)},line3Dto2D:function(n){const e=n.point,t=n.direction.plus(e),i=this.to2D(e),s=this.to2D(t);return Line2D.fromPoints(i,s)},line2Dto3D:function(n){const e=n.origin(),t=n.direction().plus(e),i=this.to3D(e),s=this.to3D(t);return Line3D.fromPoints(i,s)},transform:function(n){const e=this.plane.transform(n),t=this.u.transform(n),i=new Vector3D(0,0,0).transform(n),s=t.minus(i);return new _c(e,s)}};var _oe=_c;const woe=u(n=>n*.017453292519943295,"degToRad");var Aoe=woe;const Moe=u((n,e)=>n-e,"fnNumberSort$2");var s4=Moe;const Soe=u((n,e,t)=>{let i=0,s=n.length;for(;s>i;){const r=Math.floor((i+s)/2),o=n[r];t(e,o)>0?i=r+1:s=r}n.splice(i,0,e)},"insertSorted$1");var Toe=Soe;const{TAU:vT}=at,Coe=u((n,e,t)=>{const i=e>0?n*vT/e:0,s=t>0?vT/t:0;return Math.ceil(Math.max(i,s,4))},"radiusToSegments");var Eoe=Coe;const Poe=u(n=>n*57.29577951308232,"radToDeg");var Roe=Poe,Ioe={areAllShapesTheSameType:Up,degToRad:Aoe,flatten:Xt,fnNumberSort:s4,insertSorted:Toe,radiusToSegments:Eoe,radToDeg:Roe};const{EPS:yo}=at,Aa=i4,ur=vt,Doe=_oe,Jc=t4,{insertSorted:Loe,fnNumberSort:Ooe}=Ioe,yT=Kt,Foe=u(n=>{if(n.length<2)return n;const e=[],t=n.length,i=yT.plane(n[0]),s=new Doe(i),r=[],o=[],a=new Map,l=new Map,c=new Map,h=10/yo;for(let g=0;g<t;g++){const m=n[g];let v=[],y=m.vertices.length,b=-1;if(y>0){let x,w;for(let _=0;_<y;_++){let A=s.to2D(m.vertices[_]);const S=Math.floor(A[1]*h);let M;c.has(S)?M=c.get(S):c.has(S+1)?M=c.get(S+1):c.has(S-1)?M=c.get(S-1):(M=A[1],c.set(S,A[1])),A=ur.fromValues(A[0],M),v.push(A);const C=A[1];(_===0||C<x)&&(x=C,b=_),(_===0||C>w)&&(w=C);let I=l.get(C);I||(I={},l.set(C,I)),I[g]=!0}if(x>=w)v=[],y=0,b=-1;else{let _=a.get(x);_||(_=[],a.set(x,_)),_.push(g)}}v.reverse(),b=y-b-1,r.push(v),o.push(b)}const f=[];l.forEach((g,m)=>f.push(m)),f.sort(Ooe);let d=[],p=[];for(let g=0;g<f.length;g++){const m=[],v=f[g],y=l.get(v);for(let x=0;x<d.length;++x){const w=d[x],_=w.polygonindex;if(y[_]){const A=r[_],S=A.length;let M=w.leftvertexindex,C=w.rightvertexindex;for(;;){let F=M+1;if(F>=S&&(F=0),A[F][1]!==v)break;M=F}let I=C-1;if(I<0&&(I=S-1),A[I][1]===v&&(C=I),M!==w.leftvertexindex&&M===C)d.splice(x,1),--x;else{w.leftvertexindex=M,w.rightvertexindex=C,w.topleft=A[M],w.topright=A[C];let F=M+1;F>=S&&(F=0),w.bottomleft=A[F];let O=C-1;O<0&&(O=S-1),w.bottomright=A[O]}}}let b;if(g>=f.length-1)d=[],b=null;else{b=Number(f[g+1]);const x=.5*(v+b),w=a.get(v);for(const _ in w){const A=w[_],S=r[A],M=S.length,C=o[A];let I=C;for(;;){let k=I+1;if(k>=M&&(k=0),S[k][1]!==v||k===C)break;I=k}let F=C;for(;;){let k=F-1;if(k<0&&(k=M-1),S[k][1]!==v||k===I)break;F=k}let O=I+1;O>=M&&(O=0);let N=F-1;N<0&&(N=M-1);const E={polygonindex:A,leftvertexindex:I,rightvertexindex:F,topleft:S[I],topright:S[F],bottomleft:S[O],bottomright:S[N]};Loe(d,E,(k,G)=>{const X=Jc(k.topleft,k.bottomleft,x),te=Jc(G.topleft,G.bottomleft,x);return X>te?1:X<te?-1:0})}}for(const x in d){const w=d[x];let _=Jc(w.topleft,w.bottomleft,v);const A=ur.fromValues(_,v);_=Jc(w.topright,w.bottomright,v);const S=ur.fromValues(_,v);_=Jc(w.topleft,w.bottomleft,b);const M=ur.fromValues(_,b);_=Jc(w.topright,w.bottomright,b);const C=ur.fromValues(_,b),I={topleft:A,topright:S,bottomleft:M,bottomright:C,leftline:Aa.fromPoints(Aa.create(),A,M),rightline:Aa.fromPoints(Aa.create(),C,S)};if(m.length>0){const F=m[m.length-1],O=ur.distance(I.topleft,F.topright),N=ur.distance(I.bottomleft,F.bottomright);O<yo&&N<yo&&(I.topleft=F.topleft,I.leftline=F.leftline,I.bottomleft=F.bottomleft,m.splice(m.length-1,1))}m.push(I)}if(g>0){const x=new Set,w=new Set;for(let _=0;_<m.length;_++){const A=m[_];for(let S=0;S<p.length;S++)if(!w.has(S)){const M=p[S];if(ur.distance(M.bottomleft,A.topleft)<yo&&ur.distance(M.bottomright,A.topright)<yo){w.add(S);const C=Aa.direction(A.leftline),I=Aa.direction(M.leftline),F=C[0]-I[0],O=Aa.direction(A.rightline),N=Aa.direction(M.rightline),E=O[0]-N[0],k=Math.abs(F)<yo,G=Math.abs(E)<yo,X=k||F>=0,te=G||E>=0;X&&te&&(A.outpolygon=M.outpolygon,A.leftlinecontinues=k,A.rightlinecontinues=G,x.add(S));break}}}for(let _=0;_<p.length;_++)if(!x.has(_)){const A=p[_];A.outpolygon.rightpoints.push(A.bottomright),ur.distance(A.bottomright,A.bottomleft)>yo&&A.outpolygon.leftpoints.push(A.bottomleft),A.outpolygon.leftpoints.reverse();const M=A.outpolygon.rightpoints.concat(A.outpolygon.leftpoints).map(I=>s.to3D(I)),C=yT.fromPointsAndPlane(M,i);C.vertices.length&&e.push(C)}}for(let x=0;x<m.length;x++){const w=m[x];w.outpolygon?(w.leftlinecontinues||w.outpolygon.leftpoints.push(w.topleft),w.rightlinecontinues||w.outpolygon.rightpoints.push(w.topright)):(w.outpolygon={leftpoints:[],rightpoints:[]},w.outpolygon.leftpoints.push(w.topleft),ur.distance(w.topleft,w.topright)>yo&&w.outpolygon.rightpoints.push(w.topright))}p=m}return e},"reTesselateCoplanarPolygons$1");var Noe=Foe;const bT=Mt,xT=Kt,koe=Hw,zoe=Noe,Boe=u((n,e)=>Math.abs(n[3]-e[3])<15e-8?koe(n,e):!1,"coplanar"),Uoe=u(n=>{if(n.isRetesselated)return n;const e=bT.toPolygons(n),t=[];e.forEach(r=>{const o=t.find(a=>Boe(a[0],xT.plane(r)));o?o[1].push(r):t.push([xT.plane(r),[r]])});let i=[];t.forEach(r=>{const o=r[1],a=zoe(o);i=i.concat(a)});const s=bT.create(i);return s.isRetesselated=!0,s},"retessellate$4");var rv=Uoe;const{EPS:eu}=at,_T=iv,$oe=u((n,e)=>{if(n.polygons.length===0||e.polygons.length===0)return!1;const t=_T(n),i=t[0],s=t[1],r=_T(e),o=r[0],a=r[1];return!(o[0]-s[0]>eu||i[0]-a[0]>eu||o[1]-s[1]>eu||i[1]-a[1]>eu||o[2]-s[2]>eu||i[2]-a[2]>eu)},"mayOverlap$3");var Xw=$oe;const wT=ra,Voe=Kt;class xp{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=e}invert(){const e=[this];let t;for(let i=0;i<e.length;i++){t=e[i],t.plane&&(t.plane=wT.flip(wT.create(),t.plane)),t.front&&e.push(t.front),t.back&&e.push(t.back);const s=t.front;t.front=t.back,t.back=s}}clipPolygons(e,t){let i={node:this,polygontreenodes:e},s;const r=[];do{if(s=i.node,e=i.polygontreenodes,s.plane){const o=s.plane,a=[],l=[],c=t?a:l,h=e.length;for(let d=0;d<h;d++){const p=e[d];p.isRemoved()||p.splitByPlane(o,c,a,l,a)}s.front&&l.length>0&&r.push({node:s.front,polygontreenodes:l});const f=a.length;if(s.back&&f>0)r.push({node:s.back,polygontreenodes:a});else for(let d=0;d<f;d++)a[d].remove()}i=r.pop()}while(i!==void 0)}clipTo(e,t){let i=this;const s=[];do i.polygontreenodes.length>0&&e.rootnode.clipPolygons(i.polygontreenodes,t),i.front&&s.push(i.front),i.back&&s.push(i.back),i=s.pop();while(i!==void 0)}addPolygonTreeNodes(e){let t={node:this,polygontreenodes:e};const i=[];do{const s=t.node,r=t.polygontreenodes;if(r.length===0){t=i.pop();continue}if(!s.plane){let c=0;c=Math.floor(r.length/2);const h=r[c].getPolygon();s.plane=Voe.plane(h)}const o=[],a=[],l=r.length;for(let c=0;c<l;++c)r[c].splitByPlane(s.plane,s.polygontreenodes,a,o,a);o.length>0&&(s.front||(s.front=new xp(s)),l===o.length&&a.length===0?s.front.polygontreenodes=o:i.push({node:s.front,polygontreenodes:o})),a.length>0&&(s.back||(s.back=new xp(s)),l===a.length&&o.length===0?s.back.polygontreenodes=a:i.push({node:s.back,polygontreenodes:a})),t=i.pop()}while(t!==void 0)}}u(xp,"Node$3");var Hoe=xp;const tu=mt,Goe=u((n,e,t)=>{const i=tu.subtract(tu.create(),t,e);let s=(n[3]-tu.dot(n,e))/tu.dot(n,i);return Number.isNaN(s)&&(s=0),s>1&&(s=1),s<0&&(s=0),tu.scale(i,i,s),tu.add(i,e,i),i},"splitLineSegmentByPlane$1");var Woe=Goe;const{EPS:ig}=at,joe=ra,sg=mt,Uy=Kt,Xoe=Woe,qoe=u((n,e)=>{const t={type:null,front:null,back:null},i=e.vertices,s=i.length,r=Uy.plane(e);if(joe.equals(r,n))t.type=0;else{let o=!1,a=!1;const l=[],c=-ig;for(let h=0;h<s;h++){const f=sg.dot(n,i[h])-n[3],d=f<c;l.push(d),f>ig&&(o=!0),f<c&&(a=!0)}if(!o&&!a){const h=sg.dot(n,r);t.type=h>=0?0:1}else if(!a)t.type=2;else if(!o)t.type=3;else{t.type=4;const h=[],f=[];let d=l[0];for(let g=0;g<s;g++){const m=i[g];let v=g+1;v>=s&&(v=0);const y=l[v];if(d===y)d?f.push(m):h.push(m);else{const b=i[v],x=Xoe(n,m,b);d?(f.push(m),f.push(x),h.push(x)):(h.push(m),h.push(x),f.push(x))}d=y}const p=ig*ig;if(f.length>=3){let g=f[f.length-1];for(let m=0;m<f.length;m++){const v=f[m];sg.squaredDistance(v,g)<p&&(f.splice(m,1),m--),g=v}}if(h.length>=3){let g=h[h.length-1];for(let m=0;m<h.length;m++){const v=h[m];sg.squaredDistance(v,g)<p&&(h.splice(m,1),m--),g=v}}h.length>=3&&(t.front=Uy.fromPointsAndPlane(h,r)),f.length>=3&&(t.back=Uy.fromPointsAndPlane(f,r))}}return t},"splitPolygonByPlane$1");var Yoe=qoe;const{EPS:Zoe}=at,Koe=mt,AT=Kt,Qoe=Yoe;class ov{constructor(e,t){this.parent=e,this.children=[],this.polygon=t,this.removed=!1}addPolygons(e){if(!this.isRootNode())throw new Error("Assertion failed");const t=this;e.forEach(i=>{t.addChild(i)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const e=this.parent.children,t=e.indexOf(this);if(t<0)throw new Error("Assertion failed");e.splice(t,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(e){let t=[this];const i=[t];let s,r,o,a;for(s=0;s<i.length;++s)for(t=i[s],r=0,o=t.length;r<o;r++)a=t[r],a.polygon?e.push(a.polygon):a.children.length>0&&i.push(a.children)}splitByPlane(e,t,i,s,r){if(this.children.length){const o=[this.children];let a,l,c,h,f;for(a=0;a<o.length;a++)for(f=o[a],l=0,c=f.length;l<c;l++)h=f[l],h.children.length>0?o.push(h.children):h._splitByPlane(e,t,i,s,r)}else this._splitByPlane(e,t,i,s,r)}_splitByPlane(e,t,i,s,r){const o=this.polygon;if(o){const a=AT.measureBoundingSphere(o),l=a[3]+Zoe,c=a,h=Koe.dot(e,c)-e[3];if(h>l)s.push(this);else if(h<-l)r.push(this);else{const f=Qoe(e,o);switch(f.type){case 0:t.push(this);break;case 1:i.push(this);break;case 2:s.push(this);break;case 3:r.push(this);break;case 4:if(f.front){const d=this.addChild(f.front);s.push(d)}if(f.back){const d=this.addChild(f.back);r.push(d)}break}}}}addChild(e){const t=new ov(this,e);return this.children.push(t),t}invertSub(){let e=[this];const t=[e];let i,s,r,o;for(i=0;i<t.length;i++)for(e=t[i],s=0,r=e.length;s<r;s++)o=e[s],o.polygon&&(o.polygon=AT.invert(o.polygon)),o.children.length>0&&t.push(o.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let e=[this];const t=[e];for(let i=0;i<t.length;++i){e=t[i];const s=e.length;for(let r=0;r<s;r++){const o=e[r];o.polygon&&(o.polygon=null),o.parent&&(o.parent=null),o.children.length>0&&t.push(o.children),o.children=[]}}}toString(){let e="",t=[this];const i=[t];let s,r,o,a;for(s=0;s<i.length;++s){t=i[s];const l=" ".repeat(s);for(r=0,o=t.length;r<o;r++)a=t[r],e+=`${l}PolygonTreeNode (${a.isRootNode()}): ${a.children.length}`,a.polygon?e+=`
 ${l}polygon: ${a.polygon.vertices}
`:e+=`
`,a.children.length>0&&i.push(a.children)}return e}}u(ov,"PolygonTreeNode$1");var Joe=ov;const eae=Hoe,tae=Joe;class r4{constructor(e){this.polygonTree=new tae,this.rootnode=new eae(null),e&&this.addPolygons(e)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(e,t=!1){this.rootnode.clipTo(e,t)}allPolygons(){const e=[];return this.polygonTree.getPolygons(e),e}addPolygons(e){const t=new Array(e.length);for(let i=0;i<e.length;i++)t[i]=this.polygonTree.addChild(e[i]);this.rootnode.addPolygonTreeNodes(t)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}}u(r4,"Tree$3");var nae=r4,qw={Tree:nae};const rg=Mt,iae=Xw,{Tree:MT}=qw,sae=u((n,e)=>{if(!iae(n,e))return rg.create();const t=new MT(rg.toPolygons(n)),i=new MT(rg.toPolygons(e));t.invert(),i.clipTo(t),i.invert(),t.clipTo(i),i.clipTo(t),t.addPolygons(i.allPolygons()),t.invert();const s=t.allPolygons();return rg.create(s)},"intersectGeom3Sub");var rae=sae;const oae=Xt,aae=rv,lae=rae,cae=u((...n)=>{n=oae(n);let e=n.shift();return n.forEach(t=>{e=lae(e,t)}),e=aae(e),e},"intersect$4");var o4=cae;const uae=Xt,hae=Mt,fae=$p,dae=$w,pae=Vw,mae=o4,gae=u((...n)=>{n=uae(n);const e=n.map(s=>pae({z0:-1,z1:1},s)),t=mae(e),i=fae(t);return dae(i,hae.toPolygons(t))},"intersect$3");var vae=gae;const yae=Xt,bae=Up,xae=Tt,_ae=Mt,wae=vae,Aae=o4,Mae=u((...n)=>{if(n=yae(n),n.length===0)throw new Error("wrong number of arguments");if(!bae(n))throw new Error("only intersect of the types are supported");const e=n[0];return xae.isA(e)?wae(n):_ae.isA(e)?Aae(n):e},"intersect$2");var Sae=Mae;const $y=mt,Tae=$p,ST=Mt,Cae=u(n=>n.sort((e,t)=>e-t).filter((e,t,i)=>!t||e!==i[t-1]),"sortNb"),Eae=u((n,e,t)=>{const i=`${e}`,s=n.get(i);s===void 0?n.set(i,[t]):s.push(t)},"insertMapping"),Pae=u((n,e)=>{const t=`${e}`;return n.get(t)},"findMapping"),Rae=u(n=>{const e=Tae(n),t=ST.toPolygons(n),i=t.length,s=new Map,r=$y.create();t.forEach((h,f)=>{h.vertices.forEach(d=>{Eae(s,$y.snap(r,d,e),f)})});const o=t.map(h=>{let f=[];return h.vertices.forEach(d=>{f=f.concat(Pae(s,$y.snap(r,d,e)))}),{e:1,d:Cae(f)}});s.clear();let a=0;const l=o.length;for(let h=0;h<l;h++){const f=o[h];if(f.e>0){const d=new Array(i);d[h]=!0;do a=0,d.forEach((p,g)=>{const m=o[g];if(m.e>0){m.e=-1;for(let v=0;v<m.d.length;v++)d[m.d[v]]=!0;a++}});while(a>0);f.indexes=d}}const c=[];for(let h=0;h<l;h++)if(o[h].indexes){const f=[];o[h].indexes.forEach((d,p)=>f.push(t[p])),c.push(ST.create(f))}return c},"scissionGeom3$1");var Iae=Rae;const Dae=Xt,Lae=Mt,Oae=Iae,Fae=u((...n)=>{if(n=Dae(n),n.length===0)throw new Error("wrong number of arguments");const e=n.map(t=>Lae.isA(t)?Oae(t):t);return e.length===1?e[0]:e},"scission");var Nae=Fae;const og=Mt,kae=Xw,{Tree:TT}=qw,zae=u((n,e)=>{if(!kae(n,e))return og.clone(n);const t=new TT(og.toPolygons(n)),i=new TT(og.toPolygons(e));t.invert(),t.clipTo(i),i.clipTo(t,!0),t.addPolygons(i.allPolygons()),t.invert();const s=t.allPolygons();return og.create(s)},"subtractGeom3Sub");var Bae=zae;const Uae=Xt,$ae=rv,Vae=Bae,Hae=u((...n)=>{n=Uae(n);let e=n.shift();return n.forEach(t=>{e=Vae(e,t)}),e=$ae(e),e},"subtract$6");var a4=Hae;const Gae=Xt,Wae=Mt,jae=$p,Xae=$w,qae=Vw,Yae=a4,Zae=u((...n)=>{n=Gae(n);const e=n.map(s=>qae({z0:-1,z1:1},s)),t=Yae(e),i=jae(t);return Xae(i,Wae.toPolygons(t))},"subtract$5");var Kae=Zae;const Qae=Xt,Jae=Up,ele=Tt,tle=Mt,nle=Kae,ile=a4,sle=u((...n)=>{if(n=Qae(n),n.length===0)throw new Error("wrong number of arguments");if(!Jae(n))throw new Error("only subtract of the types are supported");const e=n[0];return ele.isA(e)?nle(n):tle.isA(e)?ile(n):e},"subtract$4");var rle=sle;const qu=Mt,ole=Xw,{Tree:CT}=qw,ale=u((n,e)=>{if(!ole(n,e))return lle(n,e);const t=new CT(qu.toPolygons(n)),i=new CT(qu.toPolygons(e));t.clipTo(i,!1),i.clipTo(t),i.invert(),i.clipTo(t),i.invert();const s=t.allPolygons().concat(i.allPolygons());return qu.create(s)},"unionSub$1"),lle=u((n,e)=>{let t=qu.toPolygons(n);return t=t.concat(qu.toPolygons(e)),qu.create(t)},"unionForNonIntersecting");var l4=ale;const cle=Xt,ule=rv,hle=l4,fle=u((...n)=>{n=cle(n);let e;for(e=1;e<n.length;e+=2)n.push(hle(n[e-1],n[e]));let t=n[e-1];return t=ule(t),t},"union$4");var c4=fle;const dle=Xt,ple=Mt,mle=$p,gle=$w,vle=Vw,yle=c4,ble=u((...n)=>{n=dle(n);const e=n.map(s=>vle({z0:-1,z1:1},s)),t=yle(e),i=mle(t);return gle(i,ple.toPolygons(t))},"union$3");var u4=ble;const xle=Xt,_le=Up,wle=Tt,Ale=Mt,Mle=u4,Sle=c4,Tle=u((...n)=>{if(n=xle(n),n.length===0)throw new Error("wrong number of arguments");if(!_le(n))throw new Error("only unions of the same type are supported");const e=n[0];return wle.isA(e)?Mle(n):Ale.isA(e)?Sle(n):e},"union$2");var Yw=Tle,hr={intersect:Sae,scission:Nae,subtract:rle,union:Yw};const ET=ra,Al=mt,Cle=u(n=>{const e=n.edges;if(e.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const t=e.reduce((o,a)=>Al.add(Al.create(),o,a[0]),Al.create());Al.scale(t,t,1/e.length);let i,s=0;e.forEach(o=>{if(!Al.equals(o[0],o[1])){const a=Al.squaredDistance(t,o[0]);a>s&&(i=o,s=a)}});const r=e.find(o=>Al.equals(o[1],i[0]));return ET.fromPoints(ET.create(),r[0],i[0],i[1])},"calculatePlane$1");var h4=Cle;const Ele=u(n=>(n||(n=[]),{edges:n}),"create$6");var Pc=Ele;const Ple=Pc,PT=mt,Rle=u((...n)=>{let e,t;return n.length===1?(e=Ple(),t=n[0]):(e=n[0],t=n[1]),e.edges=t.edges.map(i=>[PT.clone(i[0]),PT.clone(i[1])]),e},"clone");var Ile=Rle;const Dle=mt,Lle=u((n,e)=>{const t=n.edges,i=e.edges;return t.length!==i.length?!1:t.reduce((r,o,a)=>{const l=i[a],c=Dle.squaredDistance(o[0],l[0]);return r&&c<Number.EPSILON},!0)},"equals$1");var Ole=Lle;const ag=mt,Fle=Pc,Nle=u(n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");if(n.length<3)throw new Error("the given points must contain THREE or more points");const e=[];let t=n[n.length-1];return n.forEach(i=>{i.length===2&&e.push([ag.fromVec2(ag.create(),t),ag.fromVec2(ag.create(),i)]),i.length===3&&e.push([t,i]),t=i}),Fle(e)},"fromPoints");var kle=Nle;const lg=mt,zle=Pc,Ble=u(n=>{if(!Array.isArray(n))throw new Error("the given sides must be an array");const e=[];return n.forEach(t=>{e.push([lg.fromVec2(lg.create(),t[0]),lg.fromVec2(lg.create(),t[1])])}),zle(e)},"fromSides");var Ule=Ble;const $le=u(n=>!!(n&&typeof n=="object"&&"edges"in n&&Array.isArray(n.edges)),"isA");var Vle=$le;const Hle=Pc,Gle=u((...n)=>{let e,t;return n.length===1?(e=Hle(),t=n[0]):(e=n[0],t=n[1]),e.edges=t.edges.map(i=>[i[1],i[0]]),e},"reverse");var Wle=Gle;const jle=u(n=>n.edges,"toEdges");var Xle=jle;const qle=u((n,e)=>{let t,i,s,r,o,a=1;do{i=n,n=null;let l=null;for(o=0;i;){o++,s=i;let c=0;for(t=0;t<a&&(c++,s=s.nextZ,!!s);t++);let h=a;for(;c>0||h>0&&s;)c!==0&&(h===0||!s||e(i)<=e(s))?(r=i,i=i.nextZ,c--):(r=s,s=s.nextZ,h--),l?l.nextZ=r:n=r,r.prevZ=l,l=r;i=s}l.nextZ=null,a*=2}while(o>1);return n},"sortLinked$2");var Yle=qle;const Zle=Yle;class Zw{constructor(e,t,i){this.i=e,this.x=t,this.y=i,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}u(Zw,"Node$1");const Kle=u((n,e,t,i)=>{const s=new Zw(n,e,t);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s},"insertNode$1"),Qle=u(n=>{n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)},"removeNode$2");var f4={Node:Zw,insertNode:Kle,removeNode:Qle,sortLinked:Zle};const Jle=u((n,e,t,i,s,r,o,a)=>(s-o)*(e-a)-(n-o)*(r-a)>=0&&(n-o)*(i-a)-(t-o)*(e-a)>=0&&(t-o)*(r-a)-(s-o)*(i-a)>=0,"pointInTriangle$2"),ece=u((n,e,t)=>(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y),"area$7");var Kw={area:ece,pointInTriangle:Jle};const{Node:RT,insertNode:IT,removeNode:K0}=f4,{area:ps}=Kw,tce=u((n,e,t,i,s)=>{let r;if(s===ace(n,e,t,i)>0)for(let o=e;o<t;o+=i)r=IT(o,n[o],n[o+1],r);else for(let o=t-i;o>=e;o-=i)r=IT(o,n[o],n[o+1],r);return r&&av(r,r.next)&&(K0(r),r=r.next),r},"linkedPolygon$2"),d4=u((n,e)=>{if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&(av(t,t.next)||ps(t.prev,t,t.next)===0)){if(K0(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e},"filterPoints$2"),nce=u((n,e,t)=>{let i=n;do{const s=i.prev,r=i.next.next;!av(s,r)&&p4(s,i,i.next,r)&&_p(s,r)&&_p(r,s)&&(e.push(s.i/t),e.push(i.i/t),e.push(r.i/t),K0(i),K0(i.next),i=n=r),i=i.next}while(i!==n);return d4(i)},"cureLocalIntersections$1"),ice=u((n,e)=>{let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&p4(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1},"intersectsPolygon"),_p=u((n,e)=>ps(n.prev,n,n.next)<0?ps(n,e,n.next)>=0&&ps(n,n.prev,e)>=0:ps(n,e,n.prev)<0||ps(n,n.next,e)<0,"locallyInside$1"),sce=u((n,e)=>{let t=n,i=!1;const s=(n.x+e.x)/2,r=(n.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&s<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i},"middleInside"),rce=u((n,e)=>{const t=new RT(n.i,n.x,n.y),i=new RT(e.i,e.x,e.y),s=n.next,r=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,i.next=t,t.prev=i,r.next=i,i.prev=r,i},"splitPolygon$2"),oce=u((n,e)=>n.next.i!==e.i&&n.prev.i!==e.i&&!ice(n,e)&&(_p(n,e)&&_p(e,n)&&sce(n,e)&&(ps(n.prev,n,e.prev)||ps(n,e.prev,e))||av(n,e)&&ps(n.prev,n,n.next)>0&&ps(e.prev,e,e.next)>0),"isValidDiagonal$1"),p4=u((n,e,t,i)=>{const s=Math.sign(ps(n,e,t)),r=Math.sign(ps(n,e,i)),o=Math.sign(ps(t,i,n)),a=Math.sign(ps(t,i,e));return!!(s!==r&&o!==a||s===0&&cg(n,t,e)||r===0&&cg(n,i,e)||o===0&&cg(t,n,i)||a===0&&cg(t,e,i))},"intersects"),cg=u((n,e,t)=>e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y),"onSegment"),ace=u((n,e,t,i)=>{let s=0;for(let r=e,o=t-i;r<t;r+=i)s+=(n[o]-n[r])*(n[r+1]+n[o+1]),o=r;return s},"signedArea"),av=u((n,e)=>n.x===e.x&&n.y===e.y,"equals");var m4={cureLocalIntersections:nce,filterPoints:d4,isValidDiagonal:oce,linkedPolygon:tce,locallyInside:_p,splitPolygon:rce};const{filterPoints:Ux,linkedPolygon:lce,locallyInside:cce,splitPolygon:uce}=m4,{area:DT,pointInTriangle:hce}=Kw,fce=u((n,e,t,i)=>{const s=[];for(let r=0,o=e.length;r<o;r++){const a=e[r]*i,l=r<o-1?e[r+1]*i:n.length,c=lce(n,a,l,i,!1);c===c.next&&(c.steiner=!0),s.push(gce(c))}s.sort((r,o)=>r.x-o.x);for(let r=0;r<s.length;r++)t=dce(s[r],t),t=Ux(t,t.next);return t},"eliminateHoles$1"),dce=u((n,e)=>{const t=pce(n,e);if(!t)return e;const i=uce(t,n),s=Ux(t,t.next);return Ux(i,i.next),e===t?s:e},"eliminateHole"),pce=u((n,e)=>{let t=e;const i=n.x,s=n.y;let r=-1/0,o;do{if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const f=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=i&&f>r){if(r=f,f===i){if(s===t.y)return t;if(s===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(i===r)return o;const a=o,l=o.x,c=o.y;let h=1/0;t=o;do{if(i>=t.x&&t.x>=l&&i!==t.x&&hce(s<c?i:r,s,l,c,s<c?r:i,s,t.x,t.y)){const f=Math.abs(s-t.y)/(i-t.x);cce(t,n)&&(f<h||f===h&&(t.x>o.x||t.x===o.x&&mce(o,t)))&&(o=t,h=f)}t=t.next}while(t!==a);return o},"findHoleBridge"),mce=u((n,e)=>DT(n.prev,n,e.prev)<0&&DT(e.next,n,n.next)<0,"sectorContainsSector"),gce=u(n=>{let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t},"getLeftmost");var vce=fce;const yce=vce,{removeNode:bce,sortLinked:xce}=f4,{cureLocalIntersections:_ce,filterPoints:Q0,isValidDiagonal:wce,linkedPolygon:Ace,splitPolygon:Mce}=m4,{area:Yl,pointInTriangle:Td}=Kw,Sce=u((n,e,t=2)=>{const i=e&&e.length,s=i?e[0]*t:n.length;let r=Ace(n,0,s,t,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,c,h,f;if(i&&(r=yce(n,e,r,t)),n.length>80*t){a=c=n[0],l=h=n[1];for(let d=t;d<s;d+=t){const p=n[d],g=n[d+1];p<a&&(a=p),g<l&&(l=g),p>c&&(c=p),g>h&&(h=g)}f=Math.max(c-a,h-l),f=f!==0?1/f:0}return wp(r,o,t,a,l,f),o},"triangulate"),wp=u((n,e,t,i,s,r,o)=>{if(!n)return;!o&&r&&Pce(n,i,s,r);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,r?Cce(n,i,s,r):Tce(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),bce(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=_ce(Q0(n),e,t),wp(n,e,t,i,s,r,2)):o===2&&Ece(n,e,t,i,s,r):wp(Q0(n),e,t,i,s,r,1);break}}},"earcutLinked"),Tce=u(n=>{const e=n.prev,t=n,i=n.next;if(Yl(e,t,i)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(Td(e.x,e.y,t.x,t.y,i.x,i.y,s.x,s.y)&&Yl(s.prev,s,s.next)>=0)return!1;s=s.next}return!0},"isEar"),Cce=u((n,e,t,i)=>{const s=n.prev,r=n,o=n.next;if(Yl(s,r,o)>=0)return!1;const a=s.x<r.x?s.x<o.x?s.x:o.x:r.x<o.x?r.x:o.x,l=s.y<r.y?s.y<o.y?s.y:o.y:r.y<o.y?r.y:o.y,c=s.x>r.x?s.x>o.x?s.x:o.x:r.x>o.x?r.x:o.x,h=s.y>r.y?s.y>o.y?s.y:o.y:r.y>o.y?r.y:o.y,f=$x(a,l,e,t,i),d=$x(c,h,e,t,i);let p=n.prevZ,g=n.nextZ;for(;p&&p.z>=f&&g&&g.z<=d;){if(p!==n.prev&&p!==n.next&&Td(s.x,s.y,r.x,r.y,o.x,o.y,p.x,p.y)&&Yl(p.prev,p,p.next)>=0||(p=p.prevZ,g!==n.prev&&g!==n.next&&Td(s.x,s.y,r.x,r.y,o.x,o.y,g.x,g.y)&&Yl(g.prev,g,g.next)>=0))return!1;g=g.nextZ}for(;p&&p.z>=f;){if(p!==n.prev&&p!==n.next&&Td(s.x,s.y,r.x,r.y,o.x,o.y,p.x,p.y)&&Yl(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;g&&g.z<=d;){if(g!==n.prev&&g!==n.next&&Td(s.x,s.y,r.x,r.y,o.x,o.y,g.x,g.y)&&Yl(g.prev,g,g.next)>=0)return!1;g=g.nextZ}return!0},"isEarHashed"),Ece=u((n,e,t,i,s,r)=>{let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&wce(o,a)){let l=Mce(o,a);o=Q0(o,o.next),l=Q0(l,l.next),wp(o,e,t,i,s,r),wp(l,e,t,i,s,r);return}a=a.next}o=o.next}while(o!==n)},"splitEarcut"),Pce=u((n,e,t,i)=>{let s=n;do s.z===null&&(s.z=$x(s.x,s.y,e,t,i)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,xce(s,r=>r.z)},"indexCurve"),$x=u((n,e,t,i,s)=>(n=32767*(n-t)*s,e=32767*(e-i)*s,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1),"zOrder");var Rce=Sce;const{area:Ice}=jw,{toOutlines:Dce}=Tt,{arePointsInside:Lce}=qO,Oce=u(n=>{const e=Dce(n),t=[],i=[];e.forEach((o,a)=>{const l=Ice(o);l<0?i.push(a):l>0&&t.push(a)});const s=[],r=[];return t.forEach((o,a)=>{const l=e[o];s[a]=[],i.forEach((c,h)=>{const f=e[c];Lce([f[0]],{vertices:l})&&(s[a].push(c),r[h]||(r[h]=[]),r[h].push(a))})}),i.forEach((o,a)=>{if(r[a]&&r[a].length>1){const l=Fce(r[a],c=>s[c].length);r[a].forEach((c,h)=>{h!==l&&(s[c]=s[c].filter(f=>f!==o))})}}),s.map((o,a)=>({solid:e[t[a]],holes:o.map(l=>e[l])}))},"assignHoles$1"),Fce=u((n,e)=>{let t,i;return n.forEach((s,r)=>{const o=e(s);(i===void 0||o<i)&&(t=r,i=o)}),t},"minIndex");var Nce=Oce;const kce=Tt,LT=ra,zce=vt,Ai=mt,Bce=h4,Uce=Nce;class g4{constructor(e){this.plane=Bce(e);const t=Ai.orthogonal(Ai.create(),this.plane),i=Ai.cross(Ai.create(),this.plane,t);this.v=Ai.normalize(i,i),this.u=Ai.cross(Ai.create(),this.v,this.plane),this.basisMap=new Map;const s=e.edges.map(o=>o.map(a=>this.to2D(a))),r=kce.create(s);this.roots=Uce(r)}to2D(e){const t=zce.fromValues(Ai.dot(e,this.u),Ai.dot(e,this.v));return this.basisMap.set(t,e),t}to3D(e){const t=this.basisMap.get(e);if(t)return t;{console.log("Warning: point not in original slice");const i=Ai.scale(Ai.create(),this.u,e[0]),s=Ai.scale(Ai.create(),this.v,e[1]),r=Ai.scale(Ai.create(),LT,LT[3]),o=Ai.add(i,i,r);return Ai.add(s,s,o)}}}u(g4,"PolygonHierarchy$1");var $ce=g4;const Vce=Kt,Hce=Rce,Gce=$ce,Wce=u(n=>{const e=new Gce(n),t=[];return e.roots.forEach(({solid:i,holes:s})=>{let r=i.length;const o=[];s.forEach((f,d)=>{o.push(r),r+=f.length});const a=[i,...s].flat(),l=a.flat(),c=u(f=>e.to3D(a[f]),"getVertex"),h=Hce(l,o);for(let f=0;f<h.length;f+=3){const d=h.slice(f,f+3).map(c);t.push(Vce.fromPointsAndPlane(d,e.plane))}}),t},"toPolygons");var jce=Wce;const OT=mt,Xce=u(n=>n.reduce((e,t)=>e+=`[${OT.toString(t[0])}, ${OT.toString(t[1])}], `,""),"edgesToString"),qce=u(n=>`[${Xce(n.edges)}]`,"toString");var Yce=qce;const ug=mt,Zce=Pc,Kce=u((n,e)=>{const t=e.edges.map(i=>[ug.transform(ug.create(),i[0],n),ug.transform(ug.create(),i[1],n)]);return Zce(t)},"transform$1");var Qce=Kce,Wh={calculatePlane:h4,clone:Ile,create:Pc,equals:Ole,fromPoints:kle,fromSides:Ule,isA:Vle,reverse:Wle,toEdges:Xle,toPolygons:jce,toString:Yce,transform:Qce};const FT=mt,Jce=Pc,eue=u(n=>{if(!n.edges)return n;let e=n.edges;const t=new Map,i=new Map;e=e.filter(o=>!FT.equals(o[0],o[1])),e.forEach(o=>{const a=o[0].toString(),l=o[1].toString();t.set(a,o[0]),t.set(l,o[1]),i.set(a,(i.get(a)||0)+1),i.set(l,(i.get(l)||0)-1)});const s=[],r=[];return i.forEach((o,a)=>{o<0&&s.push(a),o>0&&r.push(a)}),s.forEach(o=>{const a=t.get(o);let l=1/0,c;r.forEach(h=>{const f=t.get(h),d=FT.distance(a,f);d<l&&(l=d,c=f)}),console.warn(`slice.repair: repairing vertex gap ${a} to ${c} distance ${l}`),e=e.map(h=>h[0].toString()===o?[c,h[1]]:h[1].toString()===o?[h[0],c]:h)}),Jce(e)},"repair");var tue=eue;const{EPS:NT}=at,nu=mt,hg=Kt,kT=Wh,Vx=u((n,e)=>n===e?n:n<e?Vx(e,n):e===1?1:e===0?n:Vx(e,n%e),"gcd"),nue=u((n,e)=>n*e/Vx(n,e),"lcm"),zT=u((n,e)=>{const t=n/e.length;if(t===1)return e;const i=nu.fromValues(t,t,t),s=[];return e.forEach(r=>{const o=nu.subtract(nu.create(),r[1],r[0]);nu.divide(o,o,i);let a=r[0];for(let l=1;l<=t;++l){const c=nu.add(nu.create(),a,o);s.push([a,c]),a=c}}),s},"repartitionEdges"),BT=NT*NT/2*Math.sin(Math.PI/3),iue=u((n,e)=>{let t=kT.toEdges(n),i=kT.toEdges(e);if(t.length!==i.length){const r=nue(t.length,i.length);r!==t.length&&(t=zT(r,t)),r!==i.length&&(i=zT(r,i))}const s=[];return t.forEach((r,o)=>{const a=i[o],l=hg.create([r[0],r[1],a[1]]),c=hg.measureArea(l);Number.isFinite(c)&&c>BT&&s.push(l);const h=hg.create([r[0],a[1],a[0]]),f=hg.measureArea(h);Number.isFinite(f)&&f>BT&&s.push(h)}),s},"extrudeWalls$1");var sue=iue;const UT=an,$T=Tt,rue=Mt,Hx=Kt,$a=Wh,oue=tue,VT=sue,aue=u((n,e,t)=>{let i=null;return $T.isA(t)&&(i=$a.fromSides($T.toSides(t))),Hx.isA(t)&&(i=$a.fromPoints(Hx.toPoints(t))),n===0||n===1?$a.transform(UT.fromTranslation(UT.create(),[0,0,n]),i):null},"defaultCallback"),lue=u((n,e)=>{const t={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:aue},{numberOfSlices:i,capStart:s,capEnd:r,close:o,repair:a,callback:l}=Object.assign({},t,n);if(i<2)throw new Error("numberOfSlices must be 2 or more");a&&(e=oue(e));const c=i-1;let h=null,f=null,d=null,p=[];for(let g=0;g<i;g++){const m=l(g/c,g,e);if(m){if(!$a.isA(m))throw new Error("the callback function must return slice objects");if($a.toEdges(m).length===0)throw new Error("the callback function must return slices with one or more edges");d&&(p=p.concat(VT(d,m))),g===0&&(h=m),g===i-1&&(f=m),d=m}}if(r){const g=$a.toPolygons(f);p=p.concat(g)}if(s){const g=$a.toPolygons(h).map(Hx.invert);p=p.concat(g)}return!s&&!r&&o&&!$a.equals(f,h)&&(p=p.concat(VT(f,h))),rue.create(p)},"extrudeFromSlices$3");var lv=lue;const If=an,Vy=mt,cue=Tt,Hy=Wh,uue=lv,hue=u((n,e)=>{const t={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:i,twistAngle:s,twistSteps:r,repair:o}=Object.assign({},t,n);if(r<1)throw new Error("twistSteps must be 1 or more");s===0&&(r=1);const a=Vy.clone(i),l=cue.toSides(e);if(l.length===0)throw new Error("the given geometry cannot be empty");const c=Hy.fromSides(l);a[2]<0&&Hy.reverse(c,c);const h=If.create(),f=u((d,p,g)=>{const m=p/r*s,v=Vy.scale(Vy.create(),a,p/r);return If.multiply(h,If.fromZRotation(h,m),If.fromTranslation(If.create(),v)),Hy.transform(h,g)},"createTwist");return n={numberOfSlices:r+1,capStart:!0,capEnd:!0,repair:o,callback:f},uue(n,c)},"extrudeGeom2");var cv=hue;const fue=Tt,due=qn,pue=cv,mue=u((n,e)=>{if(!e.isClosed)throw new Error("extruded path must be closed");const t=due.toPoints(e),i=fue.fromPoints(t);return pue(n,i)},"extrudePath2");var gue=mue;const vue=Xt,yue=Tt,bue=qn,xue=cv,_ue=gue,wue=u((n,...e)=>{const t={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:i,twistAngle:s,twistSteps:r,repair:o}=Object.assign({},t,n);if(e=vue(e),e.length===0)throw new Error("wrong number of arguments");n={offset:[0,0,i],twistAngle:s,twistSteps:r,repair:o};const a=e.map(l=>bue.isA(l)?_ue(n,l):yue.isA(l)?xue(n,l):l);return a.length===1?a[0]:a},"extrudeLinear");var Aue=wue;const{EPS:Mue,TAU:Sue}=at,HT=n4,Df=i4,wn=vt,Tue=nv,Cue=u((n,e)=>{const t={delta:1,corners:"edge",closed:!1,segments:16};let{delta:i,corners:s,closed:r,segments:o}=Object.assign({},t,n);if(Math.abs(i)<Mue)return e;let a=n.closed?Tue(e):1;a===0&&(a=1);const l=a>0&&i>=0||a<0&&i<0;i=Math.abs(i);let c=null,h=[];const f=[],d=wn.create(),p=e.length;for(let g=0;g<p;g++){const m=(g+1)%p,v=e[g],y=e[m];l?wn.subtract(d,v,y):wn.subtract(d,y,v),wn.normal(d,d),wn.normalize(d,d),wn.scale(d,d,i);const b=wn.add(wn.create(),v,d),x=wn.add(wn.create(),y,d),w=[b,x];if(c!=null&&(r||!r&&m!==0)){const _=HT(c[0],c[1],w[0],w[1]);_?(h.pop(),w[0]=_):f.push({c:v,s0:c,s1:w})}c=[b,x],!(m===0&&!r)&&(h.push(w[0]),h.push(w[1]))}if(r&&c!=null){const g=h[0],m=h[1],v=HT(c[0],c[1],g,m);if(v)h[0]=v,h.pop();else{const y=e[0],b=[g,m];f.push({c:y,s0:c,s1:b})}}if(s==="edge"){const g=new Map;h.forEach((y,b)=>g.set(y,b));const m=Df.create(),v=Df.create();f.forEach(y=>{Df.fromPoints(m,y.s0[0],y.s0[1]),Df.fromPoints(v,y.s1[0],y.s1[1]);const b=Df.intersectPointOfLines(m,v);if(Number.isFinite(b[0])&&Number.isFinite(b[1])){const x=y.s0[1],w=g.get(x);h[w]=b,h[(w+1)%h.length]=void 0}else{const x=y.s1[0],w=g.get(x);h[w]=void 0}}),h=h.filter(y=>y!==void 0)}if(s==="round"){let g=Math.floor(o/4);const m=wn.create();f.forEach(v=>{let y=wn.angle(wn.subtract(m,v.s1[0],v.c));if(y-=wn.angle(wn.subtract(m,v.s0[1],v.c)),l&&y<0&&(y=y+Math.PI,y<0&&(y=y+Math.PI)),!l&&y>0&&(y=y-Math.PI,y>0&&(y=y-Math.PI)),y!==0){g=Math.floor(o*(Math.abs(y)/Sue));const b=y/g,x=wn.angle(wn.subtract(m,v.s0[1],v.c)),w=[];for(let _=1;_<g;_++){const A=x+b*_,S=wn.fromAngleRadians(wn.create(),A);wn.scale(S,S,i),wn.add(S,S,v.c),w.push(S)}if(w.length>0){const _=v.s0[1];let A=h.findIndex(S=>wn.equals(_,S));A=(A+1)%h.length,h.splice(A,0,...w)}}else{const b=v.s1[0],x=h.findIndex(w=>wn.equals(b,w));h.splice(x,1)}})}return h},"offsetFromPoints$2");var v4=Cue;const fg=Tt,Eue=v4,Pue=u((n,e)=>{const t={delta:1,corners:"edge",segments:16},{delta:i,corners:s,segments:r}=Object.assign({},t,n);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const l=fg.toOutlines(e).map(c=>(n={delta:i,corners:s,closed:!0,segments:r},Eue(n,c))).reduce((c,h)=>c.concat(fg.toSides(fg.fromPoints(h))),[]);return fg.create(l)},"expandGeom2$1");var Rue=Pue;const Iue=u((n,e)=>Array.isArray(n)&&n.length>=e?n.every(t=>Number.isFinite(t)):!1,"isNumberArray$c"),Due=u((n,e)=>Number.isFinite(n)&&n>e,"isGT$d"),Lue=u((n,e)=>Number.isFinite(n)&&n>=e,"isGTE$a");var di={isNumberArray:Iue,isGT:Due,isGTE:Lue};const{TAU:GT}=at,Ze=mt,Oue=Mt,WT=Kt,{sin:jT,cos:XT}=Ei,{isGTE:Fue,isNumberArray:qT}=di,Nue=u(n=>{const e={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:t,radius:i,segments:s,axes:r}=Object.assign({},e,n);if(!qT(t,3))throw new Error("center must be an array of X, Y and Z values");if(!qT(i,3))throw new Error("radius must be an array of X, Y and Z values");if(!i.every(g=>g>0))throw new Error("radius values must be greater than zero");if(!Fue(s,4))throw new Error("segments must be four or more");const o=Ze.scale(Ze.create(),Ze.normalize(Ze.create(),r[0]),i[0]),a=Ze.scale(Ze.create(),Ze.normalize(Ze.create(),r[1]),i[1]),l=Ze.scale(Ze.create(),Ze.normalize(Ze.create(),r[2]),i[2]),c=Math.round(s/4);let h;const f=[],d=Ze.create(),p=Ze.create();for(let g=0;g<=s;g++){const m=GT*g/s,v=Ze.add(Ze.create(),Ze.scale(d,o,XT(m)),Ze.scale(p,a,jT(m)));if(g>0){let y,b;for(let x=0;x<=c;x++){const w=GT/4*x/c,_=XT(w),A=jT(w);if(x>0){let S=[],M;M=Ze.subtract(Ze.create(),Ze.scale(d,h,y),Ze.scale(p,l,b)),S.push(Ze.add(M,M,t)),M=Ze.subtract(Ze.create(),Ze.scale(d,v,y),Ze.scale(p,l,b)),S.push(Ze.add(M,M,t)),x<c&&(M=Ze.subtract(Ze.create(),Ze.scale(d,v,_),Ze.scale(p,l,A)),S.push(Ze.add(M,M,t))),M=Ze.subtract(Ze.create(),Ze.scale(d,h,_),Ze.scale(p,l,A)),S.push(Ze.add(M,M,t)),f.push(WT.create(S)),S=[],M=Ze.add(Ze.create(),Ze.scale(d,h,y),Ze.scale(p,l,b)),S.push(Ze.add(Ze.create(),t,M)),M=Ze.add(M,Ze.scale(d,v,y),Ze.scale(p,l,b)),S.push(Ze.add(Ze.create(),t,M)),x<c&&(M=Ze.add(M,Ze.scale(d,v,_),Ze.scale(p,l,A)),S.push(Ze.add(Ze.create(),t,M))),M=Ze.add(M,Ze.scale(d,h,_),Ze.scale(p,l,A)),S.push(Ze.add(Ze.create(),t,M)),S.reverse(),f.push(WT.create(S))}y=_,b=A}}h=v}return Oue.create(f)},"ellipsoid$1");var Qw=Nue;const kue=Qw,{isGT:zue}=di,Bue=u(n=>{const e={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:t,radius:i,segments:s,axes:r}=Object.assign({},e,n);if(!zue(i,0))throw new Error("radius must be greater than zero");return i=[i,i,i],kue({center:t,radius:i,segments:s,axes:r})},"sphere$2");var y4=Bue;const YT=an,Uue=mt,$ue=Mt,Lf=Kt,Vue=u((n,e)=>{Uue.dot(Lf.plane(e),n)>0&&(e=Lf.invert(e));const i=[e],s=Lf.transform(YT.fromTranslation(YT.create(),n),e),r=e.vertices.length;for(let o=0;o<r;o++){const a=o<r-1?o+1:0,l=Lf.create([e.vertices[o],s.vertices[o],s.vertices[a],e.vertices[a]]);i.push(l)}return i.push(Lf.invert(s)),$ue.create(i)},"extrudePolygon$1");var Hue=Vue;const{EPS:Gue,TAU:Gy}=at,ZT=an,en=mt,Wue=s4,Wy=Mt,Ml=Kt,jue=y4,Xue=rv,jy=l4,que=Hue,Yue=u((n,e,t)=>{const i=e.toString();if(n.has(i))n.get(i)[1].push(t);else{const s=[e,[t]];n.set(i,s)}},"mapPlaneToVertex"),Zue=u((n,e,t)=>{const i=e[0].toString(),s=e[1].toString(),r=i<s?`${i},${s}`:`${s},${i}`;if(n.has(r))n.get(r)[1].push(t);else{const o=[e,[t]];n.set(r,o)}},"mapPlaneToEdge"),Xy=u((n,e)=>{n.findIndex(i=>i===e)<0&&n.push(e)},"addUniqueAngle"),Kue=u((n,e)=>{const t={delta:1,segments:12},{delta:i,segments:s}=Object.assign({},t,n);let r=Wy.create();const o=new Map,a=new Map,l=en.create(),c=en.create();return Wy.toPolygons(e).forEach((f,d)=>{const p=en.scale(en.create(),Ml.plane(f),2*i),g=Ml.transform(ZT.fromTranslation(ZT.create(),en.scale(en.create(),p,-.5)),f),m=que(p,g);r=jy(r,m);const v=f.vertices;for(let y=0;y<v.length;y++){Yue(o,v[y],Ml.plane(f));const b=(y+1)%v.length,x=[v[y],v[b]];Zue(a,x,Ml.plane(f))}}),a.forEach(f=>{const d=f[0],p=f[1],g=d[0],m=d[1],v=en.subtract(en.create(),m,g);en.normalize(v,v);const y=p[0],b=en.cross(en.create(),y,v);let x=[];for(let F=0;F<s;F++)Xy(x,F*Gy/s);for(let F=0,O=p.length;F<O;F++){const N=p[F],E=en.dot(b,N),k=en.dot(y,N);let G=Math.atan2(E,k);G<0&&(G+=Gy),Xy(x,G),G=Math.atan2(-E,-k),G<0&&(G+=Gy),Xy(x,G)}x=x.sort(Wue);const w=x.length;let _,A;const S=[],M=[],C=[];for(let F=-1;F<w;F++){const O=x[F<0?F+w:F],N=Math.sin(O),E=Math.cos(O);en.scale(l,y,E*i),en.scale(c,b,N*i),en.add(l,l,c);const k=en.add(en.create(),g,l),G=en.add(en.create(),m,l);let X=!1;if(F>=0&&en.distance(k,_)<Gue&&(X=!0),!X){if(F>=0){S.push(k),M.push(G);const te=[A,G,k,_],j=Ml.create(te);C.push(j)}_=k,A=G}}M.reverse(),C.push(Ml.create(S)),C.push(Ml.create(M));const I=Wy.create(C);r=jy(r,I)}),o.forEach(f=>{const d=f[0],p=f[1],g=p[0];let m=null,v=0;for(let w=1;w<p.length;w++){const _=p[w],A=en.cross(l,g,_),S=en.length(A);S>.05&&S>v&&(v=S,m=_)}m||(m=en.orthogonal(l,g));const y=en.cross(l,g,m);en.normalize(y,y);const b=en.cross(c,y,g),x=jue({center:[d[0],d[1],d[2]],radius:i,segments:s,axes:[g,y,b]});r=jy(r,x)}),Xue(r)},"expandShell$1");var Que=Kue;const Jue=Mt,ehe=Yw,the=Que,nhe=u((n,e)=>{const t={delta:1,corners:"round",segments:12},{delta:i,corners:s,segments:r}=Object.assign({},t,n);if(s!=="round")throw new Error('corners must be "round" for 3D geometries');if(Jue.toPolygons(e).length===0)throw new Error("the given geometry cannot be empty");n={delta:i,corners:s,segments:r};const a=the(n,e);return ehe(e,a)},"expandGeom3$1");var ihe=nhe;const she=nv,ls=vt,Eu=Tt,Cd=qn,KT=v4,rhe=u(n=>{let{external:e,internal:t}=n;she(e)<0?e=e.reverse():t=t.reverse();const i=Cd.fromPoints({closed:!0},e),s=Cd.fromPoints({closed:!0},t),r=Eu.toSides(Eu.fromPoints(Cd.toPoints(i))),o=Eu.toSides(Eu.fromPoints(Cd.toPoints(s)));return r.push(...o),Eu.create(r)},"createGeometryFromClosedOffsets"),ohe=u((n,e,t,i)=>{const{points:s,external:r,internal:o}=n,a=Math.floor(e/2),l=[],c=[];if(t==="round"&&a>0){const f=Math.PI/a,d=s[s.length-1],p=ls.angle(ls.subtract(ls.create(),r[r.length-1],d)),g=s[0],m=ls.angle(ls.subtract(ls.create(),o[0],g));for(let v=1;v<a;v++){let y=p+f*v,b=ls.fromAngleRadians(ls.create(),y);ls.scale(b,b,i),ls.add(b,b,d),l.push(b),y=m+f*v,b=ls.fromAngleRadians(ls.create(),y),ls.scale(b,b,i),ls.add(b,b,g),c.push(b)}}const h=[];return h.push(...r,...l,...o.reverse(),...c),Eu.fromPoints(h)},"createGeometryFromExpandedOpenPath"),ahe=u((n,e)=>{n=Object.assign({},{delta:1,corners:"edge",segments:16},n);const{delta:i,corners:s,segments:r}=n;if(i<=0)throw new Error("the given delta must be positive for paths");if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const o=e.isClosed,a=Cd.toPoints(e);if(a.length===0)throw new Error("the given geometry cannot be empty");const l={points:a,external:KT({delta:i,corners:s,segments:r,closed:o},a),internal:KT({delta:-i,corners:s,segments:r,closed:o},a)};return e.isClosed?rhe(l):ohe(l,r,s,i)},"expandPath2$1");var lhe=ahe;const che=Xt,uhe=Tt,hhe=Mt,fhe=qn,dhe=Rue,phe=ihe,mhe=lhe,ghe=u((n,...e)=>{if(e=che(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(i=>fhe.isA(i)?mhe(n,i):uhe.isA(i)?dhe(n,i):hhe.isA(i)?phe(n,i):i);return t.length===1?t[0]:t},"expand$2");var b4=ghe;const vhe=qn,yhe=b4,bhe=cv,xhe=u((n,e)=>{const t={size:1,height:1},{size:i,height:s}=Object.assign({},t,n);if(n.delta=i,n.offset=[0,0,s],vhe.toPoints(e).length===0)throw new Error("the given geometry cannot be empty");const o=yhe(n,e);return bhe(n,o)},"extrudeRectangularPath2$1");var _he=xhe;const{area:whe}=jw,qy=Tt,Ahe=qn,Mhe=b4,She=cv,The=u((n,e)=>{const t={size:1,height:1},{size:i,height:s}=Object.assign({},t,n);n.delta=i,n.offset=[0,0,s];const r=qy.toOutlines(e);if(r.length===0)throw new Error("the given geometry cannot be empty");const a=r.map(c=>(whe(c)<0&&c.reverse(),Mhe(n,Ahe.fromPoints({closed:!0},c)))).reduce((c,h)=>c.concat(qy.toSides(h)),[]),l=qy.create(a);return She(n,l)},"extrudeRectangularGeom2$1");var Che=The;const Ehe=Xt,Phe=Tt,Rhe=qn,Ihe=_he,Dhe=Che,Lhe=u((n,...e)=>{const t={size:1,height:1},{size:i,height:s}=Object.assign({},t,n);if(e=Ehe(e),e.length===0)throw new Error("wrong number of arguments");if(i<=0)throw new Error("size must be positive");if(s<=0)throw new Error("height must be positive");const r=e.map(o=>Rhe.isA(o)?Ihe(n,o):Phe.isA(o)?Dhe(n,o):o);return r.length===1?r[0]:r},"extrudeRectangular");var Ohe=Lhe;const Fhe=Xt,QT=an,JT=ra,eC=Tt,tC=Mt,nC=qn,uv=u((n,...e)=>{const t={origin:[0,0,0],normal:[0,0,1]},{origin:i,normal:s}=Object.assign({},t,n);if(e=Fhe(e),e.length===0)throw new Error("wrong number of arguments");const r=JT.fromNormalAndPoint(JT.create(),s,i);if(Number.isNaN(r[0]))throw new Error("the given origin and normal do not define a proper plane");const o=QT.mirrorByPlane(QT.create(),r),a=e.map(l=>nC.isA(l)?nC.transform(o,l):eC.isA(l)?eC.transform(o,l):tC.isA(l)?tC.transform(o,l):l);return a.length===1?a[0]:a},"mirror"),Nhe=u((...n)=>uv({normal:[1,0,0]},n),"mirrorX$1"),khe=u((...n)=>uv({normal:[0,1,0]},n),"mirrorY"),zhe=u((...n)=>uv({normal:[0,0,1]},n),"mirrorZ");var Ed={mirror:uv,mirrorX:Nhe,mirrorY:khe,mirrorZ:zhe};const{TAU:As}=at,Of=an,{mirrorX:Bhe}=Ed,Ff=Tt,Yy=Wh,Uhe=lv,$he=u((n,e)=>{const t={segments:12,startAngle:0,angle:As,overflow:"cap"};let{segments:i,startAngle:s,angle:r,overflow:o}=Object.assign({},t,n);if(i<3)throw new Error("segments must be greater then 3");s=Math.abs(s)>As?s%As:s,r=Math.abs(r)>As?r%As:r;let a=s+r;if(a=Math.abs(a)>As?a%As:a,a<s){const b=s;s=a,a=b}let l=a-s;if(l<=0&&(l=As),Math.abs(l)<As){const b=As/i;i=Math.floor(Math.abs(l)/b),Math.abs(l)>i*b&&i++}let c=Ff.toSides(e);if(c.length===0)throw new Error("the given geometry cannot be empty");const h=c.filter(b=>b[0][0]<0),f=c.filter(b=>b[0][0]>=0);h.length>0&&f.length>0&&o==="cap"&&(h.length>f.length?(c=c.map(b=>{let x=b[0],w=b[1];return x=[Math.min(x[0],0),x[1]],w=[Math.min(w[0],0),w[1]],[x,w]}),e=Ff.reverse(Ff.create(c)),e=Bhe(e)):f.length>=h.length&&(c=c.map(b=>{let x=b[0],w=b[1];return x=[Math.max(x[0],0),x[1]],w=[Math.max(w[0],0),w[1]],[x,w]}),e=Ff.create(c)));const p=l/i,g=Math.abs(l)<As,m=Yy.fromSides(Ff.toSides(e));Yy.reverse(m,m);const v=Of.create(),y=u((b,x,w)=>{let _=p*x+s;return l===As&&x===i&&(_=s),Of.multiply(v,Of.fromZRotation(v,_),Of.fromXRotation(Of.create(),As/4)),Yy.transform(v,w)},"createSlice");return n={numberOfSlices:i+1,capStart:g,capEnd:g,close:!g,callback:y},Uhe(n,m)},"extrudeRotate$1");var x4=$he;const{TAU:Nf}=at,Zy=Wh,Nr=an,Vhe=lv,Hhe=Tt,Ghe=u((n,e)=>{const t={angle:Nf,startAngle:0,pitch:10,endOffset:0,segmentsPerRotation:32},{angle:i,endOffset:s,segmentsPerRotation:r,startAngle:o}=Object.assign({},t,n);let a;if(!n.pitch&&n.height?a=n.height/(i/Nf):a=n.pitch?n.pitch:t.pitch,r<3)throw new Error("The number of segments per rotation needs to be at least 3.");let c=Hhe.toSides(e);if(c.length===0)throw new Error("the given geometry cannot be empty");const h=c.filter(y=>y[0][0]>=0);let f=Zy.fromSides(c);h.length===0&&(f=Zy.reverse(f));const d=Math.round(r/Nf*Math.abs(i)),p=d>=2?d:2,g=Nr.create();let m;const v=u((y,b,x)=>{const w=o+i/p*b,_=s/p*b,A=(w-o)/Nf*a;return Nr.multiply(g,Nr.fromTranslation(Nr.create(),[_,0,A*Math.sign(i)]),Nr.fromXRotation(Nr.create(),-Nf/4*Math.sign(i))),m=Nr.create(),Nr.multiply(m,Nr.fromZRotation(Nr.create(),w),g),Zy.transform(m,x)},"sliceCallback");return Vhe({numberOfSlices:p+1,callback:v},f)},"extrudeHelical");var Whe=Ghe;const jhe=Xt,iC=Hw,Ky=ra,sC=an,rC=Tt,_4=Mt,iu=Kt,Xhe=$p,qhe=u4,Yhe=u((n,e)=>{const t=Ky.fromNormalAndPoint(Ky.create(),n.axis,n.origin);if(Number.isNaN(t[0])||Number.isNaN(t[1])||Number.isNaN(t[2])||Number.isNaN(t[3]))throw new Error("project: invalid axis or origin");const i=Xhe(e),s=i*i*Math.sqrt(3)/4;if(i===0)return rC.create();const r=_4.toPolygons(e);let o=[];for(let l=0;l<r.length;l++){const c=r[l].vertices.map(d=>Ky.projectionOfPoint(t,d)),h=iu.create(c),f=iu.plane(h);!iC(t,f)||iu.measureArea(h)<s||o.push(h)}if(!iC(t,[0,0,1])){const l=sC.fromVectorRotation(sC.create(),t,[0,0,1]);o=o.map(c=>iu.transform(l,c))}o=o.sort((l,c)=>iu.measureArea(c)-iu.measureArea(l));const a=o.map(l=>rC.fromPoints(l.vertices));return qhe(a)},"projectGeom3"),Zhe=u((n,...e)=>{const t={axis:[0,0,1],origin:[0,0,0]},{axis:i,origin:s}=Object.assign({},t,n);if(e=jhe(e),e.length===0)throw new Error("wrong number of arguments");n={axis:i,origin:s};const r=e.map(o=>_4.isA(o)?Yhe(n,o):o);return r.length===1?r[0]:r},"project");var Khe=Zhe,dg={extrudeFromSlices:lv,extrudeLinear:Aue,extrudeRectangular:Ohe,extrudeRotate:x4,extrudeHelical:Whe,project:Khe,slice:Wh};const oC=vt,Qhe=u(n=>{let e=oC.fromValues(1/0,1/0);n.forEach(s=>{(s[1]<e[1]||s[1]===e[1]&&s[0]<e[0])&&(e=s)});const t=[];n.forEach(s=>{const r=efe(s[1]-e[1],s[0]-e[0]),o=oC.squaredDistance(s,e);t.push({point:s,angle:r,distSq:o})}),t.sort((s,r)=>s.angle<r.angle?-1:s.angle>r.angle?1:s.distSq<r.distSq?-1:s.distSq>r.distSq?1:0);const i=[];return t.forEach(s=>{let r=i.length;for(;r>1&&Jhe(i[r-2],i[r-1],s.point)<=Number.EPSILON;)i.pop(),r=i.length;i.push(s.point)}),i},"hullPoints2$2"),Jhe=u((n,e,t)=>(e[0]-n[0])*(t[1]-n[1])-(e[1]-n[1])*(t[0]-n[0]),"ccw"),efe=u((n,e)=>n===0&&e===0?-1/0:-e/n,"fakeAtan2");var w4=Qhe;const aC=Tt,lC=Mt,cC=qn,tfe=u(n=>{const e=new Set,t=[],i=u(s=>{const r=s.toString();e.has(r)||(t.push(s),e.add(r))},"addPoint");return n.forEach(s=>{aC.isA(s)?aC.toPoints(s).forEach(i):lC.isA(s)?lC.toPoints(s).forEach(r=>r.forEach(i)):cC.isA(s)&&cC.toPoints(s).forEach(i)}),t},"toUniquePoints$3");var Jw=tfe;const nfe=Xt,ife=qn,sfe=w4,rfe=Jw,ofe=u((...n)=>{n=nfe(n);const e=rfe(n),t=sfe(e);return ife.fromPoints({closed:!0},t)},"hullPath2$1");var afe=ofe;const lfe=Xt,uC=Tt,cfe=w4,ufe=Jw,hfe=u((...n)=>{n=lfe(n);const e=ufe(n),t=cfe(e);return t.length<3?uC.create():uC.fromPoints(t)},"hullGeom2$1");var ffe=hfe;const dfe=zp,hC=Y1,fC=MO,pfe=u((n,e,t)=>{const i=[],s=[],r=[];hC(i,t,e),hC(s,n,e);const o=fC(dfe(r,s,i)),a=fC(i);if(a===0)throw Error("a and b are the same point");return o/a},"distanceSquared"),mfe=u((n,e,t)=>Math.sqrt(pfe(n,e,t)),"pointLineDistance$1");var gfe=mfe;const vfe=zp,yfe=Ow,dC=Y1,bfe=u((n,e,t,i)=>{const s=[0,0,0];return dC(n,e,t),dC(s,t,i),vfe(n,n,s),yfe(n,n)},"planeNormal");var xfe=bfe;class A4{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(e,t){t.prev=e.prev,t.next=e,t.prev?t.prev.next=t:this.head=t,e.prev=t}insertAfter(e,t){t.prev=e,t.next=e.next,t.next?t.next.prev=t:this.tail=t,e.next=t}add(e){this.head?this.tail.next=e:this.head=e,e.prev=this.tail,e.next=null,this.tail=e}addAll(e){for(this.head?this.tail.next=e:this.head=e,e.prev=this.tail;e.next;)e=e.next;this.tail=e}remove(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}removeChain(e,t){e.prev?e.prev.next=t.next:this.head=t.next,t.next?t.next.prev=e.prev:this.tail=e.prev}first(){return this.head}isEmpty(){return!this.head}}u(A4,"VertexList$1");var _fe=A4;class M4{constructor(e,t){this.point=e,this.index=t,this.next=null,this.prev=null,this.face=null}}u(M4,"Vertex$1");var wfe=M4;const Afe=yO,Mfe=AO;class S4{constructor(e,t){this.vertex=e,this.face=t,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?Afe(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?Mfe(this.tail().point,this.head().point):-1}setOpposite(e){this.opposite=e,e.opposite=this}}u(S4,"HalfEdge$1");var Sfe=S4;const Qy=gO,Tfe=vO,Cfe=zp,Jy=X1,Efe=bO,Pfe=Ow,pg=wO,eb=Y1,tb=Sfe,T4=0,Rfe=1,Gx=2;class hv{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=T4,this.edge=null,this.nVertices=0}getEdge(e){if(typeof e!="number")throw Error("requires a number");let t=this.edge;for(;e>0;)t=t.next,e-=1;for(;e<0;)t=t.prev,e+=1;return t}computeNormal(){const e=this.edge,t=e.next;let i=t.next;const s=eb([],t.head().point,e.head().point),r=[],o=[];for(this.nVertices=2,this.normal=[0,0,0];i!==e;)Tfe(o,s),eb(s,i.head().point,e.head().point),Qy(this.normal,this.normal,Cfe(r,o,s)),i=i.next,this.nVertices+=1;this.area=Efe(this.normal),this.normal=pg(this.normal,this.normal,1/this.area)}computeNormalMinArea(e){if(this.computeNormal(),this.area<e){let t,i=0,s=this.edge;do{const h=s.lengthSquared();h>i&&(t=s,i=h),s=s.next}while(s!==this.edge);const r=t.tail().point,o=t.head().point,a=eb([],o,r),l=Math.sqrt(i);pg(a,a,1/l);const c=Jy(this.normal,a);pg(a,a,-c),Qy(this.normal,this.normal,a),Pfe(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let e=this.edge;do Qy(this.centroid,this.centroid,e.head().point),e=e.next;while(e!==this.edge);pg(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(e){typeof e!="undefined"?this.computeNormalMinArea(e):this.computeNormal(),this.computeCentroid(),this.offset=Jy(this.normal,this.centroid)}distanceToPlane(e){return Jy(this.normal,e)-this.offset}connectHalfEdges(e,t){let i;if(e.opposite.face===t.opposite.face){const s=t.opposite.face;let r;e===this.edge&&(this.edge=t),s.nVertices===3?(r=t.opposite.prev.opposite,s.mark=Gx,i=s):(r=t.opposite.next,s.edge===r.prev&&(s.edge=r),r.prev=r.prev.prev,r.prev.next=r),t.prev=e.prev,t.prev.next=t,t.setOpposite(r),s.computeNormalAndCentroid()}else e.next=t,t.prev=e;return i}mergeAdjacentFaces(e,t){const i=e.opposite,s=i.face;t.push(s),s.mark=Gx;let r=e.prev,o=e.next,a=i.prev,l=i.next;for(;r.opposite.face===s;)r=r.prev,l=l.next;for(;o.opposite.face===s;)o=o.next,a=a.prev;let c;for(c=l;c!==a.next;c=c.next)c.face=this;this.edge=o;let h;return h=this.connectHalfEdges(a,o),h&&t.push(h),h=this.connectHalfEdges(r,l),h&&t.push(h),this.computeNormalAndCentroid(),t}collectIndices(){const e=[];let t=this.edge;do e.push(t.head().index),t=t.next;while(t!==this.edge);return e}static createTriangle(e,t,i,s=0){const r=new hv,o=new tb(e,r),a=new tb(t,r),l=new tb(i,r);return o.next=l.prev=a,a.next=o.prev=l,l.next=a.prev=o,r.edge=o,r.computeNormalAndCentroid(s),r}}u(hv,"Face$1");var Ife={VISIBLE:T4,NON_CONVEX:Rfe,DELETED:Gx,Face:hv};const nb=X1,Dfe=gfe,Lfe=xfe,pC=_fe,Ofe=wfe,{Face:bo,VISIBLE:su,NON_CONVEX:mC,DELETED:Ffe}=Ife,Nfe=1,gC=2;class C4{constructor(e){if(!Array.isArray(e))throw TypeError("input is not a valid array");if(e.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=e.length,this.faces=[],this.newFaces=[],this.claimed=new pC,this.unclaimed=new pC,this.vertices=[];for(let t=0;t<e.length;t+=1)this.vertices.push(new Ofe(e[t],t));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(e,t){e.face=t,t.outside?this.claimed.insertBefore(t.outside,e):this.claimed.add(e),t.outside=e}removeVertexFromFace(e,t){e===t.outside&&(e.next&&e.next.face===t?t.outside=e.next:t.outside=null),this.claimed.remove(e)}removeAllVerticesFromFace(e){if(e.outside){let t=e.outside;for(;t.next&&t.next.face===e;)t=t.next;return this.claimed.removeChain(e.outside,t),t.next=null,e.outside}}deleteFaceVertices(e,t){const i=this.removeAllVerticesFromFace(e);if(i)if(!t)this.unclaimed.addAll(i);else{let s;for(let r=i;r;r=s)s=r.next,t.distanceToPlane(r.point)>this.tolerance?this.addVertexToFace(r,t):this.unclaimed.add(r)}}resolveUnclaimedPoints(e){let t=this.unclaimed.first();for(let i=t;i;i=t){t=i.next;let s=this.tolerance,r;for(let o=0;o<e.length;o+=1){const a=e[o];if(a.mark===su){const l=a.distanceToPlane(i.point);if(l>s&&(s=l,r=a),s>1e3*this.tolerance)break}}r&&this.addVertexToFace(i,r)}}computeExtremes(){const e=[],t=[],i=[],s=[];let r,o;for(r=0;r<3;r+=1)i[r]=s[r]=this.vertices[0];for(r=0;r<3;r+=1)e[r]=t[r]=this.vertices[0].point[r];for(r=1;r<this.vertices.length;r+=1){const a=this.vertices[r],l=a.point;for(o=0;o<3;o+=1)l[o]<e[o]&&(e[o]=l[o],i[o]=a);for(o=0;o<3;o+=1)l[o]>t[o]&&(t[o]=l[o],s[o]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e[0]),Math.abs(t[0]))+Math.max(Math.abs(e[1]),Math.abs(t[1]))+Math.max(Math.abs(e[2]),Math.abs(t[2]))),[i,s]}createInitialSimplex(){const e=this.vertices,[t,i]=this.computeExtremes();let s,r,o,a,l=0,c=0;for(o=0;o<3;o+=1){const m=i[o].point[o]-t[o].point[o];m>l&&(l=m,c=o)}const h=t[c],f=i[c];for(l=0,o=0;o<this.vertices.length;o+=1){const m=this.vertices[o];if(m!==h&&m!==f){const v=Dfe(m.point,h.point,f.point);v>l&&(l=v,s=m)}}const d=Lfe([],h.point,f.point,s.point),p=nb(h.point,d);for(l=-1,o=0;o<this.vertices.length;o+=1){const m=this.vertices[o];if(m!==h&&m!==f&&m!==s){const v=Math.abs(nb(d,m.point)-p);v>l&&(l=v,r=m)}}const g=[];if(nb(r.point,d)-p<0)for(g.push(bo.createTriangle(h,f,s),bo.createTriangle(r,f,h),bo.createTriangle(r,s,f),bo.createTriangle(r,h,s)),o=0;o<3;o+=1){const m=(o+1)%3;g[o+1].getEdge(2).setOpposite(g[0].getEdge(m)),g[o+1].getEdge(1).setOpposite(g[m+1].getEdge(0))}else for(g.push(bo.createTriangle(h,s,f),bo.createTriangle(r,h,f),bo.createTriangle(r,f,s),bo.createTriangle(r,s,h)),o=0;o<3;o+=1){const m=(o+1)%3;g[o+1].getEdge(2).setOpposite(g[0].getEdge((3-o)%3)),g[o+1].getEdge(0).setOpposite(g[m+1].getEdge(1))}for(o=0;o<4;o+=1)this.faces.push(g[o]);for(o=0;o<e.length;o+=1){const m=e[o];if(m!==h&&m!==f&&m!==s&&m!==r){l=this.tolerance;let v;for(a=0;a<4;a+=1){const y=g[a].distanceToPlane(m.point);y>l&&(l=y,v=g[a])}v&&this.addVertexToFace(m,v)}}}reindexFaceAndVertices(){const e=[];for(let t=0;t<this.faces.length;t+=1){const i=this.faces[t];i.mark===su&&e.push(i)}this.faces=e}collectFaces(e){const t=[];for(let i=0;i<this.faces.length;i+=1){if(this.faces[i].mark!==su)throw Error("attempt to include a destroyed face in the hull");const s=this.faces[i].collectIndices();if(e)t.push(s);else for(let r=0;r<s.length-2;r+=1)t.push([s[0],s[r+1],s[r+2]])}return t}nextVertexToAdd(){if(!this.claimed.isEmpty()){let e,t,i=0;const s=this.claimed.first().face;for(t=s.outside;t&&t.face===s;t=t.next){const r=s.distanceToPlane(t.point);r>i&&(i=r,e=t)}return e}}computeHorizon(e,t,i,s){this.deleteFaceVertices(i),i.mark=Ffe;let r;t?r=t.next:r=t=i.getEdge(0);do{const o=r.opposite,a=o.face;a.mark===su&&(a.distanceToPlane(e)>this.tolerance?this.computeHorizon(e,o,a,s):s.push(r)),r=r.next}while(r!==t)}addAdjoiningFace(e,t){const i=bo.createTriangle(e,t.tail(),t.head());return this.faces.push(i),i.getEdge(-1).setOpposite(t.opposite),i.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let i,s;for(let r=0;r<t.length;r+=1){const o=t[r],a=this.addAdjoiningFace(e,o);i?a.next.setOpposite(s):i=a,this.newFaces.push(a.face),s=a}i.next.setOpposite(s)}oppositeFaceDistance(e){return e.face.distanceToPlane(e.opposite.face.centroid)}doAdjacentMerge(e,t){let i=e.edge,s=!0,r=0;do{if(r>=e.nVertices)throw Error("merge recursion limit exceeded");const o=i.opposite.face;let a=!1;if(t===gC?(this.oppositeFaceDistance(i)>-this.tolerance||this.oppositeFaceDistance(i.opposite)>-this.tolerance)&&(a=!0):e.area>o.area?this.oppositeFaceDistance(i)>-this.tolerance?a=!0:this.oppositeFaceDistance(i.opposite)>-this.tolerance&&(s=!1):this.oppositeFaceDistance(i.opposite)>-this.tolerance?a=!0:this.oppositeFaceDistance(i)>-this.tolerance&&(s=!1),a){const l=e.mergeAdjacentFaces(i,[]);for(let c=0;c<l.length;c+=1)this.deleteFaceVertices(l[c],e);return!0}i=i.next,r+=1}while(i!==e.edge);return s||(e.mark=mC),!1}addVertexToHull(e){const t=[];this.unclaimed.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t);for(let i=0;i<this.newFaces.length;i+=1){const s=this.newFaces[i];if(s.mark===su)for(;this.doAdjacentMerge(s,Nfe););}for(let i=0;i<this.newFaces.length;i+=1){const s=this.newFaces[i];if(s.mark===mC)for(s.mark=su;this.doAdjacentMerge(s,gC););}this.resolveUnclaimedPoints(this.newFaces)}build(){let e;for(this.createInitialSimplex();e=this.nextVertexToAdd();)this.addVertexToHull(e);this.reindexFaceAndVertices()}}u(C4,"QuickHull$1");var kfe=C4;const zfe=kfe,Bfe=u((n,e={})=>{const t=new zfe(n);return t.build(),t.collectFaces(e.skipTriangulation)},"runner");var Ufe=Bfe;const $fe=Xt,Vfe=Mt,Hfe=Kt,Gfe=Ufe,Wfe=Jw,jfe=u((...n)=>{if(n=$fe(n),n.length===1)return n[0];const e=Wfe(n),i=Gfe(e,{skipTriangulation:!0}).map(s=>{const r=s.map(o=>e[o]);return Hfe.create(r)});return Vfe.create(i)},"hullGeom3$1");var Xfe=jfe;const qfe=Xt,Yfe=Up,Zfe=Tt,Kfe=Mt,Qfe=qn,Jfe=afe,ede=ffe,tde=Xfe,nde=u((...n)=>{if(n=qfe(n),n.length===0)throw new Error("wrong number of arguments");if(!Yfe(n))throw new Error("only hulls of the same type are supported");const e=n[0];return Qfe.isA(e)?Jfe(n):Zfe.isA(e)?ede(n):Kfe.isA(e)?tde(n):e},"hull$1");var E4=nde;const ide=Xt,sde=Yw,rde=E4,ode=u((...n)=>{if(n=ide(n),n.length<2)throw new Error("wrong number of arguments");const e=[];for(let t=1;t<n.length;t++)e.push(rde(n[t-1],n[t]));return sde(e)},"hullChain");var ade=ode,vC={hull:E4,hullChain:ade};const lde=u((n,e,t)=>{for(n=n.slice();n.length<t;)n.push(e);return n},"padArrayToLength$1");var cde=lde;const ude=Xt,hde=_O,fde=xO,dde=iv,pde=u((...n)=>{if(n=ude(n),n.length===0)throw new Error("measureAggregateBoundingBox: no geometries supplied");const e=dde(n);if(n.length===1)return e;const t=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return e.reduce((i,s)=>(i=[hde(i[0],i[0],s[0]),fde(i[1],i[1],s[1])],i),t)},"measureAggregateBoundingBox$1");var mde=pde;const gde=Xt,yC=an,bC=Tt,xC=Mt,_C=qn,fv=u((n,...e)=>{if(!Array.isArray(n))throw new Error("offset must be an array");if(e=gde(e),e.length===0)throw new Error("wrong number of arguments");for(n=n.slice();n.length<3;)n.push(0);const t=yC.fromTranslation(yC.create(),n),i=e.map(s=>_C.isA(s)?_C.transform(t,s):bC.isA(s)?bC.transform(t,s):xC.isA(s)?xC.transform(t,s):s);return i.length===1?i[0]:i},"translate$3"),vde=u((n,...e)=>fv([n,0,0],e),"translateX"),yde=u((n,...e)=>fv([0,n,0],e),"translateY"),bde=u((n,...e)=>fv([0,0,n],e),"translateZ");var Ql={translate:fv,translateX:vde,translateY:yde,translateZ:bde};const xde=Xt,wC=cde,P4=mde,{translate:_de}=Ql,wde=u(n=>{if(!Array.isArray(n.modes)||n.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(n.modes=wC(n.modes,"none",3),n.modes.filter(e=>["center","max","min","none"].includes(e)).length!==3)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(n.relativeTo)||n.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(n.relativeTo=wC(n.relativeTo,0,3),n.relativeTo.filter(e=>Number.isFinite(e)||e==null).length!==3)throw new Error("align(): all relativeTo values must be a number, or null.");if(typeof n.grouped!="boolean")throw new Error("align(): grouped must be a boolean value.");return n},"validateOptions"),Ade=u((n,e,t)=>{for(let i=0;i<3;i++)n[i]==null&&(e[i]==="center"?n[i]=(t[0][i]+t[1][i])/2:e[i]==="max"?n[i]=t[1][i]:e[i]==="min"&&(n[i]=t[0][i]));return n},"populateRelativeToFromBounds"),AC=u((n,e,t)=>{const i=P4(n),s=[0,0,0];for(let r=0;r<3;r++)e[r]==="center"?s[r]=t[r]-(i[0][r]+i[1][r])/2:e[r]==="max"?s[r]=t[r]-i[1][r]:e[r]==="min"&&(s[r]=t[r]-i[0][r]);return _de(s,n)},"alignGeometries"),Mde=u((n,...e)=>{n=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},n),n=wde(n);let{modes:i,relativeTo:s,grouped:r}=n;if(e=xde(e),e.length===0)throw new Error("align(): No geometries were provided to act upon");if(s.filter(o=>o==null).length){const o=P4(e);s=Ade(s,i,o)}return r?e=AC(e,i,s):e=e.map(o=>AC(o,i,s)),e.length===1?e[0]:e},"align");var Sde=Mde;const Tde=Xt,Cde=Tt,Ede=Mt,Pde=qn,Rde=iv,{translate:Ide}=Ql,ib=u((n,e)=>{const t={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:i,relativeTo:s}=Object.assign({},t,n),r=Rde(e),o=[0,0,0];return i[0]&&(o[0]=s[0]-(r[0][0]+(r[1][0]-r[0][0])/2)),i[1]&&(o[1]=s[1]-(r[0][1]+(r[1][1]-r[0][1])/2)),i[2]&&(o[2]=s[2]-(r[0][2]+(r[1][2]-r[0][2])/2)),Ide(o,e)},"centerGeometry"),dv=u((n,...e)=>{const t={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:i,relativeTo:s}=Object.assign({},t,n);if(e=Tde(e),e.length===0)throw new Error("wrong number of arguments");if(s.length!==3)throw new Error("relativeTo must be an array of length 3");n={axes:i,relativeTo:s};const r=e.map(o=>Pde.isA(o)||Cde.isA(o)||Ede.isA(o)?ib(n,o):o);return r.length===1?r[0]:r},"center"),Dde=u((...n)=>dv({axes:[!0,!1,!1]},n),"centerX"),Lde=u((...n)=>dv({axes:[!1,!0,!1]},n),"centerY"),Ode=u((...n)=>dv({axes:[!1,!1,!0]},n),"centerZ");var mg={center:dv,centerX:Dde,centerY:Lde,centerZ:Ode};const Fde=Xt,MC=an,SC=Tt,TC=Mt,CC=qn,pv=u((n,...e)=>{if(!Array.isArray(n))throw new Error("angles must be an array");if(e=Fde(e),e.length===0)throw new Error("wrong number of arguments");for(n=n.slice();n.length<3;)n.push(0);const t=n[2],i=n[1],s=n[0],r=MC.fromTaitBryanRotation(MC.create(),t,i,s),o=e.map(a=>CC.isA(a)?CC.transform(r,a):SC.isA(a)?SC.transform(r,a):TC.isA(a)?TC.transform(r,a):a);return o.length===1?o[0]:o},"rotate$1"),Nde=u((n,...e)=>pv([n,0,0],e),"rotateX"),kde=u((n,...e)=>pv([0,n,0],e),"rotateY"),zde=u((n,...e)=>pv([0,0,n],e),"rotateZ");var Pd={rotate:pv,rotateX:Nde,rotateY:kde,rotateZ:zde};const Bde=Xt,EC=an,PC=Tt,RC=Mt,IC=qn,mv=u((n,...e)=>{if(!Array.isArray(n))throw new Error("factors must be an array");if(e=Bde(e),e.length===0)throw new Error("wrong number of arguments");for(n=n.slice();n.length<3;)n.push(1);if(n[0]<=0||n[1]<=0||n[2]<=0)throw new Error("factors must be positive");const t=EC.fromScaling(EC.create(),n),i=e.map(s=>IC.isA(s)?IC.transform(t,s):PC.isA(s)?PC.transform(t,s):RC.isA(s)?RC.transform(t,s):s);return i.length===1?i[0]:i},"scale"),Ude=u((n,...e)=>mv([n,1,1],e),"scaleX"),$de=u((n,...e)=>mv([1,n,1],e),"scaleY"),Vde=u((n,...e)=>mv([1,1,n],e),"scaleZ");var gg={scale:mv,scaleX:Ude,scaleY:$de,scaleZ:Vde};const Hde=Xt,DC=Tt,LC=Mt,OC=qn,Gde=u((n,...e)=>{if(e=Hde(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(i=>OC.isA(i)?OC.transform(n,i):DC.isA(i)?DC.transform(n,i):LC.isA(i)?LC.transform(n,i):i);return t.length===1?t[0]:t},"transform");var Wde=Gde,sb={align:Sde,center:mg.center,centerX:mg.centerX,centerY:mg.centerY,centerZ:mg.centerZ,mirror:Ed.mirror,mirrorX:Ed.mirrorX,mirrorY:Ed.mirrorY,mirrorZ:Ed.mirrorZ,rotate:Pd.rotate,rotateX:Pd.rotateX,rotateY:Pd.rotateY,rotateZ:Pd.rotateZ,scale:gg.scale,scaleX:gg.scaleX,scaleY:gg.scaleY,scaleZ:gg.scaleZ,transform:Wde,translate:Ql.translate,translateX:Ql.translateX,translateY:Ql.translateY,translateZ:Ql.translateZ};const{EPS:FC,TAU:ru}=at,xo=vt,jde=qn,{isGT:Xde,isGTE:rb,isNumberArray:qde}=di,Yde=u(n=>{const e={center:[0,0],radius:1,startAngle:0,endAngle:ru,makeTangent:!1,segments:32};let{center:t,radius:i,startAngle:s,endAngle:r,makeTangent:o,segments:a}=Object.assign({},e,n);if(!qde(t,2))throw new Error("center must be an array of X and Y values");if(!Xde(i,0))throw new Error("radius must be greater than zero");if(!rb(s,0))throw new Error("startAngle must be positive");if(!rb(r,0))throw new Error("endAngle must be positive");if(!rb(a,4))throw new Error("segments must be four or more");s=s%ru,r=r%ru;let l=ru;s<r&&(l=r-s),s>r&&(l=r+(ru-s));const c=Math.acos((i*i+i*i-FC*FC)/(2*i*i)),h=xo.clone(t);let f;const d=[];if(l<c)f=xo.fromAngleRadians(xo.create(),s),xo.scale(f,f,i),xo.add(f,f,h),d.push(f);else{const p=Math.max(1,Math.floor(a*(l/ru)))+1;let g=p*.5/l;g>.25&&(g=.25);const m=o?p+2:p;for(let v=0;v<=m;v++){let y=v;o&&(y=(v-1)*(p-2*g)/p+g,y<0&&(y=0),y>p&&(y=p));const b=s+y*(l/p);f=xo.fromAngleRadians(xo.create(),b),xo.scale(f,f,i),xo.add(f,f,h),d.push(f)}}return jde.fromPoints({closed:!1},d)},"arc");var Zde=Yde;const{EPS:NC,TAU:Ma}=at,ob=vt,Kde=Tt,{sin:Qde,cos:Jde}=Ei,{isGTE:ab,isNumberArray:kC}=di,epe=u(n=>{const e={center:[0,0],radius:[1,1],startAngle:0,endAngle:Ma,segments:32};let{center:t,radius:i,startAngle:s,endAngle:r,segments:o}=Object.assign({},e,n);if(!kC(t,2))throw new Error("center must be an array of X and Y values");if(!kC(i,2))throw new Error("radius must be an array of X and Y values");if(!i.every(p=>p>0))throw new Error("radius values must be greater than zero");if(!ab(s,0))throw new Error("startAngle must be positive");if(!ab(r,0))throw new Error("endAngle must be positive");if(!ab(o,3))throw new Error("segments must be three or more");s=s%Ma,r=r%Ma;let a=Ma;s<r&&(a=r-s),s>r&&(a=r+(Ma-s));const l=Math.min(i[0],i[1]),c=Math.acos((l*l+l*l-NC*NC)/(2*l*l));if(a<c)throw new Error("startAngle and endAngle do not define a significant rotation");o=Math.floor(o*(a/Ma));const h=ob.clone(t),f=a/o,d=[];o=a<Ma?o+1:o;for(let p=0;p<o;p++){const g=f*p+s,m=ob.fromValues(i[0]*Jde(g),i[1]*Qde(g));ob.add(m,h,m),d.push(m)}return a<Ma&&d.push(h),Kde.fromPoints(d)},"ellipse$1");var R4=epe;const{TAU:tpe}=at,npe=R4,{isGT:ipe}=di,spe=u(n=>{const e={center:[0,0],radius:1,startAngle:0,endAngle:tpe,segments:32};let{center:t,radius:i,startAngle:s,endAngle:r,segments:o}=Object.assign({},e,n);if(!ipe(i,0))throw new Error("radius must be greater than zero");return i=[i,i],npe({center:t,radius:i,startAngle:s,endAngle:r,segments:o})},"circle$1");var I4=spe;const rpe=Mt,ope=Kt,{isNumberArray:zC}=di,ape=u(n=>{const e={center:[0,0,0],size:[2,2,2]},{center:t,size:i}=Object.assign({},e,n);if(!zC(t,3))throw new Error("center must be an array of X, Y and Z values");if(!zC(i,3))throw new Error("size must be an array of width, depth and height values");if(!i.every(r=>r>0))throw new Error("size values must be greater than zero");return rpe.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(r=>{const o=r[0].map(a=>[t[0]+i[0]/2*(2*!!(a&1)-1),t[1]+i[1]/2*(2*!!(a&2)-1),t[2]+i[2]/2*(2*!!(a&4)-1)]);return ope.create(o)}))},"cuboid$1");var D4=ape;const lpe=D4,{isGT:cpe}=di,upe=u(n=>{const e={center:[0,0,0],size:2};let{center:t,size:i}=Object.assign({},e,n);if(!cpe(i,0))throw new Error("size must be greater than zero");return i=[i,i,i],lpe({center:t,size:i})},"cube");var hpe=upe;const{EPS:BC,TAU:Sa}=at,vi=mt,fpe=Mt,dpe=Kt,{sin:ppe,cos:mpe}=Ei,{isGT:gpe,isGTE:lb,isNumberArray:cb}=di,vpe=u(n=>{const e={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:Sa,segments:32};let{center:t,height:i,startRadius:s,startAngle:r,endRadius:o,endAngle:a,segments:l}=Object.assign({},e,n);if(!cb(t,3))throw new Error("center must be an array of X, Y and Z values");if(!gpe(i,0))throw new Error("height must be greater then zero");if(!cb(s,2))throw new Error("startRadius must be an array of X and Y values");if(!s.every(C=>C>=0))throw new Error("startRadius values must be positive");if(!cb(o,2))throw new Error("endRadius must be an array of X and Y values");if(!o.every(C=>C>=0))throw new Error("endRadius values must be positive");if(o.every(C=>C===0)&&s.every(C=>C===0))throw new Error("at least one radius must be positive");if(!lb(r,0))throw new Error("startAngle must be positive");if(!lb(a,0))throw new Error("endAngle must be positive");if(!lb(l,4))throw new Error("segments must be four or more");r=r%Sa,a=a%Sa;let c=Sa;r<a&&(c=a-r),r>a&&(c=a+(Sa-r));const h=Math.min(s[0],s[1],o[0],o[1]),f=Math.acos((h*h+h*h-BC*BC)/(2*h*h));if(c<f)throw new Error("startAngle and endAngle do not define a significant rotation");const d=Math.floor(l*(c/Sa)),p=vi.fromValues(0,0,-(i/2)),g=vi.fromValues(0,0,i/2),m=vi.subtract(vi.create(),g,p),v=vi.fromValues(1,0,0),y=vi.fromValues(0,1,0),b=vi.create(),x=vi.create(),w=vi.create(),_=u((C,I,F)=>{const O=I*c+r;return vi.scale(b,v,F[0]*mpe(O)),vi.scale(x,y,F[1]*ppe(O)),vi.add(b,b,x),vi.scale(w,m,C),vi.add(w,w,p),vi.add(vi.create(),b,w)},"point"),A=u((...C)=>{const I=C.map(F=>vi.add(vi.create(),F,t));return dpe.create(I)},"fromPoints"),S=[];for(let C=0;C<d;C++){const I=C/d;let F=(C+1)/d;c===Sa&&C===d-1&&(F=0),o[0]===s[0]&&o[1]===s[1]?(S.push(A(p,_(0,F,o),_(0,I,o))),S.push(A(_(0,F,o),_(1,F,o),_(1,I,o),_(0,I,o))),S.push(A(g,_(1,I,o),_(1,F,o)))):(s[0]>0&&s[1]>0&&S.push(A(p,_(0,F,s),_(0,I,s))),(s[0]>0||s[1]>0)&&S.push(A(_(0,I,s),_(0,F,s),_(1,I,o))),o[0]>0&&o[1]>0&&S.push(A(g,_(1,I,o),_(1,F,o))),(o[0]>0||o[1]>0)&&S.push(A(_(1,I,o),_(0,F,s),_(1,F,o))))}return c<Sa&&(S.push(A(p,_(0,0,s),g)),S.push(A(_(0,0,s),_(1,0,o),g)),S.push(A(p,g,_(0,1,s))),S.push(A(_(0,1,s),g,_(1,1,o)))),fpe.create(S)},"cylinderElliptic$1");var L4=vpe;const ype=L4,{isGT:bpe}=di,xpe=u(n=>{const e={center:[0,0,0],height:2,radius:1,segments:32},{center:t,height:i,radius:s,segments:r}=Object.assign({},e,n);if(!bpe(s,0))throw new Error("radius must be greater than zero");return ype({center:t,height:i,startRadius:[s,s],endRadius:[s,s],segments:r})},"cylinder");var _pe=xpe;const wpe=Mt,Ape=Kt,{isNumberArray:UC}=di,Mpe=u(n=>{const e={points:[],faces:[],colors:void 0,orientation:"outward"},{points:t,faces:i,colors:s,orientation:r}=Object.assign({},e,n);if(!(Array.isArray(t)&&Array.isArray(i)))throw new Error("points and faces must be arrays");if(t.length<3)throw new Error("three or more points are required");if(i.length<1)throw new Error("one or more faces are required");if(s){if(!Array.isArray(s))throw new Error("colors must be an array");if(s.length!==i.length)throw new Error("faces and colors must have the same length")}t.forEach((a,l)=>{if(!UC(a,3))throw new Error(`point ${l} must be an array of X, Y, Z values`)}),i.forEach((a,l)=>{if(a.length<3)throw new Error(`face ${l} must contain 3 or more indexes`);if(!UC(a,a.length))throw new Error(`face ${l} must be an array of numbers`)}),r!=="outward"&&i.forEach(a=>a.reverse());const o=i.map((a,l)=>{const c=Ape.create(a.map(h=>t[h]));return s&&s[l]&&(c.color=s[l]),c});return wpe.create(o)},"polyhedron$1");var O4=Mpe;const $C=an,VC=mt,Spe=Mt,Tpe=O4,{isGT:Cpe,isGTE:Epe}=di,Ppe=u(n=>{const e={radius:1,frequency:6};let{radius:t,frequency:i}=Object.assign({},e,n);if(!Cpe(t,0))throw new Error("radius must be greater than zero");if(!Epe(i,6))throw new Error("frequency must be six or more");i=Math.floor(i/6);const s=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],r=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],o=u((d,p,g)=>{const m=d[0],v=d[1],y=d[2];let b=g;const x=[],w=[];for(let _=0;_<p;_++)for(let A=0;A<p-_;A++){const S=_/p,M=(_+1)/p,C=A/(p-_),I=(A+1)/(p-_),F=p-_-1?A/(p-_-1):1,O=[];O[0]=a(a(m,v,C),y,S),O[1]=a(a(m,v,I),y,S),O[2]=a(a(m,v,F),y,M);for(let N=0;N<3;N++){const E=VC.length(O[N]);for(let k=0;k<3;k++)O[N][k]/=E}if(x.push(O[0],O[1],O[2]),w.push([b,b+1,b+2]),b+=3,A<p-_-1){const N=p-_-1?(A+1)/(p-_-1):1;O[0]=a(a(m,v,I),y,S),O[1]=a(a(m,v,N),y,M),O[2]=a(a(m,v,F),y,M);for(let E=0;E<3;E++){const k=VC.length(O[E]);for(let G=0;G<3;G++)O[E][G]/=k}x.push(O[0],O[1],O[2]),w.push([b,b+1,b+2]),b+=3}}return{points:x,triangles:w,offset:b}},"geodesicSubDivide"),a=u((d,p,g)=>{const m=1-g,v=[];for(let y=0;y<3;y++)v[y]=d[y]*m+p[y]*g;return v},"mix3");let l=[],c=[],h=0;for(let d=0;d<r.length;d++){const p=o([s[r[d][0]],s[r[d][1]],s[r[d][2]]],i,h);l=l.concat(p.points),c=c.concat(p.triangles),h=p.offset}let f=Tpe({points:l,faces:c,orientation:"inward"});return t!==1&&(f=Spe.transform($C.fromScaling($C.create(),[t,t,t]),f)),f},"geodesicSphere");var Rpe=Ppe;const Ipe=qn,Dpe=u(n=>{if(!Array.isArray(n))throw new Error("points must be an array");return Ipe.fromPoints({},n)},"line$2");var Lpe=Dpe;const ub=Tt,Ope=u(n=>{const e={points:[],paths:[]},{points:t,paths:i}=Object.assign({},e,n);if(!(Array.isArray(t)&&Array.isArray(i)))throw new Error("points and paths must be arrays");let s=t;Array.isArray(t[0])&&(Array.isArray(t[0][0])||(s=[t])),s.forEach((l,c)=>{if(!Array.isArray(l))throw new Error("list of points "+c+" must be an array");if(l.length<3)throw new Error("list of points "+c+" must contain three or more points");l.forEach((h,f)=>{if(!Array.isArray(h))throw new Error("list of points "+c+", point "+f+" must be an array");if(h.length<2)throw new Error("list of points "+c+", point "+f+" must contain by X and Y values")})});let r=i;if(i.length===0){let l=0;r=s.map(c=>c.map(h=>l++))}const o=[];s.forEach(l=>l.forEach(c=>o.push(c)));let a=[];return r.forEach(l=>{const c=l.map(f=>o[f]),h=ub.fromPoints(c);a=a.concat(ub.toSides(h))}),ub.create(a)},"polygon");var Fpe=Ope;const Ta=vt,Npe=Tt,{isNumberArray:HC}=di,kpe=u(n=>{const e={center:[0,0],size:[2,2]},{center:t,size:i}=Object.assign({},e,n);if(!HC(t,2))throw new Error("center must be an array of X and Y values");if(!HC(i,2))throw new Error("size must be an array of X and Y values");if(!i.every(a=>a>0))throw new Error("size values must be greater than zero");const s=[i[0]/2,i[1]/2],r=[s[0],-s[1]],o=[Ta.subtract(Ta.create(),t,s),Ta.add(Ta.create(),t,r),Ta.add(Ta.create(),t,s),Ta.subtract(Ta.create(),t,r)];return Npe.fromPoints(o)},"rectangle$1");var F4=kpe;const{EPS:S0,TAU:kf}=at,hb=vt,kn=mt,zpe=Mt,Ih=Kt,{sin:Bpe,cos:Upe}=Ei,{isGT:$pe,isGTE:Vpe,isNumberArray:GC}=di,WC=u((n,e,t,i,s,r)=>{const o=kf/4*s/i,a=Upe(o),l=Bpe(o),c=i-s;let h=t*a,f=e[2]-(t-t*l);r||(f=t-t*l-e[2]),h=h>S0?h:0;const d=kn.add(kn.create(),n,[e[0]-t,e[1]-t,f]),p=kn.add(kn.create(),n,[t-e[0],e[1]-t,f]),g=kn.add(kn.create(),n,[t-e[0],t-e[1],f]),m=kn.add(kn.create(),n,[e[0]-t,t-e[1],f]),v=[],y=[],b=[],x=[];for(let w=0;w<=c;w++){const _=c>0?kf/4*w/c:0,A=hb.fromAngleRadians(hb.create(),_);hb.scale(A,A,h);const S=kn.fromVec2(kn.create(),A);v.push(kn.add(kn.create(),d,S)),kn.rotateZ(S,S,[0,0,0],kf/4),y.push(kn.add(kn.create(),p,S)),kn.rotateZ(S,S,[0,0,0],kf/4),b.push(kn.add(kn.create(),g,S)),kn.rotateZ(S,S,[0,0,0],kf/4),x.push(kn.add(kn.create(),m,S))}return r?[v,y,b,x]:(v.reverse(),y.reverse(),b.reverse(),x.reverse(),[x,b,y,v])},"createCorners"),jC=u((n,e)=>{const t=[];for(let i=0;i<n.length;i++){const s=n[i],r=e[i];for(let o=0;o<s.length-1;o++)t.push(Ih.create([s[o],s[o+1],r[o]])),o<r.length-1&&t.push(Ih.create([r[o],s[o+1],r[o+1]]))}return t},"stitchCorners"),XC=u((n,e)=>{const t=[];for(let i=0;i<n.length;i++){let s=n[i],r=e[i];const o=s[s.length-1],a=r[r.length-1],l=(i+1)%n.length;s=n[l],r=e[l];const c=s[0],h=r[0];t.push(Ih.create([o,c,h,a]))}return t},"stitchWalls"),Hpe=u((n,e)=>{n=[n[3],n[2],n[1],n[0]],n=n.map(r=>r.slice().reverse());const t=[];n.forEach(r=>{r.forEach(o=>t.push(o))});const i=[];e.forEach(r=>{r.forEach(o=>i.push(o))});const s=[];for(let r=0;r<i.length;r++){const o=(r+1)%i.length;s.push(Ih.create([t[r],t[o],i[o],i[r]]))}return s},"stitchSides"),Gpe=u(n=>{const e={center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32};let{center:t,size:i,roundRadius:s,segments:r}=Object.assign({},e,n);if(!GC(t,3))throw new Error("center must be an array of X, Y and Z values");if(!GC(i,3))throw new Error("size must be an array of X, Y and Z values");if(!i.every(c=>c>0))throw new Error("size values must be greater than zero");if(!$pe(s,0))throw new Error("roundRadius must be greater than zero");if(!Vpe(r,4))throw new Error("segments must be four or more");if(i=i.map(c=>c/2),s>i[0]-S0||s>i[1]-S0||s>i[2]-S0)throw new Error("roundRadius must be smaller then the radius of all dimensions");r=Math.floor(r/4);let o=null,a=null,l=[];for(let c=0;c<=r;c++){const h=WC(t,i,s,r,c,!0),f=WC(t,i,s,r,c,!1);if(c===0&&(l=l.concat(Hpe(f,h))),o&&(l=l.concat(jC(o,h),XC(o,h))),a&&(l=l.concat(jC(a,f),XC(a,f))),c===r){let d=h.map(p=>p[0]);l.push(Ih.create(d)),d=f.map(p=>p[0]),l.push(Ih.create(d))}o=h,a=f}return zpe.create(l)},"roundedCuboid");var Wpe=Gpe;const{EPS:qC,TAU:YC}=at,Le=mt,jpe=Mt,Xpe=Kt,{sin:ZC,cos:KC}=Ei,{isGT:fb,isGTE:qpe,isNumberArray:Ype}=di,Zpe=u(n=>{const e={center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},{center:t,height:i,radius:s,roundRadius:r,segments:o}=Object.assign({},e,n);if(!Ype(t,3))throw new Error("center must be an array of X, Y and Z values");if(!fb(i,0))throw new Error("height must be greater then zero");if(!fb(s,0))throw new Error("radius must be greater then zero");if(!fb(r,0))throw new Error("roundRadius must be greater then zero");if(r>s-qC)throw new Error("roundRadius must be smaller then the radius");if(!qpe(o,4))throw new Error("segments must be four or more");const a=[0,0,-(i/2)],l=[0,0,i/2],c=Le.subtract(Le.create(),l,a),h=Le.length(c);if(2*r>h-qC)throw new Error("height must be larger than twice roundRadius");let f;Math.abs(c[0])>Math.abs(c[1])?f=Le.fromValues(0,1,0):f=Le.fromValues(1,0,0);const d=Le.scale(Le.create(),Le.normalize(Le.create(),c),r),p=Le.scale(Le.create(),Le.normalize(Le.create(),Le.cross(Le.create(),d,f)),s),g=Le.scale(Le.create(),Le.normalize(Le.create(),Le.cross(Le.create(),p,d)),s);Le.add(a,a,d),Le.subtract(l,l,d);const m=Math.floor(.25*o),v=u(A=>{const S=A.map(M=>Le.add(M,M,t));return Xpe.create(S)},"fromPoints"),y=[],b=Le.create(),x=Le.create();let w;for(let A=0;A<=o;A++){const S=YC*A/o,M=Le.add(Le.create(),Le.scale(b,p,KC(S)),Le.scale(x,g,ZC(S)));if(A>0){let C=[];C.push(Le.add(Le.create(),a,M)),C.push(Le.add(Le.create(),a,w)),C.push(Le.add(Le.create(),l,w)),C.push(Le.add(Le.create(),l,M)),y.push(v(C));let I,F;for(let O=0;O<=m;O++){const N=YC/4*O/m,E=KC(N),k=ZC(N);if(O>0){C=[];let G;G=Le.add(Le.create(),a,Le.subtract(b,Le.scale(b,w,I),Le.scale(x,d,F))),C.push(G),G=Le.add(Le.create(),a,Le.subtract(b,Le.scale(b,M,I),Le.scale(x,d,F))),C.push(G),O<m&&(G=Le.add(Le.create(),a,Le.subtract(b,Le.scale(b,M,E),Le.scale(x,d,k))),C.push(G)),G=Le.add(Le.create(),a,Le.subtract(b,Le.scale(b,w,E),Le.scale(x,d,k))),C.push(G),y.push(v(C)),C=[],G=Le.add(Le.create(),Le.scale(b,w,I),Le.scale(x,d,F)),Le.add(G,G,l),C.push(G),G=Le.add(Le.create(),Le.scale(b,M,I),Le.scale(x,d,F)),Le.add(G,G,l),C.push(G),O<m&&(G=Le.add(Le.create(),Le.scale(b,M,E),Le.scale(x,d,k)),Le.add(G,G,l),C.push(G)),G=Le.add(Le.create(),Le.scale(b,w,E),Le.scale(x,d,k)),Le.add(G,G,l),C.push(G),C.reverse(),y.push(v(C))}I=E,F=k}}w=M}return jpe.create(y)},"roundedCylinder");var Kpe=Zpe;const{EPS:QC,TAU:vg}=at,hn=vt,Qpe=Tt,{isGT:Jpe,isGTE:eme,isNumberArray:JC}=di,tme=u(n=>{const e={center:[0,0],size:[2,2],roundRadius:.2,segments:32};let{center:t,size:i,roundRadius:s,segments:r}=Object.assign({},e,n);if(!JC(t,2))throw new Error("center must be an array of X and Y values");if(!JC(i,2))throw new Error("size must be an array of X and Y values");if(!i.every(m=>m>0))throw new Error("size values must be greater than zero");if(!Jpe(s,0))throw new Error("roundRadius must be greater than zero");if(!eme(r,4))throw new Error("segments must be four or more");if(i=i.map(m=>m/2),s>i[0]-QC||s>i[1]-QC)throw new Error("roundRadius must be smaller then the radius of all dimensions");const o=Math.floor(r/4),a=hn.add(hn.create(),t,[i[0]-s,i[1]-s]),l=hn.add(hn.create(),t,[s-i[0],i[1]-s]),c=hn.add(hn.create(),t,[s-i[0],s-i[1]]),h=hn.add(hn.create(),t,[i[0]-s,s-i[1]]),f=[],d=[],p=[],g=[];for(let m=0;m<=o;m++){const v=vg/4*m/o,y=hn.fromAngleRadians(hn.create(),v);hn.scale(y,y,s),f.push(hn.add(hn.create(),a,y)),hn.rotate(y,y,hn.create(),vg/4),d.push(hn.add(hn.create(),l,y)),hn.rotate(y,y,hn.create(),vg/4),p.push(hn.add(hn.create(),c,y)),hn.rotate(y,y,hn.create(),vg/4),g.push(hn.add(hn.create(),h,y))}return Qpe.fromPoints(f.concat(d,p,g))},"roundedRectangle");var nme=tme;const ime=F4,{isGT:sme}=di,rme=u(n=>{const e={center:[0,0],size:2};let{center:t,size:i}=Object.assign({},e,n);if(!sme(i,0))throw new Error("size must be greater than zero");return i=[i,i],ime({center:t,size:i})},"square");var ome=rme;const{TAU:N4}=at,Rd=vt,ame=Tt,{isGT:lme,isGTE:yg,isNumberArray:cme}=di,ume=u((n,e)=>n>0&&e>1&&e<n/2?Math.cos(Math.PI*e/n)/Math.cos(Math.PI*(e-1)/n):0,"getRadiusRatio"),eE=u((n,e,t,i)=>{const s=N4/n,r=[];for(let o=0;o<n;o++){const a=Rd.fromAngleRadians(Rd.create(),s*o+t);Rd.scale(a,a,e),Rd.add(a,i,a),r.push(a)}return r},"getPoints"),hme=u(n=>{const e={center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0};let{center:t,vertices:i,outerRadius:s,innerRadius:r,density:o,startAngle:a}=Object.assign({},e,n);if(!cme(t,2))throw new Error("center must be an array of X and Y values");if(!yg(i,2))throw new Error("vertices must be two or more");if(!lme(s,0))throw new Error("outerRadius must be greater than zero");if(!yg(r,0))throw new Error("innerRadius must be greater than zero");if(!yg(a,0))throw new Error("startAngle must be greater than zero");if(i=Math.floor(i),o=Math.floor(o),a=a%N4,r===0){if(!yg(o,2))throw new Error("density must be two or more");r=s*ume(i,o)}const l=Rd.clone(t),c=eE(i,s,a,l),h=eE(i,r,a+Math.PI/i,l),f=[];for(let d=0;d<i;d++)f.push(c[d]),f.push(h[d]);return ame.fromPoints(f)},"star");var fme=hme;const{TAU:dme}=at,pme=x4,{rotate:mme}=Pd,{translate:gme}=Ql,vme=I4,{isGT:db,isGTE:pb}=di,yme=u(n=>{const e={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:dme},{innerRadius:t,innerSegments:i,outerRadius:s,outerSegments:r,innerRotation:o,startAngle:a,outerRotation:l}=Object.assign({},e,n);if(!db(t,0))throw new Error("innerRadius must be greater than zero");if(!pb(i,3))throw new Error("innerSegments must be three or more");if(!db(s,0))throw new Error("outerRadius must be greater than zero");if(!pb(r,3))throw new Error("outerSegments must be three or more");if(!pb(a,0))throw new Error("startAngle must be positive");if(!db(l,0))throw new Error("outerRotation must be greater than zero");if(t>=s)throw new Error("inner circle is two large to rotate about the outer circle");let c=vme({radius:t,segments:i});return o!==0&&(c=mme([0,0,o],c)),c=gme([s,0],c),pme({startAngle:a,angle:l,segments:r},c)},"torus");var bme=yme;const{NEPS:Dh}=at,zf=vt,xme=Tt,{isNumberArray:_me}=di,Wx=u((n,e,t)=>Math.acos((n*n+e*e-t*t)/(2*n*e)),"solveAngleFromSSS"),wme=u((n,e,t)=>e>Dh?Math.sqrt(n*n+t*t-2*n*t*Math.cos(e)):Math.sqrt((n-t)*(n-t)+n*t*e*e*(1-e*e/12)),"solveSideFromSAS"),Ame=u(n=>{if(Math.abs(n[0]+n[1]+n[2]-Math.PI)>Dh)throw new Error("AAA triangles require angles that sum to PI");const t=n[0],i=n[1],s=Math.PI-t-i,r=1,o=r/Math.sin(s)*Math.sin(t),a=r/Math.sin(s)*Math.sin(i);return jh(t,i,s,o,a,r)},"solveAAA"),Mme=u(n=>{const e=n[0],t=n[1],i=Math.PI+Dh-e-t;if(i<Dh)throw new Error("AAS triangles require angles that sum to PI");const s=n[2],r=s/Math.sin(e)*Math.sin(t),o=s/Math.sin(e)*Math.sin(i);return jh(e,t,i,s,r,o)},"solveAAS"),Sme=u(n=>{const e=n[0],t=n[2],i=Math.PI+Dh-e-t;if(i<Dh)throw new Error("ASA triangles require angles that sum to PI");const s=n[1],r=s/Math.sin(i)*Math.sin(e),o=s/Math.sin(i)*Math.sin(t);return jh(e,t,i,r,o,s)},"solveASA"),Tme=u(n=>{const e=n[0],t=n[1],i=n[2],s=wme(e,t,i),r=Wx(s,e,i),o=Math.PI-r-t;return jh(r,t,o,i,s,e)},"solveSAS"),Cme=u(n=>{const e=n[0],t=n[1],i=n[2],s=Math.asin(t*Math.sin(i)/e),r=Math.PI-s-i,o=e/Math.sin(i)*Math.sin(r);return jh(s,r,i,t,o,e)},"solveSSA"),Eme=u(n=>{const e=n[1],t=n[2],i=n[0];if(e+t<=i||t+i<=e||i+e<=t)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const s=Wx(t,i,e),r=Wx(i,e,t),o=Math.PI-s-r;return jh(s,r,o,e,t,i)},"solveSSS"),jh=u((n,e,t,i,s,r)=>{const o=zf.fromValues(0,0),a=zf.fromValues(r,0),l=zf.fromValues(i,0);return zf.add(l,zf.rotate(l,l,[0,0],Math.PI-e),a),xme.fromPoints([o,a,l])},"createTriangle"),Pme=u(n=>{const e={type:"SSS",values:[1,1,1]};let{type:t,values:i}=Object.assign({},e,n);if(typeof t!="string")throw new Error("triangle type must be a string");if(t=t.toUpperCase(),!((t[0]==="A"||t[0]==="S")&&(t[1]==="A"||t[1]==="S")&&(t[2]==="A"||t[2]==="S")))throw new Error("triangle type must contain three letters; A or S");if(!_me(i,3))throw new Error("triangle values must contain three values");if(!i.every(s=>s>0))throw new Error("triangle values must be greater than zero");switch(t){case"AAA":return Ame(i);case"AAS":return Mme(i);case"ASA":return Sme(i);case"SAS":return Tme(i);case"SSA":return Cme(i);case"SSS":return Eme(i);default:throw new Error("invalid triangle type, try again")}},"triangle");var Rme=Pme,_o={arc:Zde,circle:I4,cube:hpe,cuboid:D4,cylinder:_pe,cylinderElliptic:L4,ellipse:R4,ellipsoid:Qw,geodesicSphere:Rpe,line:Lpe,polygon:Fpe,polyhedron:O4,rectangle:F4,roundedCuboid:Wpe,roundedCylinder:Kpe,roundedRectangle:nme,sphere:y4,square:ome,star:fme,torus:bme,triangle:Rme};class gv extends Je{constructor(e=(s,r,o)=>o.set(s,r,Math.cos(s)*Math.sin(r)),t=8,i=8){super(),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:i};const s=[],r=[],o=[],a=[],l=1e-5,c=new P,h=new P,f=new P,d=new P,p=new P,g=t+1;for(let m=0;m<=i;m++){const v=m/i;for(let y=0;y<=t;y++){const b=y/t;e(b,v,h),r.push(h.x,h.y,h.z),b-l>=0?(e(b-l,v,f),d.subVectors(h,f)):(e(b+l,v,f),d.subVectors(f,h)),v-l>=0?(e(b,v-l,f),p.subVectors(h,f)):(e(b,v+l,f),p.subVectors(f,h)),c.crossVectors(d,p).normalize(),o.push(c.x,c.y,c.z),a.push(b,v)}}for(let m=0;m<i;m++)for(let v=0;v<t;v++){const y=m*g+v,b=m*g+v+1,x=(m+1)*g+v+1,w=(m+1)*g+v;s.push(y,b,w),s.push(b,x,w)}this.setIndex(s),this.setAttribute("position",new Ve(r,3)),this.setAttribute("normal",new Ve(o,3)),this.setAttribute("uv",new Ve(a,2))}}u(gv,"ParametricGeometry");const wc={klein:function(n,e,t){e*=Math.PI,n*=2*Math.PI,e=e*2;let i,s;e<Math.PI?(i=3*Math.cos(e)*(1+Math.sin(e))+2*(1-Math.cos(e)/2)*Math.cos(e)*Math.cos(n),s=-8*Math.sin(e)-2*(1-Math.cos(e)/2)*Math.sin(e)*Math.cos(n)):(i=3*Math.cos(e)*(1+Math.sin(e))+2*(1-Math.cos(e)/2)*Math.cos(n+Math.PI),s=-8*Math.sin(e));const r=-2*(1-Math.cos(e)/2)*Math.sin(n);t.set(i,r,s)},plane:function(n,e){return function(t,i,s){const r=t*n,o=0,a=i*e;s.set(r,o,a)}},mobius:function(n,e,t){n=n-.5;const i=2*Math.PI*e,s=2,r=Math.cos(i)*(s+n*Math.cos(i/2)),o=Math.sin(i)*(s+n*Math.cos(i/2)),a=n*Math.sin(i/2);t.set(r,o,a)},mobius3d:function(n,e,t){n*=Math.PI,e*=2*Math.PI,n=n*2;const i=n/2,s=2.25,r=.125,o=.65;let a=r*Math.cos(e)*Math.cos(i)-o*Math.sin(e)*Math.sin(i);const l=r*Math.cos(e)*Math.sin(i)+o*Math.sin(e)*Math.cos(i),c=(s+a)*Math.sin(n);a=(s+a)*Math.cos(n),t.set(a,c,l)}};wc.TubeGeometry=u(class extends gv{constructor(e,t=64,i=1,s=8,r=!1){const o=t+1,a=e.computeFrenetFrames(t,r),l=a.tangents,c=a.normals,h=a.binormals,f=new P;function d(p,g,m){g*=2*Math.PI;const v=Math.floor(p*(o-1));e.getPointAt(p,f);const y=c[v],b=h[v],x=-i*Math.cos(g),w=i*Math.sin(g);f.x+=x*y.x+w*b.x,f.y+=x*y.y+w*b.y,f.z+=x*y.z+w*b.z,m.copy(f)}u(d,"ParametricTube"),super(d,t,s),this.tangents=l,this.normals=c,this.binormals=h,this.path=e,this.segments=t,this.radius=i,this.segmentsRadius=s,this.closed=r}},"TubeGeometry");wc.TorusKnotGeometry=u(class extends wc.TubeGeometry{constructor(e=200,t=40,i=64,s=8,r=2,o=3){class a extends H_{getPoint(d,p=new P){const g=p;d*=Math.PI*2;const m=.5,v=(1+m*Math.cos(o*d))*Math.cos(r*d),y=(1+m*Math.cos(o*d))*Math.sin(r*d),b=m*Math.sin(o*d);return g.set(v,y,b).multiplyScalar(e)}}u(a,"TorusKnotCurve");const l=i,c=s,h=new a;super(h,l,t,c,!0,!1),this.radius=e,this.tube=t,this.segmentsT=i,this.segmentsR=s,this.p=r,this.q=o}},"TorusKnotGeometry");wc.SphereGeometry=u(class extends gv{constructor(e,t,i){function s(r,o,a){r*=Math.PI,o*=2*Math.PI;const l=e*Math.sin(r)*Math.cos(o),c=e*Math.sin(r)*Math.sin(o),h=e*Math.cos(r);a.set(l,c,h)}u(s,"sphere"),super(s,t,i)}},"SphereGeometry");wc.PlaneGeometry=u(class extends gv{constructor(e,t,i,s){function r(o,a,l){const c=o*e,h=0,f=a*t;l.set(c,h,f)}u(r,"plane"),super(r,i,s)}},"PlaneGeometry");var Ime=Object.defineProperty,k4=u((n,e)=>Ime(n,"name",{value:e,configurable:!0}),"__name$1u");const bg=new P,Dme=[1,1,1];function z4(n){const e=[],t=[],i=[],s=[];let r=0;for(let o of n.polygons){B4(bg,o);const a=o.color||n.color||Dme;for(let c of o.vertices)e.push(...c),t.push(bg.x,bg.y,bg.z),i.push(a[0],a[1],a[2]);const l=o.vertices.length;for(let c=2;c<l;++c)s.push(r,r+c-1,r+c);r+=l}return new Je().setAttribute("position",new Ve(new Float32Array(e),3)).setAttribute("normal",new Ve(new Float32Array(t),3)).setAttribute("color",new Ve(new Float32Array(i),3)).setIndex(s)}u(z4,"geom3ToBufferGeometry");k4(z4,"geom3ToBufferGeometry");const mb=new P,tE=new P,nE=new P,iE=new P,sE=new P;function B4(n,e){const t=e.vertices;return mb.fromArray(t[0]),tE.fromArray(t[1]),nE.fromArray(t[2]),iE.subVectors(tE,mb),sE.subVectors(nE,mb),n.crossVectors(iE,sE),n.normalize(),n}u(B4,"calculatePoly3Normal");k4(B4,"calculatePoly3Normal");var Lme="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAOJJREFUSImtVUkSBCEIS6bm322/nD6MWi7I0jUclZBQBiFiUZLnPb6RwiJyaZckXaITwVSY5K0lDfdHIo2gKIVVha3wQqTmjsWlJpmJK27B2sW9xAz2o2WTvGvbEZIiItfpnTYFzlkaZ9m0kERVB4VoVG6JcJW+6a7fe4MG7J0gqhzwJ3kjAfp8uMWBg4v+GeEORisaD/+KYHOL465jEc0VlltCGHMOHLd4c2IqyvxHJk51Ucbn+HXS/q6cmgig4ZDoukiNAFFR8qdQN9phU20R2Xw6clZoLX1zpUYIJqLEeY8HyX71TroxJVAAAAAASUVORK5CYII=",Ome=Object.defineProperty,Fme=u((n,e)=>Ome(n,"name",{value:e,configurable:!0}),"__name$1t");const Nme=wc.SphereGeometry,Sl=new P,wo=new je,Ca=new P,ou=new P(0,0,1),Tl=new P,rE=new je,xg=new me,_g=new Array(16).fill(0),oE=new rr({toneMapped:!1,color:15114812,transparent:!0,opacity:.5,depthTest:!1}),kme=new rr({toneMapped:!1,transparent:!0,opacity:0,depthTest:!1,depthWrite:!1}),zme=new Op,jx=zme.load(Lme);jx.minFilter=jx.magFilter=Yt;const Bme=new Yr({map:jx,sizeAttenuation:!1,depthTest:!1,depthWrite:!1,transparent:!0,size:24});class eA extends Bs{begin(e){const t=e.readonlyRef().model;if(!t.dirty)return;const i=[...t.nodes];for(;i.length;){const s=i.pop();if(!s)break;s.has(Ge)?(this.updateMatrix(s),s.instanceId||e.throttle(`#${s.id}-update-csg`,50,()=>{this.updateGeometry(t,s)},!1)):i.push(...s.children)}}updateMatrix(e){if(!e.has(Ge))return;const t=e.get(Ge);if(t.dirty&&!e.instanceId)for(let i of e.children)this.updateMatrix(i);t.matDirty&&(t.matDirty=!1,e.has(ze)?Sl.copy(e.value(ze)):Sl.set(0,0,0),e.has(tt)?wo.setFromEuler(e.value(tt)):wo.set(0,0,0,1),e.has(Et)?Ca.copy(e.value(Et)):e.has(Wt)?Ca.setScalar(e.value(Wt)):Ca.setScalar(1),t.matrix.compose(Sl,wo,Ca),!e.instanceId&&!t.dirty&&t.value&&t.matrix.toArray(t.value.transforms=[...t.value.transforms]))}updateGeometry(e,t){if(!t.has(Ge))return;const i=t.get(Ge);if(i.dirty){if(i.dirty=!1,!t.instanceId){for(let r of t.children)this.updateGeometry(e,r);switch(t.type){case"CsgGroup":{let r=null,o=!0,a=[];for(let l of t.children){if(!l.value(ft))continue;let c=null;if(l.instanceId){if(c=e.getNode(l.instanceId).value(Ge),!c)continue;c=Object.assign({},c),c.transforms=[...c.transforms],l.get(Ge).matrix.toArray(c.transforms)}else{if(c=l.value(Ge),!c)continue;c=Object.assign({},c)}const h=l.value(Mi)==="positive";o===h?a.push(c):(o?(r&&(a=[r,...a]),a.length&&(r=hr.union(...a))):r&&(r=hr.subtract(r,...a)),a=[c],o=h)}if(a.length&&(o?(r&&(a=[r,...a]),r=hr.union(...a)):r&&(r=hr.subtract(r,...a))),r)switch(t.value(Ui)){case"x":r=hr.union(r,sb.mirrorX(r));break;case"y":r=hr.union(r,sb.mirrorY(r));break;case"z":r=hr.union(r,sb.mirrorZ(r));break}i.value=r}break;case"CsgIntersect":{const r=[];for(let o of t.children){if(!o.value(ft))continue;let a=null;if(o.instanceId){if(a=e.getNode(o.instanceId).value(Ge),!a)continue;a=Object.assign({},a),a.transforms=[...a.transforms],o.get(Ge).matrix.toArray(a.transforms)}else{if(a=o.value(Ge),!a)continue;a=Object.assign({},a)}r.push(Object.assign({},a))}r.length?i.value=r.length>1?hr.intersect(...r):hr.union(r[0]):i.value=null}break;case"CsgHull":{const r=[];for(let o of t.children){if(!o.value(ft))continue;let a=null;if(o.instanceId){if(a=e.getNode(o.instanceId).value(Ge),!a)continue;a=Object.assign({},a),a.transforms=[...a.transforms],o.get(Ge).matrix.toArray(a.transforms)}else{if(a=o.value(Ge),!a)continue;a=Object.assign({},a)}r.push(Object.assign({},a))}r.length?i.value=r.length>1?vC.hull(...r):hr.union(r[0]):i.value=null}break;case"CsgHullChain":{const r=[];for(let o of t.children){if(!o.value(ft))continue;let a=null;if(o.instanceId){if(a=e.getNode(o.instanceId).value(Ge),!a)continue;a=Object.assign({},a),a.transforms=[...a.transforms],o.get(Ge).matrix.toArray(a.transforms)}else{if(a=o.value(Ge),!a)continue;a=Object.assign({},a)}r.push(Object.assign({},a))}r.length?i.value=r.length>1?vC.hullChain(...r):hr.union(r[0]):i.value=null}break;case"CsgEllipsoid":{const r=t.value(xr),o=Math.max(4,t.value(ni));r.x>0&&r.y>0&&r.z>0?i.value=Qw({radius:[r.x,r.y,r.z],segments:o}):i.value=null}break;case"CsgCuboid":{const r=t.value(Ks),o=Math.min(t.value(Os),r.x/2-1e-5,r.y/2-1e-5,r.z/2-1e-5),a=Math.max(4,t.value(ni));r.x>0&&r.y>0&&r.z>0?o>0?i.value=_o.roundedCuboid({size:[r.x,r.y,r.z],roundRadius:o,segments:a}):i.value=_o.cuboid({size:[r.x,r.y,r.z]}):i.value=null}break;case"CsgCylinder":{const r=t.value(ln),o=t.value(ds),a=Math.min(t.value(Os),o-1e-5,r/2-1e-5),l=Math.max(4,t.value(ni));r>0&&o>0?a>0?i.value=_o.roundedCylinder({height:r,radius:o,roundRadius:a,segments:l}):i.value=_o.cylinder({height:r,radius:o,segments:l}):i.value=null}break;case"CsgCylinderElliptic":{const r=t.value(ln),o=t.value(xc),a=t.value(mc),l=Math.max(4,t.value(ni)),c=t.value(ph);r>0&&(o.x>0||o.y>0||a.x>0||a.y>0)&&c[1]>c[0]?i.value=_o.cylinderElliptic({height:r,startRadius:[o.x,o.y],endRadius:[a.x,a.y],segments:l,startAngle:c[0]/180*Math.PI,endAngle:c[1]/180*Math.PI}):i.value=null}break;case"CsgTorus":{const r=t.value(gc),o=t.value(vc),a=Math.max(3,t.value(gh)),l=Math.max(3,t.value(bh)),c=t.value(mh)/180*Math.PI,h=t.value(yh)/180*Math.PI;r>0&&o>0&&o>r&&h>0?i.value=_o.torus({innerRadius:r,outerRadius:o,innerSegments:a,outerSegments:l,innerRotation:c,outerRotation:h}):i.value=null}break;case"CsgBezier":{const r=t.value(Ch),o=t.value(bc),a=t.value(yc),l=t.value(Sh),c=Math.max(3,t.value(Ph)),h=t.value(Mh)/180*Math.PI,f=t.value(Ah)/180*Math.PI,d=Math.max(3,t.value(ni)),p=Math.max(2,t.value(vh));if(o.x>=0&&o.y>=0&&a.x>=0&&a.y>=0&&(o.x||o.y||a.x||a.y)&&!(r==="star"&&l===0)&&t.children.length>1){const g=[];for(let b of t.children)g.push(b.value(ze).toArray([0,0,0]));let m;switch(r){case"ellipse":m=_o.ellipse({radius:[Math.max(at.EPS,o.x),Math.max(at.EPS,o.y)],segments:d});break;case"rectangle":m=_o.rectangle({size:[Math.max(at.EPS,o.x),Math.max(at.EPS,o.y)]});break;case"star":m=_o.star({outerRadius:Math.max(at.EPS,o.x),innerRadius:Math.max(at.EPS,o.x*l),vertices:c});break;default:throw new Error(`Unknown shape ${r}`)}const v=Iy.create(g);let y=dg.slice.fromSides(m.sides);t.value(Th)?(Tl.set(g[1][0]-g[0][0],g[1][1]-g[0][1],g[1][2]-g[0][2]).normalize(),Tl.lengthSq()<.5&&Tl.set(0,0,1),ou.set(0,0,1),Sl.set(0,0,0),wo.setFromUnitVectors(ou,Tl),Ca.set(1,1,1),xg.compose(Sl,wo,Ca),xg.toArray(_g),y=dg.slice.transform(_g,y),ou.copy(Tl)):ou.set(0,0,1),i.value=dg.extrudeFromSlices({numberOfSlices:p,capStart:!0,capEnd:!0,callback:(b,x,w)=>{const _=Iy.valueAt(b,v),A=Iy.tangentAt(b,v);Sl.fromArray(_),Tl.fromArray(A).normalize(),wo.setFromUnitVectors(ou,Tl);const S=(h-f)*b+h;rE.setFromAxisAngle(ou,S),wo.multiplyQuaternions(wo,rE);let M=(a.x-o.x)*b+o.x,C=(a.y-o.y)*b+o.y;return M=M/Math.max(o.x,at.EPS),C=C/Math.max(o.y,at.EPS),r==="star"&&(C*=o.y/Math.max(at.EPS,o.x)),Ca.set(Math.max(at.EPS,M),Math.max(at.EPS,C),1),xg.compose(Sl,wo,Ca),xg.toArray(_g),dg.slice.transform(_g,w)}},y)}else i.value=null}break;case"CsgBezierControlPoint":i.value=null;break;default:throw new Error(`Unknown csg node type [${t.type}]`)}}const s=t.get(Me);if(t.type==="CsgBezierControlPoint")t.instanceId||(s.value||(s.value=new We(new Nme(.001,8,8),kme),s.value.visible=!1),i.placeholder=new Wa(new Je().setFromPoints([new P]),Bme),i.placeholder.renderOrder=2);else if(t.instanceId){const r=e.getNode(t.instanceId).get(Ge).placeholder;if(r){const o=r;o.isMesh&&(i.placeholder=new We(o.geometry,oE))}}else{const r=i.value?z4(i.value):new Je;if(s.value){const o=s.value.children[0];o.geometry.dispose(),o.geometry=r,r.computeBoundingSphere()}else{const o=s.value=new _i;o.userData.node=t;const a=new We(r,new rr);a.userData.node=t,o.add(a)}i.placeholder&&(i.placeholder.removeFromParent(),delete i.placeholder),r&&(i.placeholder=new We(r,oE)),e.instanceMeshUpdated(t.id,!0)}i.useTempMat=!1,t.instanceId||(i.value&&i.matrix.toArray(i.value.transforms=[...i.value.transforms]),e.dirty=!0,t.dirty=!0,s.parentChanged=!0,s.localTransformChanged=!0,s.worldTransformChanged=!0)}}end(e){}}u(eA,"CsgUpdateSystem");Fme(eA,"CsgUpdateSystem");var Ume=Object.defineProperty,$me=u((n,e)=>Ume(n,"name",{value:e,configurable:!0}),"__name$1s");class tA extends Bs{begin(e){e.history.update()}end(e){}}u(tA,"HistorySystem");$me(tA,"HistorySystem");var Vme=Object.defineProperty,Hme=u((n,e)=>Vme(n,"name",{value:e,configurable:!0}),"__name$1r");class nA extends Bs{constructor(){super(...arguments);T(this,"showIkBones",!1)}setup(t){this.showIkBones=t.options.showIkBones&&t.options.shadingMode!=="path-tracing"}begin(t){t=t.readonlyRef();const i=t.options.showIkBones&&t.options.shadingMode!=="path-tracing";this.showIkBones!==i&&(this.showIkBones=i,t.model.forEach(s=>{if(s.has(At)){const r=s.get(At);r.boneMesh&&(r.boneMesh.visible=i),r.hingeIndicator&&(r.hingeIndicator.visible=i&&r.hingeEnabled)}}))}end(t){}}u(nA,"IkBoneVisibleUpdateSystem");Hme(nA,"IkBoneVisibleUpdateSystem");var Gme=Object.defineProperty,Wme=u((n,e)=>Gme(n,"name",{value:e,configurable:!0}),"__name$1q");class iA extends Bs{constructor(){super(...arguments);T(this,"ambientLight",new $1(16777215,.5))}setup(t){t.scene.add(this.ambientLight)}begin(t){if(t=t.readonlyRef(),t.options.shadingMode==="solid"){t.renderer.physicallyCorrectLights=!1,this.ambientLight.visible=!0;for(let r of t.views){if(!r.enabled)continue;const o=r.defaultLight;o.intensity=.5,o.position.copy(r.camera._position).addScaledVector(r.camera._dir,2),o.up.copy(r.camera._up),o.lookAt(r.camera.target)}}else this.ambientLight.visible=!1,t.renderer.physicallyCorrectLights=!0;const i=t.options.shadingMode==="rendered"||t.options.shadingMode==="path-tracing",s=t.options.showLightHelpers;t.model.forEach(r=>{if(ii(r.type).light){const o=r.value(Me),a=r.visible;if(o&&(o.visible=i&&a),r.has(es)){const l=r.get(es),c=t.model.selected.includes(r.id)||!!r.children.length&&t.model.selected.includes(r.children[0].id);l.value&&(l.value.visible=a&&(s||c)),l.camera&&(l.camera.visible=i&&o.castShadow&&a&&(s||c))}}})}end(t){}}u(iA,"LightUpdateSystem");Wme(iA,"LightUpdateSystem");var jme=Object.defineProperty,Xme=u((n,e)=>jme(n,"name",{value:e,configurable:!0}),"__name$1p");class sA{update(e,t){if(t.instanceId||t.type!=="Box")return;const i=t.get(Zs);if(!i.dirty)return;i.dirty=!1;const s=t.get(Me),r=i.value,o=new br(r.x,r.y,r.z);if(s.value){const a=s.value;a.geometry.dispose(),a.geometry=o}else s.value=new We(o,new rr),s.value.userData={node:t},s.parentChanged=!0,s.localTransformChanged=!0;o.computeBoundingSphere(),e.model.instanceMeshUpdated(t.id,!0)}}u(sA,"BoxUpdateFilter");Xme(sA,"BoxUpdateFilter");var qme=Object.defineProperty,Yme=u((n,e)=>qme(n,"name",{value:e,configurable:!0}),"__name$1o");class Qr{constructor(e=0){T(this,"bits");this.bits=new Uint32Array((e>>>5)+1)}checkCapacity(e){if(e>this.bits.length){const t=new Uint32Array(e);t.set(this.bits,0),this.bits=t}}expandCapacity(e){this.checkCapacity((e>>>5)+1)}clear(){for(let e=0,t=this.bits.length;e<t;++e)this.bits[e]=0}set(e){const t=e>>>5;this.checkCapacity(t+1),this.bits[t]=(this.bits[t]|1<<(e&31))>>>0}get(e){const t=e>>>5;return t>=this.bits.length?!1:(this.bits[t]&1<<(e&31))!==0}clearBit(e){const t=e>>>5;t>=this.bits.length||(this.bits[t]=(this.bits[t]&~(1<<(e&31)))>>>0)}setBit(e,t){t?this.set(e):this.clearBit(e)}and(e){const t=Math.min(this.bits.length,e.bits.length);for(let i=0;i<t;++i)this.bits[i]=(this.bits[i]&e.bits[i])>>>0;if(this.bits.length>t)for(let i=t,s=this.bits.length;i<s;++i)this.bits[i]=0}or(e){const t=Math.min(this.bits.length,e.bits.length);for(let i=0;i<t;++i)this.bits[i]=(this.bits[i]|e.bits[i])>>>0;if(e.bits.length>t){this.checkCapacity(e.bits.length);for(let i=t,s=e.bits.length;i<s;++i)this.bits[i]=e.bits[i]}}equals(e){const t=this.bits.length>=e.bits.length?this:e,i=t===this?e:this;for(let s=0,r=i.bits.length;s<r;++s)if(t.bits[s]!==i.bits[s])return!1;for(let s=t.bits.length-i.bits.length+1,r=t.bits.length;s<r;++s)if(t.bits[s])return!1;return!0}intersects(e){for(let t=0,i=Math.min(this.bits.length,e.bits.length);t<i;++t)if((this.bits[t]&e.bits[t])!==0)return!0;return!1}containsAll(e){if(e.bits.length>this.bits.length){for(let t=this.bits.length,i=e.bits.length;t<i;++t)if(e.bits[t]!==0)return!1}for(let t=0,i=Math.min(this.bits.length,e.bits.length);t<i;++t)if((this.bits[t]&e.bits[t])!==e.bits[t])return!1;return!0}isEmpty(){for(let e=0,t=this.bits.length;e<t;++e)if(this.bits[e]!==0)return!1;return!0}clone(){const e=new Qr;return e.bits=this.bits.slice(),e}}u(Qr,"Bits");Yme(Qr,"Bits");var Zme=Object.defineProperty,U4=u((n,e)=>Zme(n,"name",{value:e,configurable:!0}),"__name$1n");const Jl=new DataView(new ArrayBuffer(12)),aE=new Array(8),lE=new Array(8);function Xx(n,e){Jl.setUint32(0,n),Jl.setUint32(4,e);for(let t=0;t<8;++t)aE[t]=String.fromCharCode(Jl.getUint8(t));return aE.join("")}u(Xx,"hashUint32x2");U4(Xx,"hashUint32x2");function rA(n,e,t){Jl.setFloat32(0,n||0),Jl.setFloat32(4,e||0),Jl.setFloat32(8,t||0);for(let i=0;i<12;++i)lE[i]=String.fromCharCode(Jl.getUint8(i));return lE.join("")}u(rA,"hashFloat32x3");U4(rA,"hashFloat32x3");var Kme=Object.defineProperty,$4=u((n,e)=>Kme(n,"name",{value:e,configurable:!0}),"__name$1m");const Si=new P,gb=new un,wg=new un,cE=new P,uE=new P,hE=new P,Qme=new P;function qx(n,e){if(e.isLeaf=!1,e.depth>=qr.MAX_DEPTH){e.isLeaf=!0;return}if(e.indices.length<=qr.MAX_TRI_PER_NODE){e.isLeaf=!0;return}if(!e.indices.length){e.isLeaf=!0;return}wg.makeEmpty();for(let t of e.indices)wg.expandByPoint(n.getTriangleCenter(Si,t));e.splitCenter.copy(wg.min).add(wg.max).multiplyScalar(.5),e.children.length=0;for(let t=0;t<8;++t){const i=new qr;i.depth=e.depth+1,e.children.push(i)}for(let t of e.indices)n.getTriangleCenter(Si,t),Si.x<e.splitCenter.x?Si.y<e.splitCenter.y?Si.z<e.splitCenter.z?e.children[0].indices.push(t):e.children[1].indices.push(t):Si.z<e.splitCenter.z?e.children[2].indices.push(t):e.children[3].indices.push(t):Si.y<e.splitCenter.y?Si.z<e.splitCenter.z?e.children[4].indices.push(t):e.children[5].indices.push(t):Si.z<e.splitCenter.z?e.children[6].indices.push(t):e.children[7].indices.push(t)}u(qx,"constructChildren");$4(qx,"constructChildren");const c1=class{constructor(){T(this,"depth",1);T(this,"children",[]);T(this,"box",new un);T(this,"splitCenter",new P);T(this,"isLeaf",!1);T(this,"indices",[])}build(e){this.indices.length=0;for(let i=0;i<e.triNum;++i)this.indices.push(i);const t=[this];for(;t.length;){const i=t.pop();if(!i)break;i.recomputeBox(e),qx(e,i),i.isLeaf||t.push(...i.children)}}recomputeBox(e){this.box.makeEmpty();for(let t of this.indices)this.box.union(e.getTriangleBox(gb,t));this.box.expandByScalar(1e-7)}update(e,t){if(!t.length)return;const i=new Qr(e.triNum);for(let r of t)i.set(r);const s=new Set;{const r=[this];for(;r.length;){const o=r.pop();if(!o)break;let a=!1;if(o.depth===1)a=!0;else{const l=o.indices.filter(c=>!i.get(c));a=l.length!==o.indices.length,o.indices=l}a&&(o.indices.length?(s.add(o),r.push(...o.children)):(o.box.makeEmpty(),o.isLeaf=!0,o.children.length=0))}}{const r=[[this,t]];for(;r.length;){const o=r.pop();if(!o)break;const a=o[0],l=o[1];if(s.add(a),a.depth!==1&&a.indices.push(...l),a.isLeaf){if(a.indices.length<=c1.MAX_TRI_PER_NODE||a.depth>=c1.MAX_DEPTH)continue;const y=[a];for(;y.length;){const b=y.pop();if(!b)break;b.recomputeBox(e),qx(e,b),b.isLeaf||y.push(...b.children)}continue}const c=[],h=[],f=[],d=[],p=[],g=[],m=[],v=[];for(let y of l)e.getTriangleCenter(Si,y),Si.x<a.splitCenter.x?Si.y<a.splitCenter.y?Si.z<a.splitCenter.z?c.push(y):h.push(y):Si.z<a.splitCenter.z?f.push(y):d.push(y):Si.y<a.splitCenter.y?Si.z<a.splitCenter.z?p.push(y):g.push(y):Si.z<a.splitCenter.z?m.push(y):v.push(y);c.length&&r.push([a.children[0],c]),h.length&&r.push([a.children[1],h]),f.length&&r.push([a.children[2],f]),d.length&&r.push([a.children[3],d]),p.length&&r.push([a.children[4],p]),g.length&&r.push([a.children[5],g]),m.length&&r.push([a.children[6],m]),v.length&&r.push([a.children[7],v])}}for(let r of s)r.recomputeBox(e)}raycast(e,t,i){const s=[],r=[this],o=1/t.direction.x,a=1/t.direction.y,l=1/t.direction.z;for(;r.length;){const c=r.pop();if(!c)break;const h=(c.box.min.x-t.origin.x)*o,f=(c.box.max.x-t.origin.x)*o,d=(c.box.min.y-t.origin.y)*a,p=(c.box.max.y-t.origin.y)*a,g=(c.box.min.z-t.origin.z)*l,m=(c.box.max.z-t.origin.z)*l,v=Math.max(Math.min(h,f),Math.min(d,p),Math.min(g,m)),y=Math.min(Math.max(h,f),Math.max(d,p),Math.max(g,m));if(!(y<0||v>y))if(c.isLeaf)for(let b of c.indices){e.getTriangle(cE,uE,hE,b);const x=t.intersectTriangle(cE,uE,hE,i,Qme);if(x){const w=new P().copy(x),_=e.getNormal(new P,b),A=t.origin.distanceTo(w);s.push({point:w,normal:_,distance:A,triangleIndex:b})}}else r.push(...c.children)}return s.sort((c,h)=>c.distance-h.distance)}intersectSphere(e,t){const i=[this],s=[];for(;i.length;){const r=i.pop();if(!r)break;if(!!r.box.intersectsSphere(t))if(r.isLeaf)for(let o of r.indices)e.getTriangleBox(gb,o),gb.intersectsSphere(t)&&s.push(o);else i.push(...r.children)}return s}};let qr=c1;u(qr,"OctreeNode"),T(qr,"MAX_DEPTH",8),T(qr,"MAX_TRI_PER_NODE",100);$4(qr,"OctreeNode");var Jme=Object.defineProperty,V4=u((n,e)=>Jme(n,"name",{value:e,configurable:!0}),"__name$1l");const zn=new P,An=new P,Bn=new P,Ag=new P,kr=new P,Ao=new P,ege=new P,bi=1e-7;function T0(n,e){let t=n.x,i=n.y,s=n.z,r=e.x,o=e.y,a=e.z;return t=Math.round(t/bi)*bi,i=Math.round(i/bi)*bi,s=Math.round(s/bi)*bi,r=Math.round(r/bi)*bi,o=Math.round(o/bi)*bi,a=Math.round(a/bi)*bi,t===r&&i===o&&s===a}u(T0,"isSameVertex");V4(T0,"isSameVertex");class oA{constructor(){T(this,"aPosition",new Float32Array);T(this,"aColor",new Float32Array);T(this,"aNormal",new Float32Array);T(this,"triCenter",new Float32Array);T(this,"triBox",new Float32Array);T(this,"triNum",0);T(this,"sharedVertexMap",new Uint32Array);T(this,"sharedVertexIndices",new Map);T(this,"edgeNeighborMap",new Uint32Array);T(this,"holes",new Uint8Array);T(this,"octree",new qr);T(this,"dirtyTriangles",[]);T(this,"dirtyTrianglesMask",new Qr);T(this,"positionNeedsUpdate",!1);T(this,"colorNeedsUpdate",!1)}buildFromTriangles(e,t){const i=this.aPosition=new Float32Array(e.length),s=this.aNormal=new Float32Array(e.length),r=this.aColor=new Float32Array(e.length);(t==null?void 0:t.length)!==r.length&&(t=void 0);let o=0;for(let a=0,l=e.length/9;a<l;++a)if(zn.fromArray(e,a*9),An.fromArray(e,a*9+3),Bn.fromArray(e,a*9+6),!(T0(zn,An)||T0(zn,Bn)||T0(An,Bn))){for(let c=0;c<9;++c)i[o*9+c]=e[a*9+c];if(t)for(let c=0;c<9;++c)r[o*9+c]=t[a*9+c];else for(let c=0;c<9;++c)r[o*9+c]=1;Ag.subVectors(zn,An),kr.subVectors(Bn,An),kr.cross(Ag).normalize();for(let c=0;c<3;++c){const h=o*9+c*3;s[h]=kr.x,s[h+1]=kr.y,s[h+2]=kr.z}o+=1}o<e.length/9&&(this.aPosition=i.subarray(0,o*9),this.aNormal=s.subarray(0,o*9),this.aColor=r.subarray(0,o*9),console.info(`Discard ${e.length/9-o} zero area triangles`)),this.init()}init(){const e=this.aPosition,t=this.triNum=e.length/9,i=this.triCenter=new Float32Array(t*3),s=this.triBox=new Float32Array(t*6);for(let r=0;r<t;++r)zn.fromArray(e,r*9),An.fromArray(e,r*9+3),Bn.fromArray(e,r*9+6),Ao.copy(zn).add(An).add(Bn).multiplyScalar(1/3),i[r*3]=Ao.x,i[r*3+1]=Ao.y,i[r*3+2]=Ao.z,s[r*6]=Math.min(zn.x,An.x,Bn.x),s[r*6+1]=Math.min(zn.y,An.y,Bn.y),s[r*6+2]=Math.min(zn.z,An.z,Bn.z),s[r*6+3]=Math.max(zn.x,An.x,Bn.x),s[r*6+4]=Math.max(zn.y,An.y,Bn.y),s[r*6+5]=Math.max(zn.z,An.z,Bn.z);this.buildTriangleNeighborEdgeMap(),this.octree.build(this),this.dirtyTrianglesMask.expandCapacity(t)}buildTriangleNeighborEdgeMap(){const e=this.triNum,t=this.aPosition,i=this.sharedVertexMap=new Uint32Array(e*3),s=this.sharedVertexIndices;s.clear();const r=new Map;for(let p=0,g=e*3;p<g;++p){let m=t[p*3],v=t[p*3+1],y=t[p*3+2];m=Math.round(m/bi)*bi,v=Math.round(v/bi)*bi,y=Math.round(y/bi)*bi;const b=rA(m,v,y);let x=r.get(b);x==null?(x=p,r.set(b,x),s.set(x,[])):s.get(x).push(p),i[p]=x}const o=new Map,a=new Uint8Array(e);let l=0,c=0;for(let p=0;p<e;++p){let g=!1;for(let m=0;m<3;++m){const v=p*3+m,y=i[v],b=i[p*3+(m+1)%3];if(y===b){g=!0;break}}if(g){c+=1,a[p]=1;continue}for(let m=0;m<3;++m){const v=p*3+m,y=i[v],b=i[p*3+(m+1)%3],x=Xx(y,b);o.get(x)==null?o.set(x,v):l+=1}}c&&console.warn(`Mesh has ${c} zero area triangles`),l&&console.warn(`Mesh has ${l} duplicate edges (embedded faces may exist)`);const h=this.edgeNeighborMap=new Uint32Array(e*3),f=this.holes=new Uint8Array(e*3);let d=0;for(let p=0;p<e;++p)if(!a[p])for(let g=0;g<3;++g){const m=p*3+g,v=i[m],y=i[p*3+(g+1)%3],b=Xx(y,v),x=o.get(b);x==null?(f[m]=1,d+=1):h[m]=x}d&&console.warn(`Mesh has ${d} edges border hole`)}getTriangleCenter(e,t){return e.fromArray(this.triCenter,t*3),e}getTriangleBox(e,t){return e.min.fromArray(this.triBox,t*6),e.max.fromArray(this.triBox,t*6+3),e}getTriangle(e,t,i,s){e.fromArray(this.aPosition,this.sharedVertexMap[s*3]*3),t.fromArray(this.aPosition,this.sharedVertexMap[s*3+1]*3),i.fromArray(this.aPosition,this.sharedVertexMap[s*3+2]*3)}getVertex(e,t){return e.fromArray(this.aPosition,t*3)}getNormal(e,t){return e.fromArray(this.aNormal,t*3*3),e}getAverageNormal(e,t){e.set(0,0,0);for(let i of t)e.add(this.getNormal(ege,i));return e.normalize()}getAverageCenter(e,t){e.set(0,0,0);for(let i of t)e.add(this.getTriangleCenter(Ao,i));return e.divideScalar(t.length)}toThree(e){if(e){const t=e,i=t.geometry.getAttribute("position");if(i.array===this.aPosition){if(this.positionNeedsUpdate){this.positionNeedsUpdate=!1,i.needsUpdate=!0;const s=t.geometry.getAttribute("normal");s.needsUpdate=!0}if(this.colorNeedsUpdate){this.colorNeedsUpdate=!1;const s=t.geometry.getAttribute("color");s.needsUpdate=!0}}else t.geometry.dispose(),t.geometry=new Je,t.geometry.setAttribute("position",new Ve(this.aPosition,3)),t.geometry.setAttribute("normal",new Ve(this.aNormal,3)),t.geometry.setAttribute("color",new Ve(this.aColor,3));return t}else return new We(new Je().setAttribute("position",new Rt(this.aPosition,3)).setAttribute("normal",new Rt(this.aNormal,3)).setAttribute("color",new Rt(this.aColor,3)),new rr({vertexColors:!0}))}raycast(e,t){return this.octree.raycast(this,e,t)}intersectSphere(e){return this.octree.intersectSphere(this,e)}getVertexTriangleIndex(e){return(e-e%3)/3}markTriangleDirty(e){this.dirtyTrianglesMask.get(e)||(this.dirtyTrianglesMask.set(e),this.dirtyTriangles.push(e))}updateVertices(e,t){const i=this.aPosition;for(let s=0,r=e.length;s<r;++s){const o=this.sharedVertexMap[e[s]];this.markTriangleDirty(this.getVertexTriangleIndex(o));for(let l=0;l<3;++l)i[o*3+l]=t[s*3+l];const a=this.sharedVertexIndices.get(o);if(a)for(let l of a){this.markTriangleDirty(this.getVertexTriangleIndex(l));for(let c=0;c<3;++c)i[l*3+c]=t[s*3+c]}}this.positionNeedsUpdate=!0}updateColors(e,t){const i=this.aColor;for(let s=0,r=e.length;s<r;++s){const o=this.sharedVertexMap[e[s]];for(let l=0;l<3;++l)i[o*3+l]=t[s*3+l];const a=this.sharedVertexIndices.get(o);if(a)for(let l of a)for(let c=0;c<3;++c)i[l*3+c]=t[s*3+c]}this.colorNeedsUpdate=!0}update(e){const t=this.dirtyTriangles,i=this.aPosition,s=this.aNormal,r=this.triCenter,o=this.triBox;let a=0,l=0,c=0,h=0,f=0,d=0,p=!1;if(e!=null&&e.boundingSphere){p=!0;const g=e.boundingSphere.center,m=e.boundingSphere.radius;a=g.x-m,l=g.y-m,c=g.z-m,h=g.x+m,f=g.y+m,d=g.z+m}for(let g of t){zn.fromArray(i,g*9),An.fromArray(i,g*9+3),Bn.fromArray(i,g*9+6),Ag.subVectors(zn,An),kr.subVectors(Bn,An),kr.cross(Ag).normalize();for(let m=0;m<3;++m){const v=g*9+m*3;s[v]=kr.x,s[v+1]=kr.y,s[v+2]=kr.z}Ao.copy(zn).add(An).add(Bn).multiplyScalar(1/3),r[g*3]=Ao.x,r[g*3+1]=Ao.y,r[g*3+2]=Ao.z,o[g*6]=Math.min(zn.x,An.x,Bn.x),o[g*6+1]=Math.min(zn.y,An.y,Bn.y),o[g*6+2]=Math.min(zn.z,An.z,Bn.z),o[g*6+3]=Math.max(zn.x,An.x,Bn.x),o[g*6+4]=Math.max(zn.y,An.y,Bn.y),o[g*6+5]=Math.max(zn.z,An.z,Bn.z),p&&(a=Math.min(o[g*6],a),l=Math.min(o[g*6+1],l),c=Math.min(o[g*6+2],c),h=Math.max(o[g*6+3],h),f=Math.max(o[g*6+4],f),d=Math.max(o[g*6+5],d))}if(p){const g=e.boundingSphere;g.center.set((h+a)/2,(f+l)/2,(d+c)/2),g.radius=Math.max(h-g.center.x,g.center.x-a,f-g.center.y,g.center.y-l,d-g.center.z,g.center.z-c)}this.octree.update(this,t),this.dirtyTriangles.length=0,this.dirtyTrianglesMask.clear()}}u(oA,"DynamicMesh");V4(oA,"DynamicMesh");var tge=Object.defineProperty,H4=u((n,e)=>tge(n,"name",{value:e,configurable:!0}),"__name$1k");const vb=new Int8Array([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,9,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,2,10,0,2,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,8,3,2,10,8,10,9,8,-1,-1,-1,-1,-1,-1,-1,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,8,11,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,11,2,1,9,11,9,8,11,-1,-1,-1,-1,-1,-1,-1,3,10,1,11,10,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,10,1,0,8,10,8,11,10,-1,-1,-1,-1,-1,-1,-1,3,9,0,3,11,9,11,10,9,-1,-1,-1,-1,-1,-1,-1,9,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,7,3,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,1,9,4,7,1,7,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,4,7,3,0,4,1,2,10,-1,-1,-1,-1,-1,-1,-1,9,2,10,9,0,2,8,4,7,-1,-1,-1,-1,-1,-1,-1,2,10,9,2,9,7,2,7,3,7,9,4,-1,-1,-1,-1,8,4,7,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,4,7,11,2,4,2,0,4,-1,-1,-1,-1,-1,-1,-1,9,0,1,8,4,7,2,3,11,-1,-1,-1,-1,-1,-1,-1,4,7,11,9,4,11,9,11,2,9,2,1,-1,-1,-1,-1,3,10,1,3,11,10,7,8,4,-1,-1,-1,-1,-1,-1,-1,1,11,10,1,4,11,1,0,4,7,11,4,-1,-1,-1,-1,4,7,8,9,0,11,9,11,10,11,0,3,-1,-1,-1,-1,4,7,11,4,11,9,9,11,10,-1,-1,-1,-1,-1,-1,-1,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,4,1,5,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,5,4,8,3,5,3,1,5,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,10,4,9,5,-1,-1,-1,-1,-1,-1,-1,5,2,10,5,4,2,4,0,2,-1,-1,-1,-1,-1,-1,-1,2,10,5,3,2,5,3,5,4,3,4,8,-1,-1,-1,-1,9,5,4,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,0,8,11,4,9,5,-1,-1,-1,-1,-1,-1,-1,0,5,4,0,1,5,2,3,11,-1,-1,-1,-1,-1,-1,-1,2,1,5,2,5,8,2,8,11,4,8,5,-1,-1,-1,-1,10,3,11,10,1,3,9,5,4,-1,-1,-1,-1,-1,-1,-1,4,9,5,0,8,1,8,10,1,8,11,10,-1,-1,-1,-1,5,4,0,5,0,11,5,11,10,11,0,3,-1,-1,-1,-1,5,4,8,5,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,9,7,8,5,7,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,3,0,9,5,3,5,7,3,-1,-1,-1,-1,-1,-1,-1,0,7,8,0,1,7,1,5,7,-1,-1,-1,-1,-1,-1,-1,1,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,7,8,9,5,7,10,1,2,-1,-1,-1,-1,-1,-1,-1,10,1,2,9,5,0,5,3,0,5,7,3,-1,-1,-1,-1,8,0,2,8,2,5,8,5,7,10,5,2,-1,-1,-1,-1,2,10,5,2,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,7,9,5,7,8,9,3,11,2,-1,-1,-1,-1,-1,-1,-1,9,5,7,9,7,2,9,2,0,2,7,11,-1,-1,-1,-1,2,3,11,0,1,8,1,7,8,1,5,7,-1,-1,-1,-1,11,2,1,11,1,7,7,1,5,-1,-1,-1,-1,-1,-1,-1,9,5,8,8,5,7,10,1,3,10,3,11,-1,-1,-1,-1,5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,-1,11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,-1,11,10,5,7,11,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,0,1,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,1,9,8,5,10,6,-1,-1,-1,-1,-1,-1,-1,1,6,5,2,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,6,5,1,2,6,3,0,8,-1,-1,-1,-1,-1,-1,-1,9,6,5,9,0,6,0,2,6,-1,-1,-1,-1,-1,-1,-1,5,9,8,5,8,2,5,2,6,3,2,8,-1,-1,-1,-1,2,3,11,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,0,8,11,2,0,10,6,5,-1,-1,-1,-1,-1,-1,-1,0,1,9,2,3,11,5,10,6,-1,-1,-1,-1,-1,-1,-1,5,10,6,1,9,2,9,11,2,9,8,11,-1,-1,-1,-1,6,3,11,6,5,3,5,1,3,-1,-1,-1,-1,-1,-1,-1,0,8,11,0,11,5,0,5,1,5,11,6,-1,-1,-1,-1,3,11,6,0,3,6,0,6,5,0,5,9,-1,-1,-1,-1,6,5,9,6,9,11,11,9,8,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,4,7,3,6,5,10,-1,-1,-1,-1,-1,-1,-1,1,9,0,5,10,6,8,4,7,-1,-1,-1,-1,-1,-1,-1,10,6,5,1,9,7,1,7,3,7,9,4,-1,-1,-1,-1,6,1,2,6,5,1,4,7,8,-1,-1,-1,-1,-1,-1,-1,1,2,5,5,2,6,3,0,4,3,4,7,-1,-1,-1,-1,8,4,7,9,0,5,0,6,5,0,2,6,-1,-1,-1,-1,7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,-1,3,11,2,7,8,4,10,6,5,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,2,4,2,0,2,7,11,-1,-1,-1,-1,0,1,9,4,7,8,2,3,11,5,10,6,-1,-1,-1,-1,9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,-1,8,4,7,3,11,5,3,5,1,5,11,6,-1,-1,-1,-1,5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,-1,0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,-1,6,5,9,6,9,11,4,7,9,7,11,9,-1,-1,-1,-1,10,4,9,6,4,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,10,6,4,9,10,0,8,3,-1,-1,-1,-1,-1,-1,-1,10,0,1,10,6,0,6,4,0,-1,-1,-1,-1,-1,-1,-1,8,3,1,8,1,6,8,6,4,6,1,10,-1,-1,-1,-1,1,4,9,1,2,4,2,6,4,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,9,2,4,9,2,6,4,-1,-1,-1,-1,0,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,3,2,8,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,10,4,9,10,6,4,11,2,3,-1,-1,-1,-1,-1,-1,-1,0,8,2,2,8,11,4,9,10,4,10,6,-1,-1,-1,-1,3,11,2,0,1,6,0,6,4,6,1,10,-1,-1,-1,-1,6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,-1,9,6,4,9,3,6,9,1,3,11,6,3,-1,-1,-1,-1,8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,-1,3,11,6,3,6,0,0,6,4,-1,-1,-1,-1,-1,-1,-1,6,4,8,11,6,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,10,6,7,8,10,8,9,10,-1,-1,-1,-1,-1,-1,-1,0,7,3,0,10,7,0,9,10,6,7,10,-1,-1,-1,-1,10,6,7,1,10,7,1,7,8,1,8,0,-1,-1,-1,-1,10,6,7,10,7,1,1,7,3,-1,-1,-1,-1,-1,-1,-1,1,2,6,1,6,8,1,8,9,8,6,7,-1,-1,-1,-1,2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,-1,7,8,0,7,0,6,6,0,2,-1,-1,-1,-1,-1,-1,-1,7,3,2,6,7,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,11,10,6,8,10,8,9,8,6,7,-1,-1,-1,-1,2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,-1,1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,-1,11,2,1,11,1,7,10,6,1,6,7,1,-1,-1,-1,-1,8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,-1,0,9,1,11,6,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,8,0,7,0,6,3,11,0,11,6,0,-1,-1,-1,-1,7,11,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,1,9,8,3,1,11,7,6,-1,-1,-1,-1,-1,-1,-1,10,1,2,6,11,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,8,6,11,7,-1,-1,-1,-1,-1,-1,-1,2,9,0,2,10,9,6,11,7,-1,-1,-1,-1,-1,-1,-1,6,11,7,2,10,3,10,8,3,10,9,8,-1,-1,-1,-1,7,2,3,6,2,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,0,8,7,6,0,6,2,0,-1,-1,-1,-1,-1,-1,-1,2,7,6,2,3,7,0,1,9,-1,-1,-1,-1,-1,-1,-1,1,6,2,1,8,6,1,9,8,8,7,6,-1,-1,-1,-1,10,7,6,10,1,7,1,3,7,-1,-1,-1,-1,-1,-1,-1,10,7,6,1,7,10,1,8,7,1,0,8,-1,-1,-1,-1,0,3,7,0,7,10,0,10,9,6,10,7,-1,-1,-1,-1,7,6,10,7,10,8,8,10,9,-1,-1,-1,-1,-1,-1,-1,6,8,4,11,8,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,6,11,3,0,6,0,4,6,-1,-1,-1,-1,-1,-1,-1,8,6,11,8,4,6,9,0,1,-1,-1,-1,-1,-1,-1,-1,9,4,6,9,6,3,9,3,1,11,3,6,-1,-1,-1,-1,6,8,4,6,11,8,2,10,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,11,0,6,11,0,4,6,-1,-1,-1,-1,4,11,8,4,6,11,0,2,9,2,10,9,-1,-1,-1,-1,10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,-1,8,2,3,8,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,0,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,4,2,4,6,4,3,8,-1,-1,-1,-1,1,9,4,1,4,2,2,4,6,-1,-1,-1,-1,-1,-1,-1,8,1,3,8,6,1,8,4,6,6,10,1,-1,-1,-1,-1,10,1,0,10,0,6,6,0,4,-1,-1,-1,-1,-1,-1,-1,4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,-1,10,9,4,6,10,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,5,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,5,11,7,6,-1,-1,-1,-1,-1,-1,-1,5,0,1,5,4,0,7,6,11,-1,-1,-1,-1,-1,-1,-1,11,7,6,8,3,4,3,5,4,3,1,5,-1,-1,-1,-1,9,5,4,10,1,2,7,6,11,-1,-1,-1,-1,-1,-1,-1,6,11,7,1,2,10,0,8,3,4,9,5,-1,-1,-1,-1,7,6,11,5,4,10,4,2,10,4,0,2,-1,-1,-1,-1,3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,-1,7,2,3,7,6,2,5,4,9,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,6,0,6,2,6,8,7,-1,-1,-1,-1,3,6,2,3,7,6,1,5,0,5,4,0,-1,-1,-1,-1,6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,-1,9,5,4,10,1,6,1,7,6,1,3,7,-1,-1,-1,-1,1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,-1,4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,-1,7,6,10,7,10,8,5,4,10,4,8,10,-1,-1,-1,-1,6,9,5,6,11,9,11,8,9,-1,-1,-1,-1,-1,-1,-1,3,6,11,0,6,3,0,5,6,0,9,5,-1,-1,-1,-1,0,11,8,0,5,11,0,1,5,5,6,11,-1,-1,-1,-1,6,11,3,6,3,5,5,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,11,9,11,8,11,5,6,-1,-1,-1,-1,0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,-1,11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,-1,6,11,3,6,3,5,2,10,3,10,5,3,-1,-1,-1,-1,5,8,9,5,2,8,5,6,2,3,8,2,-1,-1,-1,-1,9,5,6,9,6,0,0,6,2,-1,-1,-1,-1,-1,-1,-1,1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,-1,1,5,6,2,1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,-1,10,1,0,10,0,6,9,5,0,5,6,0,-1,-1,-1,-1,0,3,8,5,6,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,5,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,7,5,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,11,7,5,8,3,0,-1,-1,-1,-1,-1,-1,-1,5,11,7,5,10,11,1,9,0,-1,-1,-1,-1,-1,-1,-1,10,7,5,10,11,7,9,8,1,8,3,1,-1,-1,-1,-1,11,1,2,11,7,1,7,5,1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,7,1,7,5,7,2,11,-1,-1,-1,-1,9,7,5,9,2,7,9,0,2,2,11,7,-1,-1,-1,-1,7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,-1,2,5,10,2,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,8,2,0,8,5,2,8,7,5,10,2,5,-1,-1,-1,-1,9,0,1,5,10,3,5,3,7,3,10,2,-1,-1,-1,-1,9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,-1,1,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,7,0,7,1,1,7,5,-1,-1,-1,-1,-1,-1,-1,9,0,3,9,3,5,5,3,7,-1,-1,-1,-1,-1,-1,-1,9,8,7,5,9,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,8,4,5,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,5,0,4,5,11,0,5,10,11,11,3,0,-1,-1,-1,-1,0,1,9,8,4,10,8,10,11,10,4,5,-1,-1,-1,-1,10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,-1,2,5,1,2,8,5,2,11,8,4,5,8,-1,-1,-1,-1,0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,-1,0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,-1,9,4,5,2,11,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,5,10,3,5,2,3,4,5,3,8,4,-1,-1,-1,-1,5,10,2,5,2,4,4,2,0,-1,-1,-1,-1,-1,-1,-1,3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,-1,5,10,2,5,2,4,1,9,2,9,4,2,-1,-1,-1,-1,8,4,5,8,5,3,3,5,1,-1,-1,-1,-1,-1,-1,-1,0,4,5,1,0,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,4,5,8,5,3,9,0,5,0,3,5,-1,-1,-1,-1,9,4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,11,7,4,9,11,9,10,11,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,7,9,11,7,9,10,11,-1,-1,-1,-1,1,10,11,1,11,4,1,4,0,7,4,11,-1,-1,-1,-1,3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,-1,4,11,7,9,11,4,9,2,11,9,1,2,-1,-1,-1,-1,9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,-1,11,7,4,11,4,2,2,4,0,-1,-1,-1,-1,-1,-1,-1,11,7,4,11,4,2,8,3,4,3,2,4,-1,-1,-1,-1,2,9,10,2,7,9,2,3,7,7,4,9,-1,-1,-1,-1,9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,-1,3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,-1,1,10,2,8,7,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,7,1,3,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,0,8,1,8,7,1,-1,-1,-1,-1,4,0,3,7,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,11,9,10,-1,-1,-1,-1,-1,-1,-1,0,1,10,0,10,8,8,10,11,-1,-1,-1,-1,-1,-1,-1,3,1,10,11,3,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,11,1,11,9,9,11,8,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,1,2,9,2,11,9,-1,-1,-1,-1,0,2,11,8,0,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,10,8,9,-1,-1,-1,-1,-1,-1,-1,9,10,2,0,9,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,0,1,8,1,10,8,-1,-1,-1,-1,1,10,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,8,9,1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,3,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]),Ms=new Uint16Array([0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0]);function Ps(n,e){return n/(n-e)}u(Ps,"getAlpha");H4(Ps,"getAlpha");const rt=new Float32Array(12*3),ot=new Float32Array(12*3),qe=new P,yn=new P;function aA(n,e,t,i,s,r,o,a,l,c,h,f,d,p,g,m,v){const y=a[c],b=a[h],x=a[f],w=a[d],_=a[p],A=a[g],S=a[m],M=a[v],C=!!(t&&l);let I=0;if(y<0&&(I|=1<<0),b<0&&(I|=1<<1),x<0&&(I|=1<<2),w<0&&(I|=1<<3),_<0&&(I|=1<<4),A<0&&(I|=1<<5),S<0&&(I|=1<<6),M<0&&(I|=1<<7),Ms[I]!==0){if(Ms[I]&1<<0){const F=Ps(y,b);rt[0]=i+F*o,rt[1]=s,rt[2]=r,C&&(qe.fromArray(l,c*3),yn.fromArray(l,h*3),qe.lerp(yn,F),ot[0]=qe.x,ot[1]=qe.y,ot[2]=qe.z)}if(Ms[I]&1<<1){const F=Ps(b,x);rt[3]=i+o,rt[3+1]=s,rt[3+2]=r+F*o,C&&(qe.fromArray(l,h*3),yn.fromArray(l,f*3),qe.lerp(yn,F),ot[3]=qe.x,ot[3+1]=qe.y,ot[3+2]=qe.z)}if(Ms[I]&1<<2){const F=Ps(w,x);rt[3*2]=i+F*o,rt[3*2+1]=s,rt[3*2+2]=r+o,C&&(qe.fromArray(l,d*3),yn.fromArray(l,f*3),qe.lerp(yn,F),ot[3*2]=qe.x,ot[3*2+1]=qe.y,ot[3*2+2]=qe.z)}if(Ms[I]&1<<3){const F=Ps(y,w);rt[3*3]=i,rt[3*3+1]=s,rt[3*3+2]=r+F*o,C&&(qe.fromArray(l,c*3),yn.fromArray(l,d*3),qe.lerp(yn,F),ot[3*3]=qe.x,ot[3*3+1]=qe.y,ot[3*3+2]=qe.z)}if(Ms[I]&1<<4){const F=Ps(_,A);rt[3*4]=i+F*o,rt[3*4+1]=s+o,rt[3*4+2]=r,C&&(qe.fromArray(l,p*3),yn.fromArray(l,g*3),qe.lerp(yn,F),ot[3*4]=qe.x,ot[3*4+1]=qe.y,ot[3*4+2]=qe.z)}if(Ms[I]&1<<5){const F=Ps(A,S);rt[3*5]=i+o,rt[3*5+1]=s+o,rt[3*5+2]=r+F*o,C&&(qe.fromArray(l,g*3),yn.fromArray(l,m*3),qe.lerp(yn,F),ot[3*5]=qe.x,ot[3*5+1]=qe.y,ot[3*5+2]=qe.z)}if(Ms[I]&1<<6){const F=Ps(M,S);rt[3*6]=i+F*o,rt[3*6+1]=s+o,rt[3*6+2]=r+o,C&&(qe.fromArray(l,v*3),yn.fromArray(l,m*3),qe.lerp(yn,F),ot[3*6]=qe.x,ot[3*6+1]=qe.y,ot[3*6+2]=qe.z)}if(Ms[I]&1<<7){const F=Ps(_,M);rt[3*7]=i,rt[3*7+1]=s+o,rt[3*7+2]=r+F*o,C&&(qe.fromArray(l,p*3),yn.fromArray(l,v*3),qe.lerp(yn,F),ot[3*7]=qe.x,ot[3*7+1]=qe.y,ot[3*7+2]=qe.z)}if(Ms[I]&1<<8){const F=Ps(y,_);rt[3*8]=i,rt[3*8+1]=s+F*o,rt[3*8+2]=r,C&&(qe.fromArray(l,c*3),yn.fromArray(l,p*3),qe.lerp(yn,F),ot[3*8]=qe.x,ot[3*8+1]=qe.y,ot[3*8+2]=qe.z)}if(Ms[I]&1<<9){const F=Ps(b,A);rt[3*9]=i+o,rt[3*9+1]=s+F*o,rt[3*9+2]=r,C&&(qe.fromArray(l,h*3),yn.fromArray(l,g*3),qe.lerp(yn,F),ot[3*9]=qe.x,ot[3*9+1]=qe.y,ot[3*9+2]=qe.z)}if(Ms[I]&1<<10){const F=Ps(x,S);rt[3*10]=i+o,rt[3*10+1]=s+F*o,rt[3*10+2]=r+o,C&&(qe.fromArray(l,f*3),yn.fromArray(l,m*3),qe.lerp(yn,F),ot[3*10]=qe.x,ot[3*10+1]=qe.y,ot[3*10+2]=qe.z)}if(Ms[I]&1<<11){const F=Ps(w,M);rt[3*11]=i,rt[3*11+1]=s+F*o,rt[3*11+2]=r+o,C&&(qe.fromArray(l,d*3),yn.fromArray(l,v*3),qe.lerp(yn,F),ot[3*11]=qe.x,ot[3*11+1]=qe.y,ot[3*11+2]=qe.z)}for(let F=0;;F+=3){const O=vb[I*16+F];if(O===-1)break;const N=vb[I*16+F+1],E=vb[I*16+F+2],k=rt[O*3],G=rt[O*3+1],X=rt[O*3+2],te=rt[N*3],j=rt[N*3+1],ie=rt[N*3+2],K=rt[E*3],$=rt[E*3+1],le=rt[E*3+2];if(n.push(k,G,X,te,j,ie,K,$,le),C&&t.push(ot[O*3],ot[O*3+1],ot[O*3+2],ot[N*3],ot[N*3+1],ot[N*3+2],ot[E*3],ot[E*3+1],ot[E*3+2]),e){const ae=te-k,J=j-G,ne=ie-X,ve=te-K,he=j-$,_e=ie-le,we=J*_e-ne*he,Se=ne*ve-ae*_e,V=ae*he-J*ve,Y=1/Math.sqrt(we**2+Se**2+V**2),R=-we*Y,ee=-Se*Y,Q=-V*Y;e.push(R,ee,Q,R,ee,Q,R,ee,Q)}}}}u(aA,"marchingCubes");H4(aA,"marchingCubes");var nge=Object.defineProperty,ll=u((n,e)=>nge(n,"name",{value:e,configurable:!0}),"__name$1j");function G4(n,e,t,i,s,r,o){return Math.sqrt((n-i)**2+(e-s)**2+(t-r)**2)-o}u(G4,"sphere");ll(G4,"sphere");function W4(n,e,t,i,s,r,o,a,l,c,h){const f=a-i,d=l-s,p=c-r,g=f**2+d**2+p**2,m=o-h,v=g-m**2,y=1/g,b=n-i,x=e-s,w=t-r,_=b*f+x*d+w*p,A=_-g,S=(b*g-f*_)**2+(x*g-d*_)**2+(w*g-p*_)**2,M=_**2*g,C=A**2*g,I=Math.sign(m)*m*m*S;return Math.sign(A)*v*C>I?Math.sqrt(S+C)*y-h:Math.sign(_)*v*M<I?Math.sqrt(S+M)*y-o:(Math.sqrt(S*v*y)+_*m)*y-o}u(W4,"roundCone");ll(W4,"roundCone");function ige(n,e){return Math.min(n,e)}u(ige,"merge");ll(ige,"merge");function j4(n,e,t){const i=Math.max(0,Math.min(1,.5+.5*(e-n)/t));return e*(1-i)+n*i-t*i*(1-i)}u(j4,"mergeSmooth");ll(j4,"mergeSmooth");function X4(n,e){return Math.max(n,e)}u(X4,"intersect");ll(X4,"intersect");function q4(n,e,t){const i=Math.max(0,Math.min(1,.5-.5*(e-n)/t));return e*(1-i)+n*i+t*i*(1-i)}u(q4,"intersectSmooth");ll(q4,"intersectSmooth");function sge(n,e){return X4(n,-e)}u(sge,"subtract");ll(sge,"subtract");function Y4(n,e,t){return q4(n,-e,t)}u(Y4,"subtractSmooth");ll(Y4,"subtractSmooth");var rge=Object.defineProperty,lA=u((n,e)=>rge(n,"name",{value:e,configurable:!0}),"__name$1i");class Vp{constructor(e,t,i){T(this,"position");T(this,"radius");T(this,"operator");T(this,"bb");T(this,"fatBb",new un);this.position=e,this.radius=t,this.operator=i,this.bb=new un().expandByPoint(e).expandByScalar(t)}createSymmetry(e){const t=new P().copy(this.position);return t.setComponent(e,-t.getComponent(e)),new Vp(t,this.radius,this.operator)}sdf(e,t,i){return G4(e,t,i,this.position.x,this.position.y,this.position.z,this.radius)}}u(Vp,"SdfSphere");lA(Vp,"SdfSphere");class Hp{constructor(e,t,i,s,r){T(this,"p1");T(this,"r1");T(this,"p2");T(this,"r2");T(this,"operator");T(this,"bb");T(this,"fatBb",new un);this.p1=e,this.r1=t,this.p2=i,this.r2=s,this.operator=r,this.bb=new un().union(new un().expandByPoint(e).expandByScalar(t)).union(new un().expandByPoint(i).expandByScalar(s))}createSymmetry(e){const t=new P().copy(this.p1).setComponent(e,-this.p1.getComponent(e)),i=new P().copy(this.p2).setComponent(e,-this.p2.getComponent(e));return new Hp(t,this.r1,i,this.r2,this.operator)}sdf(e,t,i){return W4(e,t,i,this.p1.x,this.p1.y,this.p1.z,this.r1,this.p2.x,this.p2.y,this.p2.z,this.r2)}}u(Hp,"SdfRoundCone");lA(Hp,"SdfRoundCone");const au=new P;class vv{constructor(){T(this,"resolution",.003);T(this,"maxResolutionSeg",100);T(this,"symmetryAxis",-1);T(this,"smoothRange",.01);T(this,"shapes",[])}sphere(e,t,i){if(t<=0)return;const s=new Vp(e,t,i);this.shapes.push(s),this.symmetryAxis>=0&&this.shapes.push(s.createSymmetry(this.symmetryAxis))}roundCone(e,t,i,s,r){if(t<=0&&s<=0)return;if(au.subVectors(e,i).length()+Math.min(t,s)<=Math.max(t,s))return t>s?this.sphere(e,t,r):this.sphere(i,s,r);const a=new Hp(e,t,i,s,r);this.shapes.push(a),this.symmetryAxis>=0&&this.shapes.push(a.createSymmetry(this.symmetryAxis))}build(){const e=new un;for(let y of this.shapes)y.operator&&e.union(y.bb);if(e.isEmpty())return{position:[],normal:[]};e.getSize(au);let t=Math.max(this.resolution,Math.max(au.x,au.y,au.z)/this.maxResolutionSeg);const i=this.smoothRange;for(let y of this.shapes)y.fatBb.copy(y.bb).expandByScalar(t+i);const s=e.min.x-t-i,r=e.min.y-t-i,o=e.min.z-t-i,a=e.max.x+t+i,l=e.max.y+t+i,c=e.max.z+t+i,h=Math.ceil((a-s)/t),f=Math.ceil((l-r)/t),d=Math.ceil((c-o)/t),p=new Float32Array(h*f*d),g=new Qr(p.length);for(let y=0;y<h;++y){const b=s+y*t;for(let x=0;x<f;++x){const w=r+x*t;for(let _=0;_<d;++_){const A=o+_*t,S=y*f*d+x*d+_;for(let M of this.shapes)if(!!M.fatBb.containsPoint(au.set(b,w,A)))if(M.operator)g.get(S)?p[S]=j4(p[S],M.sdf(b,w,A),i):(g.set(S),p[S]=M.sdf(b,w,A));else{if(!g.get(S))continue;p[S]=Y4(p[S],M.sdf(b,w,A),i)}}}}const m=[],v=[];for(let y=0;y<h-1;++y){const b=s+y*t;for(let x=0;x<f-1;++x){const w=r+x*t;for(let _=0;_<d-1;++_){const A=o+_*t;!g.get(y*f*d+x*d+_)||aA(m,v,null,b,w,A,t,p,null,y*f*d+x*d+_,(y+1)*f*d+x*d+_,(y+1)*f*d+x*d+(_+1),y*f*d+x*d+(_+1),y*f*d+(x+1)*d+_,(y+1)*f*d+(x+1)*d+_,(y+1)*f*d+(x+1)*d+(_+1),y*f*d+(x+1)*d+(_+1))}}}return{position:m,normal:v}}}u(vv,"SdfMeshBuilder");lA(vv,"SdfMeshBuilder");var oge=Object.defineProperty,age=u((n,e)=>oge(n,"name",{value:e,configurable:!0}),"__name$1h");class cA{update(e,t){var l;if(t.instanceId||t.type!=="Clay")return;const i=t.get(Fn),s=t.get(Pr);if(!i.dirty&&!s.dirty)return;i.dirty=!1,s.dirty=!1;const r=i.partialUpdate||s.partialUpdate;if(i.partialUpdate=!1,s.partialUpdate=!1,i.value.length===0){const c=new vv;c.sphere(new P(0,0,0),.25,!0);const{position:h}=c.build();i.value=new Float32Array(h),s.value=new Float32Array(h.length);for(let f=0,d=s.value.length;f<d;++f)s.value[f]=1}const o=t.get(Me);!o.mesh||!r?(o.mesh=new oA,o.mesh.buildFromTriangles(i.value,s.value),i.value=new Float32Array(o.mesh.aPosition),s.value=new Float32Array(o.mesh.aColor)):o.mesh.update((l=o.value)==null?void 0:l.geometry),r||o.dispose();const a=o.value;o.value?o.mesh.toThree(o.value):(o.value=o.mesh.toThree(),o.value.userData={node:t},o.parentChanged=!0,o.localTransformChanged=!0),e.model.instanceMeshUpdated(t.id,a!==o.value)}}u(cA,"ClayUpdateFilter");age(cA,"ClayUpdateFilter");var lge=Object.defineProperty,cge=u((n,e)=>lge(n,"name",{value:e,configurable:!0}),"__name$1g");class uA{update(e,t){if(t.type==="Container"){const i=t.get(Me);i.value||(i.value=new _i,i.value.userData={node:t}),t.instanceId&&(t.instanceMeshDirty=!1)}}}u(uA,"ContainerUpdateFilter");cge(uA,"ContainerUpdateFilter");var uge="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGZJREFUSIntlsEOwCAIQ8vCf+u+HC8z0WnUMEh2oDc09PVkJQAZjmIAEJHkYU5EN7eDpXkNzbPDr2rD8upSo3fIAfAoK/2HvUtpdKwABCAAAfgDwPo13QOs67MDWNdmB3Arfjh/WwpBzho97mV7igAAAABJRU5ErkJggg==",hge="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAALhJREFUSIntVdsOwjAIHcb/HvtyfAFCESjVGmPieVuBc8k2CkcPuHiuuHeIieiMigAwFcoEBmIAuKImU58KDeTE4AF99vD1SMAnQCI6xfFCAu3nNGESFBfeYZXW9/sk6UtmVxW5OgWA9EMI3TeI2xy3F4j2KO/i+niCv8D3BQS//R+UDt6dTXeR2YxHIYbSm/FYAZSlFazr1ATX7bqeLsmtF05sbf3KvOxcRyAUehouiLsCg9DCueIBQtEIj3OkCCMAAAAASUVORK5CYII=",fge=Object.defineProperty,dge=u((n,e)=>fge(n,"name",{value:e,configurable:!0}),"__name$1f");const Z4=new Op,Yx=Z4.load(uge);Yx.minFilter=Yx.magFilter=Yt;const Zx=Z4.load(hge);Zx.minFilter=Zx.magFilter=Yt;class hA{update(e,t){var s,r,o,a;if(t.type!=="IKChain")return;t.instanceId&&(t.instanceMeshDirty=!1);const i=t.get(Me);i.value||(i.value=new _i,i.value.userData={node:t});for(let l=0,c=t.children.length;l<c;++l){const h=t.children[l];h.instanceId&&(h.instanceMeshDirty=!1);const f=h.get(Me);f.value||(f.value=new _i,f.value.userData={node:h});const d=h.get(At);if(!d.dirty)continue;if(!d.boneMesh){const A=d.boneMesh=new We;A.material=new xi({depthWrite:!1,depthTest:!1,fog:!1,toneMapped:!1,transparent:!0,opacity:.5,color:7829367}),A.renderOrder=1,A.visible=e.options.showIkBones,f.value.add(A)}const p=d.boneMesh,g=h.value(Ji),m=p.geometry;((s=m==null?void 0:m.parameters)==null?void 0:s.height)!==g&&((r=p.geometry)==null||r.dispose(),p.geometry=new F1(.003,g,6).translate(0,h.value(Ji)/2,0).rotateZ(-Math.PI/2));const v=h.value(Ja);let y=v[0]/180*Math.PI,b=v[1]/180*Math.PI;if(h.instanceId&&h.has(jn)){const A=h.value(jn);switch(h.value(gs)){case"horizontal":A.z>1e-6&&([y,b]=[-b,-y]);break;case"vertical":A.y>1e-6&&([y,b]=[-b,-y]);break}}if(!d.hingeIndicator){const A=d.hingeIndicator=new We;A.material=new xi({depthWrite:!1,depthTest:!1,fog:!1,toneMapped:!1,transparent:!0,opacity:.5,color:16777215,side:Ki}),A.renderOrder=1}const x=d.hingeIndicator;x.visible=e.options.showIkBones&&h.value(gs)!=="none";const w=l===0?t.value(Me):t.children[l-1].value(Me);x.parent!==w&&w.add(x);const _=x.geometry;switch((!_||((o=_==null?void 0:_.parameters)==null?void 0:o.thetaStart)!==y||((a=_==null?void 0:_.parameters)==null?void 0:a.thetaLength)!==b-y)&&(_==null||_.dispose(),x.geometry=new ah(.025,32,y,b-y)),h.value(gs)){case"horizontal":x.rotation.set(-Math.PI/2,0,0),d.hingeEnabled=!0,x.material.color.setHex(65535);break;case"vertical":x.rotation.set(0,0,0),d.hingeEnabled=!0,x.material.color.setHex(16776960);break;default:d.hingeEnabled=!1;break}if(l===0?x.position.set(0,0,0):x.position.set(t.children[l-1].value(Ji),0,0),d.moveHandler||(d.moveHandler=new Wa(new Je().setFromPoints([new P]),new Yr({map:Yx,sizeAttenuation:!1,depthTest:!1,depthWrite:!1,transparent:!0,size:24})),d.moveHandler.renderOrder=2,f.value.add(d.moveHandler),d.moveHandler.visible=!1),d.rotateHandler||(d.rotateHandler=new Wa(new Je().setFromPoints([new P]),new Yr({map:Zx,sizeAttenuation:!1,depthTest:!1,depthWrite:!1,transparent:!0,size:24})),d.rotateHandler.renderOrder=2,f.value.add(d.rotateHandler),d.rotateHandler.visible=!1),d.dirty=!1,d.quaternion.setFromEuler(h.value(Sn)),l>0){const A=t.children[l-1].get(At);d.start.copy(A.end),d.quaternion.multiplyQuaternions(A.quaternion,d.quaternion).normalize()}else d.start.set(0,0,0);d.end.set(h.value(Ji),0,0).applyQuaternion(d.quaternion).add(d.start),d.rotateHandler.position.set(g,0,0)}}}u(hA,"IkChainUpdateFilter");dge(hA,"IkChainUpdateFilter");var pge=Object.defineProperty,mge=u((n,e)=>pge(n,"name",{value:e,configurable:!0}),"__name$1e");class fA extends Je{constructor(e=1,t=1,i=1,s=1){super(),this.type="DoubleSidedPlaneGeometry";const r=e/2,o=t/2,a=Math.floor(i),l=Math.floor(s),c=a+1,h=l+1,f=e/a,d=t/l,p=[],g=[],m=[],v=[];for(let b=0;b<2;++b)for(let x=0;x<h;x++){const w=x*d-o;for(let _=0;_<c;_++){const A=_*f-r;g.push(A,-w,0),m.push(0,0,b===0?1:-1),v.push(_/a),v.push(1-x/l)}}const y=c*h;for(let b=0;b<l;b++)for(let x=0;x<a;x++){const w=x+c*b,_=x+c*(b+1),A=x+1+c*(b+1),S=x+1+c*b;p.push(w,_,S),p.push(_,A,S),p.push(w+y,S+y,A+y),p.push(w+y,A+y,_+y)}this.setIndex(p),this.setAttribute("position",new Ve(g,3)),this.setAttribute("normal",new Ve(m,3)),this.setAttribute("uv",new Ve(v,2))}}u(fA,"DoubleSidedPlaneGeometry");mge(fA,"DoubleSidedPlaneGeometry");var gge=Object.defineProperty,vge=u((n,e)=>gge(n,"name",{value:e,configurable:!0}),"__name$1d");class dA{update(e,t){if(t.instanceId||!t.has(io))return;const i=t.get(io);if(!i.dirty||(i.dirty=!1,!i.value))return;const s=new Image;s.onload=function(){if(t.deleted||s.src!==i.value)return;i.texture&&i.texture.dispose();const r=i.texture=new ui;if(i.texture.image=s,i.texture.needsUpdate=!0,t.type!=="Image")return;const o=t.get(Me);o.dispose();const a=1,l=s.height/s.width*a;o.value=new We(new fA(a,l),new G_({map:r})),o.value.userData={node:t},e.model.dirty=!0,t.dirty=!0,o.parentChanged=!0,o.localTransformChanged=!0,e.model.instanceMeshUpdated(t.id,!0)},s.src=i.value}}u(dA,"ImageUpdateFilter");vge(dA,"ImageUpdateFilter");var K4={exports:{}};/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/(function(n,e){(function(t){n.exports=t()})(function(){return u(function t(i,s,r){function o(c,h){if(!s[c]){if(!i[c]){var f=typeof eg=="function"&&eg;if(!h&&f)return f(c,!0);if(a)return a(c,!0);var d=new Error("Cannot find module '"+c+"'");throw d.code="MODULE_NOT_FOUND",d}var p=s[c]={exports:{}};i[c][0].call(p.exports,function(g){var m=i[c][1][g];return o(m||g)},p,p.exports,t,i,s,r)}return s[c].exports}u(o,"u");for(var a=typeof eg=="function"&&eg,l=0;l<r.length;l++)o(r[l]);return o},"s")({1:[function(t,i,s){var r=t("./utils"),o=t("./support"),a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";s.encode=function(l){for(var c,h,f,d,p,g,m,v=[],y=0,b=l.length,x=b,w=r.getTypeOf(l)!=="string";y<l.length;)x=b-y,f=w?(c=l[y++],h=y<b?l[y++]:0,y<b?l[y++]:0):(c=l.charCodeAt(y++),h=y<b?l.charCodeAt(y++):0,y<b?l.charCodeAt(y++):0),d=c>>2,p=(3&c)<<4|h>>4,g=1<x?(15&h)<<2|f>>6:64,m=2<x?63&f:64,v.push(a.charAt(d)+a.charAt(p)+a.charAt(g)+a.charAt(m));return v.join("")},s.decode=function(l){var c,h,f,d,p,g,m=0,v=0,y="data:";if(l.substr(0,y.length)===y)throw new Error("Invalid base64 input, it looks like a data url.");var b,x=3*(l=l.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(l.charAt(l.length-1)===a.charAt(64)&&x--,l.charAt(l.length-2)===a.charAt(64)&&x--,x%1!=0)throw new Error("Invalid base64 input, bad content length.");for(b=o.uint8array?new Uint8Array(0|x):new Array(0|x);m<l.length;)c=a.indexOf(l.charAt(m++))<<2|(d=a.indexOf(l.charAt(m++)))>>4,h=(15&d)<<4|(p=a.indexOf(l.charAt(m++)))>>2,f=(3&p)<<6|(g=a.indexOf(l.charAt(m++))),b[v++]=c,p!==64&&(b[v++]=h),g!==64&&(b[v++]=f);return b}},{"./support":30,"./utils":32}],2:[function(t,i,s){var r=t("./external"),o=t("./stream/DataWorker"),a=t("./stream/Crc32Probe"),l=t("./stream/DataLengthProbe");function c(h,f,d,p,g){this.compressedSize=h,this.uncompressedSize=f,this.crc32=d,this.compression=p,this.compressedContent=g}u(c,"o"),c.prototype={getContentWorker:function(){var h=new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")),f=this;return h.on("end",function(){if(this.streamInfo.data_length!==f.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),h},getCompressedWorker:function(){return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},c.createWorkerFrom=function(h,f,d){return h.pipe(new a).pipe(new l("uncompressedSize")).pipe(f.compressWorker(d)).pipe(new l("compressedSize")).withStreamInfo("compression",f)},i.exports=c},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,i,s){var r=t("./stream/GenericWorker");s.STORE={magic:"\0\0",compressWorker:function(){return new r("STORE compression")},uncompressWorker:function(){return new r("STORE decompression")}},s.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,i,s){var r=t("./utils"),o=function(){for(var a,l=[],c=0;c<256;c++){a=c;for(var h=0;h<8;h++)a=1&a?3988292384^a>>>1:a>>>1;l[c]=a}return l}();i.exports=function(a,l){return a!==void 0&&a.length?r.getTypeOf(a)!=="string"?function(c,h,f,d){var p=o,g=d+f;c^=-1;for(var m=d;m<g;m++)c=c>>>8^p[255&(c^h[m])];return-1^c}(0|l,a,a.length,0):function(c,h,f,d){var p=o,g=d+f;c^=-1;for(var m=d;m<g;m++)c=c>>>8^p[255&(c^h.charCodeAt(m))];return-1^c}(0|l,a,a.length,0):0}},{"./utils":32}],5:[function(t,i,s){s.base64=!1,s.binary=!1,s.dir=!1,s.createFolders=!0,s.date=null,s.compression=null,s.compressionOptions=null,s.comment=null,s.unixPermissions=null,s.dosPermissions=null},{}],6:[function(t,i,s){var r=null;r=typeof Promise!="undefined"?Promise:t("lie"),i.exports={Promise:r}},{lie:37}],7:[function(t,i,s){var r=typeof Uint8Array!="undefined"&&typeof Uint16Array!="undefined"&&typeof Uint32Array!="undefined",o=t("pako"),a=t("./utils"),l=t("./stream/GenericWorker"),c=r?"uint8array":"array";function h(f,d){l.call(this,"FlateWorker/"+f),this._pako=null,this._pakoAction=f,this._pakoOptions=d,this.meta={}}u(h,"h"),s.magic="\b\0",a.inherits(h,l),h.prototype.processChunk=function(f){this.meta=f.meta,this._pako===null&&this._createPako(),this._pako.push(a.transformTo(c,f.data),!1)},h.prototype.flush=function(){l.prototype.flush.call(this),this._pako===null&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){l.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new o[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var f=this;this._pako.onData=function(d){f.push({data:d,meta:f.meta})}},s.compressWorker=function(f){return new h("Deflate",f)},s.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,i,s){function r(p,g){var m,v="";for(m=0;m<g;m++)v+=String.fromCharCode(255&p),p>>>=8;return v}u(r,"A");function o(p,g,m,v,y,b){var x,w,_=p.file,A=p.compression,S=b!==c.utf8encode,M=a.transformTo("string",b(_.name)),C=a.transformTo("string",c.utf8encode(_.name)),I=_.comment,F=a.transformTo("string",b(I)),O=a.transformTo("string",c.utf8encode(I)),N=C.length!==_.name.length,E=O.length!==I.length,k="",G="",X="",te=_.dir,j=_.date,ie={crc32:0,compressedSize:0,uncompressedSize:0};g&&!m||(ie.crc32=p.crc32,ie.compressedSize=p.compressedSize,ie.uncompressedSize=p.uncompressedSize);var K=0;g&&(K|=8),S||!N&&!E||(K|=2048);var $=0,le=0;te&&($|=16),y==="UNIX"?(le=798,$|=function(J,ne){var ve=J;return J||(ve=ne?16893:33204),(65535&ve)<<16}(_.unixPermissions,te)):(le=20,$|=function(J){return 63&(J||0)}(_.dosPermissions)),x=j.getUTCHours(),x<<=6,x|=j.getUTCMinutes(),x<<=5,x|=j.getUTCSeconds()/2,w=j.getUTCFullYear()-1980,w<<=4,w|=j.getUTCMonth()+1,w<<=5,w|=j.getUTCDate(),N&&(G=r(1,1)+r(h(M),4)+C,k+="up"+r(G.length,2)+G),E&&(X=r(1,1)+r(h(F),4)+O,k+="uc"+r(X.length,2)+X);var ae="";return ae+=`
\0`,ae+=r(K,2),ae+=A.magic,ae+=r(x,2),ae+=r(w,2),ae+=r(ie.crc32,4),ae+=r(ie.compressedSize,4),ae+=r(ie.uncompressedSize,4),ae+=r(M.length,2),ae+=r(k.length,2),{fileRecord:f.LOCAL_FILE_HEADER+ae+M+k,dirRecord:f.CENTRAL_FILE_HEADER+r(le,2)+ae+r(F.length,2)+"\0\0\0\0"+r($,4)+r(v,4)+M+k+F}}u(o,"n");var a=t("../utils"),l=t("../stream/GenericWorker"),c=t("../utf8"),h=t("../crc32"),f=t("../signature");function d(p,g,m,v){l.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=g,this.zipPlatform=m,this.encodeFileName=v,this.streamFiles=p,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}u(d,"s"),a.inherits(d,l),d.prototype.push=function(p){var g=p.meta.percent||0,m=this.entriesCount,v=this._sources.length;this.accumulate?this.contentBuffer.push(p):(this.bytesWritten+=p.data.length,l.prototype.push.call(this,{data:p.data,meta:{currentFile:this.currentFile,percent:m?(g+100*(m-v-1))/m:100}}))},d.prototype.openedSource=function(p){this.currentSourceOffset=this.bytesWritten,this.currentFile=p.file.name;var g=this.streamFiles&&!p.file.dir;if(g){var m=o(p,g,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:m.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(p){this.accumulate=!1;var g=this.streamFiles&&!p.file.dir,m=o(p,g,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(m.dirRecord),g)this.push({data:function(v){return f.DATA_DESCRIPTOR+r(v.crc32,4)+r(v.compressedSize,4)+r(v.uncompressedSize,4)}(p),meta:{percent:100}});else for(this.push({data:m.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var p=this.bytesWritten,g=0;g<this.dirRecords.length;g++)this.push({data:this.dirRecords[g],meta:{percent:100}});var m=this.bytesWritten-p,v=function(y,b,x,w,_){var A=a.transformTo("string",_(w));return f.CENTRAL_DIRECTORY_END+"\0\0\0\0"+r(y,2)+r(y,2)+r(b,4)+r(x,4)+r(A.length,2)+A}(this.dirRecords.length,m,p,this.zipComment,this.encodeFileName);this.push({data:v,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(p){this._sources.push(p);var g=this;return p.on("data",function(m){g.processChunk(m)}),p.on("end",function(){g.closedSource(g.previous.streamInfo),g._sources.length?g.prepareNextSource():g.end()}),p.on("error",function(m){g.error(m)}),this},d.prototype.resume=function(){return!!l.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(p){var g=this._sources;if(!l.prototype.error.call(this,p))return!1;for(var m=0;m<g.length;m++)try{g[m].error(p)}catch{}return!0},d.prototype.lock=function(){l.prototype.lock.call(this);for(var p=this._sources,g=0;g<p.length;g++)p[g].lock()},i.exports=d},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,i,s){var r=t("../compressions"),o=t("./ZipFileWorker");s.generateWorker=function(a,l,c){var h=new o(l.streamFiles,c,l.platform,l.encodeFileName),f=0;try{a.forEach(function(d,p){f++;var g=function(b,x){var w=b||x,_=r[w];if(!_)throw new Error(w+" is not a valid compression method !");return _}(p.options.compression,l.compression),m=p.options.compressionOptions||l.compressionOptions||{},v=p.dir,y=p.date;p._compressWorker(g,m).withStreamInfo("file",{name:d,dir:v,date:y,comment:p.comment||"",unixPermissions:p.unixPermissions,dosPermissions:p.dosPermissions}).pipe(h)}),h.entriesCount=f}catch(d){h.error(d)}return h}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,i,s){function r(){if(!(this instanceof r))return new r;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var o=new r;for(var a in this)typeof this[a]!="function"&&(o[a]=this[a]);return o}}u(r,"n"),(r.prototype=t("./object")).loadAsync=t("./load"),r.support=t("./support"),r.defaults=t("./defaults"),r.version="3.10.1",r.loadAsync=function(o,a){return new r().loadAsync(o,a)},r.external=t("./external"),i.exports=r},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,i,s){var r=t("./utils"),o=t("./external"),a=t("./utf8"),l=t("./zipEntries"),c=t("./stream/Crc32Probe"),h=t("./nodejsUtils");function f(d){return new o.Promise(function(p,g){var m=d.decompressed.getContentWorker().pipe(new c);m.on("error",function(v){g(v)}).on("end",function(){m.streamInfo.crc32!==d.decompressed.crc32?g(new Error("Corrupted zip : CRC32 mismatch")):p()}).resume()})}u(f,"f"),i.exports=function(d,p){var g=this;return p=r.extend(p||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:a.utf8decode}),h.isNode&&h.isStream(d)?o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):r.prepareContent("the loaded zip file",d,!0,p.optimizedBinaryString,p.base64).then(function(m){var v=new l(p);return v.load(m),v}).then(function(m){var v=[o.Promise.resolve(m)],y=m.files;if(p.checkCRC32)for(var b=0;b<y.length;b++)v.push(f(y[b]));return o.Promise.all(v)}).then(function(m){for(var v=m.shift(),y=v.files,b=0;b<y.length;b++){var x=y[b],w=x.fileNameStr,_=r.resolve(x.fileNameStr);g.file(_,x.decompressed,{binary:!0,optimizedBinaryString:!0,date:x.date,dir:x.dir,comment:x.fileCommentStr.length?x.fileCommentStr:null,unixPermissions:x.unixPermissions,dosPermissions:x.dosPermissions,createFolders:p.createFolders}),x.dir||(g.file(_).unsafeOriginalName=w)}return v.zipComment.length&&(g.comment=v.zipComment),g})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,i,s){var r=t("../utils"),o=t("../stream/GenericWorker");function a(l,c){o.call(this,"Nodejs stream input adapter for "+l),this._upstreamEnded=!1,this._bindStream(c)}u(a,"s"),r.inherits(a,o),a.prototype._bindStream=function(l){var c=this;(this._stream=l).pause(),l.on("data",function(h){c.push({data:h,meta:{percent:0}})}).on("error",function(h){c.isPaused?this.generatedError=h:c.error(h)}).on("end",function(){c.isPaused?c._upstreamEnded=!0:c.end()})},a.prototype.pause=function(){return!!o.prototype.pause.call(this)&&(this._stream.pause(),!0)},a.prototype.resume=function(){return!!o.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},i.exports=a},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,i,s){var r=t("readable-stream").Readable;function o(a,l,c){r.call(this,l),this._helper=a;var h=this;a.on("data",function(f,d){h.push(f)||h._helper.pause(),c&&c(d)}).on("error",function(f){h.emit("error",f)}).on("end",function(){h.push(null)})}u(o,"n"),t("../utils").inherits(o,r),o.prototype._read=function(){this._helper.resume()},i.exports=o},{"../utils":32,"readable-stream":16}],14:[function(t,i,s){i.exports={isNode:typeof Buffer!="undefined",newBufferFrom:function(r,o){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(r,o);if(typeof r=="number")throw new Error('The "data" argument must not be a number');return new Buffer(r,o)},allocBuffer:function(r){if(Buffer.alloc)return Buffer.alloc(r);var o=new Buffer(r);return o.fill(0),o},isBuffer:function(r){return Buffer.isBuffer(r)},isStream:function(r){return r&&typeof r.on=="function"&&typeof r.pause=="function"&&typeof r.resume=="function"}}},{}],15:[function(t,i,s){function r(_,A,S){var M,C=a.getTypeOf(A),I=a.extend(S||{},h);I.date=I.date||new Date,I.compression!==null&&(I.compression=I.compression.toUpperCase()),typeof I.unixPermissions=="string"&&(I.unixPermissions=parseInt(I.unixPermissions,8)),I.unixPermissions&&16384&I.unixPermissions&&(I.dir=!0),I.dosPermissions&&16&I.dosPermissions&&(I.dir=!0),I.dir&&(_=y(_)),I.createFolders&&(M=v(_))&&b.call(this,M,!0);var F=C==="string"&&I.binary===!1&&I.base64===!1;S&&S.binary!==void 0||(I.binary=!F),(A instanceof f&&A.uncompressedSize===0||I.dir||!A||A.length===0)&&(I.base64=!1,I.binary=!0,A="",I.compression="STORE",C="string");var O=null;O=A instanceof f||A instanceof l?A:g.isNode&&g.isStream(A)?new m(_,A):a.prepareContent(_,A,I.binary,I.optimizedBinaryString,I.base64);var N=new d(_,O,I);this.files[_]=N}u(r,"s");var o=t("./utf8"),a=t("./utils"),l=t("./stream/GenericWorker"),c=t("./stream/StreamHelper"),h=t("./defaults"),f=t("./compressedObject"),d=t("./zipObject"),p=t("./generate"),g=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),v=u(function(_){_.slice(-1)==="/"&&(_=_.substring(0,_.length-1));var A=_.lastIndexOf("/");return 0<A?_.substring(0,A):""},"_"),y=u(function(_){return _.slice(-1)!=="/"&&(_+="/"),_},"g"),b=u(function(_,A){return A=A!==void 0?A:h.createFolders,_=y(_),this.files[_]||r.call(this,_,null,{dir:!0,createFolders:A}),this.files[_]},"b");function x(_){return Object.prototype.toString.call(_)==="[object RegExp]"}u(x,"h");var w={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(_){var A,S,M;for(A in this.files)M=this.files[A],(S=A.slice(this.root.length,A.length))&&A.slice(0,this.root.length)===this.root&&_(S,M)},filter:function(_){var A=[];return this.forEach(function(S,M){_(S,M)&&A.push(M)}),A},file:function(_,A,S){if(arguments.length!==1)return _=this.root+_,r.call(this,_,A,S),this;if(x(_)){var M=_;return this.filter(function(I,F){return!F.dir&&M.test(I)})}var C=this.files[this.root+_];return C&&!C.dir?C:null},folder:function(_){if(!_)return this;if(x(_))return this.filter(function(C,I){return I.dir&&_.test(C)});var A=this.root+_,S=b.call(this,A),M=this.clone();return M.root=S.name,M},remove:function(_){_=this.root+_;var A=this.files[_];if(A||(_.slice(-1)!=="/"&&(_+="/"),A=this.files[_]),A&&!A.dir)delete this.files[_];else for(var S=this.filter(function(C,I){return I.name.slice(0,_.length)===_}),M=0;M<S.length;M++)delete this.files[S[M].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(_){var A,S={};try{if((S=a.extend(_||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:o.utf8encode})).type=S.type.toLowerCase(),S.compression=S.compression.toUpperCase(),S.type==="binarystring"&&(S.type="string"),!S.type)throw new Error("No output type specified.");a.checkSupport(S.type),S.platform!=="darwin"&&S.platform!=="freebsd"&&S.platform!=="linux"&&S.platform!=="sunos"||(S.platform="UNIX"),S.platform==="win32"&&(S.platform="DOS");var M=S.comment||this.comment||"";A=p.generateWorker(this,S,M)}catch(C){(A=new l("error")).error(C)}return new c(A,S.type||"string",S.mimeType)},generateAsync:function(_,A){return this.generateInternalStream(_).accumulate(A)},generateNodeStream:function(_,A){return(_=_||{}).type||(_.type="nodebuffer"),this.generateInternalStream(_).toNodejsStream(A)}};i.exports=w},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,i,s){i.exports=t("stream")},{stream:void 0}],17:[function(t,i,s){var r=t("./DataReader");function o(a){r.call(this,a);for(var l=0;l<this.data.length;l++)a[l]=255&a[l]}u(o,"i"),t("../utils").inherits(o,r),o.prototype.byteAt=function(a){return this.data[this.zero+a]},o.prototype.lastIndexOfSignature=function(a){for(var l=a.charCodeAt(0),c=a.charCodeAt(1),h=a.charCodeAt(2),f=a.charCodeAt(3),d=this.length-4;0<=d;--d)if(this.data[d]===l&&this.data[d+1]===c&&this.data[d+2]===h&&this.data[d+3]===f)return d-this.zero;return-1},o.prototype.readAndCheckSignature=function(a){var l=a.charCodeAt(0),c=a.charCodeAt(1),h=a.charCodeAt(2),f=a.charCodeAt(3),d=this.readData(4);return l===d[0]&&c===d[1]&&h===d[2]&&f===d[3]},o.prototype.readData=function(a){if(this.checkOffset(a),a===0)return[];var l=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,l},i.exports=o},{"../utils":32,"./DataReader":18}],18:[function(t,i,s){var r=t("../utils");function o(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}u(o,"i"),o.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var l,c=0;for(this.checkOffset(a),l=this.index+a-1;l>=this.index;l--)c=(c<<8)+this.byteAt(l);return this.index+=a,c},readString:function(a){return r.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC(1980+(a>>25&127),(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},i.exports=o},{"../utils":32}],19:[function(t,i,s){var r=t("./Uint8ArrayReader");function o(a){r.call(this,a)}u(o,"i"),t("../utils").inherits(o,r),o.prototype.readData=function(a){this.checkOffset(a);var l=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,l},i.exports=o},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,i,s){var r=t("./DataReader");function o(a){r.call(this,a)}u(o,"i"),t("../utils").inherits(o,r),o.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},o.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},o.prototype.readAndCheckSignature=function(a){return a===this.readData(4)},o.prototype.readData=function(a){this.checkOffset(a);var l=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,l},i.exports=o},{"../utils":32,"./DataReader":18}],21:[function(t,i,s){var r=t("./ArrayReader");function o(a){r.call(this,a)}u(o,"i"),t("../utils").inherits(o,r),o.prototype.readData=function(a){if(this.checkOffset(a),a===0)return new Uint8Array(0);var l=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,l},i.exports=o},{"../utils":32,"./ArrayReader":17}],22:[function(t,i,s){var r=t("../utils"),o=t("../support"),a=t("./ArrayReader"),l=t("./StringReader"),c=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");i.exports=function(f){var d=r.getTypeOf(f);return r.checkSupport(d),d!=="string"||o.uint8array?d==="nodebuffer"?new c(f):o.uint8array?new h(r.transformTo("uint8array",f)):new a(r.transformTo("array",f)):new l(f)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,i,s){s.LOCAL_FILE_HEADER="PK",s.CENTRAL_FILE_HEADER="PK",s.CENTRAL_DIRECTORY_END="PK",s.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x07",s.ZIP64_CENTRAL_DIRECTORY_END="PK",s.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(t,i,s){var r=t("./GenericWorker"),o=t("../utils");function a(l){r.call(this,"ConvertWorker to "+l),this.destType=l}u(a,"s"),o.inherits(a,r),a.prototype.processChunk=function(l){this.push({data:o.transformTo(this.destType,l.data),meta:l.meta})},i.exports=a},{"../utils":32,"./GenericWorker":28}],25:[function(t,i,s){var r=t("./GenericWorker"),o=t("../crc32");function a(){r.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}u(a,"s"),t("../utils").inherits(a,r),a.prototype.processChunk=function(l){this.streamInfo.crc32=o(l.data,this.streamInfo.crc32||0),this.push(l)},i.exports=a},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,i,s){var r=t("../utils"),o=t("./GenericWorker");function a(l){o.call(this,"DataLengthProbe for "+l),this.propName=l,this.withStreamInfo(l,0)}u(a,"s"),r.inherits(a,o),a.prototype.processChunk=function(l){if(l){var c=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=c+l.data.length}o.prototype.processChunk.call(this,l)},i.exports=a},{"../utils":32,"./GenericWorker":28}],27:[function(t,i,s){var r=t("../utils"),o=t("./GenericWorker");function a(l){o.call(this,"DataWorker");var c=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,l.then(function(h){c.dataIsReady=!0,c.data=h,c.max=h&&h.length||0,c.type=r.getTypeOf(h),c.isPaused||c._tickAndRepeat()},function(h){c.error(h)})}u(a,"s"),r.inherits(a,o),a.prototype.cleanUp=function(){o.prototype.cleanUp.call(this),this.data=null},a.prototype.resume=function(){return!!o.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,r.delay(this._tickAndRepeat,[],this)),!0)},a.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(r.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},a.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var l=null,c=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":l=this.data.substring(this.index,c);break;case"uint8array":l=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":l=this.data.slice(this.index,c)}return this.index=c,this.push({data:l,meta:{percent:this.max?this.index/this.max*100:0}})},i.exports=a},{"../utils":32,"./GenericWorker":28}],28:[function(t,i,s){function r(o){this.name=o||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}u(r,"n"),r.prototype={push:function(o){this.emit("data",o)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(o){this.emit("error",o)}return!0},error:function(o){return!this.isFinished&&(this.isPaused?this.generatedError=o:(this.isFinished=!0,this.emit("error",o),this.previous&&this.previous.error(o),this.cleanUp()),!0)},on:function(o,a){return this._listeners[o].push(a),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(o,a){if(this._listeners[o])for(var l=0;l<this._listeners[o].length;l++)this._listeners[o][l].call(this,a)},pipe:function(o){return o.registerPrevious(this)},registerPrevious:function(o){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=o.streamInfo,this.mergeStreamInfo(),this.previous=o;var a=this;return o.on("data",function(l){a.processChunk(l)}),o.on("end",function(){a.end()}),o.on("error",function(l){a.error(l)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var o=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),o=!0),this.previous&&this.previous.resume(),!o},flush:function(){},processChunk:function(o){this.push(o)},withStreamInfo:function(o,a){return this.extraStreamInfo[o]=a,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var o in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,o)&&(this.streamInfo[o]=this.extraStreamInfo[o])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var o="Worker "+this.name;return this.previous?this.previous+" -> "+o:o}},i.exports=r},{}],29:[function(t,i,s){var r=t("../utils"),o=t("./ConvertWorker"),a=t("./GenericWorker"),l=t("../base64"),c=t("../support"),h=t("../external"),f=null;if(c.nodestream)try{f=t("../nodejs/NodejsStreamOutputAdapter")}catch{}function d(g,m){return new h.Promise(function(v,y){var b=[],x=g._internalType,w=g._outputType,_=g._mimeType;g.on("data",function(A,S){b.push(A),m&&m(S)}).on("error",function(A){b=[],y(A)}).on("end",function(){try{var A=function(S,M,C){switch(S){case"blob":return r.newBlob(r.transformTo("arraybuffer",M),C);case"base64":return l.encode(M);default:return r.transformTo(S,M)}}(w,function(S,M){var C,I=0,F=null,O=0;for(C=0;C<M.length;C++)O+=M[C].length;switch(S){case"string":return M.join("");case"array":return Array.prototype.concat.apply([],M);case"uint8array":for(F=new Uint8Array(O),C=0;C<M.length;C++)F.set(M[C],I),I+=M[C].length;return F;case"nodebuffer":return Buffer.concat(M);default:throw new Error("concat : unsupported type '"+S+"'")}}(x,b),_);v(A)}catch(S){y(S)}b=[]}).resume()})}u(d,"l");function p(g,m,v){var y=m;switch(m){case"blob":case"arraybuffer":y="uint8array";break;case"base64":y="string"}try{this._internalType=y,this._outputType=m,this._mimeType=v,r.checkSupport(y),this._worker=g.pipe(new o(y)),g.lock()}catch(b){this._worker=new a("error"),this._worker.error(b)}}u(p,"f"),p.prototype={accumulate:function(g){return d(this,g)},on:function(g,m){var v=this;return g==="data"?this._worker.on(g,function(y){m.call(v,y.data,y.meta)}):this._worker.on(g,function(){r.delay(m,arguments,v)}),this},resume:function(){return r.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(g){if(r.checkSupport("nodestream"),this._outputType!=="nodebuffer")throw new Error(this._outputType+" is not supported by this method");return new f(this,{objectMode:this._outputType!=="nodebuffer"},g)}},i.exports=p},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,i,s){if(s.base64=!0,s.array=!0,s.string=!0,s.arraybuffer=typeof ArrayBuffer!="undefined"&&typeof Uint8Array!="undefined",s.nodebuffer=typeof Buffer!="undefined",s.uint8array=typeof Uint8Array!="undefined",typeof ArrayBuffer=="undefined")s.blob=!1;else{var r=new ArrayBuffer(0);try{s.blob=new Blob([r],{type:"application/zip"}).size===0}catch{try{var o=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);o.append(r),s.blob=o.getBlob("application/zip").size===0}catch{s.blob=!1}}}try{s.nodestream=!!t("readable-stream").Readable}catch{s.nodestream=!1}},{"readable-stream":16}],31:[function(t,i,s){for(var r=t("./utils"),o=t("./support"),a=t("./nodejsUtils"),l=t("./stream/GenericWorker"),c=new Array(256),h=0;h<256;h++)c[h]=252<=h?6:248<=h?5:240<=h?4:224<=h?3:192<=h?2:1;c[254]=c[254]=1;function f(){l.call(this,"utf-8 decode"),this.leftOver=null}u(f,"a");function d(){l.call(this,"utf-8 encode")}u(d,"l"),s.utf8encode=function(p){return o.nodebuffer?a.newBufferFrom(p,"utf-8"):function(g){var m,v,y,b,x,w=g.length,_=0;for(b=0;b<w;b++)(64512&(v=g.charCodeAt(b)))==55296&&b+1<w&&(64512&(y=g.charCodeAt(b+1)))==56320&&(v=65536+(v-55296<<10)+(y-56320),b++),_+=v<128?1:v<2048?2:v<65536?3:4;for(m=o.uint8array?new Uint8Array(_):new Array(_),b=x=0;x<_;b++)(64512&(v=g.charCodeAt(b)))==55296&&b+1<w&&(64512&(y=g.charCodeAt(b+1)))==56320&&(v=65536+(v-55296<<10)+(y-56320),b++),v<128?m[x++]=v:(v<2048?m[x++]=192|v>>>6:(v<65536?m[x++]=224|v>>>12:(m[x++]=240|v>>>18,m[x++]=128|v>>>12&63),m[x++]=128|v>>>6&63),m[x++]=128|63&v);return m}(p)},s.utf8decode=function(p){return o.nodebuffer?r.transformTo("nodebuffer",p).toString("utf-8"):function(g){var m,v,y,b,x=g.length,w=new Array(2*x);for(m=v=0;m<x;)if((y=g[m++])<128)w[v++]=y;else if(4<(b=c[y]))w[v++]=65533,m+=b-1;else{for(y&=b===2?31:b===3?15:7;1<b&&m<x;)y=y<<6|63&g[m++],b--;1<b?w[v++]=65533:y<65536?w[v++]=y:(y-=65536,w[v++]=55296|y>>10&1023,w[v++]=56320|1023&y)}return w.length!==v&&(w.subarray?w=w.subarray(0,v):w.length=v),r.applyFromCharCode(w)}(p=r.transformTo(o.uint8array?"uint8array":"array",p))},r.inherits(f,l),f.prototype.processChunk=function(p){var g=r.transformTo(o.uint8array?"uint8array":"array",p.data);if(this.leftOver&&this.leftOver.length){if(o.uint8array){var m=g;(g=new Uint8Array(m.length+this.leftOver.length)).set(this.leftOver,0),g.set(m,this.leftOver.length)}else g=this.leftOver.concat(g);this.leftOver=null}var v=function(b,x){var w;for((x=x||b.length)>b.length&&(x=b.length),w=x-1;0<=w&&(192&b[w])==128;)w--;return w<0||w===0?x:w+c[b[w]]>x?w:x}(g),y=g;v!==g.length&&(o.uint8array?(y=g.subarray(0,v),this.leftOver=g.subarray(v,g.length)):(y=g.slice(0,v),this.leftOver=g.slice(v,g.length))),this.push({data:s.utf8decode(y),meta:p.meta})},f.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=f,r.inherits(d,l),d.prototype.processChunk=function(p){this.push({data:s.utf8encode(p.data),meta:p.meta})},s.Utf8EncodeWorker=d},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,i,s){var r=t("./support"),o=t("./base64"),a=t("./nodejsUtils"),l=t("./external");function c(m){return m}u(c,"n");function h(m,v){for(var y=0;y<m.length;++y)v[y]=255&m.charCodeAt(y);return v}u(h,"l"),t("setimmediate"),s.newBlob=function(m,v){s.checkSupport("blob");try{return new Blob([m],{type:v})}catch{try{var y=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return y.append(m),y.getBlob(v)}catch{throw new Error("Bug : can't construct the Blob.")}}};var f={stringifyByChunk:function(m,v,y){var b=[],x=0,w=m.length;if(w<=y)return String.fromCharCode.apply(null,m);for(;x<w;)v==="array"||v==="nodebuffer"?b.push(String.fromCharCode.apply(null,m.slice(x,Math.min(x+y,w)))):b.push(String.fromCharCode.apply(null,m.subarray(x,Math.min(x+y,w)))),x+=y;return b.join("")},stringifyByChar:function(m){for(var v="",y=0;y<m.length;y++)v+=String.fromCharCode(m[y]);return v},applyCanBeUsed:{uint8array:function(){try{return r.uint8array&&String.fromCharCode.apply(null,new Uint8Array(1)).length===1}catch{return!1}}(),nodebuffer:function(){try{return r.nodebuffer&&String.fromCharCode.apply(null,a.allocBuffer(1)).length===1}catch{return!1}}()}};function d(m){var v=65536,y=s.getTypeOf(m),b=!0;if(y==="uint8array"?b=f.applyCanBeUsed.uint8array:y==="nodebuffer"&&(b=f.applyCanBeUsed.nodebuffer),b)for(;1<v;)try{return f.stringifyByChunk(m,y,v)}catch{v=Math.floor(v/2)}return f.stringifyByChar(m)}u(d,"s");function p(m,v){for(var y=0;y<m.length;y++)v[y]=m[y];return v}u(p,"f"),s.applyFromCharCode=d;var g={};g.string={string:c,array:function(m){return h(m,new Array(m.length))},arraybuffer:function(m){return g.string.uint8array(m).buffer},uint8array:function(m){return h(m,new Uint8Array(m.length))},nodebuffer:function(m){return h(m,a.allocBuffer(m.length))}},g.array={string:d,array:c,arraybuffer:function(m){return new Uint8Array(m).buffer},uint8array:function(m){return new Uint8Array(m)},nodebuffer:function(m){return a.newBufferFrom(m)}},g.arraybuffer={string:function(m){return d(new Uint8Array(m))},array:function(m){return p(new Uint8Array(m),new Array(m.byteLength))},arraybuffer:c,uint8array:function(m){return new Uint8Array(m)},nodebuffer:function(m){return a.newBufferFrom(new Uint8Array(m))}},g.uint8array={string:d,array:function(m){return p(m,new Array(m.length))},arraybuffer:function(m){return m.buffer},uint8array:c,nodebuffer:function(m){return a.newBufferFrom(m)}},g.nodebuffer={string:d,array:function(m){return p(m,new Array(m.length))},arraybuffer:function(m){return g.nodebuffer.uint8array(m).buffer},uint8array:function(m){return p(m,new Uint8Array(m.length))},nodebuffer:c},s.transformTo=function(m,v){if(v=v||"",!m)return v;s.checkSupport(m);var y=s.getTypeOf(v);return g[y][m](v)},s.resolve=function(m){for(var v=m.split("/"),y=[],b=0;b<v.length;b++){var x=v[b];x==="."||x===""&&b!==0&&b!==v.length-1||(x===".."?y.pop():y.push(x))}return y.join("/")},s.getTypeOf=function(m){return typeof m=="string"?"string":Object.prototype.toString.call(m)==="[object Array]"?"array":r.nodebuffer&&a.isBuffer(m)?"nodebuffer":r.uint8array&&m instanceof Uint8Array?"uint8array":r.arraybuffer&&m instanceof ArrayBuffer?"arraybuffer":void 0},s.checkSupport=function(m){if(!r[m.toLowerCase()])throw new Error(m+" is not supported by this platform")},s.MAX_VALUE_16BITS=65535,s.MAX_VALUE_32BITS=-1,s.pretty=function(m){var v,y,b="";for(y=0;y<(m||"").length;y++)b+="\\x"+((v=m.charCodeAt(y))<16?"0":"")+v.toString(16).toUpperCase();return b},s.delay=function(m,v,y){setImmediate(function(){m.apply(y||null,v||[])})},s.inherits=function(m,v){function y(){}u(y,"r"),y.prototype=v.prototype,m.prototype=new y},s.extend=function(){var m,v,y={};for(m=0;m<arguments.length;m++)for(v in arguments[m])Object.prototype.hasOwnProperty.call(arguments[m],v)&&y[v]===void 0&&(y[v]=arguments[m][v]);return y},s.prepareContent=function(m,v,y,b,x){return l.Promise.resolve(v).then(function(w){return r.blob&&(w instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(w))!==-1)&&typeof FileReader!="undefined"?new l.Promise(function(_,A){var S=new FileReader;S.onload=function(M){_(M.target.result)},S.onerror=function(M){A(M.target.error)},S.readAsArrayBuffer(w)}):w}).then(function(w){var _=s.getTypeOf(w);return _?(_==="arraybuffer"?w=s.transformTo("uint8array",w):_==="string"&&(x?w=o.decode(w):y&&b!==!0&&(w=function(A){return h(A,r.uint8array?new Uint8Array(A.length):new Array(A.length))}(w))),w):l.Promise.reject(new Error("Can't read the data of '"+m+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(t,i,s){var r=t("./reader/readerFor"),o=t("./utils"),a=t("./signature"),l=t("./zipEntry"),c=t("./support");function h(f){this.files=[],this.loadOptions=f}u(h,"h"),h.prototype={checkSignature:function(f){if(!this.reader.readAndCheckSignature(f)){this.reader.index-=4;var d=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+o.pretty(d)+", expected "+o.pretty(f)+")")}},isSignature:function(f,d){var p=this.reader.index;this.reader.setIndex(f);var g=this.reader.readString(4)===d;return this.reader.setIndex(p),g},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var f=this.reader.readData(this.zipCommentLength),d=c.uint8array?"uint8array":"array",p=o.transformTo(d,f);this.zipComment=this.loadOptions.decodeFileName(p)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var f,d,p,g=this.zip64EndOfCentralSize-44;0<g;)f=this.reader.readInt(2),d=this.reader.readInt(4),p=this.reader.readData(d),this.zip64ExtensibleData[f]={id:f,length:d,value:p}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var f,d;for(f=0;f<this.files.length;f++)d=this.files[f],this.reader.setIndex(d.localHeaderOffset),this.checkSignature(a.LOCAL_FILE_HEADER),d.readLocalPart(this.reader),d.handleUTF8(),d.processAttributes()},readCentralDir:function(){var f;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER);)(f=new l({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(f);if(this.centralDirRecords!==this.files.length&&this.centralDirRecords!==0&&this.files.length===0)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var f=this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);if(f<0)throw this.isSignature(0,a.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(f);var d=f;if(this.checkSignature(a.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===o.MAX_VALUE_16BITS||this.diskWithCentralDirStart===o.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===o.MAX_VALUE_16BITS||this.centralDirRecords===o.MAX_VALUE_16BITS||this.centralDirSize===o.MAX_VALUE_32BITS||this.centralDirOffset===o.MAX_VALUE_32BITS){if(this.zip64=!0,(f=this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(f),this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,a.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var p=this.centralDirOffset+this.centralDirSize;this.zip64&&(p+=20,p+=12+this.zip64EndOfCentralSize);var g=d-p;if(0<g)this.isSignature(d,a.CENTRAL_FILE_HEADER)||(this.reader.zero=g);else if(g<0)throw new Error("Corrupted zip: missing "+Math.abs(g)+" bytes.")},prepareReader:function(f){this.reader=r(f)},load:function(f){this.prepareReader(f),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},i.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(t,i,s){var r=t("./reader/readerFor"),o=t("./utils"),a=t("./compressedObject"),l=t("./crc32"),c=t("./utf8"),h=t("./compressions"),f=t("./support");function d(p,g){this.options=p,this.loadOptions=g}u(d,"l"),d.prototype={isEncrypted:function(){return(1&this.bitFlag)==1},useUTF8:function(){return(2048&this.bitFlag)==2048},readLocalPart:function(p){var g,m;if(p.skip(22),this.fileNameLength=p.readInt(2),m=p.readInt(2),this.fileName=p.readData(this.fileNameLength),p.skip(m),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if((g=function(v){for(var y in h)if(Object.prototype.hasOwnProperty.call(h,y)&&h[y].magic===v)return h[y];return null}(this.compressionMethod))===null)throw new Error("Corrupted zip : compression "+o.pretty(this.compressionMethod)+" unknown (inner file : "+o.transformTo("string",this.fileName)+")");this.decompressed=new a(this.compressedSize,this.uncompressedSize,this.crc32,g,p.readData(this.compressedSize))},readCentralPart:function(p){this.versionMadeBy=p.readInt(2),p.skip(2),this.bitFlag=p.readInt(2),this.compressionMethod=p.readString(2),this.date=p.readDate(),this.crc32=p.readInt(4),this.compressedSize=p.readInt(4),this.uncompressedSize=p.readInt(4);var g=p.readInt(2);if(this.extraFieldsLength=p.readInt(2),this.fileCommentLength=p.readInt(2),this.diskNumberStart=p.readInt(2),this.internalFileAttributes=p.readInt(2),this.externalFileAttributes=p.readInt(4),this.localHeaderOffset=p.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");p.skip(g),this.readExtraFields(p),this.parseZIP64ExtraField(p),this.fileComment=p.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var p=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),p==0&&(this.dosPermissions=63&this.externalFileAttributes),p==3&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||this.fileNameStr.slice(-1)!=="/"||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var p=r(this.extraFields[1].value);this.uncompressedSize===o.MAX_VALUE_32BITS&&(this.uncompressedSize=p.readInt(8)),this.compressedSize===o.MAX_VALUE_32BITS&&(this.compressedSize=p.readInt(8)),this.localHeaderOffset===o.MAX_VALUE_32BITS&&(this.localHeaderOffset=p.readInt(8)),this.diskNumberStart===o.MAX_VALUE_32BITS&&(this.diskNumberStart=p.readInt(4))}},readExtraFields:function(p){var g,m,v,y=p.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});p.index+4<y;)g=p.readInt(2),m=p.readInt(2),v=p.readData(m),this.extraFields[g]={id:g,length:m,value:v};p.setIndex(y)},handleUTF8:function(){var p=f.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=c.utf8decode(this.fileName),this.fileCommentStr=c.utf8decode(this.fileComment);else{var g=this.findExtraFieldUnicodePath();if(g!==null)this.fileNameStr=g;else{var m=o.transformTo(p,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(m)}var v=this.findExtraFieldUnicodeComment();if(v!==null)this.fileCommentStr=v;else{var y=o.transformTo(p,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(y)}}},findExtraFieldUnicodePath:function(){var p=this.extraFields[28789];if(p){var g=r(p.value);return g.readInt(1)!==1||l(this.fileName)!==g.readInt(4)?null:c.utf8decode(g.readData(p.length-5))}return null},findExtraFieldUnicodeComment:function(){var p=this.extraFields[25461];if(p){var g=r(p.value);return g.readInt(1)!==1||l(this.fileComment)!==g.readInt(4)?null:c.utf8decode(g.readData(p.length-5))}return null}},i.exports=d},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,i,s){function r(g,m,v){this.name=g,this.dir=v.dir,this.date=v.date,this.comment=v.comment,this.unixPermissions=v.unixPermissions,this.dosPermissions=v.dosPermissions,this._data=m,this._dataBinary=v.binary,this.options={compression:v.compression,compressionOptions:v.compressionOptions}}u(r,"n");var o=t("./stream/StreamHelper"),a=t("./stream/DataWorker"),l=t("./utf8"),c=t("./compressedObject"),h=t("./stream/GenericWorker");r.prototype={internalStream:function(g){var m=null,v="string";try{if(!g)throw new Error("No output type specified.");var y=(v=g.toLowerCase())==="string"||v==="text";v!=="binarystring"&&v!=="text"||(v="string"),m=this._decompressWorker();var b=!this._dataBinary;b&&!y&&(m=m.pipe(new l.Utf8EncodeWorker)),!b&&y&&(m=m.pipe(new l.Utf8DecodeWorker))}catch(x){(m=new h("error")).error(x)}return new o(m,v,"")},async:function(g,m){return this.internalStream(g).accumulate(m)},nodeStream:function(g,m){return this.internalStream(g||"nodebuffer").toNodejsStream(m)},_compressWorker:function(g,m){if(this._data instanceof c&&this._data.compression.magic===g.magic)return this._data.getCompressedWorker();var v=this._decompressWorker();return this._dataBinary||(v=v.pipe(new l.Utf8EncodeWorker)),c.createWorkerFrom(v,g,m)},_decompressWorker:function(){return this._data instanceof c?this._data.getContentWorker():this._data instanceof h?this._data:new a(this._data)}};for(var f=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],d=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},p=0;p<f.length;p++)r.prototype[f[p]]=d;i.exports=r},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,i,s){(function(r){var o,a,l=r.MutationObserver||r.WebKitMutationObserver;if(l){var c=0,h=new l(g),f=r.document.createTextNode("");h.observe(f,{characterData:!0}),o=u(function(){f.data=c=++c%2},"r")}else if(r.setImmediate||r.MessageChannel===void 0)o="document"in r&&"onreadystatechange"in r.document.createElement("script")?function(){var m=r.document.createElement("script");m.onreadystatechange=function(){g(),m.onreadystatechange=null,m.parentNode.removeChild(m),m=null},r.document.documentElement.appendChild(m)}:function(){setTimeout(g,0)};else{var d=new r.MessageChannel;d.port1.onmessage=g,o=u(function(){d.port2.postMessage(0)},"r")}var p=[];function g(){var m,v;a=!0;for(var y=p.length;y;){for(v=p,p=[],m=-1;++m<y;)v[m]();y=p.length}a=!1}u(g,"u"),i.exports=function(m){p.push(m)!==1||a||o()}}).call(this,typeof Jm!="undefined"?Jm:typeof self!="undefined"?self:typeof window!="undefined"?window:{})},{}],37:[function(t,i,s){var r=t("immediate");function o(){}u(o,"u");var a={},l=["REJECTED"],c=["FULFILLED"],h=["PENDING"];function f(y){if(typeof y!="function")throw new TypeError("resolver must be a function");this.state=h,this.queue=[],this.outcome=void 0,y!==o&&m(this,y)}u(f,"o");function d(y,b,x){this.promise=y,typeof b=="function"&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),typeof x=="function"&&(this.onRejected=x,this.callRejected=this.otherCallRejected)}u(d,"h");function p(y,b,x){r(function(){var w;try{w=b(x)}catch(_){return a.reject(y,_)}w===y?a.reject(y,new TypeError("Cannot resolve promise with itself")):a.resolve(y,w)})}u(p,"f");function g(y){var b=y&&y.then;if(y&&(typeof y=="object"||typeof y=="function")&&typeof b=="function")return function(){b.apply(y,arguments)}}u(g,"c");function m(y,b){var x=!1;function w(S){x||(x=!0,a.reject(y,S))}u(w,"n");function _(S){x||(x=!0,a.resolve(y,S))}u(_,"i");var A=v(function(){b(_,w)});A.status==="error"&&w(A.value)}u(m,"d");function v(y,b){var x={};try{x.value=y(b),x.status="success"}catch(w){x.status="error",x.value=w}return x}u(v,"p"),(i.exports=f).prototype.finally=function(y){if(typeof y!="function")return this;var b=this.constructor;return this.then(function(x){return b.resolve(y()).then(function(){return x})},function(x){return b.resolve(y()).then(function(){throw x})})},f.prototype.catch=function(y){return this.then(null,y)},f.prototype.then=function(y,b){if(typeof y!="function"&&this.state===c||typeof b!="function"&&this.state===l)return this;var x=new this.constructor(o);return this.state!==h?p(x,this.state===c?y:b,this.outcome):this.queue.push(new d(x,y,b)),x},d.prototype.callFulfilled=function(y){a.resolve(this.promise,y)},d.prototype.otherCallFulfilled=function(y){p(this.promise,this.onFulfilled,y)},d.prototype.callRejected=function(y){a.reject(this.promise,y)},d.prototype.otherCallRejected=function(y){p(this.promise,this.onRejected,y)},a.resolve=function(y,b){var x=v(g,b);if(x.status==="error")return a.reject(y,x.value);var w=x.value;if(w)m(y,w);else{y.state=c,y.outcome=b;for(var _=-1,A=y.queue.length;++_<A;)y.queue[_].callFulfilled(b)}return y},a.reject=function(y,b){y.state=l,y.outcome=b;for(var x=-1,w=y.queue.length;++x<w;)y.queue[x].callRejected(b);return y},f.resolve=function(y){return y instanceof this?y:a.resolve(new this(o),y)},f.reject=function(y){var b=new this(o);return a.reject(b,y)},f.all=function(y){var b=this;if(Object.prototype.toString.call(y)!=="[object Array]")return this.reject(new TypeError("must be an array"));var x=y.length,w=!1;if(!x)return this.resolve([]);for(var _=new Array(x),A=0,S=-1,M=new this(o);++S<x;)C(y[S],S);return M;function C(I,F){b.resolve(I).then(function(O){_[F]=O,++A!==x||w||(w=!0,a.resolve(M,_))},function(O){w||(w=!0,a.reject(M,O))})}},f.race=function(y){var b=this;if(Object.prototype.toString.call(y)!=="[object Array]")return this.reject(new TypeError("must be an array"));var x=y.length,w=!1;if(!x)return this.resolve([]);for(var _=-1,A=new this(o);++_<x;)S=y[_],b.resolve(S).then(function(M){w||(w=!0,a.resolve(A,M))},function(M){w||(w=!0,a.reject(A,M))});var S;return A}},{immediate:36}],38:[function(t,i,s){var r={};(0,t("./lib/utils/common").assign)(r,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),i.exports=r},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,i,s){var r=t("./zlib/deflate"),o=t("./utils/common"),a=t("./utils/strings"),l=t("./zlib/messages"),c=t("./zlib/zstream"),h=Object.prototype.toString,f=0,d=-1,p=0,g=8;function m(y){if(!(this instanceof m))return new m(y);this.options=o.assign({level:d,method:g,chunkSize:16384,windowBits:15,memLevel:8,strategy:p,to:""},y||{});var b=this.options;b.raw&&0<b.windowBits?b.windowBits=-b.windowBits:b.gzip&&0<b.windowBits&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var x=r.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(x!==f)throw new Error(l[x]);if(b.header&&r.deflateSetHeader(this.strm,b.header),b.dictionary){var w;if(w=typeof b.dictionary=="string"?a.string2buf(b.dictionary):h.call(b.dictionary)==="[object ArrayBuffer]"?new Uint8Array(b.dictionary):b.dictionary,(x=r.deflateSetDictionary(this.strm,w))!==f)throw new Error(l[x]);this._dict_set=!0}}u(m,"p");function v(y,b){var x=new m(b);if(x.push(y,!0),x.err)throw x.msg||l[x.err];return x.result}u(v,"n"),m.prototype.push=function(y,b){var x,w,_=this.strm,A=this.options.chunkSize;if(this.ended)return!1;w=b===~~b?b:b===!0?4:0,typeof y=="string"?_.input=a.string2buf(y):h.call(y)==="[object ArrayBuffer]"?_.input=new Uint8Array(y):_.input=y,_.next_in=0,_.avail_in=_.input.length;do{if(_.avail_out===0&&(_.output=new o.Buf8(A),_.next_out=0,_.avail_out=A),(x=r.deflate(_,w))!==1&&x!==f)return this.onEnd(x),!(this.ended=!0);_.avail_out!==0&&(_.avail_in!==0||w!==4&&w!==2)||(this.options.to==="string"?this.onData(a.buf2binstring(o.shrinkBuf(_.output,_.next_out))):this.onData(o.shrinkBuf(_.output,_.next_out)))}while((0<_.avail_in||_.avail_out===0)&&x!==1);return w===4?(x=r.deflateEnd(this.strm),this.onEnd(x),this.ended=!0,x===f):w!==2||(this.onEnd(f),!(_.avail_out=0))},m.prototype.onData=function(y){this.chunks.push(y)},m.prototype.onEnd=function(y){y===f&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=y,this.msg=this.strm.msg},s.Deflate=m,s.deflate=v,s.deflateRaw=function(y,b){return(b=b||{}).raw=!0,v(y,b)},s.gzip=function(y,b){return(b=b||{}).gzip=!0,v(y,b)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,i,s){var r=t("./zlib/inflate"),o=t("./utils/common"),a=t("./utils/strings"),l=t("./zlib/constants"),c=t("./zlib/messages"),h=t("./zlib/zstream"),f=t("./zlib/gzheader"),d=Object.prototype.toString;function p(m){if(!(this instanceof p))return new p(m);this.options=o.assign({chunkSize:16384,windowBits:0,to:""},m||{});var v=this.options;v.raw&&0<=v.windowBits&&v.windowBits<16&&(v.windowBits=-v.windowBits,v.windowBits===0&&(v.windowBits=-15)),!(0<=v.windowBits&&v.windowBits<16)||m&&m.windowBits||(v.windowBits+=32),15<v.windowBits&&v.windowBits<48&&(15&v.windowBits)==0&&(v.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new h,this.strm.avail_out=0;var y=r.inflateInit2(this.strm,v.windowBits);if(y!==l.Z_OK)throw new Error(c[y]);this.header=new f,r.inflateGetHeader(this.strm,this.header)}u(p,"a");function g(m,v){var y=new p(v);if(y.push(m,!0),y.err)throw y.msg||c[y.err];return y.result}u(g,"o"),p.prototype.push=function(m,v){var y,b,x,w,_,A,S=this.strm,M=this.options.chunkSize,C=this.options.dictionary,I=!1;if(this.ended)return!1;b=v===~~v?v:v===!0?l.Z_FINISH:l.Z_NO_FLUSH,typeof m=="string"?S.input=a.binstring2buf(m):d.call(m)==="[object ArrayBuffer]"?S.input=new Uint8Array(m):S.input=m,S.next_in=0,S.avail_in=S.input.length;do{if(S.avail_out===0&&(S.output=new o.Buf8(M),S.next_out=0,S.avail_out=M),(y=r.inflate(S,l.Z_NO_FLUSH))===l.Z_NEED_DICT&&C&&(A=typeof C=="string"?a.string2buf(C):d.call(C)==="[object ArrayBuffer]"?new Uint8Array(C):C,y=r.inflateSetDictionary(this.strm,A)),y===l.Z_BUF_ERROR&&I===!0&&(y=l.Z_OK,I=!1),y!==l.Z_STREAM_END&&y!==l.Z_OK)return this.onEnd(y),!(this.ended=!0);S.next_out&&(S.avail_out!==0&&y!==l.Z_STREAM_END&&(S.avail_in!==0||b!==l.Z_FINISH&&b!==l.Z_SYNC_FLUSH)||(this.options.to==="string"?(x=a.utf8border(S.output,S.next_out),w=S.next_out-x,_=a.buf2string(S.output,x),S.next_out=w,S.avail_out=M-w,w&&o.arraySet(S.output,S.output,x,w,0),this.onData(_)):this.onData(o.shrinkBuf(S.output,S.next_out)))),S.avail_in===0&&S.avail_out===0&&(I=!0)}while((0<S.avail_in||S.avail_out===0)&&y!==l.Z_STREAM_END);return y===l.Z_STREAM_END&&(b=l.Z_FINISH),b===l.Z_FINISH?(y=r.inflateEnd(this.strm),this.onEnd(y),this.ended=!0,y===l.Z_OK):b!==l.Z_SYNC_FLUSH||(this.onEnd(l.Z_OK),!(S.avail_out=0))},p.prototype.onData=function(m){this.chunks.push(m)},p.prototype.onEnd=function(m){m===l.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=m,this.msg=this.strm.msg},s.Inflate=p,s.inflate=g,s.inflateRaw=function(m,v){return(v=v||{}).raw=!0,g(m,v)},s.ungzip=g},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,i,s){var r=typeof Uint8Array!="undefined"&&typeof Uint16Array!="undefined"&&typeof Int32Array!="undefined";s.assign=function(l){for(var c=Array.prototype.slice.call(arguments,1);c.length;){var h=c.shift();if(h){if(typeof h!="object")throw new TypeError(h+"must be non-object");for(var f in h)h.hasOwnProperty(f)&&(l[f]=h[f])}}return l},s.shrinkBuf=function(l,c){return l.length===c?l:l.subarray?l.subarray(0,c):(l.length=c,l)};var o={arraySet:function(l,c,h,f,d){if(c.subarray&&l.subarray)l.set(c.subarray(h,h+f),d);else for(var p=0;p<f;p++)l[d+p]=c[h+p]},flattenChunks:function(l){var c,h,f,d,p,g;for(c=f=0,h=l.length;c<h;c++)f+=l[c].length;for(g=new Uint8Array(f),c=d=0,h=l.length;c<h;c++)p=l[c],g.set(p,d),d+=p.length;return g}},a={arraySet:function(l,c,h,f,d){for(var p=0;p<f;p++)l[d+p]=c[h+p]},flattenChunks:function(l){return[].concat.apply([],l)}};s.setTyped=function(l){l?(s.Buf8=Uint8Array,s.Buf16=Uint16Array,s.Buf32=Int32Array,s.assign(s,o)):(s.Buf8=Array,s.Buf16=Array,s.Buf32=Array,s.assign(s,a))},s.setTyped(r)},{}],42:[function(t,i,s){var r=t("./common"),o=!0,a=!0;try{String.fromCharCode.apply(null,[0])}catch{o=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{a=!1}for(var l=new r.Buf8(256),c=0;c<256;c++)l[c]=252<=c?6:248<=c?5:240<=c?4:224<=c?3:192<=c?2:1;function h(f,d){if(d<65537&&(f.subarray&&a||!f.subarray&&o))return String.fromCharCode.apply(null,r.shrinkBuf(f,d));for(var p="",g=0;g<d;g++)p+=String.fromCharCode(f[g]);return p}u(h,"l"),l[254]=l[254]=1,s.string2buf=function(f){var d,p,g,m,v,y=f.length,b=0;for(m=0;m<y;m++)(64512&(p=f.charCodeAt(m)))==55296&&m+1<y&&(64512&(g=f.charCodeAt(m+1)))==56320&&(p=65536+(p-55296<<10)+(g-56320),m++),b+=p<128?1:p<2048?2:p<65536?3:4;for(d=new r.Buf8(b),m=v=0;v<b;m++)(64512&(p=f.charCodeAt(m)))==55296&&m+1<y&&(64512&(g=f.charCodeAt(m+1)))==56320&&(p=65536+(p-55296<<10)+(g-56320),m++),p<128?d[v++]=p:(p<2048?d[v++]=192|p>>>6:(p<65536?d[v++]=224|p>>>12:(d[v++]=240|p>>>18,d[v++]=128|p>>>12&63),d[v++]=128|p>>>6&63),d[v++]=128|63&p);return d},s.buf2binstring=function(f){return h(f,f.length)},s.binstring2buf=function(f){for(var d=new r.Buf8(f.length),p=0,g=d.length;p<g;p++)d[p]=f.charCodeAt(p);return d},s.buf2string=function(f,d){var p,g,m,v,y=d||f.length,b=new Array(2*y);for(p=g=0;p<y;)if((m=f[p++])<128)b[g++]=m;else if(4<(v=l[m]))b[g++]=65533,p+=v-1;else{for(m&=v===2?31:v===3?15:7;1<v&&p<y;)m=m<<6|63&f[p++],v--;1<v?b[g++]=65533:m<65536?b[g++]=m:(m-=65536,b[g++]=55296|m>>10&1023,b[g++]=56320|1023&m)}return h(b,g)},s.utf8border=function(f,d){var p;for((d=d||f.length)>f.length&&(d=f.length),p=d-1;0<=p&&(192&f[p])==128;)p--;return p<0||p===0?d:p+l[f[p]]>d?p:d}},{"./common":41}],43:[function(t,i,s){i.exports=function(r,o,a,l){for(var c=65535&r|0,h=r>>>16&65535|0,f=0;a!==0;){for(a-=f=2e3<a?2e3:a;h=h+(c=c+o[l++]|0)|0,--f;);c%=65521,h%=65521}return c|h<<16|0}},{}],44:[function(t,i,s){i.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,i,s){var r=function(){for(var o,a=[],l=0;l<256;l++){o=l;for(var c=0;c<8;c++)o=1&o?3988292384^o>>>1:o>>>1;a[l]=o}return a}();i.exports=function(o,a,l,c){var h=r,f=c+l;o^=-1;for(var d=c;d<f;d++)o=o>>>8^h[255&(o^a[d])];return-1^o}},{}],46:[function(t,i,s){var r,o=t("../utils/common"),a=t("./trees"),l=t("./adler32"),c=t("./crc32"),h=t("./messages"),f=0,d=4,p=0,g=-2,m=-1,v=4,y=2,b=8,x=9,w=286,_=30,A=19,S=2*w+1,M=15,C=3,I=258,F=I+C+1,O=42,N=113,E=1,k=2,G=3,X=4;function te(R,ee){return R.msg=h[ee],ee}u(te,"R");function j(R){return(R<<1)-(4<R?9:0)}u(j,"T");function ie(R){for(var ee=R.length;0<=--ee;)R[ee]=0}u(ie,"D");function K(R){var ee=R.state,Q=ee.pending;Q>R.avail_out&&(Q=R.avail_out),Q!==0&&(o.arraySet(R.output,ee.pending_buf,ee.pending_out,Q,R.next_out),R.next_out+=Q,ee.pending_out+=Q,R.total_out+=Q,R.avail_out-=Q,ee.pending-=Q,ee.pending===0&&(ee.pending_out=0))}u(K,"F");function $(R,ee){a._tr_flush_block(R,0<=R.block_start?R.block_start:-1,R.strstart-R.block_start,ee),R.block_start=R.strstart,K(R.strm)}u($,"N");function le(R,ee){R.pending_buf[R.pending++]=ee}u(le,"U");function ae(R,ee){R.pending_buf[R.pending++]=ee>>>8&255,R.pending_buf[R.pending++]=255&ee}u(ae,"P");function J(R,ee){var Q,U,z=R.max_chain_length,W=R.strstart,re=R.prev_length,B=R.nice_match,D=R.strstart>R.w_size-F?R.strstart-(R.w_size-F):0,L=R.window,H=R.w_mask,q=R.prev,se=R.strstart+I,de=L[W+re-1],ge=L[W+re];R.prev_length>=R.good_match&&(z>>=2),B>R.lookahead&&(B=R.lookahead);do if(L[(Q=ee)+re]===ge&&L[Q+re-1]===de&&L[Q]===L[W]&&L[++Q]===L[W+1]){W+=2,Q++;do;while(L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&L[++W]===L[++Q]&&W<se);if(U=I-(se-W),W=se-I,re<U){if(R.match_start=ee,B<=(re=U))break;de=L[W+re-1],ge=L[W+re]}}while((ee=q[ee&H])>D&&--z!=0);return re<=R.lookahead?re:R.lookahead}u(J,"L");function ne(R){var ee,Q,U,z,W,re,B,D,L,H,q=R.w_size;do{if(z=R.window_size-R.lookahead-R.strstart,R.strstart>=q+(q-F)){for(o.arraySet(R.window,R.window,q,q,0),R.match_start-=q,R.strstart-=q,R.block_start-=q,ee=Q=R.hash_size;U=R.head[--ee],R.head[ee]=q<=U?U-q:0,--Q;);for(ee=Q=q;U=R.prev[--ee],R.prev[ee]=q<=U?U-q:0,--Q;);z+=q}if(R.strm.avail_in===0)break;if(re=R.strm,B=R.window,D=R.strstart+R.lookahead,L=z,H=void 0,H=re.avail_in,L<H&&(H=L),Q=H===0?0:(re.avail_in-=H,o.arraySet(B,re.input,re.next_in,H,D),re.state.wrap===1?re.adler=l(re.adler,B,H,D):re.state.wrap===2&&(re.adler=c(re.adler,B,H,D)),re.next_in+=H,re.total_in+=H,H),R.lookahead+=Q,R.lookahead+R.insert>=C)for(W=R.strstart-R.insert,R.ins_h=R.window[W],R.ins_h=(R.ins_h<<R.hash_shift^R.window[W+1])&R.hash_mask;R.insert&&(R.ins_h=(R.ins_h<<R.hash_shift^R.window[W+C-1])&R.hash_mask,R.prev[W&R.w_mask]=R.head[R.ins_h],R.head[R.ins_h]=W,W++,R.insert--,!(R.lookahead+R.insert<C)););}while(R.lookahead<F&&R.strm.avail_in!==0)}u(ne,"j");function ve(R,ee){for(var Q,U;;){if(R.lookahead<F){if(ne(R),R.lookahead<F&&ee===f)return E;if(R.lookahead===0)break}if(Q=0,R.lookahead>=C&&(R.ins_h=(R.ins_h<<R.hash_shift^R.window[R.strstart+C-1])&R.hash_mask,Q=R.prev[R.strstart&R.w_mask]=R.head[R.ins_h],R.head[R.ins_h]=R.strstart),Q!==0&&R.strstart-Q<=R.w_size-F&&(R.match_length=J(R,Q)),R.match_length>=C)if(U=a._tr_tally(R,R.strstart-R.match_start,R.match_length-C),R.lookahead-=R.match_length,R.match_length<=R.max_lazy_match&&R.lookahead>=C){for(R.match_length--;R.strstart++,R.ins_h=(R.ins_h<<R.hash_shift^R.window[R.strstart+C-1])&R.hash_mask,Q=R.prev[R.strstart&R.w_mask]=R.head[R.ins_h],R.head[R.ins_h]=R.strstart,--R.match_length!=0;);R.strstart++}else R.strstart+=R.match_length,R.match_length=0,R.ins_h=R.window[R.strstart],R.ins_h=(R.ins_h<<R.hash_shift^R.window[R.strstart+1])&R.hash_mask;else U=a._tr_tally(R,0,R.window[R.strstart]),R.lookahead--,R.strstart++;if(U&&($(R,!1),R.strm.avail_out===0))return E}return R.insert=R.strstart<C-1?R.strstart:C-1,ee===d?($(R,!0),R.strm.avail_out===0?G:X):R.last_lit&&($(R,!1),R.strm.avail_out===0)?E:k}u(ve,"Z");function he(R,ee){for(var Q,U,z;;){if(R.lookahead<F){if(ne(R),R.lookahead<F&&ee===f)return E;if(R.lookahead===0)break}if(Q=0,R.lookahead>=C&&(R.ins_h=(R.ins_h<<R.hash_shift^R.window[R.strstart+C-1])&R.hash_mask,Q=R.prev[R.strstart&R.w_mask]=R.head[R.ins_h],R.head[R.ins_h]=R.strstart),R.prev_length=R.match_length,R.prev_match=R.match_start,R.match_length=C-1,Q!==0&&R.prev_length<R.max_lazy_match&&R.strstart-Q<=R.w_size-F&&(R.match_length=J(R,Q),R.match_length<=5&&(R.strategy===1||R.match_length===C&&4096<R.strstart-R.match_start)&&(R.match_length=C-1)),R.prev_length>=C&&R.match_length<=R.prev_length){for(z=R.strstart+R.lookahead-C,U=a._tr_tally(R,R.strstart-1-R.prev_match,R.prev_length-C),R.lookahead-=R.prev_length-1,R.prev_length-=2;++R.strstart<=z&&(R.ins_h=(R.ins_h<<R.hash_shift^R.window[R.strstart+C-1])&R.hash_mask,Q=R.prev[R.strstart&R.w_mask]=R.head[R.ins_h],R.head[R.ins_h]=R.strstart),--R.prev_length!=0;);if(R.match_available=0,R.match_length=C-1,R.strstart++,U&&($(R,!1),R.strm.avail_out===0))return E}else if(R.match_available){if((U=a._tr_tally(R,0,R.window[R.strstart-1]))&&$(R,!1),R.strstart++,R.lookahead--,R.strm.avail_out===0)return E}else R.match_available=1,R.strstart++,R.lookahead--}return R.match_available&&(U=a._tr_tally(R,0,R.window[R.strstart-1]),R.match_available=0),R.insert=R.strstart<C-1?R.strstart:C-1,ee===d?($(R,!0),R.strm.avail_out===0?G:X):R.last_lit&&($(R,!1),R.strm.avail_out===0)?E:k}u(he,"W");function _e(R,ee,Q,U,z){this.good_length=R,this.max_lazy=ee,this.nice_length=Q,this.max_chain=U,this.func=z}u(_e,"M");function we(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=b,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new o.Buf16(2*S),this.dyn_dtree=new o.Buf16(2*(2*_+1)),this.bl_tree=new o.Buf16(2*(2*A+1)),ie(this.dyn_ltree),ie(this.dyn_dtree),ie(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new o.Buf16(M+1),this.heap=new o.Buf16(2*w+1),ie(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new o.Buf16(2*w+1),ie(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}u(we,"H");function Se(R){var ee;return R&&R.state?(R.total_in=R.total_out=0,R.data_type=y,(ee=R.state).pending=0,ee.pending_out=0,ee.wrap<0&&(ee.wrap=-ee.wrap),ee.status=ee.wrap?O:N,R.adler=ee.wrap===2?0:1,ee.last_flush=f,a._tr_init(ee),p):te(R,g)}u(Se,"G");function V(R){var ee=Se(R);return ee===p&&function(Q){Q.window_size=2*Q.w_size,ie(Q.head),Q.max_lazy_match=r[Q.level].max_lazy,Q.good_match=r[Q.level].good_length,Q.nice_match=r[Q.level].nice_length,Q.max_chain_length=r[Q.level].max_chain,Q.strstart=0,Q.block_start=0,Q.lookahead=0,Q.insert=0,Q.match_length=Q.prev_length=C-1,Q.match_available=0,Q.ins_h=0}(R.state),ee}u(V,"K");function Y(R,ee,Q,U,z,W){if(!R)return g;var re=1;if(ee===m&&(ee=6),U<0?(re=0,U=-U):15<U&&(re=2,U-=16),z<1||x<z||Q!==b||U<8||15<U||ee<0||9<ee||W<0||v<W)return te(R,g);U===8&&(U=9);var B=new we;return(R.state=B).strm=R,B.wrap=re,B.gzhead=null,B.w_bits=U,B.w_size=1<<B.w_bits,B.w_mask=B.w_size-1,B.hash_bits=z+7,B.hash_size=1<<B.hash_bits,B.hash_mask=B.hash_size-1,B.hash_shift=~~((B.hash_bits+C-1)/C),B.window=new o.Buf8(2*B.w_size),B.head=new o.Buf16(B.hash_size),B.prev=new o.Buf16(B.w_size),B.lit_bufsize=1<<z+6,B.pending_buf_size=4*B.lit_bufsize,B.pending_buf=new o.Buf8(B.pending_buf_size),B.d_buf=1*B.lit_bufsize,B.l_buf=3*B.lit_bufsize,B.level=ee,B.strategy=W,B.method=Q,V(R)}u(Y,"Y"),r=[new _e(0,0,0,0,function(R,ee){var Q=65535;for(Q>R.pending_buf_size-5&&(Q=R.pending_buf_size-5);;){if(R.lookahead<=1){if(ne(R),R.lookahead===0&&ee===f)return E;if(R.lookahead===0)break}R.strstart+=R.lookahead,R.lookahead=0;var U=R.block_start+Q;if((R.strstart===0||R.strstart>=U)&&(R.lookahead=R.strstart-U,R.strstart=U,$(R,!1),R.strm.avail_out===0)||R.strstart-R.block_start>=R.w_size-F&&($(R,!1),R.strm.avail_out===0))return E}return R.insert=0,ee===d?($(R,!0),R.strm.avail_out===0?G:X):(R.strstart>R.block_start&&($(R,!1),R.strm.avail_out),E)}),new _e(4,4,8,4,ve),new _e(4,5,16,8,ve),new _e(4,6,32,32,ve),new _e(4,4,16,16,he),new _e(8,16,32,32,he),new _e(8,16,128,128,he),new _e(8,32,128,256,he),new _e(32,128,258,1024,he),new _e(32,258,258,4096,he)],s.deflateInit=function(R,ee){return Y(R,ee,b,15,8,0)},s.deflateInit2=Y,s.deflateReset=V,s.deflateResetKeep=Se,s.deflateSetHeader=function(R,ee){return R&&R.state?R.state.wrap!==2?g:(R.state.gzhead=ee,p):g},s.deflate=function(R,ee){var Q,U,z,W;if(!R||!R.state||5<ee||ee<0)return R?te(R,g):g;if(U=R.state,!R.output||!R.input&&R.avail_in!==0||U.status===666&&ee!==d)return te(R,R.avail_out===0?-5:g);if(U.strm=R,Q=U.last_flush,U.last_flush=ee,U.status===O)if(U.wrap===2)R.adler=0,le(U,31),le(U,139),le(U,8),U.gzhead?(le(U,(U.gzhead.text?1:0)+(U.gzhead.hcrc?2:0)+(U.gzhead.extra?4:0)+(U.gzhead.name?8:0)+(U.gzhead.comment?16:0)),le(U,255&U.gzhead.time),le(U,U.gzhead.time>>8&255),le(U,U.gzhead.time>>16&255),le(U,U.gzhead.time>>24&255),le(U,U.level===9?2:2<=U.strategy||U.level<2?4:0),le(U,255&U.gzhead.os),U.gzhead.extra&&U.gzhead.extra.length&&(le(U,255&U.gzhead.extra.length),le(U,U.gzhead.extra.length>>8&255)),U.gzhead.hcrc&&(R.adler=c(R.adler,U.pending_buf,U.pending,0)),U.gzindex=0,U.status=69):(le(U,0),le(U,0),le(U,0),le(U,0),le(U,0),le(U,U.level===9?2:2<=U.strategy||U.level<2?4:0),le(U,3),U.status=N);else{var re=b+(U.w_bits-8<<4)<<8;re|=(2<=U.strategy||U.level<2?0:U.level<6?1:U.level===6?2:3)<<6,U.strstart!==0&&(re|=32),re+=31-re%31,U.status=N,ae(U,re),U.strstart!==0&&(ae(U,R.adler>>>16),ae(U,65535&R.adler)),R.adler=1}if(U.status===69)if(U.gzhead.extra){for(z=U.pending;U.gzindex<(65535&U.gzhead.extra.length)&&(U.pending!==U.pending_buf_size||(U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),K(R),z=U.pending,U.pending!==U.pending_buf_size));)le(U,255&U.gzhead.extra[U.gzindex]),U.gzindex++;U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),U.gzindex===U.gzhead.extra.length&&(U.gzindex=0,U.status=73)}else U.status=73;if(U.status===73)if(U.gzhead.name){z=U.pending;do{if(U.pending===U.pending_buf_size&&(U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),K(R),z=U.pending,U.pending===U.pending_buf_size)){W=1;break}W=U.gzindex<U.gzhead.name.length?255&U.gzhead.name.charCodeAt(U.gzindex++):0,le(U,W)}while(W!==0);U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),W===0&&(U.gzindex=0,U.status=91)}else U.status=91;if(U.status===91)if(U.gzhead.comment){z=U.pending;do{if(U.pending===U.pending_buf_size&&(U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),K(R),z=U.pending,U.pending===U.pending_buf_size)){W=1;break}W=U.gzindex<U.gzhead.comment.length?255&U.gzhead.comment.charCodeAt(U.gzindex++):0,le(U,W)}while(W!==0);U.gzhead.hcrc&&U.pending>z&&(R.adler=c(R.adler,U.pending_buf,U.pending-z,z)),W===0&&(U.status=103)}else U.status=103;if(U.status===103&&(U.gzhead.hcrc?(U.pending+2>U.pending_buf_size&&K(R),U.pending+2<=U.pending_buf_size&&(le(U,255&R.adler),le(U,R.adler>>8&255),R.adler=0,U.status=N)):U.status=N),U.pending!==0){if(K(R),R.avail_out===0)return U.last_flush=-1,p}else if(R.avail_in===0&&j(ee)<=j(Q)&&ee!==d)return te(R,-5);if(U.status===666&&R.avail_in!==0)return te(R,-5);if(R.avail_in!==0||U.lookahead!==0||ee!==f&&U.status!==666){var B=U.strategy===2?function(D,L){for(var H;;){if(D.lookahead===0&&(ne(D),D.lookahead===0)){if(L===f)return E;break}if(D.match_length=0,H=a._tr_tally(D,0,D.window[D.strstart]),D.lookahead--,D.strstart++,H&&($(D,!1),D.strm.avail_out===0))return E}return D.insert=0,L===d?($(D,!0),D.strm.avail_out===0?G:X):D.last_lit&&($(D,!1),D.strm.avail_out===0)?E:k}(U,ee):U.strategy===3?function(D,L){for(var H,q,se,de,ge=D.window;;){if(D.lookahead<=I){if(ne(D),D.lookahead<=I&&L===f)return E;if(D.lookahead===0)break}if(D.match_length=0,D.lookahead>=C&&0<D.strstart&&(q=ge[se=D.strstart-1])===ge[++se]&&q===ge[++se]&&q===ge[++se]){de=D.strstart+I;do;while(q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&q===ge[++se]&&se<de);D.match_length=I-(de-se),D.match_length>D.lookahead&&(D.match_length=D.lookahead)}if(D.match_length>=C?(H=a._tr_tally(D,1,D.match_length-C),D.lookahead-=D.match_length,D.strstart+=D.match_length,D.match_length=0):(H=a._tr_tally(D,0,D.window[D.strstart]),D.lookahead--,D.strstart++),H&&($(D,!1),D.strm.avail_out===0))return E}return D.insert=0,L===d?($(D,!0),D.strm.avail_out===0?G:X):D.last_lit&&($(D,!1),D.strm.avail_out===0)?E:k}(U,ee):r[U.level].func(U,ee);if(B!==G&&B!==X||(U.status=666),B===E||B===G)return R.avail_out===0&&(U.last_flush=-1),p;if(B===k&&(ee===1?a._tr_align(U):ee!==5&&(a._tr_stored_block(U,0,0,!1),ee===3&&(ie(U.head),U.lookahead===0&&(U.strstart=0,U.block_start=0,U.insert=0))),K(R),R.avail_out===0))return U.last_flush=-1,p}return ee!==d?p:U.wrap<=0?1:(U.wrap===2?(le(U,255&R.adler),le(U,R.adler>>8&255),le(U,R.adler>>16&255),le(U,R.adler>>24&255),le(U,255&R.total_in),le(U,R.total_in>>8&255),le(U,R.total_in>>16&255),le(U,R.total_in>>24&255)):(ae(U,R.adler>>>16),ae(U,65535&R.adler)),K(R),0<U.wrap&&(U.wrap=-U.wrap),U.pending!==0?p:1)},s.deflateEnd=function(R){var ee;return R&&R.state?(ee=R.state.status)!==O&&ee!==69&&ee!==73&&ee!==91&&ee!==103&&ee!==N&&ee!==666?te(R,g):(R.state=null,ee===N?te(R,-3):p):g},s.deflateSetDictionary=function(R,ee){var Q,U,z,W,re,B,D,L,H=ee.length;if(!R||!R.state||(W=(Q=R.state).wrap)===2||W===1&&Q.status!==O||Q.lookahead)return g;for(W===1&&(R.adler=l(R.adler,ee,H,0)),Q.wrap=0,H>=Q.w_size&&(W===0&&(ie(Q.head),Q.strstart=0,Q.block_start=0,Q.insert=0),L=new o.Buf8(Q.w_size),o.arraySet(L,ee,H-Q.w_size,Q.w_size,0),ee=L,H=Q.w_size),re=R.avail_in,B=R.next_in,D=R.input,R.avail_in=H,R.next_in=0,R.input=ee,ne(Q);Q.lookahead>=C;){for(U=Q.strstart,z=Q.lookahead-(C-1);Q.ins_h=(Q.ins_h<<Q.hash_shift^Q.window[U+C-1])&Q.hash_mask,Q.prev[U&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=U,U++,--z;);Q.strstart=U,Q.lookahead=C-1,ne(Q)}return Q.strstart+=Q.lookahead,Q.block_start=Q.strstart,Q.insert=Q.lookahead,Q.lookahead=0,Q.match_length=Q.prev_length=C-1,Q.match_available=0,R.next_in=B,R.input=D,R.avail_in=re,Q.wrap=W,p},s.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,i,s){i.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,i,s){i.exports=function(r,o){var a,l,c,h,f,d,p,g,m,v,y,b,x,w,_,A,S,M,C,I,F,O,N,E,k;a=r.state,l=r.next_in,E=r.input,c=l+(r.avail_in-5),h=r.next_out,k=r.output,f=h-(o-r.avail_out),d=h+(r.avail_out-257),p=a.dmax,g=a.wsize,m=a.whave,v=a.wnext,y=a.window,b=a.hold,x=a.bits,w=a.lencode,_=a.distcode,A=(1<<a.lenbits)-1,S=(1<<a.distbits)-1;e:do{x<15&&(b+=E[l++]<<x,x+=8,b+=E[l++]<<x,x+=8),M=w[b&A];t:for(;;){if(b>>>=C=M>>>24,x-=C,(C=M>>>16&255)===0)k[h++]=65535&M;else{if(!(16&C)){if((64&C)==0){M=w[(65535&M)+(b&(1<<C)-1)];continue t}if(32&C){a.mode=12;break e}r.msg="invalid literal/length code",a.mode=30;break e}I=65535&M,(C&=15)&&(x<C&&(b+=E[l++]<<x,x+=8),I+=b&(1<<C)-1,b>>>=C,x-=C),x<15&&(b+=E[l++]<<x,x+=8,b+=E[l++]<<x,x+=8),M=_[b&S];n:for(;;){if(b>>>=C=M>>>24,x-=C,!(16&(C=M>>>16&255))){if((64&C)==0){M=_[(65535&M)+(b&(1<<C)-1)];continue n}r.msg="invalid distance code",a.mode=30;break e}if(F=65535&M,x<(C&=15)&&(b+=E[l++]<<x,(x+=8)<C&&(b+=E[l++]<<x,x+=8)),p<(F+=b&(1<<C)-1)){r.msg="invalid distance too far back",a.mode=30;break e}if(b>>>=C,x-=C,(C=h-f)<F){if(m<(C=F-C)&&a.sane){r.msg="invalid distance too far back",a.mode=30;break e}if(N=y,(O=0)===v){if(O+=g-C,C<I){for(I-=C;k[h++]=y[O++],--C;);O=h-F,N=k}}else if(v<C){if(O+=g+v-C,(C-=v)<I){for(I-=C;k[h++]=y[O++],--C;);if(O=0,v<I){for(I-=C=v;k[h++]=y[O++],--C;);O=h-F,N=k}}}else if(O+=v-C,C<I){for(I-=C;k[h++]=y[O++],--C;);O=h-F,N=k}for(;2<I;)k[h++]=N[O++],k[h++]=N[O++],k[h++]=N[O++],I-=3;I&&(k[h++]=N[O++],1<I&&(k[h++]=N[O++]))}else{for(O=h-F;k[h++]=k[O++],k[h++]=k[O++],k[h++]=k[O++],2<(I-=3););I&&(k[h++]=k[O++],1<I&&(k[h++]=k[O++]))}break}}break}}while(l<c&&h<d);l-=I=x>>3,b&=(1<<(x-=I<<3))-1,r.next_in=l,r.next_out=h,r.avail_in=l<c?c-l+5:5-(l-c),r.avail_out=h<d?d-h+257:257-(h-d),a.hold=b,a.bits=x}},{}],49:[function(t,i,s){var r=t("../utils/common"),o=t("./adler32"),a=t("./crc32"),l=t("./inffast"),c=t("./inftrees"),h=1,f=2,d=0,p=-2,g=1,m=852,v=592;function y(O){return(O>>>24&255)+(O>>>8&65280)+((65280&O)<<8)+((255&O)<<24)}u(y,"L");function b(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}u(b,"s");function x(O){var N;return O&&O.state?(N=O.state,O.total_in=O.total_out=N.total=0,O.msg="",N.wrap&&(O.adler=1&N.wrap),N.mode=g,N.last=0,N.havedict=0,N.dmax=32768,N.head=null,N.hold=0,N.bits=0,N.lencode=N.lendyn=new r.Buf32(m),N.distcode=N.distdyn=new r.Buf32(v),N.sane=1,N.back=-1,d):p}u(x,"a");function w(O){var N;return O&&O.state?((N=O.state).wsize=0,N.whave=0,N.wnext=0,x(O)):p}u(w,"o");function _(O,N){var E,k;return O&&O.state?(k=O.state,N<0?(E=0,N=-N):(E=1+(N>>4),N<48&&(N&=15)),N&&(N<8||15<N)?p:(k.window!==null&&k.wbits!==N&&(k.window=null),k.wrap=E,k.wbits=N,w(O))):p}u(_,"h");function A(O,N){var E,k;return O?(k=new b,(O.state=k).window=null,(E=_(O,N))!==d&&(O.state=null),E):p}u(A,"u");var S,M,C=!0;function I(O){if(C){var N;for(S=new r.Buf32(512),M=new r.Buf32(32),N=0;N<144;)O.lens[N++]=8;for(;N<256;)O.lens[N++]=9;for(;N<280;)O.lens[N++]=7;for(;N<288;)O.lens[N++]=8;for(c(h,O.lens,0,288,S,0,O.work,{bits:9}),N=0;N<32;)O.lens[N++]=5;c(f,O.lens,0,32,M,0,O.work,{bits:5}),C=!1}O.lencode=S,O.lenbits=9,O.distcode=M,O.distbits=5}u(I,"j");function F(O,N,E,k){var G,X=O.state;return X.window===null&&(X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new r.Buf8(X.wsize)),k>=X.wsize?(r.arraySet(X.window,N,E-X.wsize,X.wsize,0),X.wnext=0,X.whave=X.wsize):(k<(G=X.wsize-X.wnext)&&(G=k),r.arraySet(X.window,N,E-k,G,X.wnext),(k-=G)?(r.arraySet(X.window,N,E-k,k,0),X.wnext=k,X.whave=X.wsize):(X.wnext+=G,X.wnext===X.wsize&&(X.wnext=0),X.whave<X.wsize&&(X.whave+=G))),0}u(F,"Z"),s.inflateReset=w,s.inflateReset2=_,s.inflateResetKeep=x,s.inflateInit=function(O){return A(O,15)},s.inflateInit2=A,s.inflate=function(O,N){var E,k,G,X,te,j,ie,K,$,le,ae,J,ne,ve,he,_e,we,Se,V,Y,R,ee,Q,U,z=0,W=new r.Buf8(4),re=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!O||!O.state||!O.output||!O.input&&O.avail_in!==0)return p;(E=O.state).mode===12&&(E.mode=13),te=O.next_out,G=O.output,ie=O.avail_out,X=O.next_in,k=O.input,j=O.avail_in,K=E.hold,$=E.bits,le=j,ae=ie,ee=d;e:for(;;)switch(E.mode){case g:if(E.wrap===0){E.mode=13;break}for(;$<16;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(2&E.wrap&&K===35615){W[E.check=0]=255&K,W[1]=K>>>8&255,E.check=a(E.check,W,2,0),$=K=0,E.mode=2;break}if(E.flags=0,E.head&&(E.head.done=!1),!(1&E.wrap)||(((255&K)<<8)+(K>>8))%31){O.msg="incorrect header check",E.mode=30;break}if((15&K)!=8){O.msg="unknown compression method",E.mode=30;break}if($-=4,R=8+(15&(K>>>=4)),E.wbits===0)E.wbits=R;else if(R>E.wbits){O.msg="invalid window size",E.mode=30;break}E.dmax=1<<R,O.adler=E.check=1,E.mode=512&K?10:12,$=K=0;break;case 2:for(;$<16;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(E.flags=K,(255&E.flags)!=8){O.msg="unknown compression method",E.mode=30;break}if(57344&E.flags){O.msg="unknown header flags set",E.mode=30;break}E.head&&(E.head.text=K>>8&1),512&E.flags&&(W[0]=255&K,W[1]=K>>>8&255,E.check=a(E.check,W,2,0)),$=K=0,E.mode=3;case 3:for(;$<32;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.head&&(E.head.time=K),512&E.flags&&(W[0]=255&K,W[1]=K>>>8&255,W[2]=K>>>16&255,W[3]=K>>>24&255,E.check=a(E.check,W,4,0)),$=K=0,E.mode=4;case 4:for(;$<16;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.head&&(E.head.xflags=255&K,E.head.os=K>>8),512&E.flags&&(W[0]=255&K,W[1]=K>>>8&255,E.check=a(E.check,W,2,0)),$=K=0,E.mode=5;case 5:if(1024&E.flags){for(;$<16;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.length=K,E.head&&(E.head.extra_len=K),512&E.flags&&(W[0]=255&K,W[1]=K>>>8&255,E.check=a(E.check,W,2,0)),$=K=0}else E.head&&(E.head.extra=null);E.mode=6;case 6:if(1024&E.flags&&(j<(J=E.length)&&(J=j),J&&(E.head&&(R=E.head.extra_len-E.length,E.head.extra||(E.head.extra=new Array(E.head.extra_len)),r.arraySet(E.head.extra,k,X,J,R)),512&E.flags&&(E.check=a(E.check,k,J,X)),j-=J,X+=J,E.length-=J),E.length))break e;E.length=0,E.mode=7;case 7:if(2048&E.flags){if(j===0)break e;for(J=0;R=k[X+J++],E.head&&R&&E.length<65536&&(E.head.name+=String.fromCharCode(R)),R&&J<j;);if(512&E.flags&&(E.check=a(E.check,k,J,X)),j-=J,X+=J,R)break e}else E.head&&(E.head.name=null);E.length=0,E.mode=8;case 8:if(4096&E.flags){if(j===0)break e;for(J=0;R=k[X+J++],E.head&&R&&E.length<65536&&(E.head.comment+=String.fromCharCode(R)),R&&J<j;);if(512&E.flags&&(E.check=a(E.check,k,J,X)),j-=J,X+=J,R)break e}else E.head&&(E.head.comment=null);E.mode=9;case 9:if(512&E.flags){for(;$<16;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(K!==(65535&E.check)){O.msg="header crc mismatch",E.mode=30;break}$=K=0}E.head&&(E.head.hcrc=E.flags>>9&1,E.head.done=!0),O.adler=E.check=0,E.mode=12;break;case 10:for(;$<32;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}O.adler=E.check=y(K),$=K=0,E.mode=11;case 11:if(E.havedict===0)return O.next_out=te,O.avail_out=ie,O.next_in=X,O.avail_in=j,E.hold=K,E.bits=$,2;O.adler=E.check=1,E.mode=12;case 12:if(N===5||N===6)break e;case 13:if(E.last){K>>>=7&$,$-=7&$,E.mode=27;break}for(;$<3;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}switch(E.last=1&K,$-=1,3&(K>>>=1)){case 0:E.mode=14;break;case 1:if(I(E),E.mode=20,N!==6)break;K>>>=2,$-=2;break e;case 2:E.mode=17;break;case 3:O.msg="invalid block type",E.mode=30}K>>>=2,$-=2;break;case 14:for(K>>>=7&$,$-=7&$;$<32;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if((65535&K)!=(K>>>16^65535)){O.msg="invalid stored block lengths",E.mode=30;break}if(E.length=65535&K,$=K=0,E.mode=15,N===6)break e;case 15:E.mode=16;case 16:if(J=E.length){if(j<J&&(J=j),ie<J&&(J=ie),J===0)break e;r.arraySet(G,k,X,J,te),j-=J,X+=J,ie-=J,te+=J,E.length-=J;break}E.mode=12;break;case 17:for(;$<14;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(E.nlen=257+(31&K),K>>>=5,$-=5,E.ndist=1+(31&K),K>>>=5,$-=5,E.ncode=4+(15&K),K>>>=4,$-=4,286<E.nlen||30<E.ndist){O.msg="too many length or distance symbols",E.mode=30;break}E.have=0,E.mode=18;case 18:for(;E.have<E.ncode;){for(;$<3;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.lens[re[E.have++]]=7&K,K>>>=3,$-=3}for(;E.have<19;)E.lens[re[E.have++]]=0;if(E.lencode=E.lendyn,E.lenbits=7,Q={bits:E.lenbits},ee=c(0,E.lens,0,19,E.lencode,0,E.work,Q),E.lenbits=Q.bits,ee){O.msg="invalid code lengths set",E.mode=30;break}E.have=0,E.mode=19;case 19:for(;E.have<E.nlen+E.ndist;){for(;_e=(z=E.lencode[K&(1<<E.lenbits)-1])>>>16&255,we=65535&z,!((he=z>>>24)<=$);){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(we<16)K>>>=he,$-=he,E.lens[E.have++]=we;else{if(we===16){for(U=he+2;$<U;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(K>>>=he,$-=he,E.have===0){O.msg="invalid bit length repeat",E.mode=30;break}R=E.lens[E.have-1],J=3+(3&K),K>>>=2,$-=2}else if(we===17){for(U=he+3;$<U;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}$-=he,R=0,J=3+(7&(K>>>=he)),K>>>=3,$-=3}else{for(U=he+7;$<U;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}$-=he,R=0,J=11+(127&(K>>>=he)),K>>>=7,$-=7}if(E.have+J>E.nlen+E.ndist){O.msg="invalid bit length repeat",E.mode=30;break}for(;J--;)E.lens[E.have++]=R}}if(E.mode===30)break;if(E.lens[256]===0){O.msg="invalid code -- missing end-of-block",E.mode=30;break}if(E.lenbits=9,Q={bits:E.lenbits},ee=c(h,E.lens,0,E.nlen,E.lencode,0,E.work,Q),E.lenbits=Q.bits,ee){O.msg="invalid literal/lengths set",E.mode=30;break}if(E.distbits=6,E.distcode=E.distdyn,Q={bits:E.distbits},ee=c(f,E.lens,E.nlen,E.ndist,E.distcode,0,E.work,Q),E.distbits=Q.bits,ee){O.msg="invalid distances set",E.mode=30;break}if(E.mode=20,N===6)break e;case 20:E.mode=21;case 21:if(6<=j&&258<=ie){O.next_out=te,O.avail_out=ie,O.next_in=X,O.avail_in=j,E.hold=K,E.bits=$,l(O,ae),te=O.next_out,G=O.output,ie=O.avail_out,X=O.next_in,k=O.input,j=O.avail_in,K=E.hold,$=E.bits,E.mode===12&&(E.back=-1);break}for(E.back=0;_e=(z=E.lencode[K&(1<<E.lenbits)-1])>>>16&255,we=65535&z,!((he=z>>>24)<=$);){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(_e&&(240&_e)==0){for(Se=he,V=_e,Y=we;_e=(z=E.lencode[Y+((K&(1<<Se+V)-1)>>Se)])>>>16&255,we=65535&z,!(Se+(he=z>>>24)<=$);){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}K>>>=Se,$-=Se,E.back+=Se}if(K>>>=he,$-=he,E.back+=he,E.length=we,_e===0){E.mode=26;break}if(32&_e){E.back=-1,E.mode=12;break}if(64&_e){O.msg="invalid literal/length code",E.mode=30;break}E.extra=15&_e,E.mode=22;case 22:if(E.extra){for(U=E.extra;$<U;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.length+=K&(1<<E.extra)-1,K>>>=E.extra,$-=E.extra,E.back+=E.extra}E.was=E.length,E.mode=23;case 23:for(;_e=(z=E.distcode[K&(1<<E.distbits)-1])>>>16&255,we=65535&z,!((he=z>>>24)<=$);){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if((240&_e)==0){for(Se=he,V=_e,Y=we;_e=(z=E.distcode[Y+((K&(1<<Se+V)-1)>>Se)])>>>16&255,we=65535&z,!(Se+(he=z>>>24)<=$);){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}K>>>=Se,$-=Se,E.back+=Se}if(K>>>=he,$-=he,E.back+=he,64&_e){O.msg="invalid distance code",E.mode=30;break}E.offset=we,E.extra=15&_e,E.mode=24;case 24:if(E.extra){for(U=E.extra;$<U;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}E.offset+=K&(1<<E.extra)-1,K>>>=E.extra,$-=E.extra,E.back+=E.extra}if(E.offset>E.dmax){O.msg="invalid distance too far back",E.mode=30;break}E.mode=25;case 25:if(ie===0)break e;if(J=ae-ie,E.offset>J){if((J=E.offset-J)>E.whave&&E.sane){O.msg="invalid distance too far back",E.mode=30;break}ne=J>E.wnext?(J-=E.wnext,E.wsize-J):E.wnext-J,J>E.length&&(J=E.length),ve=E.window}else ve=G,ne=te-E.offset,J=E.length;for(ie<J&&(J=ie),ie-=J,E.length-=J;G[te++]=ve[ne++],--J;);E.length===0&&(E.mode=21);break;case 26:if(ie===0)break e;G[te++]=E.length,ie--,E.mode=21;break;case 27:if(E.wrap){for(;$<32;){if(j===0)break e;j--,K|=k[X++]<<$,$+=8}if(ae-=ie,O.total_out+=ae,E.total+=ae,ae&&(O.adler=E.check=E.flags?a(E.check,G,ae,te-ae):o(E.check,G,ae,te-ae)),ae=ie,(E.flags?K:y(K))!==E.check){O.msg="incorrect data check",E.mode=30;break}$=K=0}E.mode=28;case 28:if(E.wrap&&E.flags){for(;$<32;){if(j===0)break e;j--,K+=k[X++]<<$,$+=8}if(K!==(4294967295&E.total)){O.msg="incorrect length check",E.mode=30;break}$=K=0}E.mode=29;case 29:ee=1;break e;case 30:ee=-3;break e;case 31:return-4;case 32:default:return p}return O.next_out=te,O.avail_out=ie,O.next_in=X,O.avail_in=j,E.hold=K,E.bits=$,(E.wsize||ae!==O.avail_out&&E.mode<30&&(E.mode<27||N!==4))&&F(O,O.output,O.next_out,ae-O.avail_out)?(E.mode=31,-4):(le-=O.avail_in,ae-=O.avail_out,O.total_in+=le,O.total_out+=ae,E.total+=ae,E.wrap&&ae&&(O.adler=E.check=E.flags?a(E.check,G,ae,O.next_out-ae):o(E.check,G,ae,O.next_out-ae)),O.data_type=E.bits+(E.last?64:0)+(E.mode===12?128:0)+(E.mode===20||E.mode===15?256:0),(le==0&&ae===0||N===4)&&ee===d&&(ee=-5),ee)},s.inflateEnd=function(O){if(!O||!O.state)return p;var N=O.state;return N.window&&(N.window=null),O.state=null,d},s.inflateGetHeader=function(O,N){var E;return O&&O.state?(2&(E=O.state).wrap)==0?p:((E.head=N).done=!1,d):p},s.inflateSetDictionary=function(O,N){var E,k=N.length;return O&&O.state?(E=O.state).wrap!==0&&E.mode!==11?p:E.mode===11&&o(1,N,k,0)!==E.check?-3:F(O,N,k,k)?(E.mode=31,-4):(E.havedict=1,d):p},s.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,i,s){var r=t("../utils/common"),o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],a=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],c=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];i.exports=function(h,f,d,p,g,m,v,y){var b,x,w,_,A,S,M,C,I,F=y.bits,O=0,N=0,E=0,k=0,G=0,X=0,te=0,j=0,ie=0,K=0,$=null,le=0,ae=new r.Buf16(16),J=new r.Buf16(16),ne=null,ve=0;for(O=0;O<=15;O++)ae[O]=0;for(N=0;N<p;N++)ae[f[d+N]]++;for(G=F,k=15;1<=k&&ae[k]===0;k--);if(k<G&&(G=k),k===0)return g[m++]=20971520,g[m++]=20971520,y.bits=1,0;for(E=1;E<k&&ae[E]===0;E++);for(G<E&&(G=E),O=j=1;O<=15;O++)if(j<<=1,(j-=ae[O])<0)return-1;if(0<j&&(h===0||k!==1))return-1;for(J[1]=0,O=1;O<15;O++)J[O+1]=J[O]+ae[O];for(N=0;N<p;N++)f[d+N]!==0&&(v[J[f[d+N]]++]=N);if(S=h===0?($=ne=v,19):h===1?($=o,le-=257,ne=a,ve-=257,256):($=l,ne=c,-1),O=E,A=m,te=N=K=0,w=-1,_=(ie=1<<(X=G))-1,h===1&&852<ie||h===2&&592<ie)return 1;for(;;){for(M=O-te,I=v[N]<S?(C=0,v[N]):v[N]>S?(C=ne[ve+v[N]],$[le+v[N]]):(C=96,0),b=1<<O-te,E=x=1<<X;g[A+(K>>te)+(x-=b)]=M<<24|C<<16|I|0,x!==0;);for(b=1<<O-1;K&b;)b>>=1;if(b!==0?(K&=b-1,K+=b):K=0,N++,--ae[O]==0){if(O===k)break;O=f[d+v[N]]}if(G<O&&(K&_)!==w){for(te===0&&(te=G),A+=E,j=1<<(X=O-te);X+te<k&&!((j-=ae[X+te])<=0);)X++,j<<=1;if(ie+=1<<X,h===1&&852<ie||h===2&&592<ie)return 1;g[w=K&_]=G<<24|X<<16|A-m|0}}return K!==0&&(g[A+K]=O-te<<24|64<<16|0),y.bits=G,0}},{"../utils/common":41}],51:[function(t,i,s){i.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,i,s){var r=t("../utils/common"),o=0,a=1;function l(z){for(var W=z.length;0<=--W;)z[W]=0}u(l,"n");var c=0,h=29,f=256,d=f+1+h,p=30,g=19,m=2*d+1,v=15,y=16,b=7,x=256,w=16,_=17,A=18,S=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],M=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],C=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],I=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],F=new Array(2*(d+2));l(F);var O=new Array(2*p);l(O);var N=new Array(512);l(N);var E=new Array(256);l(E);var k=new Array(h);l(k);var G,X,te,j=new Array(p);function ie(z,W,re,B,D){this.static_tree=z,this.extra_bits=W,this.extra_base=re,this.elems=B,this.max_length=D,this.has_stree=z&&z.length}u(ie,"D");function K(z,W){this.dyn_tree=z,this.max_code=0,this.stat_desc=W}u(K,"F");function $(z){return z<256?N[z]:N[256+(z>>>7)]}u($,"N");function le(z,W){z.pending_buf[z.pending++]=255&W,z.pending_buf[z.pending++]=W>>>8&255}u(le,"U");function ae(z,W,re){z.bi_valid>y-re?(z.bi_buf|=W<<z.bi_valid&65535,le(z,z.bi_buf),z.bi_buf=W>>y-z.bi_valid,z.bi_valid+=re-y):(z.bi_buf|=W<<z.bi_valid&65535,z.bi_valid+=re)}u(ae,"P");function J(z,W,re){ae(z,re[2*W],re[2*W+1])}u(J,"L");function ne(z,W){for(var re=0;re|=1&z,z>>>=1,re<<=1,0<--W;);return re>>>1}u(ne,"j");function ve(z,W,re){var B,D,L=new Array(v+1),H=0;for(B=1;B<=v;B++)L[B]=H=H+re[B-1]<<1;for(D=0;D<=W;D++){var q=z[2*D+1];q!==0&&(z[2*D]=ne(L[q]++,q))}}u(ve,"Z");function he(z){var W;for(W=0;W<d;W++)z.dyn_ltree[2*W]=0;for(W=0;W<p;W++)z.dyn_dtree[2*W]=0;for(W=0;W<g;W++)z.bl_tree[2*W]=0;z.dyn_ltree[2*x]=1,z.opt_len=z.static_len=0,z.last_lit=z.matches=0}u(he,"W");function _e(z){8<z.bi_valid?le(z,z.bi_buf):0<z.bi_valid&&(z.pending_buf[z.pending++]=z.bi_buf),z.bi_buf=0,z.bi_valid=0}u(_e,"M");function we(z,W,re,B){var D=2*W,L=2*re;return z[D]<z[L]||z[D]===z[L]&&B[W]<=B[re]}u(we,"H");function Se(z,W,re){for(var B=z.heap[re],D=re<<1;D<=z.heap_len&&(D<z.heap_len&&we(W,z.heap[D+1],z.heap[D],z.depth)&&D++,!we(W,B,z.heap[D],z.depth));)z.heap[re]=z.heap[D],re=D,D<<=1;z.heap[re]=B}u(Se,"G");function V(z,W,re){var B,D,L,H,q=0;if(z.last_lit!==0)for(;B=z.pending_buf[z.d_buf+2*q]<<8|z.pending_buf[z.d_buf+2*q+1],D=z.pending_buf[z.l_buf+q],q++,B===0?J(z,D,W):(J(z,(L=E[D])+f+1,W),(H=S[L])!==0&&ae(z,D-=k[L],H),J(z,L=$(--B),re),(H=M[L])!==0&&ae(z,B-=j[L],H)),q<z.last_lit;);J(z,x,W)}u(V,"K");function Y(z,W){var re,B,D,L=W.dyn_tree,H=W.stat_desc.static_tree,q=W.stat_desc.has_stree,se=W.stat_desc.elems,de=-1;for(z.heap_len=0,z.heap_max=m,re=0;re<se;re++)L[2*re]!==0?(z.heap[++z.heap_len]=de=re,z.depth[re]=0):L[2*re+1]=0;for(;z.heap_len<2;)L[2*(D=z.heap[++z.heap_len]=de<2?++de:0)]=1,z.depth[D]=0,z.opt_len--,q&&(z.static_len-=H[2*D+1]);for(W.max_code=de,re=z.heap_len>>1;1<=re;re--)Se(z,L,re);for(D=se;re=z.heap[1],z.heap[1]=z.heap[z.heap_len--],Se(z,L,1),B=z.heap[1],z.heap[--z.heap_max]=re,z.heap[--z.heap_max]=B,L[2*D]=L[2*re]+L[2*B],z.depth[D]=(z.depth[re]>=z.depth[B]?z.depth[re]:z.depth[B])+1,L[2*re+1]=L[2*B+1]=D,z.heap[1]=D++,Se(z,L,1),2<=z.heap_len;);z.heap[--z.heap_max]=z.heap[1],function(ge,ye){var pe,Ne,Ye,Re,Ke,$e,Qe=ye.dyn_tree,Bt=ye.max_code,Yn=ye.stat_desc.static_tree,oe=ye.stat_desc.has_stree,be=ye.stat_desc.extra_bits,Ee=ye.stat_desc.extra_base,Ue=ye.stat_desc.max_length,Xe=0;for(Re=0;Re<=v;Re++)ge.bl_count[Re]=0;for(Qe[2*ge.heap[ge.heap_max]+1]=0,pe=ge.heap_max+1;pe<m;pe++)Ue<(Re=Qe[2*Qe[2*(Ne=ge.heap[pe])+1]+1]+1)&&(Re=Ue,Xe++),Qe[2*Ne+1]=Re,Bt<Ne||(ge.bl_count[Re]++,Ke=0,Ee<=Ne&&(Ke=be[Ne-Ee]),$e=Qe[2*Ne],ge.opt_len+=$e*(Re+Ke),oe&&(ge.static_len+=$e*(Yn[2*Ne+1]+Ke)));if(Xe!==0){do{for(Re=Ue-1;ge.bl_count[Re]===0;)Re--;ge.bl_count[Re]--,ge.bl_count[Re+1]+=2,ge.bl_count[Ue]--,Xe-=2}while(0<Xe);for(Re=Ue;Re!==0;Re--)for(Ne=ge.bl_count[Re];Ne!==0;)Bt<(Ye=ge.heap[--pe])||(Qe[2*Ye+1]!==Re&&(ge.opt_len+=(Re-Qe[2*Ye+1])*Qe[2*Ye],Qe[2*Ye+1]=Re),Ne--)}}(z,W),ve(L,de,z.bl_count)}u(Y,"Y");function R(z,W,re){var B,D,L=-1,H=W[1],q=0,se=7,de=4;for(H===0&&(se=138,de=3),W[2*(re+1)+1]=65535,B=0;B<=re;B++)D=H,H=W[2*(B+1)+1],++q<se&&D===H||(q<de?z.bl_tree[2*D]+=q:D!==0?(D!==L&&z.bl_tree[2*D]++,z.bl_tree[2*w]++):q<=10?z.bl_tree[2*_]++:z.bl_tree[2*A]++,L=D,de=(q=0)===H?(se=138,3):D===H?(se=6,3):(se=7,4))}u(R,"X");function ee(z,W,re){var B,D,L=-1,H=W[1],q=0,se=7,de=4;for(H===0&&(se=138,de=3),B=0;B<=re;B++)if(D=H,H=W[2*(B+1)+1],!(++q<se&&D===H)){if(q<de)for(;J(z,D,z.bl_tree),--q!=0;);else D!==0?(D!==L&&(J(z,D,z.bl_tree),q--),J(z,w,z.bl_tree),ae(z,q-3,2)):q<=10?(J(z,_,z.bl_tree),ae(z,q-3,3)):(J(z,A,z.bl_tree),ae(z,q-11,7));L=D,de=(q=0)===H?(se=138,3):D===H?(se=6,3):(se=7,4)}}u(ee,"V"),l(j);var Q=!1;function U(z,W,re,B){ae(z,(c<<1)+(B?1:0),3),function(D,L,H,q){_e(D),q&&(le(D,H),le(D,~H)),r.arraySet(D.pending_buf,D.window,L,H,D.pending),D.pending+=H}(z,W,re,!0)}u(U,"J"),s._tr_init=function(z){Q||(function(){var W,re,B,D,L,H=new Array(v+1);for(D=B=0;D<h-1;D++)for(k[D]=B,W=0;W<1<<S[D];W++)E[B++]=D;for(E[B-1]=D,D=L=0;D<16;D++)for(j[D]=L,W=0;W<1<<M[D];W++)N[L++]=D;for(L>>=7;D<p;D++)for(j[D]=L<<7,W=0;W<1<<M[D]-7;W++)N[256+L++]=D;for(re=0;re<=v;re++)H[re]=0;for(W=0;W<=143;)F[2*W+1]=8,W++,H[8]++;for(;W<=255;)F[2*W+1]=9,W++,H[9]++;for(;W<=279;)F[2*W+1]=7,W++,H[7]++;for(;W<=287;)F[2*W+1]=8,W++,H[8]++;for(ve(F,d+1,H),W=0;W<p;W++)O[2*W+1]=5,O[2*W]=ne(W,5);G=new ie(F,S,f+1,d,v),X=new ie(O,M,0,p,v),te=new ie(new Array(0),C,0,g,b)}(),Q=!0),z.l_desc=new K(z.dyn_ltree,G),z.d_desc=new K(z.dyn_dtree,X),z.bl_desc=new K(z.bl_tree,te),z.bi_buf=0,z.bi_valid=0,he(z)},s._tr_stored_block=U,s._tr_flush_block=function(z,W,re,B){var D,L,H=0;0<z.level?(z.strm.data_type===2&&(z.strm.data_type=function(q){var se,de=4093624447;for(se=0;se<=31;se++,de>>>=1)if(1&de&&q.dyn_ltree[2*se]!==0)return o;if(q.dyn_ltree[18]!==0||q.dyn_ltree[20]!==0||q.dyn_ltree[26]!==0)return a;for(se=32;se<f;se++)if(q.dyn_ltree[2*se]!==0)return a;return o}(z)),Y(z,z.l_desc),Y(z,z.d_desc),H=function(q){var se;for(R(q,q.dyn_ltree,q.l_desc.max_code),R(q,q.dyn_dtree,q.d_desc.max_code),Y(q,q.bl_desc),se=g-1;3<=se&&q.bl_tree[2*I[se]+1]===0;se--);return q.opt_len+=3*(se+1)+5+5+4,se}(z),D=z.opt_len+3+7>>>3,(L=z.static_len+3+7>>>3)<=D&&(D=L)):D=L=re+5,re+4<=D&&W!==-1?U(z,W,re,B):z.strategy===4||L===D?(ae(z,2+(B?1:0),3),V(z,F,O)):(ae(z,4+(B?1:0),3),function(q,se,de,ge){var ye;for(ae(q,se-257,5),ae(q,de-1,5),ae(q,ge-4,4),ye=0;ye<ge;ye++)ae(q,q.bl_tree[2*I[ye]+1],3);ee(q,q.dyn_ltree,se-1),ee(q,q.dyn_dtree,de-1)}(z,z.l_desc.max_code+1,z.d_desc.max_code+1,H+1),V(z,z.dyn_ltree,z.dyn_dtree)),he(z),B&&_e(z)},s._tr_tally=function(z,W,re){return z.pending_buf[z.d_buf+2*z.last_lit]=W>>>8&255,z.pending_buf[z.d_buf+2*z.last_lit+1]=255&W,z.pending_buf[z.l_buf+z.last_lit]=255&re,z.last_lit++,W===0?z.dyn_ltree[2*re]++:(z.matches++,W--,z.dyn_ltree[2*(E[re]+f+1)]++,z.dyn_dtree[2*$(W)]++),z.last_lit===z.lit_bufsize-1},s._tr_align=function(z){ae(z,2,3),J(z,x,F),function(W){W.bi_valid===16?(le(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0):8<=W.bi_valid&&(W.pending_buf[W.pending++]=255&W.bi_buf,W.bi_buf>>=8,W.bi_valid-=8)}(z)}},{"../utils/common":41}],53:[function(t,i,s){i.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,i,s){(function(r){(function(o,a){if(!o.setImmediate){var l,c,h,f,d=1,p={},g=!1,m=o.document,v=Object.getPrototypeOf&&Object.getPrototypeOf(o);v=v&&v.setTimeout?v:o,l={}.toString.call(o.process)==="[object process]"?function(w){process.nextTick(function(){b(w)})}:function(){if(o.postMessage&&!o.importScripts){var w=!0,_=o.onmessage;return o.onmessage=function(){w=!1},o.postMessage("","*"),o.onmessage=_,w}}()?(f="setImmediate$"+Math.random()+"$",o.addEventListener?o.addEventListener("message",x,!1):o.attachEvent("onmessage",x),function(w){o.postMessage(f+w,"*")}):o.MessageChannel?((h=new MessageChannel).port1.onmessage=function(w){b(w.data)},function(w){h.port2.postMessage(w)}):m&&"onreadystatechange"in m.createElement("script")?(c=m.documentElement,function(w){var _=m.createElement("script");_.onreadystatechange=function(){b(w),_.onreadystatechange=null,c.removeChild(_),_=null},c.appendChild(_)}):function(w){setTimeout(b,0,w)},v.setImmediate=function(w){typeof w!="function"&&(w=new Function(""+w));for(var _=new Array(arguments.length-1),A=0;A<_.length;A++)_[A]=arguments[A+1];var S={callback:w,args:_};return p[d]=S,l(d),d++},v.clearImmediate=y}function y(w){delete p[w]}u(y,"f");function b(w){if(g)setTimeout(b,0,w);else{var _=p[w];if(_){g=!0;try{(function(A){var S=A.callback,M=A.args;switch(M.length){case 0:S();break;case 1:S(M[0]);break;case 2:S(M[0],M[1]);break;case 3:S(M[0],M[1],M[2]);break;default:S.apply(a,M)}})(_)}finally{y(w),g=!1}}}}u(b,"c");function x(w){w.source===o&&typeof w.data=="string"&&w.data.indexOf(f)===0&&b(+w.data.slice(f.length))}u(x,"d")})(typeof self=="undefined"?r===void 0?this:r:self)}).call(this,typeof Jm!="undefined"?Jm:typeof self!="undefined"?self:typeof window!="undefined"?window:{})},{}]},{},[10])(10)})})(K4);var yge=K4.exports;/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/var fE={},Kx=u(function(n){return URL.createObjectURL(new Blob([n],{type:"text/javascript"}))},"durl"),Q4=u(function(n){return new Worker(n)},"cwk");try{URL.revokeObjectURL(Kx(""))}catch{Kx=u(function(e){return"data:application/javascript;charset=UTF-8,"+encodeURI(e)},"durl"),Q4=u(function(e){return new Worker(e,{type:"module"})},"cwk")}var bge=u(function(n,e,t,i,s){var r=Q4(fE[e]||(fE[e]=Kx(n)));return r.onerror=function(o){return s(o.error,null)},r.onmessage=function(o){return s(null,o.data)},r.postMessage(t,i),r},"wk"),Pt=Uint8Array,wi=Uint16Array,Jo=Uint32Array,Xh=new Pt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),qh=new Pt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ap=new Pt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),J4=u(function(n,e){for(var t=new wi(31),i=0;i<31;++i)t[i]=e+=1<<n[i-1];for(var s=new Jo(t[30]),i=1;i<30;++i)for(var r=t[i];r<t[i+1];++r)s[r]=r-t[i]<<5|i;return[t,s]},"freb"),eF=J4(Xh,2),pA=eF[0],J0=eF[1];pA[28]=258,J0[258]=28;var tF=J4(qh,0),nF=tF[0],Qx=tF[1],Mp=new wi(32768);for(var mn=0;mn<32768;++mn){var Ea=(mn&43690)>>>1|(mn&21845)<<1;Ea=(Ea&52428)>>>2|(Ea&13107)<<2,Ea=(Ea&61680)>>>4|(Ea&3855)<<4,Mp[mn]=((Ea&65280)>>>8|(Ea&255)<<8)>>>1}var nr=u(function(n,e,t){for(var i=n.length,s=0,r=new wi(e);s<i;++s)++r[n[s]-1];var o=new wi(e);for(s=0;s<e;++s)o[s]=o[s-1]+r[s-1]<<1;var a;if(t){a=new wi(1<<e);var l=15-e;for(s=0;s<i;++s)if(n[s])for(var c=s<<4|n[s],h=e-n[s],f=o[n[s]-1]++<<h,d=f|(1<<h)-1;f<=d;++f)a[Mp[f]>>>l]=c}else for(a=new wi(i),s=0;s<i;++s)n[s]&&(a[s]=Mp[o[n[s]-1]++]>>>15-n[s]);return a},"hMap"),ea=new Pt(288);for(var mn=0;mn<144;++mn)ea[mn]=8;for(var mn=144;mn<256;++mn)ea[mn]=9;for(var mn=256;mn<280;++mn)ea[mn]=7;for(var mn=280;mn<288;++mn)ea[mn]=8;var Lh=new Pt(32);for(var mn=0;mn<32;++mn)Lh[mn]=5;var iF=nr(ea,9,0),sF=nr(ea,9,1),rF=nr(Lh,5,0),oF=nr(Lh,5,1),C0=u(function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},"max"),js=u(function(n,e,t){var i=e/8|0;return(n[i]|n[i+1]<<8)>>(e&7)&t},"bits"),E0=u(function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(e&7)},"bits16"),Gp=u(function(n){return(n/8|0)+(n&7&&1)},"shft"),ir=u(function(n,e,t){(e==null||e<0)&&(e=0),(t==null||t>n.length)&&(t=n.length);var i=new(n instanceof wi?wi:n instanceof Jo?Jo:Pt)(t-e);return i.set(n.subarray(e,t)),i},"slc"),Wp=u(function(n,e,t){var i=n.length;if(!i||t&&!t.l&&i<5)return e||new Pt(0);var s=!e||t,r=!t||t.i;t||(t={}),e||(e=new Pt(i*3));var o=u(function(ne){var ve=e.length;if(ne>ve){var he=new Pt(Math.max(ve*2,ne));he.set(e),e=he}},"cbuf"),a=t.f||0,l=t.p||0,c=t.b||0,h=t.l,f=t.d,d=t.m,p=t.n,g=i*8;do{if(!h){t.f=a=js(n,l,1);var m=js(n,l+1,3);if(l+=3,m)if(m==1)h=sF,f=oF,d=9,p=5;else if(m==2){var x=js(n,l,31)+257,w=js(n,l+10,15)+4,_=x+js(n,l+5,31)+1;l+=14;for(var A=new Pt(_),S=new Pt(19),M=0;M<w;++M)S[Ap[M]]=js(n,l+M*3,7);l+=w*3;for(var C=C0(S),I=(1<<C)-1,F=nr(S,C,1),M=0;M<_;){var O=F[js(n,l,I)];l+=O&15;var v=O>>>4;if(v<16)A[M++]=v;else{var N=0,E=0;for(v==16?(E=3+js(n,l,3),l+=2,N=A[M-1]):v==17?(E=3+js(n,l,7),l+=3):v==18&&(E=11+js(n,l,127),l+=7);E--;)A[M++]=N}}var k=A.subarray(0,x),G=A.subarray(x);d=C0(k),p=C0(G),h=nr(k,d,1),f=nr(G,p,1)}else throw"invalid block type";else{var v=Gp(l)+4,y=n[v-4]|n[v-3]<<8,b=v+y;if(b>i){if(r)throw"unexpected EOF";break}s&&o(c+y),e.set(n.subarray(v,b),c),t.b=c+=y,t.p=l=b*8;continue}if(l>g){if(r)throw"unexpected EOF";break}}s&&o(c+131072);for(var X=(1<<d)-1,te=(1<<p)-1,j=l;;j=l){var N=h[E0(n,l)&X],ie=N>>>4;if(l+=N&15,l>g){if(r)throw"unexpected EOF";break}if(!N)throw"invalid length/literal";if(ie<256)e[c++]=ie;else if(ie==256){j=l,h=null;break}else{var K=ie-254;if(ie>264){var M=ie-257,$=Xh[M];K=js(n,l,(1<<$)-1)+pA[M],l+=$}var le=f[E0(n,l)&te],ae=le>>>4;if(!le)throw"invalid distance";l+=le&15;var G=nF[ae];if(ae>3){var $=qh[ae];G+=E0(n,l)&(1<<$)-1,l+=$}if(l>g){if(r)throw"unexpected EOF";break}s&&o(c+131072);for(var J=c+K;c<J;c+=4)e[c]=e[c-G],e[c+1]=e[c+1-G],e[c+2]=e[c+2-G],e[c+3]=e[c+3-G];c=J}}t.l=h,t.p=j,t.b=c,h&&(a=1,t.m=d,t.d=f,t.n=p)}while(!a);return c==e.length?e:ir(e,0,c)},"inflt"),$r=u(function(n,e,t){t<<=e&7;var i=e/8|0;n[i]|=t,n[i+1]|=t>>>8},"wbits"),Pu=u(function(n,e,t){t<<=e&7;var i=e/8|0;n[i]|=t,n[i+1]|=t>>>8,n[i+2]|=t>>>16},"wbits16"),P0=u(function(n,e){for(var t=[],i=0;i<n.length;++i)n[i]&&t.push({s:i,f:n[i]});var s=t.length,r=t.slice();if(!s)return[$o,0];if(s==1){var o=new Pt(t[0].s+1);return o[t[0].s]=1,[o,1]}t.sort(function(_,A){return _.f-A.f}),t.push({s:-1,f:25001});var a=t[0],l=t[1],c=0,h=1,f=2;for(t[0]={s:-1,f:a.f+l.f,l:a,r:l};h!=s-1;)a=t[t[c].f<t[f].f?c++:f++],l=t[c!=h&&t[c].f<t[f].f?c++:f++],t[h++]={s:-1,f:a.f+l.f,l:a,r:l};for(var d=r[0].s,i=1;i<s;++i)r[i].s>d&&(d=r[i].s);var p=new wi(d+1),g=e1(t[h-1],p,0);if(g>e){var i=0,m=0,v=g-e,y=1<<v;for(r.sort(function(A,S){return p[S.s]-p[A.s]||A.f-S.f});i<s;++i){var b=r[i].s;if(p[b]>e)m+=y-(1<<g-p[b]),p[b]=e;else break}for(m>>>=v;m>0;){var x=r[i].s;p[x]<e?m-=1<<e-p[x]++-1:++i}for(;i>=0&&m;--i){var w=r[i].s;p[w]==e&&(--p[w],++m)}g=e}return[new Pt(p),g]},"hTree"),e1=u(function(n,e,t){return n.s==-1?Math.max(e1(n.l,e,t+1),e1(n.r,e,t+1)):e[n.s]=t},"ln"),Jx=u(function(n){for(var e=n.length;e&&!n[--e];);for(var t=new wi(++e),i=0,s=n[0],r=1,o=u(function(l){t[i++]=l},"w"),a=1;a<=e;++a)if(n[a]==s&&a!=e)++r;else{if(!s&&r>2){for(;r>138;r-=138)o(32754);r>2&&(o(r>10?r-11<<5|28690:r-3<<5|12305),r=0)}else if(r>3){for(o(s),--r;r>6;r-=6)o(8304);r>2&&(o(r-3<<5|8208),r=0)}for(;r--;)o(s);r=1,s=n[a]}return[t.subarray(0,i),e]},"lc"),Ru=u(function(n,e){for(var t=0,i=0;i<e.length;++i)t+=n[i]*e[i];return t},"clen"),Wd=u(function(n,e,t){var i=t.length,s=Gp(e+2);n[s]=i&255,n[s+1]=i>>>8,n[s+2]=n[s]^255,n[s+3]=n[s+1]^255;for(var r=0;r<i;++r)n[s+r+4]=t[r];return(s+4+i)*8},"wfblk"),e_=u(function(n,e,t,i,s,r,o,a,l,c,h){$r(e,h++,t),++s[256];for(var f=P0(s,15),d=f[0],p=f[1],g=P0(r,15),m=g[0],v=g[1],y=Jx(d),b=y[0],x=y[1],w=Jx(m),_=w[0],A=w[1],S=new wi(19),M=0;M<b.length;++M)S[b[M]&31]++;for(var M=0;M<_.length;++M)S[_[M]&31]++;for(var C=P0(S,7),I=C[0],F=C[1],O=19;O>4&&!I[Ap[O-1]];--O);var N=c+5<<3,E=Ru(s,ea)+Ru(r,Lh)+o,k=Ru(s,d)+Ru(r,m)+o+14+3*O+Ru(S,I)+(2*S[16]+3*S[17]+7*S[18]);if(N<=E&&N<=k)return Wd(e,h,n.subarray(l,l+c));var G,X,te,j;if($r(e,h,1+(k<E)),h+=2,k<E){G=nr(d,p,0),X=d,te=nr(m,v,0),j=m;var ie=nr(I,F,0);$r(e,h,x-257),$r(e,h+5,A-1),$r(e,h+10,O-4),h+=14;for(var M=0;M<O;++M)$r(e,h+3*M,I[Ap[M]]);h+=3*O;for(var K=[b,_],$=0;$<2;++$)for(var le=K[$],M=0;M<le.length;++M){var ae=le[M]&31;$r(e,h,ie[ae]),h+=I[ae],ae>15&&($r(e,h,le[M]>>>5&127),h+=le[M]>>>12)}}else G=iF,X=ea,te=rF,j=Lh;for(var M=0;M<a;++M)if(i[M]>255){var ae=i[M]>>>18&31;Pu(e,h,G[ae+257]),h+=X[ae+257],ae>7&&($r(e,h,i[M]>>>23&31),h+=Xh[ae]);var J=i[M]&31;Pu(e,h,te[J]),h+=j[J],J>3&&(Pu(e,h,i[M]>>>5&8191),h+=qh[J])}else Pu(e,h,G[i[M]]),h+=X[i[M]];return Pu(e,h,G[256]),h+X[256]},"wblk"),aF=new Jo([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),$o=new Pt(0),lF=u(function(n,e,t,i,s,r){var o=n.length,a=new Pt(i+o+5*(1+Math.ceil(o/7e3))+s),l=a.subarray(i,a.length-s),c=0;if(!e||o<8)for(var h=0;h<=o;h+=65535){var f=h+65535;f<o?c=Wd(l,c,n.subarray(h,f)):(l[h]=r,c=Wd(l,c,n.subarray(h,o)))}else{for(var d=aF[e-1],p=d>>>13,g=d&8191,m=(1<<t)-1,v=new wi(32768),y=new wi(m+1),b=Math.ceil(t/3),x=2*b,w=u(function(R){return(n[R]^n[R+1]<<b^n[R+2]<<x)&m},"hsh"),_=new Jo(25e3),A=new wi(288),S=new wi(32),M=0,C=0,h=0,I=0,F=0,O=0;h<o;++h){var N=w(h),E=h&32767,k=y[N];if(v[E]=k,y[N]=E,F<=h){var G=o-h;if((M>7e3||I>24576)&&G>423){c=e_(n,l,0,_,A,S,C,I,O,h-O,c),I=M=C=0,O=h;for(var X=0;X<286;++X)A[X]=0;for(var X=0;X<30;++X)S[X]=0}var te=2,j=0,ie=g,K=E-k&32767;if(G>2&&N==w(h-K))for(var $=Math.min(p,G)-1,le=Math.min(32767,h),ae=Math.min(258,G);K<=le&&--ie&&E!=k;){if(n[h+te]==n[h+te-K]){for(var J=0;J<ae&&n[h+J]==n[h+J-K];++J);if(J>te){if(te=J,j=K,J>$)break;for(var ne=Math.min(K,J-2),ve=0,X=0;X<ne;++X){var he=h-K+X+32768&32767,_e=v[he],we=he-_e+32768&32767;we>ve&&(ve=we,k=he)}}}E=k,k=v[E],K+=E-k+32768&32767}if(j){_[I++]=268435456|J0[te]<<18|Qx[j];var Se=J0[te]&31,V=Qx[j]&31;C+=Xh[Se]+qh[V],++A[257+Se],++S[V],F=h+te,++M}else _[I++]=n[h],++A[n[h]]}}c=e_(n,l,r,_,A,S,C,I,O,h-O,c),!r&&c&7&&(c=Wd(l,c+1,$o))}return ir(a,0,i+Gp(c)+s)},"dflt"),cF=function(){for(var n=new Jo(256),e=0;e<256;++e){for(var t=e,i=9;--i;)t=(t&1&&3988292384)^t>>>1;n[e]=t}return n}(),Yh=u(function(){var n=-1;return{p:function(e){for(var t=n,i=0;i<e.length;++i)t=cF[t&255^e[i]]^t>>>8;n=t},d:function(){return~n}}},"crc"),mA=u(function(){var n=1,e=0;return{p:function(t){for(var i=n,s=e,r=t.length,o=0;o!=r;){for(var a=Math.min(o+2655,r);o<a;++o)s+=i+=t[o];i=(i&65535)+15*(i>>16),s=(s&65535)+15*(s>>16)}n=i,e=s},d:function(){return n%=65521,e%=65521,(n&255)<<24|n>>>8<<16|(e&255)<<8|e>>>8}}},"adler"),Rc=u(function(n,e,t,i,s){return lF(n,e.level==null?6:e.level,e.mem==null?Math.ceil(Math.max(8,Math.min(13,Math.log(n.length)))*1.5):12+e.mem,t,i,!s)},"dopt"),jp=u(function(n,e){var t={};for(var i in n)t[i]=n[i];for(var i in e)t[i]=e[i];return t},"mrg"),dE=u(function(n,e,t){for(var i=n(),s=n.toString(),r=s.slice(s.indexOf("[")+1,s.lastIndexOf("]")).replace(/ /g,"").split(","),o=0;o<i.length;++o){var a=i[o],l=r[o];if(typeof a=="function"){e+=";"+l+"=";var c=a.toString();if(a.prototype)if(c.indexOf("[native code]")!=-1){var h=c.indexOf(" ",8)+1;e+=c.slice(h,c.indexOf("(",h))}else{e+=c;for(var f in a.prototype)e+=";"+l+".prototype."+f+"="+a.prototype[f].toString()}else e+=c}else t[l]=a}return[e,t]},"wcln"),Mg=[],xge=u(function(n){var e=[];for(var t in n)(n[t]instanceof Pt||n[t]instanceof wi||n[t]instanceof Jo)&&e.push((n[t]=new n[t].constructor(n[t])).buffer);return e},"cbfs"),uF=u(function(n,e,t,i){var s;if(!Mg[t]){for(var r="",o={},a=n.length-1,l=0;l<a;++l)s=dE(n[l],r,o),r=s[0],o=s[1];Mg[t]=dE(n[a],r,o)}var c=jp({},Mg[t][1]);return bge(Mg[t][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+e.toString()+"}",t,c,xge(c),i)},"wrkr"),Zh=u(function(){return[Pt,wi,Jo,Xh,qh,Ap,pA,nF,sF,oF,Mp,nr,C0,js,E0,Gp,ir,Wp,ef,cl,gA]},"bInflt"),Kh=u(function(){return[Pt,wi,Jo,Xh,qh,Ap,J0,Qx,iF,ea,rF,Lh,Mp,aF,$o,nr,$r,Pu,P0,e1,Jx,Ru,Wd,e_,Gp,ir,lF,Rc,Xp,cl]},"bDflt"),hF=u(function(){return[vA,bA,Ht,Yh,cF]},"gze"),fF=u(function(){return[yA,mF]},"guze"),dF=u(function(){return[xA,Ht,mA]},"zle"),pF=u(function(){return[gF]},"zule"),cl=u(function(n){return postMessage(n,[n.buffer])},"pbf"),gA=u(function(n){return n&&n.size&&new Pt(n.size)},"gu8"),Qh=u(function(n,e,t,i,s,r){var o=uF(t,i,s,function(a,l){o.terminate(),r(a,l)});return o.postMessage([n,e],e.consume?[n.buffer]:[]),function(){o.terminate()}},"cbify"),sr=u(function(n){return n.ondata=function(e,t){return postMessage([e,t],[e.buffer])},function(e){return n.push(e.data[0],e.data[1])}},"astrm"),Jh=u(function(n,e,t,i,s){var r,o=uF(n,i,s,function(a,l){a?(o.terminate(),e.ondata.call(e,a)):(l[1]&&o.terminate(),e.ondata.call(e,a,l[0],l[1]))});o.postMessage(t),e.push=function(a,l){if(r)throw"stream finished";if(!e.ondata)throw"no stream handler";o.postMessage([a,r=l],[a.buffer])},e.terminate=function(){o.terminate()}},"astrmify"),Zi=u(function(n,e){return n[e]|n[e+1]<<8},"b2"),Gn=u(function(n,e){return(n[e]|n[e+1]<<8|n[e+2]<<16|n[e+3]<<24)>>>0},"b4"),yb=u(function(n,e){return Gn(n,e)+Gn(n,e+4)*4294967296},"b8"),Ht=u(function(n,e,t){for(;t;++e)n[e]=t,t>>>=8},"wbytes"),vA=u(function(n,e){var t=e.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=e.level<2?4:e.level==9?2:0,n[9]=3,e.mtime!=0&&Ht(n,4,Math.floor(new Date(e.mtime||Date.now())/1e3)),t){n[3]=8;for(var i=0;i<=t.length;++i)n[i+10]=t.charCodeAt(i)}},"gzh"),yA=u(function(n){if(n[0]!=31||n[1]!=139||n[2]!=8)throw"invalid gzip data";var e=n[3],t=10;e&4&&(t+=n[10]|(n[11]<<8)+2);for(var i=(e>>3&1)+(e>>4&1);i>0;i-=!n[t++]);return t+(e&2)},"gzs"),mF=u(function(n){var e=n.length;return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0},"gzl"),bA=u(function(n){return 10+(n.filename&&n.filename.length+1||0)},"gzhl"),xA=u(function(n,e){var t=e.level,i=t==0?0:t<6?1:t==9?3:2;n[0]=120,n[1]=i<<6|(i?32-2*i:1)},"zlh"),gF=u(function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(n[1]&32)throw"invalid zlib data: preset dictionaries not supported"},"zlv");function _A(n,e){return!e&&typeof n=="function"&&(e=n,n={}),this.ondata=e,n}u(_A,"AsyncCmpStrm");var so=function(){function n(e,t){!t&&typeof e=="function"&&(t=e,e={}),this.ondata=t,this.o=e||{}}return u(n,"Deflate"),n.prototype.p=function(e,t){this.ondata(Rc(e,this.o,0,0,!t),t)},n.prototype.push=function(e,t){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=t,this.p(e,t||!1)},n}(),vF=function(){function n(e,t){Jh([Kh,function(){return[sr,so]}],this,_A.call(this,e,t),function(i){var s=new so(i.data);onmessage=sr(s)},6)}return u(n,"AsyncDeflate"),n}();function yF(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Kh],function(i){return cl(Xp(i.data[0],i.data[1]))},0,t)}u(yF,"deflate");function Xp(n,e){return Rc(n,e||{},0,0)}u(Xp,"deflateSync");var vs=function(){function n(e){this.s={},this.p=new Pt(0),this.ondata=e}return u(n,"Inflate"),n.prototype.e=function(e){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var t=this.p.length,i=new Pt(t+e.length);i.set(this.p),i.set(e,t),this.p=i},n.prototype.c=function(e){this.d=this.s.i=e||!1;var t=this.s.b,i=Wp(this.p,this.o,this.s);this.ondata(ir(i,t,this.s.b),this.d),this.o=ir(i,this.s.b-32768),this.s.b=this.o.length,this.p=ir(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(e,t){this.e(e),this.c(t)},n}(),wA=function(){function n(e){this.ondata=e,Jh([Zh,function(){return[sr,vs]}],this,0,function(){var t=new vs;onmessage=sr(t)},7)}return u(n,"AsyncInflate"),n}();function AA(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Zh],function(i){return cl(ef(i.data[0],gA(i.data[1])))},1,t)}u(AA,"inflate");function ef(n,e){return Wp(n,e)}u(ef,"inflateSync");var t1=function(){function n(e,t){this.c=Yh(),this.l=0,this.v=1,so.call(this,e,t)}return u(n,"Gzip"),n.prototype.push=function(e,t){so.prototype.push.call(this,e,t)},n.prototype.p=function(e,t){this.c.p(e),this.l+=e.length;var i=Rc(e,this.o,this.v&&bA(this.o),t&&8,!t);this.v&&(vA(i,this.o),this.v=0),t&&(Ht(i,i.length-8,this.c.d()),Ht(i,i.length-4,this.l)),this.ondata(i,t)},n}(),pE=function(){function n(e,t){Jh([Kh,hF,function(){return[sr,so,t1]}],this,_A.call(this,e,t),function(i){var s=new t1(i.data);onmessage=sr(s)},8)}return u(n,"AsyncGzip"),n}();function mE(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Kh,hF,function(){return[n1]}],function(i){return cl(n1(i.data[0],i.data[1]))},2,t)}u(mE,"gzip");function n1(n,e){e||(e={});var t=Yh(),i=n.length;t.p(n);var s=Rc(n,e,bA(e),8),r=s.length;return vA(s,e),Ht(s,r-8,t.d()),Ht(s,r-4,i),s}u(n1,"gzipSync");var i1=function(){function n(e){this.v=1,vs.call(this,e)}return u(n,"Gunzip"),n.prototype.push=function(e,t){if(vs.prototype.e.call(this,e),this.v){var i=this.p.length>3?yA(this.p):4;if(i>=this.p.length&&!t)return;this.p=this.p.subarray(i),this.v=0}if(t){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}vs.prototype.c.call(this,t)},n}(),bF=function(){function n(e){this.ondata=e,Jh([Zh,fF,function(){return[sr,vs,i1]}],this,0,function(){var t=new i1;onmessage=sr(t)},9)}return u(n,"AsyncGunzip"),n}();function xF(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Zh,fF,function(){return[s1]}],function(i){return cl(s1(i.data[0]))},3,t)}u(xF,"gunzip");function s1(n,e){return Wp(n.subarray(yA(n),-8),e||new Pt(mF(n)))}u(s1,"gunzipSync");var t_=function(){function n(e,t){this.c=mA(),this.v=1,so.call(this,e,t)}return u(n,"Zlib"),n.prototype.push=function(e,t){so.prototype.push.call(this,e,t)},n.prototype.p=function(e,t){this.c.p(e);var i=Rc(e,this.o,this.v&&2,t&&4,!t);this.v&&(xA(i,this.o),this.v=0),t&&Ht(i,i.length-4,this.c.d()),this.ondata(i,t)},n}(),_ge=function(){function n(e,t){Jh([Kh,dF,function(){return[sr,so,t_]}],this,_A.call(this,e,t),function(i){var s=new t_(i.data);onmessage=sr(s)},10)}return u(n,"AsyncZlib"),n}();function wge(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Kh,dF,function(){return[n_]}],function(i){return cl(n_(i.data[0],i.data[1]))},4,t)}u(wge,"zlib");function n_(n,e){e||(e={});var t=mA();t.p(n);var i=Rc(n,e,2,4);return xA(i,e),Ht(i,i.length-4,t.d()),i}u(n_,"zlibSync");var r1=function(){function n(e){this.v=1,vs.call(this,e)}return u(n,"Unzlib"),n.prototype.push=function(e,t){if(vs.prototype.e.call(this,e),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0}if(t){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}vs.prototype.c.call(this,t)},n}(),_F=function(){function n(e){this.ondata=e,Jh([Zh,pF,function(){return[sr,vs,r1]}],this,0,function(){var t=new r1;onmessage=sr(t)},11)}return u(n,"AsyncUnzlib"),n}();function wF(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return Qh(n,e,[Zh,pF,function(){return[Sp]}],function(i){return cl(Sp(i.data[0],gA(i.data[1])))},5,t)}u(wF,"unzlib");function Sp(n,e){return Wp((gF(n),n.subarray(2,-4)),e)}u(Sp,"unzlibSync");var AF=function(){function n(e){this.G=i1,this.I=vs,this.Z=r1,this.ondata=e}return u(n,"Decompress"),n.prototype.push=function(e,t){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(e,t);else{if(this.p&&this.p.length){var i=new Pt(this.p.length+e.length);i.set(this.p),i.set(e,this.p.length)}else this.p=e;if(this.p.length>2){var s=this,r=u(function(){s.ondata.apply(s,arguments)},"cb");this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(r):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(r):new this.Z(r),this.s.push(this.p,t),this.p=null}}},n}(),Age=function(){function n(e){this.G=bF,this.I=wA,this.Z=_F,this.ondata=e}return u(n,"AsyncDecompress"),n.prototype.push=function(e,t){AF.prototype.push.call(this,e,t)},n}();function Mge(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";return n[0]==31&&n[1]==139&&n[2]==8?xF(n,e,t):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?AA(n,e,t):wF(n,e,t)}u(Mge,"decompress");function Sge(n,e){return n[0]==31&&n[1]==139&&n[2]==8?s1(n,e):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?ef(n,e):Sp(n,e)}u(Sge,"decompressSync");var MA=u(function(n,e,t,i){for(var s in n){var r=n[s],o=e+s;r instanceof Pt?t[o]=[r,i]:Array.isArray(r)?t[o]=[r[0],jp(i,r[1])]:MA(r,o+"/",t,i)}},"fltn"),gE=typeof TextEncoder!="undefined"&&new TextEncoder,i_=typeof TextDecoder!="undefined"&&new TextDecoder,MF=0;try{i_.decode($o,{stream:!0}),MF=1}catch{}var SF=u(function(n){for(var e="",t=0;;){var i=n[t++],s=(i>127)+(i>223)+(i>239);if(t+s>n.length)return[e,ir(n,t-1)];s?s==3?(i=((i&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,e+=String.fromCharCode(55296|i>>10,56320|i&1023)):s&1?e+=String.fromCharCode((i&31)<<6|n[t++]&63):e+=String.fromCharCode((i&15)<<12|(n[t++]&63)<<6|n[t++]&63):e+=String.fromCharCode(i)}},"dutf8"),Tge=function(){function n(e){this.ondata=e,MF?this.t=new TextDecoder:this.p=$o}return u(n,"DecodeUTF8"),n.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(t=!!t,this.t){if(this.ondata(this.t.decode(e,{stream:!0}),t),t){if(this.t.decode().length)throw"invalid utf-8 data";this.t=null}return}if(!this.p)throw"stream finished";var i=new Pt(this.p.length+e.length);i.set(this.p),i.set(e,this.p.length);var s=SF(i),r=s[0],o=s[1];if(t){if(o.length)throw"invalid utf-8 data";this.p=null}else this.p=o;this.ondata(r,t)},n}(),Cge=function(){function n(e){this.ondata=e}return u(n,"EncodeUTF8"),n.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(this.d)throw"stream finished";this.ondata(el(e),this.d=t||!1)},n}();function el(n,e){if(e){for(var t=new Pt(n.length),i=0;i<n.length;++i)t[i]=n.charCodeAt(i);return t}if(gE)return gE.encode(n);for(var s=n.length,r=new Pt(n.length+(n.length>>1)),o=0,a=u(function(h){r[o++]=h},"w"),i=0;i<s;++i){if(o+5>r.length){var l=new Pt(o+8+(s-i<<1));l.set(r),r=l}var c=n.charCodeAt(i);c<128||e?a(c):c<2048?(a(192|c>>6),a(128|c&63)):c>55295&&c<57344?(c=65536+(c&1023<<10)|n.charCodeAt(++i)&1023,a(240|c>>18),a(128|c>>12&63),a(128|c>>6&63),a(128|c&63)):(a(224|c>>12),a(128|c>>6&63),a(128|c&63))}return ir(r,0,o)}u(el,"strToU8");function SA(n,e){if(e){for(var t="",i=0;i<n.length;i+=16384)t+=String.fromCharCode.apply(null,n.subarray(i,i+16384));return t}else{if(i_)return i_.decode(n);var s=SF(n),r=s[0],o=s[1];if(o.length)throw"invalid utf-8 data";return r}}u(SA,"strFromU8");var TF=u(function(n){return n==1?3:n<6?2:n==9?1:0},"dbf"),CF=u(function(n,e){return e+30+Zi(n,e+26)+Zi(n,e+28)},"slzh"),EF=u(function(n,e,t){var i=Zi(n,e+28),s=SA(n.subarray(e+46,e+46+i),!(Zi(n,e+8)&2048)),r=e+46+i,o=Gn(n,e+20),a=t&&o==4294967295?PF(n,r):[o,Gn(n,e+24),Gn(n,e+42)],l=a[0],c=a[1],h=a[2];return[Zi(n,e+10),l,c,s,r+Zi(n,e+30)+Zi(n,e+32),h]},"zh"),PF=u(function(n,e){for(;Zi(n,e)!=1;e+=4+Zi(n,e+2));return[yb(n,e+12),yb(n,e+4),yb(n,e+20)]},"z64e"),qa=u(function(n){var e=0;if(n)for(var t in n){var i=n[t].length;if(i>65535)throw"extra field too long";e+=i+4}return e},"exfl"),Oh=u(function(n,e,t,i,s,r,o,a){var l=i.length,c=t.extra,h=a&&a.length,f=qa(c);Ht(n,e,o!=null?33639248:67324752),e+=4,o!=null&&(n[e++]=20,n[e++]=t.os),n[e]=20,e+=2,n[e++]=t.flag<<1|(r==null&&8),n[e++]=s&&8,n[e++]=t.compression&255,n[e++]=t.compression>>8;var d=new Date(t.mtime==null?Date.now():t.mtime),p=d.getFullYear()-1980;if(p<0||p>119)throw"date not in range 1980-2099";if(Ht(n,e,p<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>>1),e+=4,r!=null&&(Ht(n,e,t.crc),Ht(n,e+4,r),Ht(n,e+8,t.size)),Ht(n,e+12,l),Ht(n,e+14,f),e+=16,o!=null&&(Ht(n,e,h),Ht(n,e+6,t.attrs),Ht(n,e+10,o),e+=14),n.set(i,e),e+=l,f)for(var g in c){var m=c[g],v=m.length;Ht(n,e,+g),Ht(n,e+2,v),n.set(m,e+4),e+=4+v}return h&&(n.set(a,e),e+=h),e},"wzh"),TA=u(function(n,e,t,i,s){Ht(n,e,101010256),Ht(n,e+8,t),Ht(n,e+10,t),Ht(n,e+12,i),Ht(n,e+16,s)},"wzf"),Tp=function(){function n(e){this.filename=e,this.c=Yh(),this.size=0,this.compression=0}return u(n,"ZipPassThrough"),n.prototype.process=function(e,t){this.ondata(null,e,t)},n.prototype.push=function(e,t){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(e),this.size+=e.length,t&&(this.crc=this.c.d()),this.process(e,t||!1)},n}(),Ege=function(){function n(e,t){var i=this;t||(t={}),Tp.call(this,e),this.d=new so(t,function(s,r){i.ondata(null,s,r)}),this.compression=8,this.flag=TF(t.level)}return u(n,"ZipDeflate"),n.prototype.process=function(e,t){try{this.d.push(e,t)}catch(i){this.ondata(i,null,t)}},n.prototype.push=function(e,t){Tp.prototype.push.call(this,e,t)},n}(),Pge=function(){function n(e,t){var i=this;t||(t={}),Tp.call(this,e),this.d=new vF(t,function(s,r,o){i.ondata(s,r,o)}),this.compression=8,this.flag=TF(t.level),this.terminate=this.d.terminate}return u(n,"AsyncZipDeflate"),n.prototype.process=function(e,t){this.d.push(e,t)},n.prototype.push=function(e,t){Tp.prototype.push.call(this,e,t)},n}(),Rge=function(){function n(e){this.ondata=e,this.u=[],this.d=1}return u(n,"Zip"),n.prototype.add=function(e){var t=this;if(this.d&2)throw"stream finished";var i=el(e.filename),s=i.length,r=e.comment,o=r&&el(r),a=s!=e.filename.length||o&&r.length!=o.length,l=s+qa(e.extra)+30;if(s>65535)throw"filename too long";var c=new Pt(l);Oh(c,0,e,i,a);var h=[c],f=u(function(){for(var v=0,y=h;v<y.length;v++){var b=y[v];t.ondata(null,b,!1)}h=[]},"pAll"),d=this.d;this.d=0;var p=this.u.length,g=jp(e,{f:i,u:a,o,t:function(){e.terminate&&e.terminate()},r:function(){if(f(),d){var v=t.u[p+1];v?v.r():t.d=1}d=1}}),m=0;e.ondata=function(v,y,b){if(v)t.ondata(v,y,b),t.terminate();else if(m+=y.length,h.push(y),b){var x=new Pt(16);Ht(x,0,134695760),Ht(x,4,e.crc),Ht(x,8,m),Ht(x,12,e.size),h.push(x),g.c=m,g.b=l+m+16,g.crc=e.crc,g.size=e.size,d&&g.r(),d=1}else d&&f()},this.u.push(g)},n.prototype.end=function(){var e=this;if(this.d&2)throw this.d&1?"stream finishing":"stream finished";this.d?this.e():this.u.push({r:function(){!(e.d&1)||(e.u.splice(-1,1),e.e())},t:function(){}}),this.d=3},n.prototype.e=function(){for(var e=0,t=0,i=0,s=0,r=this.u;s<r.length;s++){var o=r[s];i+=46+o.f.length+qa(o.extra)+(o.o?o.o.length:0)}for(var a=new Pt(i+22),l=0,c=this.u;l<c.length;l++){var o=c[l];Oh(a,e,o,o.f,o.u,o.c,t,o.o),e+=46+o.f.length+qa(o.extra)+(o.o?o.o.length:0),t+=o.b}TA(a,e,this.u.length,i,t),this.ondata(null,a,!0),this.d=2},n.prototype.terminate=function(){for(var e=0,t=this.u;e<t.length;e++){var i=t[e];i.t()}this.d=2},n}();function Ige(n,e,t){if(t||(t=e,e={}),typeof t!="function")throw"no callback";var i={};MA(n,"",i,e);var s=Object.keys(i),r=s.length,o=0,a=0,l=r,c=new Array(r),h=[],f=u(function(){for(var m=0;m<h.length;++m)h[m]()},"tAll"),d=u(function(){var m=new Pt(a+22),v=o,y=a-o;a=0;for(var b=0;b<l;++b){var x=c[b];try{var w=x.c.length;Oh(m,a,x,x.f,x.u,w);var _=30+x.f.length+qa(x.extra),A=a+_;m.set(x.c,A),Oh(m,o,x,x.f,x.u,w,a,x.m),o+=16+_+(x.m?x.m.length:0),a=A+w}catch(S){return t(S,null)}}TA(m,o,c.length,y,v),t(null,m)},"cbf");r||d();for(var p=u(function(m){var v=s[m],y=i[v],b=y[0],x=y[1],w=Yh(),_=b.length;w.p(b);var A=el(v),S=A.length,M=x.comment,C=M&&el(M),I=C&&C.length,F=qa(x.extra),O=x.level==0?0:8,N=u(function(E,k){if(E)f(),t(E,null);else{var G=k.length;c[m]=jp(x,{size:_,crc:w.d(),c:k,f:A,m:C,u:S!=v.length||C&&M.length!=I,compression:O}),o+=30+S+F+G,a+=76+2*(S+F)+(I||0)+G,--r||d()}},"cbl");if(S>65535&&N("filename too long",null),!O)N(null,b);else if(_<16e4)try{N(null,Xp(b,x))}catch(E){N(E,null)}else h.push(yF(b,x,N))},"_loop_1"),g=0;g<l;++g)p(g);return f}u(Ige,"zip");function Dge(n,e){e||(e={});var t={},i=[];MA(n,"",t,e);var s=0,r=0;for(var o in t){var a=t[o],l=a[0],c=a[1],h=c.level==0?0:8,f=el(o),d=f.length,p=c.comment,g=p&&el(p),m=g&&g.length,v=qa(c.extra);if(d>65535)throw"filename too long";var y=h?Xp(l,c):l,b=y.length,x=Yh();x.p(l),i.push(jp(c,{size:l.length,crc:x.d(),c:y,f,m:g,u:d!=o.length||g&&p.length!=m,o:s,compression:h})),s+=30+d+v+b,r+=76+2*(d+v)+(m||0)+b}for(var w=new Pt(r+22),_=s,A=r-s,S=0;S<i.length;++S){var f=i[S];Oh(w,f.o,f,f.f,f.u,f.c.length);var M=30+f.f.length+qa(f.extra);w.set(f.c,f.o+M),Oh(w,s,f,f.f,f.u,f.c.length,f.o,f.m),s+=16+M+(f.m?f.m.length:0)}return TA(w,s,i.length,A,_),w}u(Dge,"zipSync");var RF=function(){function n(){}return u(n,"UnzipPassThrough"),n.prototype.push=function(e,t){this.ondata(null,e,t)},n.compression=0,n}(),Lge=function(){function n(){var e=this;this.i=new vs(function(t,i){e.ondata(null,t,i)})}return u(n,"UnzipInflate"),n.prototype.push=function(e,t){try{this.i.push(e,t)}catch(i){this.ondata(i,e,t)}},n.compression=8,n}(),Oge=function(){function n(e,t){var i=this;t<32e4?this.i=new vs(function(s,r){i.ondata(null,s,r)}):(this.i=new wA(function(s,r,o){i.ondata(s,r,o)}),this.terminate=this.i.terminate)}return u(n,"AsyncUnzipInflate"),n.prototype.push=function(e,t){this.i.terminate&&(e=ir(e,0)),this.i.push(e,t)},n.compression=8,n}(),Fge=function(){function n(e){this.onfile=e,this.k=[],this.o={0:RF},this.p=$o}return u(n,"Unzip"),n.prototype.push=function(e,t){var i=this;if(!this.onfile)throw"no callback";if(!this.p)throw"stream finished";if(this.c>0){var s=Math.min(this.c,e.length),r=e.subarray(0,s);if(this.c-=s,this.d?this.d.push(r,!this.c):this.k[0].push(r),e=e.subarray(s),e.length)return this.push(e,t)}else{var o=0,a=0,l=void 0,c=void 0;this.p.length?e.length?(c=new Pt(this.p.length+e.length),c.set(this.p),c.set(e,this.p.length)):c=this.p:c=e;for(var h=c.length,f=this.c,d=f&&this.d,p=u(function(){var y,b=Gn(c,a);if(b==67324752){o=1,l=a,g.d=null,g.c=0;var x=Zi(c,a+6),w=Zi(c,a+8),_=x&2048,A=x&8,S=Zi(c,a+26),M=Zi(c,a+28);if(h>a+30+S+M){var C=[];g.k.unshift(C),o=2;var I=Gn(c,a+18),F=Gn(c,a+22),O=SA(c.subarray(a+30,a+=30+S),!_);I==4294967295?(y=A?[-2]:PF(c,a),I=y[0],F=y[1]):A&&(I=-1),a+=M,g.c=I;var N,E={name:O,compression:w,start:function(){if(!E.ondata)throw"no callback";if(!I)E.ondata(null,$o,!0);else{var k=i.o[w];if(!k)throw"unknown compression type "+w;N=I<0?new k(O):new k(O,I,F),N.ondata=function(j,ie,K){E.ondata(j,ie,K)};for(var G=0,X=C;G<X.length;G++){var te=X[G];N.push(te,!1)}i.k[0]==C&&i.c?i.d=N:N.push($o,!0)}},terminate:function(){N&&N.terminate&&N.terminate()}};I>=0&&(E.size=I,E.originalSize=F),g.onfile(E)}return"break"}else if(f){if(b==134695760)return l=a+=12+(f==-2&&8),o=3,g.c=0,"break";if(b==33639248)return l=a-=4,o=3,g.c=0,"break"}},"_loop_2"),g=this;a<h-4;++a){var m=p();if(m==="break")break}if(this.p=$o,f<0){var v=o?c.subarray(0,l-12-(f==-2&&8)-(Gn(c,l-16)==134695760&&4)):c.subarray(0,a);d?d.push(v,!!o):this.k[+(o==2)].push(v)}if(o&2)return this.push(c.subarray(a),t);this.p=c.subarray(a)}if(t){if(this.c)throw"invalid zip file";this.p=null}},n.prototype.register=function(e){this.o[e.compression]=e},n}();function Nge(n,e){if(typeof e!="function")throw"no callback";for(var t=[],i=u(function(){for(var d=0;d<t.length;++d)t[d]()},"tAll"),s={},r=n.length-22;Gn(n,r)!=101010256;--r)if(!r||n.length-r>65558){e("invalid zip file",null);return}var o=Zi(n,r+8);o||e(null,{});var a=o,l=Gn(n,r+16),c=l==4294967295;if(c){if(r=Gn(n,r-12),Gn(n,r)!=101075792){e("invalid zip file",null);return}a=o=Gn(n,r+32),l=Gn(n,r+48)}for(var h=u(function(d){var p=EF(n,l,c),g=p[0],m=p[1],v=p[2],y=p[3],b=p[4],x=p[5],w=CF(n,x);l=b;var _=u(function(S,M){S?(i(),e(S,null)):(s[y]=M,--o||e(null,s))},"cbl");if(!g)_(null,ir(n,w,w+m));else if(g==8){var A=n.subarray(w,w+m);if(m<32e4)try{_(null,ef(A,new Pt(v)))}catch(S){_(S,null)}else t.push(AA(A,{size:v},_))}else _("unknown compression type "+g,null)},"_loop_3"),f=0;f<a;++f)h();return i}u(Nge,"unzip");function kge(n){for(var e={},t=n.length-22;Gn(n,t)!=101010256;--t)if(!t||n.length-t>65558)throw"invalid zip file";var i=Zi(n,t+8);if(!i)return{};var s=Gn(n,t+16),r=s==4294967295;if(r){if(t=Gn(n,t-12),Gn(n,t)!=101075792)throw"invalid zip file";i=Gn(n,t+32),s=Gn(n,t+48)}for(var o=0;o<i;++o){var a=EF(n,s,r),l=a[0],c=a[1],h=a[2],f=a[3],d=a[4],p=a[5],g=CF(n,p);if(s=d,!l)e[f]=ir(n,g,g+c);else if(l==8)e[f]=ef(n.subarray(g,g+c),new Pt(h));else throw"unknown compression type "+l}return e}u(kge,"unzipSync");var zge=Object.freeze(Object.defineProperty({__proto__:null,Deflate:so,AsyncDeflate:vF,deflate:yF,deflateSync:Xp,Inflate:vs,AsyncInflate:wA,inflate:AA,inflateSync:ef,Gzip:t1,AsyncGzip:pE,gzip:mE,gzipSync:n1,Gunzip:i1,AsyncGunzip:bF,gunzip:xF,gunzipSync:s1,Zlib:t_,AsyncZlib:_ge,zlib:wge,zlibSync:n_,Unzlib:r1,AsyncUnzlib:_F,unzlib:wF,unzlibSync:Sp,compress:mE,AsyncCompress:pE,compressSync:n1,Compress:t1,Decompress:AF,AsyncDecompress:Age,decompress:Mge,decompressSync:Sge,DecodeUTF8:Tge,EncodeUTF8:Cge,strToU8:el,strFromU8:SA,ZipPassThrough:Tp,ZipDeflate:Ege,AsyncZipDeflate:Pge,Zip:Rge,zip:Ige,zipSync:Dge,UnzipPassThrough:RF,UnzipInflate:Lge,AsyncUnzipInflate:Oge,Unzip:Fge,unzip:Nge,unzipSync:kge},Symbol.toStringTag,{value:"Module"}));function IF(n,e,t){const i=t.length-n-1;if(e>=t[i])return i-1;if(e<=t[n])return n;let s=n,r=i,o=Math.floor((s+r)/2);for(;e<t[o]||e>=t[o+1];)e<t[o]?r=o:s=o,o=Math.floor((s+r)/2);return o}u(IF,"findSpan");function Bge(n,e,t,i){const s=[],r=[],o=[];s[0]=1;for(let a=1;a<=t;++a){r[a]=e-i[n+1-a],o[a]=i[n+a]-e;let l=0;for(let c=0;c<a;++c){const h=o[c+1],f=r[a-c],d=s[c]/(h+f);s[c]=l+h*d,l=f*d}s[a]=l}return s}u(Bge,"calcBasisFunctions");function Uge(n,e,t,i){const s=IF(n,i,e),r=Bge(s,i,n,e),o=new ut(0,0,0,0);for(let a=0;a<=n;++a){const l=t[s-n+a],c=r[a],h=l.w*c;o.x+=l.x*h,o.y+=l.y*h,o.z+=l.z*h,o.w+=l.w*c}return o}u(Uge,"calcBSplinePoint");function $ge(n,e,t,i,s){const r=[];for(let f=0;f<=t;++f)r[f]=0;const o=[];for(let f=0;f<=i;++f)o[f]=r.slice(0);const a=[];for(let f=0;f<=t;++f)a[f]=r.slice(0);a[0][0]=1;const l=r.slice(0),c=r.slice(0);for(let f=1;f<=t;++f){l[f]=e-s[n+1-f],c[f]=s[n+f]-e;let d=0;for(let p=0;p<f;++p){const g=c[p+1],m=l[f-p];a[f][p]=g+m;const v=a[p][f-1]/a[f][p];a[p][f]=d+g*v,d=m*v}a[f][f]=d}for(let f=0;f<=t;++f)o[0][f]=a[f][t];for(let f=0;f<=t;++f){let d=0,p=1;const g=[];for(let m=0;m<=t;++m)g[m]=r.slice(0);g[0][0]=1;for(let m=1;m<=i;++m){let v=0;const y=f-m,b=t-m;f>=m&&(g[p][0]=g[d][0]/a[b+1][y],v=g[p][0]*a[y][b]);const x=y>=-1?1:-y,w=f-1<=b?m-1:t-f;for(let A=x;A<=w;++A)g[p][A]=(g[d][A]-g[d][A-1])/a[b+1][y+A],v+=g[p][A]*a[y+A][b];f<=b&&(g[p][m]=-g[d][m-1]/a[b+1][f],v+=g[p][m]*a[f][b]),o[m][f]=v;const _=d;d=p,p=_}}let h=t;for(let f=1;f<=i;++f){for(let d=0;d<=t;++d)o[f][d]*=h;h*=t-f}return o}u($ge,"calcBasisFunctionDerivatives");function Vge(n,e,t,i,s){const r=s<n?s:n,o=[],a=IF(n,i,e),l=$ge(a,i,n,r,e),c=[];for(let h=0;h<t.length;++h){const f=t[h].clone(),d=f.w;f.x*=d,f.y*=d,f.z*=d,c[h]=f}for(let h=0;h<=r;++h){const f=c[a-n].clone().multiplyScalar(l[h][0]);for(let d=1;d<=n;++d)f.add(c[a-n+d].clone().multiplyScalar(l[h][d]));o[h]=f}for(let h=r+1;h<=s+1;++h)o[h]=new ut(0,0,0);return o}u(Vge,"calcBSplineDerivatives");function Hge(n,e){let t=1;for(let s=2;s<=n;++s)t*=s;let i=1;for(let s=2;s<=e;++s)i*=s;for(let s=2;s<=n-e;++s)i*=s;return t/i}u(Hge,"calcKoverI");function Gge(n){const e=n.length,t=[],i=[];for(let r=0;r<e;++r){const o=n[r];t[r]=new P(o.x,o.y,o.z),i[r]=o.w}const s=[];for(let r=0;r<e;++r){const o=t[r].clone();for(let a=1;a<=r;++a)o.sub(s[r-a].clone().multiplyScalar(Hge(r,a)*i[a]));s[r]=o.divideScalar(i[0])}return s}u(Gge,"calcRationalCurveDerivatives");function Wge(n,e,t,i,s){const r=Vge(n,e,t,i,s);return Gge(r)}u(Wge,"calcNURBSDerivatives");class s_ extends H_{constructor(e,t,i,s,r){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=s||0,this.endKnot=r||this.knots.length-1;for(let o=0;o<i.length;++o){const a=i[o];this.controlPoints[o]=new ut(a.x,a.y,a.z,a.w)}}getPoint(e,t=new P){const i=t,s=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=Uge(this.degree,this.knots,this.controlPoints,s);return r.w!==1&&r.divideScalar(r.w),i.set(r.x,r.y,r.z)}getTangent(e,t=new P){const i=t,s=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Wge(this.degree,this.knots,this.controlPoints,s,1);return i.copy(r[1]).normalize(),i}}u(s_,"NURBSCurve");let St,$n,hs;class DF extends ia{constructor(e){super(e)}load(e,t,i,s){const r=this,o=r.path===""?Mr.extractUrlBase(e):r.path,a=new Bh(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(l){try{t(r.parse(l,o))}catch(c){s?s(c):console.error(c),r.manager.itemError(e)}},i,s)}parse(e,t){if(jge(e))St=new kF().parse(e);else{const s=UF(e);if(!Xge(s))throw new Error("THREE.FBXLoader: Unknown format.");if(vE(s)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+vE(s));St=new NF().parse(s)}const i=new Op(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new LF(i,this.manager).parse(St)}}u(DF,"FBXLoader");class LF{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){$n=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),i=this.parseMaterials(t),s=this.parseDeformers(),r=new OF().parse(s);return this.parseScene(s,r,i),hs}parseConnections(){const e=new Map;return"Connections"in St&&St.Connections.connections.forEach(function(i){const s=i[0],r=i[1],o=i[2];e.has(s)||e.set(s,{parents:[],children:[]});const a={ID:r,relationship:o};e.get(s).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const l={ID:s,relationship:o};e.get(r).children.push(l)}),e}parseImages(){const e={},t={};if("Video"in St.Objects){const i=St.Objects.Video;for(const s in i){const r=i[s],o=parseInt(s);if(e[o]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,l=typeof r.Content=="string"&&r.Content!=="";if(a||l){const c=this.parseImage(i[s]);t[r.RelativeFilename||r.Filename]=c}}}}for(const i in e){const s=e[i];t[s]!==void 0?e[i]=t[s]:e[i]=e[i].split("\\").pop()}return e}parseImage(e){const t=e.Content,i=e.RelativeFilename||e.Filename,s=i.slice(i.lastIndexOf(".")+1).toLowerCase();let r;switch(s){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",i),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const o=new Uint8Array(t);return window.URL.createObjectURL(new Blob([o],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in St.Objects){const i=St.Objects.Texture;for(const s in i){const r=this.parseTexture(i[s],e);t.set(parseInt(s),r)}}return t}parseTexture(e,t){const i=this.loadTexture(e,t);i.ID=e.id,i.name=e.attrName;const s=e.WrapModeU,r=e.WrapModeV,o=s!==void 0?s.value:0,a=r!==void 0?r.value:0;if(i.wrapS=o===0?Qi:Wn,i.wrapT=a===0?Qi:Wn,"Scaling"in e){const l=e.Scaling.value;i.repeat.x=l[0],i.repeat.y=l[1]}if("Translation"in e){const l=e.Translation.value;i.offset.x=l[0],i.offset.y=l[1]}return i}loadTexture(e,t){let i;const s=this.textureLoader.path,r=$n.get(e.id).children;r!==void 0&&r.length>0&&t[r[0].ID]!==void 0&&(i=t[r[0].ID],(i.indexOf("blob:")===0||i.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let o;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const l=this.manager.getHandler(".tga");l===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),o=new ui):(l.setPath(this.textureLoader.path),o=l.load(i))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),o=new ui):o=this.textureLoader.load(i);return this.textureLoader.setPath(s),o}parseMaterials(e){const t=new Map;if("Material"in St.Objects){const i=St.Objects.Material;for(const s in i){const r=this.parseMaterial(i[s],e);r!==null&&t.set(parseInt(s),r)}}return t}parseMaterial(e,t){const i=e.id,s=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!$n.has(i))return null;const o=this.parseParameters(e,t,i);let a;switch(r.toLowerCase()){case"phong":a=new $d;break;case"lambert":a=new G_;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new $d;break}return a.setValues(o),a.name=s,a}parseParameters(e,t,i){const s={};e.BumpFactor&&(s.bumpScale=e.BumpFactor.value),e.Diffuse?s.color=new Ce().fromArray(e.Diffuse.value):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(s.color=new Ce().fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(s.displacementScale=e.DisplacementFactor.value),e.Emissive?s.emissive=new Ce().fromArray(e.Emissive.value):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(s.emissive=new Ce().fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(s.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(s.opacity=parseFloat(e.Opacity.value)),s.opacity<1&&(s.transparent=!0),e.ReflectionFactor&&(s.reflectivity=e.ReflectionFactor.value),e.Shininess&&(s.shininess=e.Shininess.value),e.Specular?s.specular=new Ce().fromArray(e.Specular.value):e.SpecularColor&&e.SpecularColor.type==="Color"&&(s.specular=new Ce().fromArray(e.SpecularColor.value));const r=this;return $n.get(i).children.forEach(function(o){const a=o.relationship;switch(a){case"Bump":s.bumpMap=r.getTexture(t,o.ID);break;case"Maya|TEX_ao_map":s.aoMap=r.getTexture(t,o.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":s.map=r.getTexture(t,o.ID),s.map!==void 0&&(s.map.encoding=Lt);break;case"DisplacementColor":s.displacementMap=r.getTexture(t,o.ID);break;case"EmissiveColor":s.emissiveMap=r.getTexture(t,o.ID),s.emissiveMap!==void 0&&(s.emissiveMap.encoding=Lt);break;case"NormalMap":case"Maya|TEX_normal_map":s.normalMap=r.getTexture(t,o.ID);break;case"ReflectionColor":s.envMap=r.getTexture(t,o.ID),s.envMap!==void 0&&(s.envMap.mapping=$0,s.envMap.encoding=Lt);break;case"SpecularColor":s.specularMap=r.getTexture(t,o.ID),s.specularMap!==void 0&&(s.specularMap.encoding=Lt);break;case"TransparentColor":case"TransparencyFactor":s.alphaMap=r.getTexture(t,o.ID),s.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),s}getTexture(e,t){return"LayeredTexture"in St.Objects&&t in St.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=$n.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in St.Objects){const i=St.Objects.Deformer;for(const s in i){const r=i[s],o=$n.get(parseInt(s));if(r.attrType==="Skin"){const a=this.parseSkeleton(o,i);a.ID=s,o.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=o.parents[0].ID,e[s]=a}else if(r.attrType==="BlendShape"){const a={id:s};a.rawTargets=this.parseMorphTargets(o,i),a.id=s,o.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[s]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const i=[];return e.children.forEach(function(s){const r=t[s.ID];if(r.attrType!=="Cluster")return;const o={ID:s.ID,indices:[],weights:[],transformLink:new me().fromArray(r.TransformLink.a)};"Indexes"in r&&(o.indices=r.Indexes.a,o.weights=r.Weights.a),i.push(o)}),{rawBones:i,bones:[]}}parseMorphTargets(e,t){const i=[];for(let s=0;s<e.children.length;s++){const r=e.children[s],o=t[r.ID],a={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if(o.attrType!=="BlendShapeChannel")return;a.geoID=$n.get(parseInt(r.ID)).children.filter(function(l){return l.relationship===void 0})[0].ID,i.push(a)}return i}parseScene(e,t,i){hs=new _i;const s=this.parseModels(e.skeletons,t,i),r=St.Objects.Model,o=this;s.forEach(function(l){const c=r[l.ID];o.setLookAtProperties(l,c),$n.get(l.ID).parents.forEach(function(f){const d=s.get(f.ID);d!==void 0&&d.add(l)}),l.parent===null&&hs.add(l)}),this.bindSkeleton(e.skeletons,t,s),this.createAmbientLight(),hs.traverse(function(l){if(l.userData.transformData){l.parent&&(l.userData.transformData.parentMatrix=l.parent.matrix,l.userData.transformData.parentMatrixWorld=l.parent.matrixWorld);const c=zF(l.userData.transformData);l.applyMatrix4(c),l.updateWorldMatrix()}});const a=new FF().parse();hs.children.length===1&&hs.children[0].isGroup&&(hs.children[0].animations=a,hs=hs.children[0]),hs.animations=a}parseModels(e,t,i){const s=new Map,r=St.Objects.Model;for(const o in r){const a=parseInt(o),l=r[o],c=$n.get(a);let h=this.buildSkeleton(c,e,a,l.attrName);if(!h){switch(l.attrType){case"Camera":h=this.createCamera(c);break;case"Light":h=this.createLight(c);break;case"Mesh":h=this.createMesh(c,t,i);break;case"NurbsCurve":h=this.createCurve(c,t);break;case"LimbNode":case"Root":h=new rp;break;case"Null":default:h=new _i;break}h.name=l.attrName?_t.sanitizeNodeName(l.attrName):"",h.ID=a}this.getTransformData(h,l),s.set(a,h)}return s}buildSkeleton(e,t,i,s){let r=null;return e.parents.forEach(function(o){for(const a in t){const l=t[a];l.rawBones.forEach(function(c,h){if(c.ID===o.ID){const f=r;r=new rp,r.matrixWorld.copy(c.transformLink),r.name=s?_t.sanitizeNodeName(s):"",r.ID=i,l.bones[h]=r,f!==null&&r.add(f)}})}}),r}createCamera(e){let t,i;if(e.children.forEach(function(s){const r=St.Objects.NodeAttribute[s.ID];r!==void 0&&(i=r)}),i===void 0)t=new It;else{let s=0;i.CameraProjectionType!==void 0&&i.CameraProjectionType.value===1&&(s=1);let r=1;i.NearPlane!==void 0&&(r=i.NearPlane.value/1e3);let o=1e3;i.FarPlane!==void 0&&(o=i.FarPlane.value/1e3);let a=window.innerWidth,l=window.innerHeight;i.AspectWidth!==void 0&&i.AspectHeight!==void 0&&(a=i.AspectWidth.value,l=i.AspectHeight.value);const c=a/l;let h=45;i.FieldOfView!==void 0&&(h=i.FieldOfView.value);const f=i.FocalLength?i.FocalLength.value:null;switch(s){case 0:t=new li(h,c,r,o),f!==null&&t.setFocalLength(f);break;case 1:t=new rl(-a/2,a/2,l/2,-l/2,r,o);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+s+"."),t=new It;break}}return t}createLight(e){let t,i;if(e.children.forEach(function(s){const r=St.Objects.NodeAttribute[s.ID];r!==void 0&&(i=r)}),i===void 0)t=new It;else{let s;i.LightType===void 0?s=0:s=i.LightType.value;let r=16777215;i.Color!==void 0&&(r=new Ce().fromArray(i.Color.value));let o=i.Intensity===void 0?1:i.Intensity.value/100;i.CastLightOnObject!==void 0&&i.CastLightOnObject.value===0&&(o=0);let a=0;i.FarAttenuationEnd!==void 0&&(i.EnableFarAttenuation!==void 0&&i.EnableFarAttenuation.value===0?a=0:a=i.FarAttenuationEnd.value);const l=1;switch(s){case 0:t=new op(r,o,a,l);break;case 1:t=new Fp(r,o);break;case 2:let c=Math.PI/3;i.InnerAngle!==void 0&&(c=Yi.degToRad(i.InnerAngle.value));let h=0;i.OuterAngle!==void 0&&(h=Yi.degToRad(i.OuterAngle.value),h=Math.max(h,1)),t=new U1(r,o,a,c,h,l);break;default:console.warn("THREE.FBXLoader: Unknown light type "+i.LightType.value+", defaulting to a PointLight."),t=new op(r,o);break}i.CastShadows!==void 0&&i.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,i){let s,r=null,o=null;const a=[];return e.children.forEach(function(l){t.has(l.ID)&&(r=t.get(l.ID)),i.has(l.ID)&&a.push(i.get(l.ID))}),a.length>1?o=a:a.length>0?o=a[0]:(o=new $d({color:13421772}),a.push(o)),"color"in r.attributes&&a.forEach(function(l){l.vertexColors=!0}),r.FBX_Deformer?(s=new V_(r,o),s.normalizeSkinWeights()):s=new We(r,o),s}createCurve(e,t){const i=e.children.reduce(function(r,o){return t.has(o.ID)&&(r=t.get(o.ID)),r},null),s=new Bi({color:3342591,linewidth:1});return new er(i,s)}getTransformData(e,t){const i={};"InheritType"in t&&(i.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?i.eulerOrder=BF(t.RotationOrder.value):i.eulerOrder="ZYX","Lcl_Translation"in t&&(i.translation=t.Lcl_Translation.value),"PreRotation"in t&&(i.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(i.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(i.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(i.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(i.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(i.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(i.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(i.rotationPivot=t.RotationPivot.value),e.userData.transformData=i}setLookAtProperties(e,t){"LookAtProperty"in t&&$n.get(e.ID).children.forEach(function(s){if(s.relationship==="LookAtProperty"){const r=St.Objects.Model[s.ID];if("Lcl_Translation"in r){const o=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(o),hs.add(e.target)):e.lookAt(new P().fromArray(o))}}})}bindSkeleton(e,t,i){const s=this.parsePoseNodes();for(const r in e){const o=e[r];$n.get(parseInt(o.ID)).parents.forEach(function(l){if(t.has(l.ID)){const c=l.ID;$n.get(c).parents.forEach(function(f){i.has(f.ID)&&i.get(f.ID).bind(new Lp(o.bones),s[f.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in St.Objects){const t=St.Objects.Pose;for(const i in t)if(t[i].attrType==="BindPose"&&t[i].NbPoseNodes>0){const s=t[i].PoseNode;Array.isArray(s)?s.forEach(function(r){e[r.Node]=new me().fromArray(r.Matrix.a)}):e[s.Node]=new me().fromArray(s.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in St&&"AmbientColor"in St.GlobalSettings){const e=St.GlobalSettings.AmbientColor.value,t=e[0],i=e[1],s=e[2];if(t!==0||i!==0||s!==0){const r=new Ce(t,i,s);hs.add(new $1(r,1))}}}}u(LF,"FBXTreeParser");class OF{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in St.Objects){const i=St.Objects.Geometry;for(const s in i){const r=$n.get(parseInt(s)),o=this.parseGeometry(r,i[s],e);t.set(parseInt(s),o)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,i){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,i);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,i){const s=i.skeletons,r=[],o=e.parents.map(function(f){return St.Objects.Model[f.ID]});if(o.length===0)return;const a=e.children.reduce(function(f,d){return s[d.ID]!==void 0&&(f=s[d.ID]),f},null);e.children.forEach(function(f){i.morphTargets[f.ID]!==void 0&&r.push(i.morphTargets[f.ID])});const l=o[0],c={};"RotationOrder"in l&&(c.eulerOrder=BF(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);const h=zF(c);return this.genGeometry(t,a,r,h)}genGeometry(e,t,i,s){const r=new Je;e.attrName&&(r.name=e.attrName);const o=this.parseGeoNode(e,t),a=this.genBuffers(o),l=new Ve(a.vertex,3);if(l.applyMatrix4(s),r.setAttribute("position",l),a.colors.length>0&&r.setAttribute("color",new Ve(a.colors,3)),t&&(r.setAttribute("skinIndex",new R1(a.weightsIndices,4)),r.setAttribute("skinWeight",new Ve(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const c=new ki().getNormalMatrix(s),h=new Ve(a.normal,3);h.applyNormalMatrix(c),r.setAttribute("normal",h)}if(a.uvs.forEach(function(c,h){let f="uv"+(h+1).toString();h===0&&(f="uv"),r.setAttribute(f,new Ve(a.uvs[h],2))}),o.material&&o.material.mappingType!=="AllSame"){let c=a.materialIndex[0],h=0;if(a.materialIndex.forEach(function(f,d){f!==c&&(r.addGroup(h,d-h,c),c=f,h=d)}),r.groups.length>0){const f=r.groups[r.groups.length-1],d=f.start+f.count;d!==a.materialIndex.length&&r.addGroup(d,a.materialIndex.length-d,c)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,i,s),r}parseGeoNode(e,t){const i={};if(i.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],i.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(i.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(i.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(i.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){i.uv=[];let s=0;for(;e.LayerElementUV[s];)e.LayerElementUV[s].UV&&i.uv.push(this.parseUVs(e.LayerElementUV[s])),s++}return i.weightTable={},t!==null&&(i.skeleton=t,t.rawBones.forEach(function(s,r){s.indices.forEach(function(o,a){i.weightTable[o]===void 0&&(i.weightTable[o]=[]),i.weightTable[o].push({id:r,weight:s.weights[a]})})})),i}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let i=0,s=0,r=!1,o=[],a=[],l=[],c=[],h=[],f=[];const d=this;return e.vertexIndices.forEach(function(p,g){let m,v=!1;p<0&&(p=p^-1,v=!0);let y=[],b=[];if(o.push(p*3,p*3+1,p*3+2),e.color){const x=Sg(g,i,p,e.color);l.push(x[0],x[1],x[2])}if(e.skeleton){if(e.weightTable[p]!==void 0&&e.weightTable[p].forEach(function(x){b.push(x.weight),y.push(x.id)}),b.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const x=[0,0,0,0],w=[0,0,0,0];b.forEach(function(_,A){let S=_,M=y[A];w.forEach(function(C,I,F){if(S>C){F[I]=S,S=C;const O=x[I];x[I]=M,M=O}})}),y=x,b=w}for(;b.length<4;)b.push(0),y.push(0);for(let x=0;x<4;++x)h.push(b[x]),f.push(y[x])}if(e.normal){const x=Sg(g,i,p,e.normal);a.push(x[0],x[1],x[2])}e.material&&e.material.mappingType!=="AllSame"&&(m=Sg(g,i,p,e.material)[0],m<0&&(d.negativeMaterialIndices=!0,m=0)),e.uv&&e.uv.forEach(function(x,w){const _=Sg(g,i,p,x);c[w]===void 0&&(c[w]=[]),c[w].push(_[0]),c[w].push(_[1])}),s++,v&&(d.genFace(t,e,o,m,a,l,c,h,f,s),i++,s=0,o=[],a=[],l=[],c=[],h=[],f=[])}),t}genFace(e,t,i,s,r,o,a,l,c,h){for(let f=2;f<h;f++)e.vertex.push(t.vertexPositions[i[0]]),e.vertex.push(t.vertexPositions[i[1]]),e.vertex.push(t.vertexPositions[i[2]]),e.vertex.push(t.vertexPositions[i[(f-1)*3]]),e.vertex.push(t.vertexPositions[i[(f-1)*3+1]]),e.vertex.push(t.vertexPositions[i[(f-1)*3+2]]),e.vertex.push(t.vertexPositions[i[f*3]]),e.vertex.push(t.vertexPositions[i[f*3+1]]),e.vertex.push(t.vertexPositions[i[f*3+2]]),t.skeleton&&(e.vertexWeights.push(l[0]),e.vertexWeights.push(l[1]),e.vertexWeights.push(l[2]),e.vertexWeights.push(l[3]),e.vertexWeights.push(l[(f-1)*4]),e.vertexWeights.push(l[(f-1)*4+1]),e.vertexWeights.push(l[(f-1)*4+2]),e.vertexWeights.push(l[(f-1)*4+3]),e.vertexWeights.push(l[f*4]),e.vertexWeights.push(l[f*4+1]),e.vertexWeights.push(l[f*4+2]),e.vertexWeights.push(l[f*4+3]),e.weightsIndices.push(c[0]),e.weightsIndices.push(c[1]),e.weightsIndices.push(c[2]),e.weightsIndices.push(c[3]),e.weightsIndices.push(c[(f-1)*4]),e.weightsIndices.push(c[(f-1)*4+1]),e.weightsIndices.push(c[(f-1)*4+2]),e.weightsIndices.push(c[(f-1)*4+3]),e.weightsIndices.push(c[f*4]),e.weightsIndices.push(c[f*4+1]),e.weightsIndices.push(c[f*4+2]),e.weightsIndices.push(c[f*4+3])),t.color&&(e.colors.push(o[0]),e.colors.push(o[1]),e.colors.push(o[2]),e.colors.push(o[(f-1)*3]),e.colors.push(o[(f-1)*3+1]),e.colors.push(o[(f-1)*3+2]),e.colors.push(o[f*3]),e.colors.push(o[f*3+1]),e.colors.push(o[f*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(s),e.materialIndex.push(s),e.materialIndex.push(s)),t.normal&&(e.normal.push(r[0]),e.normal.push(r[1]),e.normal.push(r[2]),e.normal.push(r[(f-1)*3]),e.normal.push(r[(f-1)*3+1]),e.normal.push(r[(f-1)*3+2]),e.normal.push(r[f*3]),e.normal.push(r[f*3+1]),e.normal.push(r[f*3+2])),t.uv&&t.uv.forEach(function(d,p){e.uvs[p]===void 0&&(e.uvs[p]=[]),e.uvs[p].push(a[p][0]),e.uvs[p].push(a[p][1]),e.uvs[p].push(a[p][(f-1)*2]),e.uvs[p].push(a[p][(f-1)*2+1]),e.uvs[p].push(a[p][f*2]),e.uvs[p].push(a[p][f*2+1])})}addMorphTargets(e,t,i,s){if(i.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;i.forEach(function(o){o.rawTargets.forEach(function(a){const l=St.Objects.Geometry[a.geoID];l!==void 0&&r.genMorphGeometry(e,t,l,s,a.name)})})}genMorphGeometry(e,t,i,s,r){const o=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=i.Vertices!==void 0?i.Vertices.a:[],l=i.Indexes!==void 0?i.Indexes.a:[],c=e.attributes.position.count*3,h=new Float32Array(c);for(let g=0;g<l.length;g++){const m=l[g]*3;h[m]=a[g*3],h[m+1]=a[g*3+1],h[m+2]=a[g*3+2]}const f={vertexIndices:o,vertexPositions:h},d=this.genBuffers(f),p=new Ve(d.vertex,3);p.name=r||i.attrName,p.applyMatrix4(s),e.morphAttributes.position.push(p)}parseNormals(e){const t=e.MappingInformationType,i=e.ReferenceInformationType,s=e.Normals.a;let r=[];return i==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:s,indices:r,mappingType:t,referenceType:i}}parseUVs(e){const t=e.MappingInformationType,i=e.ReferenceInformationType,s=e.UV.a;let r=[];return i==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:s,indices:r,mappingType:t,referenceType:i}}parseVertexColors(e){const t=e.MappingInformationType,i=e.ReferenceInformationType,s=e.Colors.a;let r=[];return i==="IndexToDirect"&&(r=e.ColorIndex.a),{dataSize:4,buffer:s,indices:r,mappingType:t,referenceType:i}}parseMaterialIndices(e){const t=e.MappingInformationType,i=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:i};const s=e.Materials.a,r=[];for(let o=0;o<s.length;++o)r.push(o);return{dataSize:1,buffer:s,indices:r,mappingType:t,referenceType:i}}parseNurbsGeometry(e){if(s_===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new Je;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new Je;const i=t-1,s=e.KnotVector.a,r=[],o=e.Points.a;for(let f=0,d=o.length;f<d;f+=4)r.push(new ut().fromArray(o,f));let a,l;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=i,l=s.length-1-a;for(let f=0;f<i;++f)r.push(r[f])}const h=new s_(i,s,r,a,l).getPoints(r.length*12);return new Je().setFromPoints(h)}}u(OF,"GeometryParser");class FF{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const i in t){const s=t[i],r=this.addClip(s);e.push(r)}return e}parseClips(){if(St.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=St.Objects.AnimationCurveNode,t=new Map;for(const i in e){const s=e[i];if(s.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:s.id,attr:s.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=St.Objects.AnimationCurve;for(const i in t){const s={id:t[i].id,times:t[i].KeyTime.a.map(qge),values:t[i].KeyValueFloat.a},r=$n.get(s.id);if(r!==void 0){const o=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(o).curves.x=s:a.match(/Y/)?e.get(o).curves.y=s:a.match(/Z/)?e.get(o).curves.z=s:a.match(/d|DeformPercent/)&&e.has(o)&&(e.get(o).curves.morph=s)}}}parseAnimationLayers(e){const t=St.Objects.AnimationLayer,i=new Map;for(const s in t){const r=[],o=$n.get(parseInt(s));o!==void 0&&(o.children.forEach(function(l,c){if(e.has(l.ID)){const h=e.get(l.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(r[c]===void 0){const f=$n.get(l.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(f!==void 0){const d=St.Objects.Model[f.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",l);return}const p={modelName:d.attrName?_t.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};hs.traverse(function(g){g.ID===d.id&&(p.transform=g.matrix,g.userData.transformData&&(p.eulerOrder=g.userData.transformData.eulerOrder))}),p.transform||(p.transform=new me),"PreRotation"in d&&(p.preRotation=d.PreRotation.value),"PostRotation"in d&&(p.postRotation=d.PostRotation.value),r[c]=p}}r[c]&&(r[c][h.attr]=h)}else if(h.curves.morph!==void 0){if(r[c]===void 0){const f=$n.get(l.ID).parents.filter(function(y){return y.relationship!==void 0})[0].ID,d=$n.get(f).parents[0].ID,p=$n.get(d).parents[0].ID,g=$n.get(p).parents[0].ID,m=St.Objects.Model[g],v={modelName:m.attrName?_t.sanitizeNodeName(m.attrName):"",morphName:St.Objects.Deformer[f].attrName};r[c]=v}r[c][h.attr]=h}}}),i.set(parseInt(s),r))}return i}parseAnimStacks(e){const t=St.Objects.AnimationStack,i={};for(const s in t){const r=$n.get(parseInt(s)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const o=e.get(r[0].ID);i[s]={name:t[s].attrName,layer:o}}return i}addClip(e){let t=[];const i=this;return e.layer.forEach(function(s){t=t.concat(i.generateTracks(s))}),new j_(e.name,-1,t)}generateTracks(e){const t=[];let i=new P,s=new je,r=new P;if(e.transform&&e.transform.decompose(i,s,r),i=i.toArray(),s=new ht().setFromQuaternion(s,e.eulerOrder).toArray(),r=r.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const o=this.generateVectorTrack(e.modelName,e.T.curves,i,"position");o!==void 0&&t.push(o)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const o=this.generateRotationTrack(e.modelName,e.R.curves,s,e.preRotation,e.postRotation,e.eulerOrder);o!==void 0&&t.push(o)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const o=this.generateVectorTrack(e.modelName,e.S.curves,r,"scale");o!==void 0&&t.push(o)}if(e.DeformPercent!==void 0){const o=this.generateMorphTrack(e);o!==void 0&&t.push(o)}return t}generateVectorTrack(e,t,i,s){const r=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(r,t,i);return new fc(e+"."+s,r,o)}generateRotationTrack(e,t,i,s,r,o){t.x!==void 0&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(Yi.degToRad)),t.y!==void 0&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(Yi.degToRad)),t.z!==void 0&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(Yi.degToRad));const a=this.getTimesForAllAxes(t),l=this.getKeyframeTrackValues(a,t,i);s!==void 0&&(s=s.map(Yi.degToRad),s.push(o),s=new ht().fromArray(s),s=new je().setFromEuler(s)),r!==void 0&&(r=r.map(Yi.degToRad),r.push(o),r=new ht().fromArray(r),r=new je().setFromEuler(r).invert());const c=new je,h=new ht,f=[];for(let d=0;d<l.length;d+=3)h.set(l[d],l[d+1],l[d+2],o),c.setFromEuler(h),s!==void 0&&c.premultiply(s),r!==void 0&&c.multiply(r),c.toArray(f,d/3*4);return new qo(e+".quaternion",a,f)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,i=t.values.map(function(r){return r/100}),s=hs.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new hc(e.modelName+".morphTargetInfluences["+s+"]",t.times,i)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(i,s){return i-s}),t.length>1){let i=1,s=t[0];for(let r=1;r<t.length;r++){const o=t[r];o!==s&&(t[i]=o,s=o,i++)}t=t.slice(0,i)}return t}getKeyframeTrackValues(e,t,i){const s=i,r=[];let o=-1,a=-1,l=-1;return e.forEach(function(c){if(t.x&&(o=t.x.times.indexOf(c)),t.y&&(a=t.y.times.indexOf(c)),t.z&&(l=t.z.times.indexOf(c)),o!==-1){const h=t.x.values[o];r.push(h),s[0]=h}else r.push(s[0]);if(a!==-1){const h=t.y.values[a];r.push(h),s[1]=h}else r.push(s[1]);if(l!==-1){const h=t.z.values[l];r.push(h),s[2]=h}else r.push(s[2])}),r}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const i=e.values[t-1],s=e.values[t]-i,r=Math.abs(s);if(r>=180){const o=r/180,a=s/o;let l=i+a;const c=e.times[t-1],f=(e.times[t]-c)/o;let d=c+f;const p=[],g=[];for(;d<e.times[t];)p.push(d),d+=f,g.push(l),l+=a;e.times=yE(e.times,t,p),e.values=yE(e.values,t,g)}}}}u(FF,"AnimationParser");class NF{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new CA,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,i=e.split(/[\r\n]+/);return i.forEach(function(s,r){const o=s.match(/^[\s\t]*;/),a=s.match(/^[\s\t]*$/);if(o||a)return;const l=s.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=s.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=s.match("^\\t{"+(t.currentIndent-1)+"}}");l?t.parseNodeBegin(s,l):c?t.parseNodeProperty(s,c,i[++r]):h?t.popStack():s.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(s)}),this.allNodes}parseNodeBegin(e,t){const i=t[1].trim().replace(/^"/,"").replace(/"$/,""),s=t[2].split(",").map(function(l){return l.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:i},o=this.parseNodeAttr(s),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(i,r):i in a?(i==="PoseNode"?a.PoseNode.push(r):a[i].id!==void 0&&(a[i]={},a[i][a[i].id]=a[i]),o.id!==""&&(a[i][o.id]=r)):typeof o.id=="number"?(a[i]={},a[i][o.id]=r):i!=="Properties70"&&(i==="PoseNode"?a[i]=[r]:a[i]=r),typeof o.id=="number"&&(r.id=o.id),o.name!==""&&(r.attrName=o.name),o.type!==""&&(r.attrType=o.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let i="",s="";return e.length>1&&(i=e[1].replace(/^(\w+)::/,""),s=e[2]),{id:t,name:i,type:s}}parseNodeProperty(e,t,i){let s=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();s==="Content"&&r===","&&(r=i.replace(/"/g,"").replace(/,$/,"").trim());const o=this.getCurrentNode();if(o.name==="Properties70"){this.parseNodeSpecialProperty(e,s,r);return}if(s==="C"){const l=r.split(",").slice(1),c=parseInt(l[0]),h=parseInt(l[1]);let f=r.split(",").slice(3);f=f.map(function(d){return d.trim().replace(/^"/,"")}),s="connections",r=[c,h],Zge(r,f),o[s]===void 0&&(o[s]=[])}s==="Node"&&(o.id=r),s in o&&Array.isArray(o[s])?o[s].push(r):s!=="a"?o[s]=r:o.a=r,this.setCurrentProp(o,s),s==="a"&&r.slice(-1)!==","&&(o.a=xb(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=xb(t.a))}parseNodeSpecialProperty(e,t,i){const s=i.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=s[0],o=s[1],a=s[2],l=s[3];let c=s[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=xb(c);break}this.getPrevNode()[r]={type:o,type2:a,flag:l,value:c},this.setCurrentProp(this.getPrevNode(),r)}}u(NF,"TextParser");class kF{parse(e){const t=new r_(e);t.skip(23);const i=t.getUint32();if(i<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+i);const s=new CA;for(;!this.endOfContent(t);){const r=this.parseNode(t,i);r!==null&&s.add(r.name,r)}return s}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const i={},s=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const o=e.getUint8(),a=e.getString(o);if(s===0)return null;const l=[];for(let d=0;d<r;d++)l.push(this.parseProperty(e));const c=l.length>0?l[0]:"",h=l.length>1?l[1]:"",f=l.length>2?l[2]:"";for(i.singleProperty=r===1&&e.getOffset()===s;s>e.getOffset();){const d=this.parseNode(e,t);d!==null&&this.parseSubNode(a,i,d)}return i.propertyList=l,typeof c=="number"&&(i.id=c),h!==""&&(i.attrName=h),f!==""&&(i.attrType=f),a!==""&&(i.name=a),i}parseSubNode(e,t,i){if(i.singleProperty===!0){const s=i.propertyList[0];Array.isArray(s)?(t[i.name]=i,i.a=s):t[i.name]=s}else if(e==="Connections"&&i.name==="C"){const s=[];i.propertyList.forEach(function(r,o){o!==0&&s.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(s)}else if(i.name==="Properties70")Object.keys(i).forEach(function(r){t[r]=i[r]});else if(e==="Properties70"&&i.name==="P"){let s=i.propertyList[0],r=i.propertyList[1];const o=i.propertyList[2],a=i.propertyList[3];let l;s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?l=[i.propertyList[4],i.propertyList[5],i.propertyList[6]]:l=i.propertyList[4],t[s]={type:r,type2:o,flag:a,value:l}}else t[i.name]===void 0?typeof i.id=="number"?(t[i.name]={},t[i.name][i.id]=i):t[i.name]=i:i.name==="PoseNode"?(Array.isArray(t[i.name])||(t[i.name]=[t[i.name]]),t[i.name].push(i)):t[i.name][i.id]===void 0&&(t[i.name][i.id]=i)}parseProperty(e){const t=e.getString(1);let i;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return i=e.getUint32(),e.getArrayBuffer(i);case"S":return i=e.getUint32(),e.getString(i);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const s=e.getUint32(),r=e.getUint32(),o=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(s);case"d":return e.getFloat64Array(s);case"f":return e.getFloat32Array(s);case"i":return e.getInt32Array(s);case"l":return e.getInt64Array(s)}typeof zge=="undefined"&&console.error("THREE.FBXLoader: External library fflate.min.js required.");const a=Sp(new Uint8Array(e.getArrayBuffer(o))),l=new r_(a.buffer);switch(t){case"b":case"c":return l.getBooleanArray(s);case"d":return l.getFloat64Array(s);case"f":return l.getFloat32Array(s);case"i":return l.getInt32Array(s);case"l":return l.getInt64Array(s)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}u(kF,"BinaryParser");class r_{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let i=0;i<e;i++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let i=0;i<e;i++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let i=0;i<e;i++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let i=0;i<e;i++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let i=0;i<e;i++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let s=0;s<e;s++)t[s]=this.getUint8();const i=t.indexOf(0);return i>=0&&(t=t.slice(0,i)),Mr.decodeText(new Uint8Array(t))}}u(r_,"BinaryReader");class CA{add(e,t){this[e]=t}}u(CA,"FBXTree");function jge(n){const e="Kaydara FBX Binary  \0";return n.byteLength>=e.length&&e===UF(n,0,e.length)}u(jge,"isFbxFormatBinary");function Xge(n){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function i(s){const r=n[s-1];return n=n.slice(t+s),t++,r}u(i,"read");for(let s=0;s<e.length;++s)if(i(1)===e[s])return!1;return!0}u(Xge,"isFbxFormatASCII");function vE(n){const e=/FBXVersion: (\d+)/,t=n.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}u(vE,"getFbxVersion");function qge(n){return n/46186158e3}u(qge,"convertFBXTimeToSeconds");const Yge=[];function Sg(n,e,t,i){let s;switch(i.mappingType){case"ByPolygonVertex":s=n;break;case"ByPolygon":s=e;break;case"ByVertice":s=t;break;case"AllSame":s=i.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+i.mappingType)}i.referenceType==="IndexToDirect"&&(s=i.indices[s]);const r=s*i.dataSize,o=r+i.dataSize;return Kge(Yge,i.buffer,r,o)}u(Sg,"getData");const bb=new ht,lu=new P;function zF(n){const e=new me,t=new me,i=new me,s=new me,r=new me,o=new me,a=new me,l=new me,c=new me,h=new me,f=new me,d=new me,p=n.inheritType?n.inheritType:0;if(n.translation&&e.setPosition(lu.fromArray(n.translation)),n.preRotation){const I=n.preRotation.map(Yi.degToRad);I.push(n.eulerOrder||ht.DefaultOrder),t.makeRotationFromEuler(bb.fromArray(I))}if(n.rotation){const I=n.rotation.map(Yi.degToRad);I.push(n.eulerOrder||ht.DefaultOrder),i.makeRotationFromEuler(bb.fromArray(I))}if(n.postRotation){const I=n.postRotation.map(Yi.degToRad);I.push(n.eulerOrder||ht.DefaultOrder),s.makeRotationFromEuler(bb.fromArray(I)),s.invert()}n.scale&&r.scale(lu.fromArray(n.scale)),n.scalingOffset&&a.setPosition(lu.fromArray(n.scalingOffset)),n.scalingPivot&&o.setPosition(lu.fromArray(n.scalingPivot)),n.rotationOffset&&l.setPosition(lu.fromArray(n.rotationOffset)),n.rotationPivot&&c.setPosition(lu.fromArray(n.rotationPivot)),n.parentMatrixWorld&&(f.copy(n.parentMatrix),h.copy(n.parentMatrixWorld));const g=t.clone().multiply(i).multiply(s),m=new me;m.extractRotation(h);const v=new me;v.copyPosition(h);const y=v.clone().invert().multiply(h),b=m.clone().invert().multiply(y),x=r,w=new me;if(p===0)w.copy(m).multiply(g).multiply(b).multiply(x);else if(p===1)w.copy(m).multiply(b).multiply(g).multiply(x);else{const F=new me().scale(new P().setFromMatrixScale(f)).clone().invert(),O=b.clone().multiply(F);w.copy(m).multiply(g).multiply(O).multiply(x)}const _=c.clone().invert(),A=o.clone().invert();let S=e.clone().multiply(l).multiply(c).multiply(t).multiply(i).multiply(s).multiply(_).multiply(a).multiply(o).multiply(r).multiply(A);const M=new me().copyPosition(S),C=h.clone().multiply(M);return d.copyPosition(C),S=d.clone().multiply(w),S.premultiply(h.invert()),S}u(zF,"generateTransform");function BF(n){n=n||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return n===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[n]}u(BF,"getEulerOrder");function xb(n){return n.split(",").map(function(t){return parseFloat(t)})}u(xb,"parseNumberArray");function UF(n,e,t){return e===void 0&&(e=0),t===void 0&&(t=n.byteLength),Mr.decodeText(new Uint8Array(n,e,t))}u(UF,"convertArrayBufferToString");function Zge(n,e){for(let t=0,i=n.length,s=e.length;t<s;t++,i++)n[i]=e[t]}u(Zge,"append");function Kge(n,e,t,i){for(let s=t,r=0;s<i;s++,r++)n[r]=e[s];return n}u(Kge,"slice");function yE(n,e,t){return n.slice(0,e).concat(t).concat(n.slice(e))}u(yE,"inject");class $F extends ia{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new WF(t)}),this.register(function(t){return new QF(t)}),this.register(function(t){return new JF(t)}),this.register(function(t){return new XF(t)}),this.register(function(t){return new qF(t)}),this.register(function(t){return new YF(t)}),this.register(function(t){return new ZF(t)}),this.register(function(t){return new GF(t)}),this.register(function(t){return new KF(t)}),this.register(function(t){return new jF(t)}),this.register(function(t){return new VF(t)}),this.register(function(t){return new eN(t)}),this.register(function(t){return new tN(t)})}load(e,t,i,s){const r=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=Mr.extractUrlBase(e),this.manager.itemStart(e);const a=u(function(c){s?s(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},"_onError"),l=new Bh(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{r.parse(c,o,function(h){t(h),r.manager.itemEnd(e)},a)}catch(h){a(h)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,s){let r;const o={},a={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(Mr.decodeText(new Uint8Array(e,0,4))===nN){try{o[wt.KHR_BINARY_GLTF]=new iN(e)}catch(h){s&&s(h);return}r=JSON.parse(o[wt.KHR_BINARY_GLTF].content)}else r=JSON.parse(Mr.decodeText(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new cN(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](l);a[h.name]=h,o[h.name]=!0}if(r.extensionsUsed)for(let c=0;c<r.extensionsUsed.length;++c){const h=r.extensionsUsed[c],f=r.extensionsRequired||[];switch(h){case wt.KHR_MATERIALS_UNLIT:o[h]=new HF;break;case wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:o[h]=new oN;break;case wt.KHR_DRACO_MESH_COMPRESSION:o[h]=new sN(r,this.dracoLoader);break;case wt.KHR_TEXTURE_TRANSFORM:o[h]=new rN;break;case wt.KHR_MESH_QUANTIZATION:o[h]=new aN;break;default:f.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}l.setExtensions(o),l.setPlugins(a),l.parse(i,s)}parseAsync(e,t){const i=this;return new Promise(function(s,r){i.parse(e,t,s,r)})}}u($F,"GLTFLoader");function Qge(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}u(Qge,"GLTFRegistry");const wt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class VF{constructor(e){this.parser=e,this.name=wt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,s=t.length;i<s;i++){const r=t[i];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let s=t.cache.get(i);if(s)return s;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const h=new Ce(16777215);l.color!==void 0&&h.fromArray(l.color);const f=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new Fp(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new op(h),c.distance=f;break;case"spot":c=new U1(h),c.distance=f,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),s=Promise.resolve(c),t.cache.add(i,s),s}createNodeAttachment(e){const t=this,i=this.parser,r=i.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return i._getNodeRef(t.cache,a,l)})}}u(VF,"GLTFLightsExtension");class HF{constructor(){this.name=wt.KHR_MATERIALS_UNLIT}getMaterialType(){return xi}extendParams(e,t,i){const s=[];e.color=new Ce(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const o=r.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}r.baseColorTexture!==void 0&&s.push(i.assignTexture(e,"map",r.baseColorTexture,Lt))}return Promise.all(s)}}u(HF,"GLTFMaterialsUnlitExtension$1");class GF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}u(GF,"GLTFMaterialsEmissiveStrengthExtension");class WF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&r.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&r.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(r.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Ie(a,a)}return Promise.all(r)}}u(WF,"GLTFMaterialsClearcoatExtension$1");class jF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&r.push(i.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&r.push(i.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(r)}}u(jF,"GLTFMaterialsIridescenceExtension$1");class XF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_SHEEN}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new Ce(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=s.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&r.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,Lt)),o.sheenRoughnessTexture!==void 0&&r.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(r)}}u(XF,"GLTFMaterialsSheenExtension");class qF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&r.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(r)}}u(qF,"GLTFMaterialsTransmissionExtension$1");class YF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_VOLUME}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&r.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new Ce(a[0],a[1],a[2]),Promise.all(r)}}u(YF,"GLTFMaterialsVolumeExtension$1");class ZF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_IOR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}u(ZF,"GLTFMaterialsIorExtension");class KF{constructor(e){this.parser=e,this.name=wt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:ol}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&r.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new Ce(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&r.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,Lt)),Promise.all(r)}}u(KF,"GLTFMaterialsSpecularExtension");class QF{constructor(e){this.parser=e,this.name=wt.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,s=i.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const r=s.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,o)}}u(QF,"GLTFTextureBasisUExtension");class JF{constructor(e){this.parser=e,this.name=wt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,s=i.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],a=s.images[o.source];let l=i.textureLoader;if(a.uri){const c=i.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return i.loadTextureImage(e,o.source,l);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}u(JF,"GLTFTextureWebPExtension");class eN{constructor(e){this.name=wt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const s=i.extensions[this.name],r=this.parser.getDependency("buffer",s.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const l=s.byteOffset||0,c=s.byteLength||0,h=s.count,f=s.byteStride,d=new Uint8Array(a,l,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(h,f,d,s.mode,s.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(h*f);return o.decodeGltfBuffer(new Uint8Array(p),h,f,d,s.mode,s.filter),p})})}else return null}}u(eN,"GLTFMeshoptCompression");class tN{constructor(e){this.name=wt.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const s=t.meshes[i.mesh];for(const c of s.primitives)if(c.mode!==Xs.TRIANGLES&&c.mode!==Xs.TRIANGLE_STRIP&&c.mode!==Xs.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=i.extensions[this.name].attributes,a=[],l={};for(const c in o)a.push(this.parser.getDependency("accessor",o[c]).then(h=>(l[c]=h,l[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const h=c.pop(),f=h.isGroup?h.children:[h],d=c[0].count,p=[];for(const g of f){const m=new me,v=new P,y=new je,b=new P(1,1,1),x=new EI(g.geometry,g.material,d);for(let w=0;w<d;w++)l.TRANSLATION&&v.fromBufferAttribute(l.TRANSLATION,w),l.ROTATION&&y.fromBufferAttribute(l.ROTATION,w),l.SCALE&&b.fromBufferAttribute(l.SCALE,w),x.setMatrixAt(w,m.compose(v,y,b));for(const w in l)w!=="TRANSLATION"&&w!=="ROTATION"&&w!=="SCALE"&&g.geometry.setAttribute(w,l[w]);It.prototype.copy.call(x,g),x.frustumCulled=!1,this.parser.assignFinalMaterial(x),p.push(x)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}u(tN,"GLTFMeshGpuInstancing");const nN="glTF",Bf=12,bE={JSON:1313821514,BIN:5130562};class iN{constructor(e){this.name=wt.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Bf);if(this.header={magic:Mr.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==nN)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-Bf,s=new DataView(e,Bf);let r=0;for(;r<i;){const o=s.getUint32(r,!0);r+=4;const a=s.getUint32(r,!0);if(r+=4,a===bE.JSON){const l=new Uint8Array(e,Bf+r,o);this.content=Mr.decodeText(l)}else if(a===bE.BIN){const l=Bf+r;this.body=e.slice(l,l+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}u(iN,"GLTFBinaryExtension");class sN{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=wt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,s=this.dracoLoader,r=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const h in o){const f=o_[h]||h.toLowerCase();a[f]=o[h]}for(const h in e.attributes){const f=o_[h]||h.toLowerCase();if(o[h]!==void 0){const d=i.accessors[e.attributes[h]],p=Cp[d.componentType];c[f]=p.name,l[f]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(h){return new Promise(function(f){s.decodeDracoFile(h,function(d){for(const p in d.attributes){const g=d.attributes[p],m=l[p];m!==void 0&&(g.normalized=m)}f(d)},a,c)})})}}u(sN,"GLTFDracoMeshCompressionExtension");class rN{constructor(){this.name=wt.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}u(rN,"GLTFTextureTransformExtension");class o1 extends rr{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),i=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),s=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),r=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),a={specular:{value:new Ce().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=a,this.onBeforeCompile=function(l){for(const c in a)l.uniforms[c]=a[c];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",i).replace("#include <roughnessmap_fragment>",s).replace("#include <metalnessmap_fragment>",r).replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return a.specular.value},set:function(l){a.specular.value=l}},specularMap:{get:function(){return a.specularMap.value},set:function(l){a.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return a.glossiness.value},set:function(l){a.glossiness.value=l}},glossinessMap:{get:function(){return a.glossinessMap.value},set:function(l){a.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}u(o1,"GLTFMeshStandardSGMaterial");class oN{constructor(){this.name=wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return o1}extendParams(e,t,i){const s=t.extensions[this.name];e.color=new Ce(1,1,1),e.opacity=1;const r=[];if(Array.isArray(s.diffuseFactor)){const o=s.diffuseFactor;e.color.fromArray(o),e.opacity=o[3]}if(s.diffuseTexture!==void 0&&r.push(i.assignTexture(e,"map",s.diffuseTexture,Lt)),e.emissive=new Ce(0,0,0),e.glossiness=s.glossinessFactor!==void 0?s.glossinessFactor:1,e.specular=new Ce(1,1,1),Array.isArray(s.specularFactor)&&e.specular.fromArray(s.specularFactor),s.specularGlossinessTexture!==void 0){const o=s.specularGlossinessTexture;r.push(i.assignTexture(e,"glossinessMap",o)),r.push(i.assignTexture(e,"specularMap",o,Lt))}return Promise.all(r)}createMaterial(e){const t=new o1(e);return t.fog=!0,t.color=e.color,t.map=e.map===void 0?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=e.aoMap===void 0?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=e.emissiveIntensity===void 0?1:e.emissiveIntensity,t.emissiveMap=e.emissiveMap===void 0?null:e.emissiveMap,t.bumpMap=e.bumpMap===void 0?null:e.bumpMap,t.bumpScale=1,t.normalMap=e.normalMap===void 0?null:e.normalMap,t.normalMapType=Pp,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=e.specularMap===void 0?null:e.specularMap,t.specular=e.specular,t.glossinessMap=e.glossinessMap===void 0?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=e.envMap===void 0?null:e.envMap,t.envMapIntensity=1,t}}u(oN,"GLTFMaterialsPbrSpecularGlossinessExtension");class aN{constructor(){this.name=wt.KHR_MESH_QUANTIZATION}}u(aN,"GLTFMeshQuantizationExtension");class EA extends zh{constructor(e,t,i,s){super(e,t,i,s)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=e*s*3+s;for(let o=0;o!==s;o++)t[o]=i[r+o];return t}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,c=a*3,h=s-t,f=(i-t)/h,d=f*f,p=d*f,g=e*c,m=g-c,v=-2*p+3*d,y=p-d,b=1-v,x=y-d+f;for(let w=0;w!==a;w++){const _=o[m+w+a],A=o[m+w+l]*h,S=o[g+w+a],M=o[g+w]*h;r[w]=b*_+x*A+v*S+y*M}return r}}u(EA,"GLTFCubicSplineInterpolant");const Jge=new je;class lN extends EA{interpolate_(e,t,i,s){const r=super.interpolate_(e,t,i,s);return Jge.fromArray(r).normalize().toArray(r),r}}u(lN,"GLTFCubicSplineQuaternionInterpolant");const Xs={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Cp={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},xE={9728:Yt,9729:Zt,9984:V0,9985:D_,9986:H0,9987:Mc},_E={33071:Wn,33648:tp,10497:Qi},wE={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},o_={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Pa={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},e0e={CUBICSPLINE:void 0,LINEAR:uc,STEP:sh},_b={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function t0e(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new rr({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:eo})),n.DefaultMaterial}u(t0e,"createDefaultMaterial");function Uf(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}u(Uf,"addUnknownExtensionsToUserData");function Gl(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}u(Gl,"assignExtrasToUserData");function n0e(n,e,t){let i=!1,s=!1,r=!1;for(let c=0,h=e.length;c<h;c++){const f=e[c];if(f.POSITION!==void 0&&(i=!0),f.NORMAL!==void 0&&(s=!0),f.COLOR_0!==void 0&&(r=!0),i&&s&&r)break}if(!i&&!s&&!r)return Promise.resolve(n);const o=[],a=[],l=[];for(let c=0,h=e.length;c<h;c++){const f=e[c];if(i){const d=f.POSITION!==void 0?t.getDependency("accessor",f.POSITION):n.attributes.position;o.push(d)}if(s){const d=f.NORMAL!==void 0?t.getDependency("accessor",f.NORMAL):n.attributes.normal;a.push(d)}if(r){const d=f.COLOR_0!==void 0?t.getDependency("accessor",f.COLOR_0):n.attributes.color;l.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const h=c[0],f=c[1],d=c[2];return i&&(n.morphAttributes.position=h),s&&(n.morphAttributes.normal=f),r&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}u(n0e,"addMorphTargets");function i0e(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,s=t.length;i<s;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}u(i0e,"updateMorphTargets");function s0e(n){const e=n.extensions&&n.extensions[wt.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+AE(e.attributes):t=n.indices+":"+AE(n.attributes)+":"+n.mode,t}u(s0e,"createPrimitiveKey");function AE(n){let e="";const t=Object.keys(n).sort();for(let i=0,s=t.length;i<s;i++)e+=t[i]+":"+n[t[i]]+";";return e}u(AE,"createAttributesKey");function a_(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}u(a_,"getNormalizedComponentScale");function r0e(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}u(r0e,"getImageURIMimeType");class cN{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Qge,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,r=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap=="undefined"||i||s&&r<98?this.textureLoader=new Op(this.options.manager):this.textureLoader=new VI(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Bh(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,s=this.json,r=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const a={scene:o[0][s.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:s.asset,parser:i,userData:{}};Uf(r,a,s),Gl(a,s),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let s=0,r=t.length;s<r;s++){const o=t[s].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let s=0,r=e.length;s<r;s++){const o=e[s];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const s=i.clone(),r=u((o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,h]of o.children.entries())r(h,a.children[c])},"updateMappings");return r(i,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const s=e(t[i]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let s=0;s<t.length;s++){const r=e(t[s]);r&&i.push(r)}return i}getDependency(e,t){const i=e+":"+t;let s=this.cache.get(i);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this.loadNode(t);break;case"mesh":s=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(i,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(r,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[wt.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(r,o){i.load(Mr.resolveURL(t.uri,s.path),r,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const s=t.byteLength||0,r=t.byteOffset||0;return i.slice(r,r+s)})}loadAccessor(e){const t=this,i=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0)return Promise.resolve(null);const r=[];return s.bufferView!==void 0?r.push(this.getDependency("bufferView",s.bufferView)):r.push(null),s.sparse!==void 0&&(r.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(r).then(function(o){const a=o[0],l=wE[s.type],c=Cp[s.componentType],h=c.BYTES_PER_ELEMENT,f=h*l,d=s.byteOffset||0,p=s.bufferView!==void 0?i.bufferViews[s.bufferView].byteStride:void 0,g=s.normalized===!0;let m,v;if(p&&p!==f){const y=Math.floor(d/p),b="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+y+":"+s.count;let x=t.cache.get(b);x||(m=new c(a,y*p,s.count*p/h),x=new CI(m,p/h),t.cache.add(b,x)),v=new O1(x,l,d%p/h,g)}else a===null?m=new c(s.count*l):m=new c(a,d,s.count*l),v=new Rt(m,l,g);if(s.sparse!==void 0){const y=wE.SCALAR,b=Cp[s.sparse.indices.componentType],x=s.sparse.indices.byteOffset||0,w=s.sparse.values.byteOffset||0,_=new b(o[1],x,s.sparse.count*y),A=new c(o[2],w,s.sparse.count*l);a!==null&&(v=new Rt(v.array.slice(),v.itemSize,v.normalized));for(let S=0,M=_.length;S<M;S++){const C=_[S];if(v.setX(C,A[S*l]),l>=2&&v.setY(C,A[S*l+1]),l>=3&&v.setZ(C,A[S*l+2]),l>=4&&v.setW(C,A[S*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,i=this.options,r=t.textures[e].source,o=t.images[r];let a=this.textureLoader;if(o.uri){const l=i.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,i){const s=this,r=this.json,o=r.textures[e],a=r.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,i).then(function(h){h.flipY=!1,h.name=o.name||a.name||"";const d=(r.samplers||{})[o.sampler]||{};return h.magFilter=xE[d.magFilter]||Zt,h.minFilter=xE[d.minFilter]||Mc,h.wrapS=_E[d.wrapS]||Qi,h.wrapT=_E[d.wrapT]||Qi,s.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const i=this,s=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(f=>f.clone());const o=s.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",c=!1;if(o.bufferView!==void 0)l=i.getDependency("bufferView",o.bufferView).then(function(f){c=!0;const d=new Blob([f],{type:o.mimeType});return l=a.createObjectURL(d),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(l).then(function(f){return new Promise(function(d,p){let g=d;t.isImageBitmapLoader===!0&&(g=u(function(m){const v=new ui(m);v.needsUpdate=!0,d(v)},"onLoad")),t.load(Mr.resolveURL(f,r.path),g,void 0,p)})}).then(function(f){return c===!0&&a.revokeObjectURL(l),f.userData.mimeType=o.mimeType||r0e(o.uri),f}).catch(function(f){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),f});return this.sourceCache[e]=h,h}assignTexture(e,t,i,s){const r=this;return this.getDependency("texture",i.index).then(function(o){if(i.texCoord!==void 0&&i.texCoord!=0&&!(t==="aoMap"&&i.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+t+" not yet supported."),r.extensions[wt.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[wt.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=r.associations.get(o);o=r.extensions[wt.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),r.associations.set(o,l)}}return s!==void 0&&(o.encoding=s),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const s=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Yr,ns.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(a,l)),i=l}else if(e.isLine){const a="LineBasicMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Bi,ns.prototype.copy.call(l,i),l.color.copy(i.color),this.cache.add(a,l)),i=l}if(s||r||o){let a="ClonedMaterial:"+i.uuid+":";i.isGLTFSpecularGlossinessMaterial&&(a+="specular-glossiness:"),s&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=i.clone(),r&&(l.vertexColors=!0),o&&(l.flatShading=!0),s&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(i))),i=l}i.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=i}getMaterialType(){return rr}loadMaterial(e){const t=this,i=this.json,s=this.extensions,r=i.materials[e];let o;const a={},l=r.extensions||{},c=[];if(l[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const f=s[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];o=f.getMaterialType(),c.push(f.extendParams(a,r,t))}else if(l[wt.KHR_MATERIALS_UNLIT]){const f=s[wt.KHR_MATERIALS_UNLIT];o=f.getMaterialType(),c.push(f.extendParams(a,r,t))}else{const f=r.pbrMetallicRoughness||{};if(a.color=new Ce(1,1,1),a.opacity=1,Array.isArray(f.baseColorFactor)){const d=f.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}f.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",f.baseColorTexture,Lt)),a.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,a.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",f.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",f.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=Ki);const h=r.alphaMode||_b.OPAQUE;if(h===_b.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===_b.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&o!==xi&&(c.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new Ie(1,1),r.normalTexture.scale!==void 0)){const f=r.normalTexture.scale;a.normalScale.set(f,f)}return r.occlusionTexture!==void 0&&o!==xi&&(c.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&o!==xi&&(a.emissive=new Ce().fromArray(r.emissiveFactor)),r.emissiveTexture!==void 0&&o!==xi&&c.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,Lt)),Promise.all(c).then(function(){let f;return o===o1?f=s[wt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):f=new o(a),r.name&&(f.name=r.name),Gl(f,r),t.associations.set(f,{materials:e}),r.extensions&&Uf(s,f,r),f})}createUniqueName(e){const t=_t.sanitizeNodeName(e||"");let i=t;for(let s=1;this.nodeNamesUsed[i];++s)i=t+"_"+s;return this.nodeNamesUsed[i]=!0,i}loadGeometries(e){const t=this,i=this.extensions,s=this.primitiveCache;function r(a){return i[wt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return ME(l,a,t)})}u(r,"createDracoPrimitive");const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],h=s0e(c),f=s[h];if(f)o.push(f.promise);else{let d;c.extensions&&c.extensions[wt.KHR_DRACO_MESH_COMPRESSION]?d=r(c):d=ME(new Je,c,t),s[h]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,s=this.extensions,r=i.meshes[e],o=r.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const h=o[l].material===void 0?t0e(this.cache):this.getDependency("material",o[l].material);a.push(h)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),h=l[l.length-1],f=[];for(let p=0,g=h.length;p<g;p++){const m=h[p],v=o[p];let y;const b=c[p];if(v.mode===Xs.TRIANGLES||v.mode===Xs.TRIANGLE_STRIP||v.mode===Xs.TRIANGLE_FAN||v.mode===void 0)y=r.isSkinnedMesh===!0?new V_(m,b):new We(m,b),y.isSkinnedMesh===!0&&!y.geometry.attributes.skinWeight.normalized&&y.normalizeSkinWeights(),v.mode===Xs.TRIANGLE_STRIP?y.geometry=SE(y.geometry,pU):v.mode===Xs.TRIANGLE_FAN&&(y.geometry=SE(y.geometry,iI));else if(v.mode===Xs.LINES)y=new Tr(m,b);else if(v.mode===Xs.LINE_STRIP)y=new er(m,b);else if(v.mode===Xs.LINE_LOOP)y=new PI(m,b);else if(v.mode===Xs.POINTS)y=new Wa(m,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(y.geometry.morphAttributes).length>0&&i0e(y,r),y.name=t.createUniqueName(r.name||"mesh_"+e),Gl(y,r),v.extensions&&Uf(s,y,v),t.assignFinalMaterial(y),f.push(y)}for(let p=0,g=f.length;p<g;p++)t.associations.set(f[p],{meshes:e,primitives:p});if(f.length===1)return f[0];const d=new _i;t.associations.set(d,{meshes:e});for(let p=0,g=f.length;p<g;p++)d.add(f[p]);return d})}loadCamera(e){let t;const i=this.json.cameras[e],s=i[i.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?t=new li(Yi.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):i.type==="orthographic"&&(t=new rl(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),Gl(t,i),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],i={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(i):this.getDependency("accessor",t.inverseBindMatrices).then(function(s){return i.inverseBindMatrices=s,i})}loadAnimation(e){const i=this.json.animations[e],s=[],r=[],o=[],a=[],l=[];for(let c=0,h=i.channels.length;c<h;c++){const f=i.channels[c],d=i.samplers[f.sampler],p=f.target,g=p.node,m=i.parameters!==void 0?i.parameters[d.input]:d.input,v=i.parameters!==void 0?i.parameters[d.output]:d.output;s.push(this.getDependency("node",g)),r.push(this.getDependency("accessor",m)),o.push(this.getDependency("accessor",v)),a.push(d),l.push(p)}return Promise.all([Promise.all(s),Promise.all(r),Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const h=c[0],f=c[1],d=c[2],p=c[3],g=c[4],m=[];for(let y=0,b=h.length;y<b;y++){const x=h[y],w=f[y],_=d[y],A=p[y],S=g[y];if(x===void 0)continue;x.updateMatrix();let M;switch(Pa[S.path]){case Pa.weights:M=hc;break;case Pa.rotation:M=qo;break;case Pa.position:case Pa.scale:default:M=fc;break}const C=x.name?x.name:x.uuid,I=A.interpolation!==void 0?e0e[A.interpolation]:uc,F=[];Pa[S.path]===Pa.weights?x.traverse(function(N){N.morphTargetInfluences&&F.push(N.name?N.name:N.uuid)}):F.push(C);let O=_.array;if(_.normalized){const N=a_(O.constructor),E=new Float32Array(O.length);for(let k=0,G=O.length;k<G;k++)E[k]=O[k]*N;O=E}for(let N=0,E=F.length;N<E;N++){const k=new M(F[N]+"."+Pa[S.path],w.array,O,I);A.interpolation==="CUBICSPLINE"&&(k.createInterpolant=u(function(X){const te=this instanceof qo?lN:EA;return new te(this.times,this.values,this.getValueSize()/3,X)},"InterpolantFactoryMethodGLTFCubicSpline"),k.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(k)}}const v=i.name?i.name:"animation_"+e;return new j_(v,void 0,m)})}createNodeMesh(e){const t=this.json,i=this,s=t.nodes[e];return s.mesh===void 0?null:i.getDependency("mesh",s.mesh).then(function(r){const o=i._getNodeRef(i.meshCache,s.mesh,r);return s.weights!==void 0&&o.traverse(function(a){if(!!a.isMesh)for(let l=0,c=s.weights.length;l<c;l++)a.morphTargetInfluences[l]=s.weights[l]}),o})}loadNode(e){const t=this.json,i=this.extensions,s=this,r=t.nodes[e],o=r.name?s.createUniqueName(r.name):"";return function(){const a=[],l=s._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),r.camera!==void 0&&a.push(s.getDependency("camera",r.camera).then(function(c){return s._getNodeRef(s.cameraCache,r.camera,c)})),s._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),Promise.all(a)}().then(function(a){let l;if(r.isBone===!0?l=new rp:a.length>1?l=new _i:a.length===1?l=a[0]:l=new It,l!==a[0])for(let c=0,h=a.length;c<h;c++)l.add(a[c]);if(r.name&&(l.userData.name=r.name,l.name=o),Gl(l,r),r.extensions&&Uf(i,l,r),r.matrix!==void 0){const c=new me;c.fromArray(r.matrix),l.applyMatrix4(c)}else r.translation!==void 0&&l.position.fromArray(r.translation),r.rotation!==void 0&&l.quaternion.fromArray(r.rotation),r.scale!==void 0&&l.scale.fromArray(r.scale);return s.associations.has(l)||s.associations.set(l,{}),s.associations.get(l).nodes=e,l})}loadScene(e){const t=this.json,i=this.extensions,s=this.json.scenes[e],r=this,o=new _i;s.name&&(o.name=r.createUniqueName(s.name)),Gl(o,s),s.extensions&&Uf(i,o,s);const a=s.nodes||[],l=[];for(let c=0,h=a.length;c<h;c++)l.push(uN(a[c],o,t,r));return Promise.all(l).then(function(){const c=u(h=>{const f=new Map;for(const[d,p]of r.associations)(d instanceof ns||d instanceof ui)&&f.set(d,p);return h.traverse(d=>{const p=r.associations.get(d);p!=null&&f.set(d,p)}),f},"reduceAssociations");return r.associations=c(o),o})}}u(cN,"GLTFParser");function uN(n,e,t,i){const s=t.nodes[n];return i.getDependency("node",n).then(function(r){if(s.skin===void 0)return r;let o;return i.getDependency("skin",s.skin).then(function(a){o=a;const l=[];for(let c=0,h=o.joints.length;c<h;c++)l.push(i.getDependency("node",o.joints[c]));return Promise.all(l)}).then(function(a){return r.traverse(function(l){if(!l.isMesh)return;const c=[],h=[];for(let f=0,d=a.length;f<d;f++){const p=a[f];if(p){c.push(p);const g=new me;o.inverseBindMatrices!==void 0&&g.fromArray(o.inverseBindMatrices.array,f*16),h.push(g)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[f])}l.bind(new Lp(c,h),l.matrixWorld)}),r})}).then(function(r){e.add(r);const o=[];if(s.children){const a=s.children;for(let l=0,c=a.length;l<c;l++){const h=a[l];o.push(uN(h,r,t,i))}}return Promise.all(o)})}u(uN,"buildNodeHierarchy");function o0e(n,e,t){const i=e.attributes,s=new un;if(i.POSITION!==void 0){const a=t.json.accessors[i.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(s.set(new P(l[0],l[1],l[2]),new P(c[0],c[1],c[2])),a.normalized){const h=a_(Cp[a.componentType]);s.min.multiplyScalar(h),s.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new P,l=new P;for(let c=0,h=r.length;c<h;c++){const f=r[c];if(f.POSITION!==void 0){const d=t.json.accessors[f.POSITION],p=d.min,g=d.max;if(p!==void 0&&g!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(g[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(g[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(g[2]))),d.normalized){const m=a_(Cp[d.componentType]);l.multiplyScalar(m)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(a)}n.boundingBox=s;const o=new na;s.getCenter(o.center),o.radius=s.min.distanceTo(s.max)/2,n.boundingSphere=o}u(o0e,"computeBounds");function ME(n,e,t){const i=e.attributes,s=[];function r(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}u(r,"assignAttributeAccessor");for(const o in i){const a=o_[o]||o.toLowerCase();a in n.attributes||s.push(r(i[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});s.push(o)}return Gl(n,e),o0e(n,e,t),Promise.all(s).then(function(){return e.targets!==void 0?n0e(n,e.targets,t):n})}u(ME,"addPrimitiveAttributes");function SE(n,e){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const i=t.count-2,s=[];if(e===iI)for(let o=1;o<=i;o++)s.push(t.getX(0)),s.push(t.getX(o)),s.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2===0?(s.push(t.getX(o)),s.push(t.getX(o+1)),s.push(t.getX(o+2))):(s.push(t.getX(o+2)),s.push(t.getX(o+1)),s.push(t.getX(o)));s.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=n.clone();return r.setIndex(s),r}u(SE,"toTrianglesDrawMode");const a0e=/^[og]\s*(.+)?/,l0e=/^mtllib /,c0e=/^usemtl /,u0e=/^usemap /,TE=/\s+/,CE=new P,wb=new P,EE=new P,PE=new P,Hs=new P,Tg=new Ce;function h0e(){const n={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const i=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(s,r){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const a={index:this.materials.length,name:s||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(l){const c={index:typeof l=="number"?l:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(s){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),s&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return s&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},i&&i.name&&typeof i.clone=="function"){const s=i.clone(0);s.inherited=!0,this.object.materials.push(s)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const i=parseInt(e,10);return(i>=0?i-1:i+t/3)*3},parseNormalIndex:function(e,t){const i=parseInt(e,10);return(i>=0?i-1:i+t/3)*3},parseUVIndex:function(e,t){const i=parseInt(e,10);return(i>=0?i-1:i+t/2)*2},addVertex:function(e,t,i){const s=this.vertices,r=this.object.geometry.vertices;r.push(s[e+0],s[e+1],s[e+2]),r.push(s[t+0],s[t+1],s[t+2]),r.push(s[i+0],s[i+1],s[i+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,i){const s=this.normals,r=this.object.geometry.normals;r.push(s[e+0],s[e+1],s[e+2]),r.push(s[t+0],s[t+1],s[t+2]),r.push(s[i+0],s[i+1],s[i+2])},addFaceNormal:function(e,t,i){const s=this.vertices,r=this.object.geometry.normals;CE.fromArray(s,e),wb.fromArray(s,t),EE.fromArray(s,i),Hs.subVectors(EE,wb),PE.subVectors(CE,wb),Hs.cross(PE),Hs.normalize(),r.push(Hs.x,Hs.y,Hs.z),r.push(Hs.x,Hs.y,Hs.z),r.push(Hs.x,Hs.y,Hs.z)},addColor:function(e,t,i){const s=this.colors,r=this.object.geometry.colors;s[e]!==void 0&&r.push(s[e+0],s[e+1],s[e+2]),s[t]!==void 0&&r.push(s[t+0],s[t+1],s[t+2]),s[i]!==void 0&&r.push(s[i+0],s[i+1],s[i+2])},addUV:function(e,t,i){const s=this.uvs,r=this.object.geometry.uvs;r.push(s[e+0],s[e+1]),r.push(s[t+0],s[t+1]),r.push(s[i+0],s[i+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,i,s,r,o,a,l,c){const h=this.vertices.length;let f=this.parseVertexIndex(e,h),d=this.parseVertexIndex(t,h),p=this.parseVertexIndex(i,h);if(this.addVertex(f,d,p),this.addColor(f,d,p),a!==void 0&&a!==""){const g=this.normals.length;f=this.parseNormalIndex(a,g),d=this.parseNormalIndex(l,g),p=this.parseNormalIndex(c,g),this.addNormal(f,d,p)}else this.addFaceNormal(f,d,p);if(s!==void 0&&s!==""){const g=this.uvs.length;f=this.parseUVIndex(s,g),d=this.parseUVIndex(r,g),p=this.parseUVIndex(o,g),this.addUV(f,d,p),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let i=0,s=e.length;i<s;i++){const r=this.parseVertexIndex(e[i],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const i=this.vertices.length,s=this.uvs.length;for(let r=0,o=e.length;r<o;r++)this.addVertexLine(this.parseVertexIndex(e[r],i));for(let r=0,o=t.length;r<o;r++)this.addUVLine(this.parseUVIndex(t[r],s))}};return n.startObject("",!1),n}u(h0e,"ParserState");class hN extends ia{constructor(e){super(e),this.materials=null}load(e,t,i,s){const r=this,o=new Bh(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(r.parse(a))}catch(l){s?s(l):console.error(l),r.manager.itemError(e)}},i,s)}setMaterials(e){return this.materials=e,this}parse(e){const t=new h0e;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const i=e.split(`
`);let s=[];for(let a=0,l=i.length;a<l;a++){const c=i[a].trimStart();if(c.length===0)continue;const h=c.charAt(0);if(h!=="#")if(h==="v"){const f=c.split(TE);switch(f[0]){case"v":t.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7?(Tg.setRGB(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6])).convertSRGBToLinear(),t.colors.push(Tg.r,Tg.g,Tg.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":t.uvs.push(parseFloat(f[1]),parseFloat(f[2]));break}}else if(h==="f"){const d=c.slice(1).trim().split(TE),p=[];for(let m=0,v=d.length;m<v;m++){const y=d[m];if(y.length>0){const b=y.split("/");p.push(b)}}const g=p[0];for(let m=1,v=p.length-1;m<v;m++){const y=p[m],b=p[m+1];t.addFace(g[0],y[0],b[0],g[1],y[1],b[1],g[2],y[2],b[2])}}else if(h==="l"){const f=c.substring(1).trim().split(" ");let d=[];const p=[];if(c.indexOf("/")===-1)d=f;else for(let g=0,m=f.length;g<m;g++){const v=f[g].split("/");v[0]!==""&&d.push(v[0]),v[1]!==""&&p.push(v[1])}t.addLineGeometry(d,p)}else if(h==="p"){const d=c.slice(1).trim().split(" ");t.addPointGeometry(d)}else if((s=a0e.exec(c))!==null){const f=(" "+s[0].slice(1).trim()).slice(1);t.startObject(f)}else if(c0e.test(c))t.object.startMaterial(c.substring(7).trim(),t.materialLibraries);else if(l0e.test(c))t.materialLibraries.push(c.substring(7).trim());else if(u0e.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(h==="s"){if(s=c.split(" "),s.length>1){const d=s[1].trim().toLowerCase();t.object.smooth=d!=="0"&&d!=="off"}else t.object.smooth=!0;const f=t.object.currentMaterial();f&&(f.smooth=t.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}t.finalize();const r=new _i;if(r.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let a=0,l=t.objects.length;a<l;a++){const c=t.objects[a],h=c.geometry,f=c.materials,d=h.type==="Line",p=h.type==="Points";let g=!1;if(h.vertices.length===0)continue;const m=new Je;m.setAttribute("position",new Ve(h.vertices,3)),h.normals.length>0&&m.setAttribute("normal",new Ve(h.normals,3)),h.colors.length>0&&(g=!0,m.setAttribute("color",new Ve(h.colors,3))),h.hasUVIndices===!0&&m.setAttribute("uv",new Ve(h.uvs,2));const v=[];for(let b=0,x=f.length;b<x;b++){const w=f[b],_=w.name+"_"+w.smooth+"_"+g;let A=t.materials[_];if(this.materials!==null){if(A=this.materials.create(w.name),d&&A&&!(A instanceof Bi)){const S=new Bi;ns.prototype.copy.call(S,A),S.color.copy(A.color),A=S}else if(p&&A&&!(A instanceof Yr)){const S=new Yr({size:10,sizeAttenuation:!1});ns.prototype.copy.call(S,A),S.color.copy(A.color),S.map=A.map,A=S}}A===void 0&&(d?A=new Bi:p?A=new Yr({size:1,sizeAttenuation:!1}):A=new $d,A.name=w.name,A.flatShading=!w.smooth,A.vertexColors=g,t.materials[_]=A),v.push(A)}let y;if(v.length>1){for(let b=0,x=f.length;b<x;b++){const w=f[b];m.addGroup(w.groupStart,w.groupCount,b)}d?y=new Tr(m,v):p?y=new Wa(m,v):y=new We(m,v)}else d?y=new Tr(m,v[0]):p?y=new Wa(m,v[0]):y=new We(m,v[0]);y.name=c.name,r.add(y)}else if(t.vertices.length>0){const a=new Yr({size:1,sizeAttenuation:!1}),l=new Je;l.setAttribute("position",new Ve(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(l.setAttribute("color",new Ve(t.colors,3)),a.vertexColors=!0);const c=new Wa(l,a);r.add(c)}return r}}u(hN,"OBJLoader");var f0e=Object.defineProperty,d0e=u((n,e)=>f0e(n,"name",{value:e,configurable:!0}),"__name$1c");class PA{update(e,t){if(!t.instanceId){if(t.has(Zo)){const i=t.get(Zo);if(!i.dirty||(i.dirty=!1,!i.value))return;const s=t.get(Me);s.dispose(),s.value=new hN().parse(i.value),s.value.userData={node:t};for(let r of s.value.children)r.userData={node:t};s.parentChanged=!0,s.localTransformChanged=!0,e.model.instanceMeshUpdated(t.id,!0)}else if(t.has(Yo)){const i=t.get(Yo);if(!i.dirty||(i.dirty=!1,!i.value))return;const s=t.get(Me);s.dispose(),uw(i.value).then(function(r){if(t.deleted)return;s.value=new DF().parse(r,void 0);const o=[s.value];for(;o.length;){const a=o.pop();if(!a)break;a.userData={node:t},o.push(...a.children)}s.parentChanged=!0,s.localTransformChanged=!0,t.dirty=!0,e.model.dirty=!0,e.model.instanceMeshUpdated(t.id,!0)})}else if(t.has(Ko)){const i=t.get(Ko);if(!i.dirty||(i.dirty=!1,!i.value.length))return;const s=t.get(Me);s.dispose(),console.info("Loading gltf zip"),yge.loadAsync(i.value).then(async function(r){if(t.deleted)return;const o=Object.values(r.files).filter(d=>!d.dir),a=o.find(d=>d.name.toLocaleLowerCase().endsWith(".gltf"));if(!a){console.error("Failed to find entry file");return}const l={};for(let d of o){console.info(`Loading ${d.name}`);const p=await d.async("blob");if(t.deleted)return;l[d.name]=URL.createObjectURL(p)}const c=new X_;c.setURLModifier(d=>{const p=new URL(d),g=p.pathname.replace(p.origin+"/","");return l[g]||d});const h=new $F(c),f=l[a.name];h.load(f,d=>{if(t.deleted)return;s.value=d.scene;const p=[d.scene];for(;p.length;){const g=p.pop();if(!g)break;g.userData={node:t},p.push(...g.children)}s.parentChanged=!0,s.localTransformChanged=!0,t.dirty=!0,e.model.dirty=!0,e.model.instanceMeshUpdated(t.id,!0)})})}}}}u(PA,"ImportModelUpdateFilter");d0e(PA,"ImportModelUpdateFilter");var p0e=Object.defineProperty,m0e=u((n,e)=>p0e(n,"name",{value:e,configurable:!0}),"__name$1b");class RA{update(e,t){if(t.instanceId){const i=e.model.getNode(t.instanceId);for(let s in t.components)is(s).autoCopy&&(t.components[s].value=i.components[s].value)}}}u(RA,"InstanceNodeUpdateFilter");m0e(RA,"InstanceNodeUpdateFilter");var g0e=Object.defineProperty,v0e=u((n,e)=>g0e(n,"name",{value:e,configurable:!0}),"__name$1a");class IA{update(e,t){if(t.has(es)){const i=t.get(es),s=i.value;s&&s.update();const r=i.camera;r&&r.update()}}}u(IA,"LightHelperUpdateFilter");v0e(IA,"LightHelperUpdateFilter");var y0e=Object.defineProperty,b0e=u((n,e)=>y0e(n,"name",{value:e,configurable:!0}),"__name$19");class DA{update(e,t){var i,s,r,o;switch(t.type){case"AmbientLight":{const a=t.get(Me);a.value||(a.value=new $1);const l=a.value,c=t.value(Ft);l.color.setRGB(c[0],c[1],c[2]),l.intensity=t.value(qi)}break;case"HemisphereLight":{const a=t.get(Me);a.value||(a.value=new zI);const l=a.value,c=t.value(gp);l.color.setRGB(c[0],c[1],c[2]);const h=t.value(fp);l.groundColor.setRGB(h[0],h[1],h[2]),l.intensity=t.value(qi);const f=t.get(es);f.value||(f.value=new qI(l,.25),e.scene.add(f.value))}break;case"DirectionalLight":{const a=t.get(Me);a.value||(a.value=new Fp);const l=a.value;l.castShadow=t.value(Vn);const c=t.value(Ft);l.color.setRGB(c[0],c[1],c[2]),l.intensity=t.value(qi);const h=Number.parseInt(t.value(Wo));l.shadow.mapSize.x!==h&&(l.shadow.mapSize.set(h,h),(i=l.shadow.map)==null||i.setSize(h,h),(s=l.shadow.mapPass)==null||s.setSize(h,h),l.shadow.dispose());const f=t.value(mp)/2;l.shadow.camera.top=+f,l.shadow.camera.right=+f,l.shadow.camera.bottom=-f,l.shadow.camera.left=-f,l.shadow.camera.near=0,l.shadow.camera.updateProjectionMatrix();const d=t.get(es);d.value||(d.value=new YI(l),e.scene.add(d.value)),d.camera||(d.camera=new ZI(l.shadow.camera),e.scene.add(d.camera));const g=t.children[0].get(Me);g.parentChanged=!1,g.value||(g.value=l.target,e.scene.add(g.value))}break;case"PointLight":{const a=t.get(Me);let l=a.value;const c=Number.parseInt(t.value(Wo));l&&l.shadow.mapSize.x!==c&&(l.dispose(),l.removeFromParent(),a.value=null,a.localTransformChanged=!0,a.worldTransformChanged=!0,a.parentChanged=!0),a.value||(l=a.value=new op,l.shadow.mapSize.set(c,c)),l.castShadow=t.value(Vn);const h=t.value(Ft);l.color.setRGB(h[0],h[1],h[2]),l.intensity=t.value(qi);const f=.005;l.shadow.camera.near!==f&&(l.shadow.camera.near=f,l.shadow.camera.updateProjectionMatrix());const d=t.get(es);let p=d.value;p&&p.light!==l&&(p.dispose(),p.removeFromParent(),d.value=null),d.value||(d.value=new XI(l,.25),e.scene.add(d.value))}break;case"SpotLight":{const a=t.get(Me);a.value||(a.value=new U1);const l=a.value;l.castShadow=t.value(Vn);const c=t.value(Ft);l.color.setRGB(c[0],c[1],c[2]),l.intensity=t.value(qi),l.angle=t.value(vp)/180*Math.PI,l.penumbra=t.value(pp);const h=Number.parseInt(t.value(Wo));l.shadow.mapSize.x!==h&&(l.shadow.mapSize.set(h,h),(r=l.shadow.map)==null||r.setSize(h,h),(o=l.shadow.mapPass)==null||o.setSize(h,h),l.shadow.dispose());const f=.005;l.shadow.camera.near!==f&&(l.shadow.camera.near=f,l.shadow.camera.updateProjectionMatrix());const d=t.get(es);d.value||(d.value=new jI(l),e.scene.add(d.value));const g=t.children[0].get(Me);g.parentChanged=!1,g.value||(g.value=l.target,e.scene.add(g.value))}break}}}u(DA,"LightUpdateFilter");b0e(DA,"LightUpdateFilter");var x0e=Object.defineProperty,_0e=u((n,e)=>x0e(n,"name",{value:e,configurable:!0}),"__name$18");class LA{update(e,t){var i;if(!t.instanceId&&t.has(Me)){const s=t.value(Me);if(!s)return;if(t.has(tr)){const r=t.value(tr);t.get(Me).usePlainMaterial=r;const o=[s];for(;o.length;){const a=o.pop();if(!a)break;const l=a;l.isMesh&&(r?(l.__plainMaterial||(l.__originalMaterial=l.material,l.__plainMaterial=new rr),l.material=l.__plainMaterial,this.updateMaterial(t,l.__plainMaterial)):l.__originalMaterial&&(l.material=l.__originalMaterial)),o.push(...a.children)}}else{const r=[s];for(;r.length;){const o=r.pop();if(!o)break;if(((i=o.userData.node)==null?void 0:i.id)!==t.id)continue;const a=o;if(a.isMesh){const l=a.material;l.isMeshStandardMaterial&&this.updateMaterial(t,l)}else r.push(...o.children)}if(!s.isMesh)return}}}updateMaterial(e,t){if(e.has(Ft)){const i=e.value(Ft);t.color.setRGB(i[0],i[1],i[2])}if(e.has(Pn)){const i=e.value(Pn);t.emissive.setRGB(i[0],i[1],i[2])}e.has(In)&&(t.roughness=e.value(In)),e.has(Rn)&&(t.metalness=e.value(Rn))}}u(LA,"MaterialUpdateFilter");_0e(LA,"MaterialUpdateFilter");class qp extends We{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new li;const i=this,s=t.color!==void 0?new Ce(t.color):new Ce(8355711),r=t.textureWidth||512,o=t.textureHeight||512,a=t.clipBias||0,l=t.shader||qp.ReflectorShader,c=t.multisample!==void 0?t.multisample:4,h=new gr,f=new P,d=new P,p=new P,g=new me,m=new P(0,0,-1),v=new ut,y=new P,b=new P,x=new ut,w=new me,_=this.camera,A=new Ln(r,o,{samples:c,type:cc}),S=new Ci({uniforms:I1.clone(l.uniforms),fragmentShader:l.fragmentShader,vertexShader:l.vertexShader});S.uniforms.tDiffuse.value=A.texture,S.uniforms.color.value=s,S.uniforms.textureMatrix.value=w,this.material=S,this.onBeforeRender=function(M,C,I){if(d.setFromMatrixPosition(i.matrixWorld),p.setFromMatrixPosition(I.matrixWorld),g.extractRotation(i.matrixWorld),f.set(0,0,1),f.applyMatrix4(g),y.subVectors(d,p),y.dot(f)>0)return;y.reflect(f).negate(),y.add(d),g.extractRotation(I.matrixWorld),m.set(0,0,-1),m.applyMatrix4(g),m.add(p),b.subVectors(d,m),b.reflect(f).negate(),b.add(d),_.position.copy(y),_.up.set(0,1,0),_.up.applyMatrix4(g),_.up.reflect(f),_.lookAt(b),_.far=I.far,_.updateMatrixWorld(),_.projectionMatrix.copy(I.projectionMatrix),w.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),w.multiply(_.projectionMatrix),w.multiply(_.matrixWorldInverse),w.multiply(i.matrixWorld),h.setFromNormalAndCoplanarPoint(f,d),h.applyMatrix4(_.matrixWorldInverse),v.set(h.normal.x,h.normal.y,h.normal.z,h.constant);const F=_.projectionMatrix;x.x=(Math.sign(v.x)+F.elements[8])/F.elements[0],x.y=(Math.sign(v.y)+F.elements[9])/F.elements[5],x.z=-1,x.w=(1+F.elements[10])/F.elements[14],v.multiplyScalar(2/v.dot(x)),F.elements[2]=v.x,F.elements[6]=v.y,F.elements[10]=v.z+1-a,F.elements[14]=v.w,i.visible=!1;const O=M.getRenderTarget(),N=M.xr.enabled,E=M.shadowMap.autoUpdate,k=M.outputEncoding,G=M.toneMapping;M.xr.enabled=!1,M.shadowMap.autoUpdate=!1,M.outputEncoding=Xo,M.toneMapping=Qs,M.setRenderTarget(A),M.state.buffers.depth.setMask(!0),M.autoClear===!1&&M.clear(),M.render(C,_),M.xr.enabled=N,M.shadowMap.autoUpdate=E,M.outputEncoding=k,M.toneMapping=G,M.setRenderTarget(O);const X=I.viewport;X!==void 0&&M.state.viewport(X),i.visible=!0},this.getRenderTarget=function(){return A},this.dispose=function(){A.dispose(),i.material.dispose()}}}u(qp,"Reflector");qp.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`};var w0e=Object.defineProperty,A0e=u((n,e)=>w0e(n,"name",{value:e,configurable:!0}),"__name$17");class OA{update(e,t){if(t.type!=="Mirror")return;const i=t.value(bp),s=t.value(ln),r=t.get(Me);if(!r.value){const f=t.value(Ft);r.value=new qp(new oh(i,s),{color:new Ce().setRGB(f[0],f[1],f[2])}),r.value.userData.node=t;return}const o=r.value,a=o.geometry;(a.parameters.width!==i||a.parameters.height!==s)&&(a.dispose(),r.value.geometry=new oh(i,s));const l=o.material.uniforms.color.value,c=t.value(Ft);l.setRGB(c[0],c[1],c[2]);const h=Number.parseInt(t.value(yp));o.getRenderTarget().setSize(h,h)}}u(OA,"MirrorUpdateFilter");A0e(OA,"MirrorUpdateFilter");var M0e=Object.defineProperty,S0e=u((n,e)=>M0e(n,"name",{value:e,configurable:!0}),"__name$16");class FA{update(e,t){var i;if(t.has(Me)){const s=t.get(Me);if(s.parentChanged){const o=s.value;if(o){o.removeFromParent();const a=it(t.parent);if(a){if(a.has(Me)){const l=a.value(Me);l&&l.add(o)}}else e.scene.add(o)}s.parentChanged=!1}let r=t.has(ft)?t.value(ft):!0;t.has(Ge)&&((i=t.parent)==null?void 0:i.has(Ge))&&(r=!1),s.value&&(s.value.visible=r)}}}u(FA,"Object3DRelationshipUpdateFilter");S0e(FA,"Object3DRelationshipUpdateFilter");var T0e=Object.defineProperty,fN=u((n,e)=>T0e(n,"name",{value:e,configurable:!0}),"__name$15");function NA(n,e){const t=n;if(t.isMesh)if(Array.isArray(t.material))for(let i of t.material)i.opacity!==e&&(i.opacity=e,i.transparent=i.opacity<1,i.needsUpdate=!0);else t.material.opacity!==e&&(t.material.opacity=e,t.material.transparent=t.material.opacity<1,t.material.needsUpdate=!0);for(let i of n.children)NA(i,e)}u(NA,"setOpacity");fN(NA,"setOpacity");class kA{update(e,t){if(t.instanceId)return;if(t.opacity=(t.parent?t.parent.opacity:1)*(t.has(nn)?t.value(nn):1),ii(t.type).mesh){const s=t.get(Me);s.value&&NA(s.value,t.opacity)}}}u(kA,"OpacityUpdateFilter");fN(kA,"OpacityUpdateFilter");var C0e=Object.defineProperty,E0e=u((n,e)=>C0e(n,"name",{value:e,configurable:!0}),"__name$14");class zA{update(e,t){if(t.instanceId||t.type!=="Shape"||!t.value(Ds))return;const i=t.get(Ds);i.value=!1;const s=t.get(Me);s.value||(s.value=new We(new Je,new rr),s.value.userData={node:t}),i.throttleHash=`#${t.id}-update-sdf-shape-geometry`,e.throttle(i.throttleHash,25,function(){if(t.deleted)return;i.throttleHash="";const r=new vv;switch(r.smoothRange=t.value(Eh),t.value(Ui)){case"x":r.symmetryAxis=0;break;case"y":r.symmetryAxis=1;break;case"z":r.symmetryAxis=2;break}for(let h of t.children){const f=h.value(dt),d=h.value(xh)==="add";if(f.length===1)r.sphere(f[0].position,f[0].radius,d);else for(let p=0;p+1<f.length;++p){const g=f[p],m=f[p+1];r.roundCone(g.position,g.radius,m.position,m.radius,d)}}const{position:o,normal:a}=r.build(),c=s.value.geometry;c.setAttribute("position",new Ve(o,3)),c.setAttribute("normal",new Ve(a,3)),c.computeBoundingSphere(),e.model.instanceMeshUpdated(t.id,!0)},!1)}}u(zA,"SdfShapeUpdateFilter");E0e(zA,"SdfShapeUpdateFilter");var P0e=Object.defineProperty,R0e=u((n,e)=>P0e(n,"name",{value:e,configurable:!0}),"__name$13");class BA{update(e,t){if(!t.has(Me)||!t.has(Vn)&&!t.has(Xi))return;const i=t.value(Me);if(!i)return;const s=t.has(Vn)?t.value(Vn):null,r=t.has(Xi)?t.value(Xi):null,o=[i];for(;o.length;){const a=o.pop();if(!a)break;s!=null&&(a.castShadow=s),r!=null&&(a.receiveShadow=r),o.push(...a.children)}}}u(BA,"ShadowUpdateFilter");R0e(BA,"ShadowUpdateFilter");var I0e=Object.defineProperty,D0e=u((n,e)=>I0e(n,"name",{value:e,configurable:!0}),"__name$12");class UA{update(e,t){if(t.has(Me)){const i=t.get(Me),s=i.value;if(s){if(i.localTransformChanged){if(t.has(ze)&&s.position.copy(t.value(ze)),t.has(tt)&&s.rotation.copy(t.value(tt)),t.has(Wt)&&(s.scale.x=s.scale.y=s.scale.z=t.value(Wt)),t.has(Et)&&s.scale.copy(t.value(Et)),t.has(Qo)&&s.scale.multiply(t.value(Qo)),t.has(At)){const r=t.get(At);s.position.copy(r.start),s.quaternion.copy(r.quaternion)}t.has(Ge)?s.matrix.copy(t.get(Ge).matrix):s.updateMatrix(),i.localTransformChanged=!1}i.worldTransformChanged&&(s.updateMatrixWorld(!0),i.worldTransformChanged=!1,t.forEach(r=>{if(r.has(dt)){const o=r.get(dt);o.group&&(o.group.matrixAutoUpdate=!1,o.group.matrix.copy(r.getWorldMatrix()))}}))}}}}u(UA,"TransformUpdateFilter");D0e(UA,"TransformUpdateFilter");var L0e=Object.defineProperty,O0e=u((n,e)=>L0e(n,"name",{value:e,configurable:!0}),"__name$11");function a1(n=1,e=20){const t=[];let i=0,s=n;const r=Math.PI*2/e,o=Math.cos(r),a=Math.sin(r);for(let l=0;l<e;++l){const c=i*o-s*a,h=i*a+s*o;t.push(new P(i,s,0),new P(c,h,0)),i=c,s=h}return t}u(a1,"xyCirclePoints");O0e(a1,"xyCirclePoints");var F0e=Object.defineProperty,N0e=u((n,e)=>F0e(n,"name",{value:e,configurable:!0}),"__name$10");class yv extends Je{constructor(e=1,t=20){super(),this.setFromPoints(a1(e,t)),this.type="CircleEdgeGeometry"}}u(yv,"CircleEdgeGeometry");N0e(yv,"CircleEdgeGeometry");var k0e=Object.defineProperty,z0e=u((n,e)=>k0e(n,"name",{value:e,configurable:!0}),"__name$$");const B0e=wc.SphereGeometry,U0e=new B0e(1,20,20),$0e=new yv,V0e=new Je().setFromPoints([new P,new P(1,0,0)]),H0e=new P(1,0,0),Ab=new P;class $A{update(e,t){if(!t.has(dt))return;const i=t.get(dt);if(!i.dirty)return;i.dirty=!1,i.group||(i.group=new _i,i.group.visible=!1,e.scene.add(i.group));const s=i.value;for(;s.length<i.pickers.length;){const o=i.pickers.pop();o==null||o.removeFromParent()}for(;s.length<i.circles.length;){const o=i.circles.pop();o==null||o.removeFromParent()}for(;i.lines.length&&s.length-1<i.lines.length;){const o=i.lines.pop();o==null||o.removeFromParent()}for(;s.length>i.pickers.length;){const o=new We(U0e);o.visible=!1;const a=i.pickers.push(o);o.userData={index:a-1},i.group.add(o)}for(;s.length>i.circles.length;){const o=new er($0e,dt.normalMaterial);i.circles.push(o),i.group.add(o)}for(;s.length-1>i.lines.length;){const o=new er(V0e,dt.normalMaterial);i.lines.push(o),i.group.add(o)}for(let o=0,a=s.length;o<a;++o){const l=s[o],c=i.circles[o];c.position.copy(l.position),c.scale.setScalar(l.radius);const h=i.pickers[o];if(h.position.copy(l.position),h.scale.setScalar(l.radius),o<a-1){const f=i.lines[o];f.position.copy(l.position),Ab.subVectors(s[o+1].position,l.position);const d=Ab.length();f.scale.setScalar(d),d>1e-8&&f.quaternion.setFromUnitVectors(H0e,Ab.divideScalar(d))}}const r=t.get(Me);r.value||(r.value=new It,r.value.userData={node:t},r.parentChanged=!0,r.localTransformChanged=!0)}}u($A,"TubeUpdateFilter");z0e($A,"TubeUpdateFilter");var G0e=Object.defineProperty,W0e=u((n,e)=>G0e(n,"name",{value:e,configurable:!0}),"__name$_");const Cg=[],zr=new P,Mb=new P,Eg=new je,Pg=new me,Sb=new me,Rg=new P;class VA extends Bs{constructor(t){super();T(this,"filters");this.filters=t}begin(t){t=t.readonlyRef();const i=it(this);if(t.model.dirty){t.model.forEach(s=>{s.parent&&!s.parent.visible?s.visible=!1:s.visible=s.has(ft)?s.value(ft):!0,s.dirty&&Cg.push(s)});for(let s of i.filters)for(let r of Cg)s.update(t,r);for(let s of Cg)s.dirty=!1;Cg.length=0,t.model.dirty=!1}t.model.instanceDirty&&(t.model.instanceDirty=!1,t.model.forEach(s=>{if(s.instanceId){if(s.instanceMeshDirty){if(s.instanceMeshDirty=!1,!ii(s.type).mesh)return;let o=s.instanceMeshRebuild;s.instanceMeshRebuild&&(s.instanceMeshRebuild=!1,i.recreateInstanceMesh(t,s)),s.has(jn)&&t.throttle(`#${s.id}-update-instance-mirror-geometry`,250,()=>{s.deleted||i.updateInstanceMirrorGeometry(t,s)},s.visible&&o)}i.updateInstanceMaterial(t,s)}}),t.model.dirty=!0)}end(t){}recreateInstanceMesh(t,i){if(!i.has(Me))return;const s=i.get(Me);if(s.instance=!0,s.dispose(),!t.model.isNodeExists(i.instanceId))return;const r=t.model.getNode(i.instanceId),o=r.value(Me);if(!o)return;const a=[[o,null]];let l=0;for(;a.length;){const c=a.pop();if(!c)break;const h=c[0],f=c[1];let d;if(h.isMesh){const p=h;d=new We(p.geometry,p.material)}else d=new It;d.visible=h.visible,d.position.copy(h.position),d.quaternion.copy(h.quaternion),d.scale.copy(h.scale),d.updateMatrix(),d.updateMatrixWorld(!0),d.userData={node:i,origin:h,instanceId:l++},f?f.add(d):s.value=d;for(let p of h.children)a.push([p,d])}i.dirty=!0,s.parentChanged=!0,s.localTransformChanged=!0,s.worldTransformChanged=!0,s.usePlainMaterial=r.get(Me).usePlainMaterial}updateInstanceMaterial(t,i){if(!i.has(Me)||!i.has(tr))return;const s=t.model.getNode(i.instanceId),r=i.get(Me),o=s.get(Me);if(r.usePlainMaterial===o.usePlainMaterial||(r.usePlainMaterial=o.usePlainMaterial,!r.value)||!o.value)return;const a=[[r.value,o.value]];for(;a.length;){const l=a.pop();if(!l)break;const c=l[0],h=l[1];if(c.isMesh&&(c.material=h.material),c.children.length===h.children.length)for(let f=0,d=c.children.length;f<d;++f)a.push([c.children[f],h.children[f]])}}updateInstanceMirrorGeometry(t,i){if(!i.has(jn))return;const s=i.value(jn),r=i.value(Me);if(!r)return;const o=t.model.getNode(i.instanceId);if(!o.value(Me))return;const l=1e-6,c=rA(Math.round(s.x/l)*l,Math.round(s.y/l)*l,Math.round(s.z/l)*l),h=r,f=[h];for(;f.length;){const d=f.shift();if(!d)break;const p=d.userData;if(p.relatedMatOrigin||(p.relatedMatOrigin=new me,p.relatedMatFlipped=new me),d!==h){const g=d.parent.userData;Pg.copy(g.relatedMatOrigin),Sb.copy(g.relatedMatFlipped).invert();const m=p.origin;Mb.copy(m.position),Mb.applyMatrix4(Pg).reflect(s).applyMatrix4(Sb),Eg.copy(m.quaternion);const v=Go(Rg,Eg);Rg.applyMatrix4(Pg).reflect(s).applyMatrix4(Sb),Rg.normalize(),Eg.setFromAxisAngle(Rg,-v),d.position.copy(Mb),d.quaternion.copy(Eg),d.updateMatrix(),d.updateMatrixWorld(!0),p.relatedMatOrigin.multiplyMatrices(Pg,m.matrix),p.relatedMatFlipped.multiplyMatrices(g.relatedMatFlipped,d.matrix)}d.isMesh&&this.mirrorMesh(o,c+"/"+p.instanceId,d,p.origin,s),f.push(...d.children)}}mirrorMesh(t,i,s,r,o){if(!(!(s!=null&&s.geometry)||!(r!=null&&r.geometry))){if(t.mirrorGeometry[i]){s.geometry=t.mirrorGeometry[i];return}if(s.geometry===r.geometry){s.geometry=new Je;const a=r.geometry.getIndex();a&&(s.geometry.index=new Rt(new Uint32Array(a.array.length),a.itemSize),this.flipIndex(s.geometry.index,a));const l=r.geometry.getAttribute("position");l&&s.geometry.setAttribute("position",new Ve(new Float32Array(l.array),l.itemSize));const c=r.geometry.getAttribute("normal");c&&s.geometry.setAttribute("normal",new Ve(new Float32Array(c.array),c.itemSize));const h=r.geometry.getAttribute("color");h&&s.geometry.setAttribute("color",new Ve(new Float32Array(h.array),h.itemSize));const f=r.geometry.getAttribute("uv");f&&s.geometry.setAttribute("uv",f.clone())}this.mirrorGeometry(s.geometry,r.geometry,o),s.geometry.boundingSphere=null,t.mirrorGeometry[i]=s.geometry}}flipIndex(t,i){const s=t.array,r=i.array;for(let o=0,a=r.length;o<a;o+=3)s[o]=r[o+2],s[o+1]=r[o+1],s[o+2]=r[o]}mirrorGeometry(t,i,s){const r=!t.getIndex();this.mirrorAttribute(t.getAttribute("position"),i.getAttribute("position"),s,r),this.mirrorAttribute(t.getAttribute("normal"),i.getAttribute("normal"),s,r),r&&this.flipTriangles(t.getAttribute("color"),i.getAttribute("color"))}mirrorAttribute(t,i,s,r){if(!t||!i||t.itemSize!==3)return;const o=t.array,a=i.array;if(r)for(let l=0,c=a.length;l<c;l+=9)for(let h=0;h<9;h+=3)zr.fromArray(a,l+6-h),zr.reflect(s),o[l+h]=zr.x,o[l+h+1]=zr.y,o[l+h+2]=zr.z;else for(let l=0,c=a.length;l<c;l+=3)zr.fromArray(a,l),zr.reflect(s),o[l]=zr.x,o[l+1]=zr.y,o[l+2]=zr.z;t.needsUpdate=!0}flipTriangles(t,i){if(!t||!i||t.itemSize!==3)return;const s=t.array,r=i.array;for(let o=0,a=r.length;o<a;o+=9)for(let l=0;l<9;l+=3)s[o+l]=r[o+6-l],s[o+l+1]=r[o+6-l+1],s[o+l+2]=r[o+6-l+2];t.needsUpdate=!0}}u(VA,"ModelUpdateSystem");W0e(VA,"ModelUpdateSystem");var j0e=Object.defineProperty,X0e=u((n,e)=>j0e(n,"name",{value:e,configurable:!0}),"__name$Z");class HA extends Bs{begin(e){e=e.readonlyRef();for(let t of e.views)t.enabled&&(t.mouseScr.x=t.input.pointerX,t.mouseScr.y=t.height-t.input.pointerY,t.mouseNdc.x=t.mouseScr.x/t.width*2-1,t.mouseNdc.y=t.mouseScr.y/t.height*2-1,t.mouseRay0.copy(t.mouseNdc),t.mouseRay0.z=-1,t.mouseRay0.unproject(t.camera.get()),t.mouseRay1.copy(t.mouseNdc),t.mouseRay1.z=1,t.mouseRay1.unproject(t.camera.get()),t.mouseRayN.subVectors(t.mouseRay1,t.mouseRay0).normalize(),t.raycaster.setFromCamera(t.mouseNdc,t.camera.get()))}end(e){}}u(HA,"MouseSystem");X0e(HA,"MouseSystem");var q0e=Object.defineProperty,Y0e=u((n,e)=>q0e(n,"name",{value:e,configurable:!0}),"__name$Y");class GA extends Bs{constructor(){super(...arguments);T(this,"selectedObjs",[]);T(this,"visibilityCache",new Map)}setup(t){t.outlinePass.render=(i,s,r,o,a)=>{this.visibilityCache.clear();for(let l of this.selectedObjs){let c=l;for(;c;)this.visibilityCache.has(c)||this.visibilityCache.set(c,c.visible),c.visible=!0,c=c.parent}Zr.prototype.render.call(t.outlinePass,i,s,r,o,a);for(let l of this.selectedObjs){let c=l;for(;c;)c.visible=!!this.visibilityCache.get(c),c=c.parent}}}begin(t){if(!t.options.outlineSelected){t.outlinePass.selectedObjects.length=0,t.outlinePass.enabled=!1;return}const i=t.readonlyRef().model.getTopmostSelectedNodes();this.selectedObjs.length=0;for(let s of i)if(s.has(Me)&&s.visible&&s.type!=="CsgBezierControlPoint"){const r=s.value(Me);r&&this.selectedObjs.push(r)}t.outlinePass.selectedObjects=this.selectedObjs,t.outlinePass.enabled=!!this.selectedObjs.length}end(t){}}u(GA,"OutlineUpdateSystem");Y0e(GA,"OutlineUpdateSystem");var Z0e=Object.defineProperty,K0e=u((n,e)=>Z0e(n,"name",{value:e,configurable:!0}),"__name$X");class zu extends Tr{constructor(e=10,t=10,i=4473924,s=4473924,r=8947848,o=!0){const a=new Ce(i),l=new Ce(s),c=new Ce(r),h=t/2,f=e/t,d=e/2,p=[],g=[];for(let y=0,b=0,x=-d;y<=t;y++,x+=f){p.push(-d,0,x,d,0,x),p.push(x,0,-d,x,0,d);const w=y===h?a:c,_=y===h?l:c;w.toArray(g,b),b+=3,w.toArray(g,b),b+=3,_.toArray(g,b),b+=3,_.toArray(g,b),b+=3}const m=new Je;m.setAttribute("position",new Ve(p,3)),m.setAttribute("color",new Ve(g,3));const v=new Bi({vertexColors:!0,toneMapped:!1,depthWrite:o});super(m,v),this.type="Grids"}dispose(){this.geometry.dispose(),this.material.dispose()}}u(zu,"Grids");K0e(zu,"Grids");var Q0e=Object.defineProperty,dN=u((n,e)=>Q0e(n,"name",{value:e,configurable:!0}),"__name$W");const Ra=200,J0e=new P(1,0,0),e1e=new P(0,1,0),t1e=new P(0,0,1),n1e=new P;function R0(n,e){return n1e.crossVectors(n._dir,e).lengthSq()<1e-8}u(R0,"isCameraParallelTo");dN(R0,"isCameraParallelTo");class WA extends Bs{constructor(){super(...arguments);T(this,"groundGrids",new zu(Ra,Ra,16135762,3113955,5592405));T(this,"xzGrids",new zu(Ra,Ra,16135762,3113955,5592405,!1));T(this,"xyGrids",new zu(Ra,Ra,16135762,7316763,5592405,!1).rotateX(Math.PI/2));T(this,"yzGrids",new zu(Ra,Ra,7316763,3113955,5592405,!1).rotateZ(Math.PI/2))}setup(t){t.scene.add(this.groundGrids),t.scene.add(this.xzGrids),t.scene.add(this.xyGrids),t.scene.add(this.yzGrids)}begin(t){t=t.readonlyRef();const i=t.canvas.getBoundingClientRect(),s=t.renderer,r=t.composer,o=t.renderPass,a=t.outlinePass;s.setScissorTest(!0),s.setClearColor(0,0),s.clear();const l=t.options.shadingMode==="solid",c=t.options.shadingMode==="path-tracing";for(let h of t.views){for(let f of t.views){const d=h===f;f.gizmo.visible=d&&f.gizmoEnabled,f.gizmo.size=t.options.quadView?1/2:1/4,f.defaultLight.visible=l&&d}if(h.enabled&&h.width&&h.height){const f=h.camera;this.xzGrids.visible=t.options.showGrids&&R0(f,e1e),this.xyGrids.visible=t.options.showGrids&&R0(f,t1e),this.yzGrids.visible=t.options.showGrids&&R0(f,J0e),this.groundGrids.visible=t.options.showGrids&&!(this.xzGrids.visible||this.xyGrids.visible||this.yzGrids.visible),t.tool.beforeRender(t,h);const d=-i.left+h.left,p=i.bottom-h.bottom,g=h.width,m=h.height;if(s.setViewport(d,p,g,m),s.setScissor(d,p,g,m),c&&(t.ptGenerator.objects=t.scene.children.filter(v=>v.visible&&!!v.userData.node)),c&&t.ptGenerator.objects.length){if(t.ptRenderer.setSize(g,m),t.bvhDirty&&t.ptGenerator.reset(),t.bvhDirty||t.transformDirty){const{bvh:v,textures:y,materials:b,lights:x}=t.ptGenerator.generate();t.ptMaterial.bvh.updateFrom(v);const w=v.geometry;t.ptMaterial.materialIndexAttribute.updateFrom(w.attributes.materialIndex),t.ptMaterial.attributesArray.updateFrom(w.attributes.normal,w.attributes.tangent,w.attributes.uv,w.attributes.color),t.ptMaterial.textures.setTextures(s,2048,2048,y),t.ptMaterial.materials.updateFrom(b,y),t.ptMaterial.lights.updateFrom(x),t.ptRenderer.reset()}t.bvhDirty=!1,t.transformDirty=!1,t.ptRenderer.update(),t.ptRenderer.samples<1&&(o.camera=f.get(),a.renderCamera=f.get(),r.setSize(g,m),r.render()),t.ptRenderer.camera=f.get(),t.ptRenderer.camera.updateMatrixWorld(),t.fsQuad.material.map=t.ptRenderer.target.texture,s.autoClear=!1,t.fsQuad.render(s),s.autoClear=!0}else o.camera=f.get(),a.renderCamera=f.get(),r.setSize(g,m),r.render()}}t.tool.afterRender(t)}end(t){}}u(WA,"RenderSystem");dN(WA,"RenderSystem");var i1e=Object.defineProperty,s1e=u((n,e)=>i1e(n,"name",{value:e,configurable:!0}),"__name$V");const RE=new P(0,0,1),$f=new P,Tb=new me,Ia=new P,Cb=new sl;class jA extends Bs{constructor(){super(...arguments);T(this,"prevTool");T(this,"dragMovedFramesCount",0);T(this,"sculptPicked",!1);T(this,"sculptStroked",!1);T(this,"sculptIndicator",new Tr(new Je().setFromPoints([...a1(1),...a1(.05)]),new Bi({fog:!1,toneMapped:!1,transparent:!0,color:15964205,opacity:1})));T(this,"sculptIndicatorSym",new Tr(this.sculptIndicator.geometry.clone(),this.sculptIndicator.material.clone()))}setup(t){this.sculptIndicator.visible=!1,t.scene.add(this.sculptIndicator),this.sculptIndicatorSym.visible=!1,this.sculptIndicatorSym.material.opacity=.33,t.scene.add(this.sculptIndicatorSym)}begin(t){var s,r,o;const i=it(t.tool);if(t.selectionRectSetThisFrame=!1,i.enableSelectionRect)for(let a of t.views){if(a=it(a),!a.enabled)continue;const l=a.input;if(l.pointerOver&&l.mouseLeft){const c=Math.max(-1,Math.min(1,a.mouseNdc.x)),h=Math.max(-1,Math.min(1,a.mouseNdc.y));t.selectionRectDragging?(t.selectionRect.setPoint2(c,h),t.selectionEnd.set(c,h),this.dragMovedFramesCount<2&&(t.selectionRect.hide(),(this.dragMovedFramesCount||!t.selectionStart.equals(t.selectionEnd))&&(this.dragMovedFramesCount+=1))):(t.selectionRectDragging=!0,t.selectionRectViewIndex=a.index,t.selectionRect.attach(a.element),t.selectionRect.setPoint1(c,h),t.selectionRect.setPoint2(c,h),t.selectionStart.set(c,h),t.selectionEnd.set(c,h),this.dragMovedFramesCount=0)}if(t.selectionRectDragging&&t.selectionRectViewIndex===a.index&&!l.mouseLeft&&(t.selectionRectDragging=!1,t.selectionRectSetThisFrame=!0,t.selectionRect.hide(),i.enableDefaultSelectionBehavior))if(t.selectionStart.equals(t.selectionEnd)){const c=a.mousePick();let h=0;for(let f of c){const d=f.object.userData.node;if(d!=null&&d.visible){if(!t.options.allowSelectingInvisibleObjectByClicking&&d.has(Ge)&&((s=d.parent)==null?void 0:s.has(Ge)))continue;h=d.id;break}}if(h){if(t.model.selected.includes(h)?a.input.isKeyPressed("Control")&&(t.model.selected=t.model.selected.filter(f=>f!==h)):(a.input.isKeyPressed("Control")||(t.model.selected=[]),t.model.addSelection(h)),l.doubleClick){let f=t.model.getNode(h);for(f=f.parent;f;)f.expanded=!0,f=f.parent}}else a.input.isKeyPressed("Control")||(t.model.selected=[])}else{const c=t.selectionRect.select(a.camera.get(),t.readonlyRef().scene.children.filter(h=>h.visible&&!!h.userData.node));a.input.isKeyPressed("Control")||(t.model.selected=[]);for(let h of c){const f=h.userData.node;if(f){if(!t.options.allowSelectingInvisibleObjectByClicking&&f.has(Ge)&&((r=f.parent)==null?void 0:r.has(Ge)))continue;t.model.addSelection(f.id)}}}}else t.selectionRect.hide(),t.selectionRectDragging=!1;do{if(this.sculptIndicator.visible=!1,this.sculptIndicatorSym.visible=!1,t.sculptNodeId=0,t.sculptSym=!1,t.sculptMoved=!1,this.sculptPicked){let c=!1;for(let h of t.views)if(h.input.mouseLeft){c=!0;break}c||(this.sculptPicked=!1);break}if(!i.sculpt)break;const a=t.readonlyRef().model.getSelectedNodes().filter(c=>c.type==="Clay"&&!c.instanceId&&c.visible)[0];if(!a)break;const l=a.get(Me).mesh;if(!l)break;t.sculptNodeId=a.id,t.sculptSym=a.value(Ui)!=="none";for(let c of t.views){if(c=it(c),!c.enabled)continue;const h=c.input;if(h.mouseLeft)(h.pointerOver||t.sculptActiveView===c.index)&&(t.sculptActiveView=c.index,h.mouseLeftDownThisFrame?(t.sculptMoved=!0,t.sculptStartThisFrame=!0,t.sculptX0=t.sculptX1=h.pointerX,t.sculptY0=t.sculptY1=h.pointerY,this.sculptStroked=!1):(t.sculptX1!==h.pointerX||t.sculptY1!==h.pointerY)&&(t.sculptMoved=!0,t.sculptStartThisFrame=!1,t.sculptX0=t.sculptX1,t.sculptY0=t.sculptY1,t.sculptX1=h.pointerX,t.sculptY1=h.pointerY,this.sculptStroked=!0));else if(t.sculptActiveView===c.index&&(t.sculptActiveView=-1,!this.sculptStroked&&h.pointerOver)){t.model.selected.length=0;for(let g of c.mousePick()){const m=g.object.userData.node;if((m==null?void 0:m.type)==="Clay"){t.model.addSelection(m.id),this.sculptPicked=!0,t.sculptActiveView=-1;break}}}if(!h.pointerOver)continue;const f=a.getWorldMatrix();Tb.copy(f).invert(),Cb.copy(c.raycaster.ray),Cb.applyMatrix4(Tb);const d=l.raycast(Cb,!0)[0];if(!d)break;h.mouseLeft?this.sculptStroked=!0:(this.sculptIndicator.visible=!0,this.sculptIndicatorSym.visible=t.sculptSym),this.sculptIndicator.position.copy(d.point).applyMatrix4(f),Ia.copy(d.normal).transformDirection(f),this.sculptIndicator.quaternion.setFromUnitVectors(RE,Ia);let p=i.brushRadius/c.height;if(c.camera.perspective?p*=this.sculptIndicator.position.distanceTo(c.camera._position):p*=c.camera.orthographicCamera.top-c.camera.orthographicCamera.bottom,this.sculptIndicator.scale.setScalar(p),t.sculptLocalRadius=p*ac(Tb),this.sculptIndicatorSym.visible){switch($f.copy(d.point),Ia.copy(d.normal),a.value(Ui)){case"x":$f.x*=-1,Ia.x*=-1;break;case"y":$f.y*=-1,Ia.y*=-1;break;case"z":$f.z*=-1,Ia.z*=-1;break}this.sculptIndicatorSym.position.copy($f).applyMatrix4(f),Ia.transformDirection(f),this.sculptIndicatorSym.quaternion.setFromUnitVectors(RE,Ia),this.sculptIndicatorSym.scale.copy(this.sculptIndicator.scale)}break}}while(!1);i.begin(t);for(let a of t.views)a=it(a),a.enabled&&i.update(t,a);if(i.end(t),i.sculpt&&!t.sculptNodeId)for(let a of t.views){a=it(a);const l=a.input;if(l.pointerOver&&l.mouseLeftDownThisFrame)for(let c of a.mousePick()){const h=c.object.userData.node;if((h==null?void 0:h.type)==="Clay"){t.model.addSelection(h.id),this.sculptPicked=!0,t.sculptActiveView=-1;break}}}if(it(this.prevTool)!==i&&((o=this.prevTool)==null||o.onUnselected(t),this.prevTool=i,t.statusBarMessage=i.tips),i.optionsProps.length){const a=t.options.tools[i.constructor.name]=t.options.tools[i.constructor.name]||{};for(let l of i.optionsProps)a[l]=i[l]}}end(t){}}u(jA,"ToolSystem");s1e(jA,"ToolSystem");var r1e=Object.defineProperty,XA=u((n,e)=>r1e(n,"name",{value:e,configurable:!0}),"__name$U");const Da=new P,Vf=new P,cu=new P,Hf=new P,Ig=new P,Dg=new P,Lg=new P,Og=new P,Eb=new P,Pb=new P,Rb=new P,Gf=new P;function l_(n,e,t){return n[e]=t.x,n[e+1]=t.y,n[e+2]=t.z,e+3}u(l_,"vertex$2");XA(l_,"vertex");function Rs(n,e,t,i){return e=l_(n,e,t),l_(n,e,i)}u(Rs,"line$1");XA(Rs,"line");class qA extends Tr{constructor(){const t=new Je,i=new Array(12*2*3).fill(0),s=new Array(12*2*3).fill(1);t.setAttribute("position",new Ve(i,3)),t.setAttribute("color",new Ve(s,3));const r=new Bi({vertexColors:!0,toneMapped:!1,color:16776960});super(t,r);T(this,"point1",new P);T(this,"point2",new P);T(this,"normal1",new P);T(this,"normal2",new P);T(this,"length",0);T(this,"width",0);T(this,"height",0);T(this,"dirty",!1);this.type="BoxEdge"}setPoint1(t){this.point1.equals(t)||(this.dirty=!0,this.point1.copy(t))}setPoint2(t){this.point2.equals(t)||(this.dirty=!0,this.point2.copy(t))}setNormal1(t){this.normal1.equals(t)||(this.dirty=!0,this.normal1.copy(t))}setNormal2(t){this.normal2.equals(t)||(this.dirty=!0,this.normal2.copy(t))}setHeight(t){t!==this.height&&(this.dirty=!0,this.height=t)}getLength(){return this.length}getWidth(){return this.width}updateGeometry(){if(!this.dirty)return;this.dirty=!1;const t=this.geometry.attributes.position,i=t.array;Da.copy(this.point1),cu.copy(this.point2),Pb.copy(this.normal1).normalize(),Rb.crossVectors(this.normal1,this.normal2).normalize(),Eb.subVectors(cu,Da),Vf.copy(Da).addScaledVector(Pb,this.width=Eb.dot(Pb)),Hf.copy(Da).addScaledVector(Rb,this.length=Eb.dot(Rb)),Gf.copy(this.normal2).normalize().multiplyScalar(this.height),Ig.addVectors(Da,Gf),Dg.addVectors(Vf,Gf),Lg.addVectors(cu,Gf),Og.addVectors(Hf,Gf);let s=0;s=Rs(i,s,Da,Vf),s=Rs(i,s,Vf,cu),s=Rs(i,s,cu,Hf),s=Rs(i,s,Hf,Da),s=Rs(i,s,Da,Ig),s=Rs(i,s,Vf,Dg),s=Rs(i,s,cu,Lg),s=Rs(i,s,Hf,Og),s=Rs(i,s,Ig,Dg),s=Rs(i,s,Dg,Lg),s=Rs(i,s,Lg,Og),Rs(i,s,Og,Ig),t.needsUpdate=!0}}u(qA,"BoxEdge");XA(qA,"BoxEdge");var o1e=Object.defineProperty,YA=u((n,e)=>o1e(n,"name",{value:e,configurable:!0}),"__name$T");const fn=new P,Ss=new P,Ts=new P,Cs=new P,Cl=new P,El=new P,Pl=new P,Rl=new P,Il=new P;function Lo(n,e,t){return n[e]=t.x,n[e+1]=t.y,n[e+2]=t.z,e+3}u(Lo,"vertex$1");YA(Lo,"vertex");function pN(n,e,t,i,s,r,o){let a=0;Lo(n,a,t),a=Lo(e,a,o),Lo(n,a,i),a=Lo(e,a,o),Lo(n,a,s),a=Lo(e,a,o),Lo(n,a,r),Lo(e,a,o)}u(pN,"face");YA(pN,"face");const tn=class extends We{constructor(){const t=new Je,i=new Float32Array(4*3),s=new Float32Array(4*3);t.setAttribute("position",new Ve(i,3)),t.setAttribute("normal",new Ve(s,3)),t.setIndex([0,1,3,0,3,2]);const r=new xi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0,color:16776960,opacity:.75});super(t,r);T(this,"size",new P(1,1,1));T(this,"face",tn.Right);T(this,"dirty",!0);this.type="BoxFace"}setSize(t){this.size.equals(t)||(this.dirty=!0,this.size.copy(t))}setFace(t){t!==this.face&&(this.dirty=!0,this.face=t)}getFace(){return this.face}setFaceFromNormal(t){t.x<-1e-6?this.setFace(tn.Left):t.x>1e-6?this.setFace(tn.Right):t.y<-1e-6?this.setFace(tn.Bottom):t.y>1e-6?this.setFace(tn.Top):t.z<-1e-6?this.setFace(tn.Back):this.setFace(tn.Front)}getFaceNormal(t){switch(this.face){case tn.Left:t.set(-1,0,0);break;case tn.Right:t.set(1,0,0);break;case tn.Bottom:t.set(0,-1,0);break;case tn.Top:t.set(0,1,0);break;case tn.Back:t.set(0,0,-1);break;case tn.Front:t.set(0,0,1);break}return t}getFaceTangent(t){switch(this.face){case tn.Left:t.set(0,0,-1);break;case tn.Right:t.set(0,0,1);break;case tn.Bottom:t.set(-1,0,0);break;case tn.Top:t.set(1,0,0);break;case tn.Back:t.set(0,-1,0);break;case tn.Front:t.set(0,1,0);break}return t}updateGeometry(){if(!this.dirty)return;this.dirty=!1,fn.copy(this.size).multiplyScalar(-.5),Ss.set(this.size.x,0,0),Ts.set(0,this.size.y,0),Cs.set(0,0,this.size.z);const t=this.geometry.attributes.position,i=this.geometry.attributes.normal,s=t.array,r=i.array;switch(t.needsUpdate=!0,i.needsUpdate=!0,this.face){case tn.Left:Cl.copy(fn),El.copy(fn).add(Cs),Pl.copy(fn).add(Ts),Rl.copy(fn).add(Cs).add(Ts),Il.set(-1,0,0);break;case tn.Right:Cl.copy(fn).add(Ss),El.copy(fn).add(Ts).add(Ss),Pl.copy(fn).add(Cs).add(Ss),Rl.copy(fn).add(Cs).add(Ts).add(Ss),Il.set(1,0,0);break;case tn.Bottom:Cl.copy(fn),El.copy(fn).add(Ss),Pl.copy(fn).add(Cs),Rl.copy(fn).add(Cs).add(Ss),Il.set(0,-1,0);break;case tn.Top:Cl.copy(fn).add(Ts),El.copy(fn).add(Cs).add(Ts),Pl.copy(fn).add(Ss).add(Ts),Rl.copy(fn).add(Cs).add(Ss).add(Ts),Il.set(0,1,0);break;case tn.Back:Cl.copy(fn),El.copy(fn).add(Ts),Pl.copy(fn).add(Ss),Rl.copy(fn).add(Ts).add(Ss),Il.set(0,0,-1);break;case tn.Front:Cl.copy(fn).add(Cs),El.copy(fn).add(Ss).add(Cs),Pl.copy(fn).add(Ts).add(Cs),Rl.copy(fn).add(Ts).add(Ss).add(Cs),Il.set(0,0,1);break}pN(s,r,Cl,El,Pl,Rl,Il)}};let ti=tn;u(ti,"BoxFace"),T(ti,"Right",0),T(ti,"Left",1),T(ti,"Top",2),T(ti,"Bottom",3),T(ti,"Front",4),T(ti,"Back",5);YA(ti,"BoxFace");var a1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAF1JREFUSIntlDkOADEIxCDa/3/Z26TKBbmUBtcZD4oQIsFr1HoAMCVUNZ1LcjLX5FOZFXkv9+1OY/15VeAJlcOMSB7RDlEQBX4AWut9pKAnP1Iwkos0zvXV8xw84QcGmUP1JGS0xQAAAABJRU5ErkJggg==",l1e=Object.defineProperty,c1e=u((n,e)=>l1e(n,"name",{value:e,configurable:!0}),"__name$S");function mN(n,e,t,i,s){let r,o,a,l,c=t-n,h=i-e,f=Math.abs(c),d=Math.abs(h),p=2*d-f,g=2*f-d;if(d<=f){c>=0?(r=n,o=e,a=t):(r=t,o=i,a=n),s(r,o);for(let m=0;r<a;m++)r=r+1,p<0?p=p+2*d:(c<0&&h<0||c>0&&h>0?o=o+1:o=o-1,p=p+2*(d-f)),s(r,o)}else{h>=0?(r=n,o=e,l=i):(r=t,o=i,l=e),s(r,o);for(let m=0;o<l;m++)o=o+1,g<=0?g=g+2*f:(c<0&&h<0||c>0&&h>0?r=r+1:r=r-1,g=g+2*(f-d)),s(r,o)}}u(mN,"pixelLine");c1e(mN,"pixelLine");var u1e=Object.defineProperty,h1e=u((n,e)=>u1e(n,"name",{value:e,configurable:!0}),"__name$R");const Dl=new na,cs=new sl,IE=new me,Fg=new P;class ri{constructor(){T(this,"sep",!1);T(this,"tips","");T(this,"enableDefaultDeleteShortcut",!0);T(this,"enableSelectionRect",!1);T(this,"enableDefaultSelectionBehavior",!1);T(this,"sculpt",!1);T(this,"brushRadius",50);T(this,"brushStepSpacingRadiusRatio",.2);T(this,"brushStrength",.5);T(this,"hasDirection",!1);T(this,"hasThirdDirection",!1);T(this,"brushDirection",1);T(this,"brushHardness",.5);T(this,"hasHardness",!1);T(this,"hasColor",!1);T(this,"frontFacesOnly",!1);T(this,"optionsProps",[])}setup(e){}dispose(){}begin(e){}update(e,t){}end(e){}beforeRender(e,t){}afterRender(e){}onUnselected(e){}sculptPickStrokeVertices(e,t,i,s,r){e=e.readonlyRef(),IE.copy(t.getWorldMatrix()).invert();const o=new Set,a=[],l=Math.max(1,Math.floor(this.brushRadius*this.brushStepSpacingRadiusRatio));e.sculptStartThisFrame&&(e.sculptAccWalkedPixels=l);const c=t.value(Ui);mN(e.sculptX0,e.sculptY0,e.sculptX1,e.sculptY1,(p,g)=>{if(e.sculptAccWalkedPixels+=1,e.sculptAccWalkedPixels<l)return;e.sculptAccWalkedPixels=0,cs.origin.set(p/i.width*2-1,(i.height-g)/i.height*2-1,-1),cs.direction.copy(cs.origin).setZ(1),cs.origin.unproject(i.camera.get()),cs.direction.unproject(i.camera.get()),cs.direction.sub(cs.origin).normalize(),cs.applyMatrix4(IE);const m=s.raycast(cs,!0)[0];if(!m)return;Dl.set(m.point,e.sculptLocalRadius);const v=s.intersectSphere(Dl),y=[],b=new Set;for(let _ of v)if(!(r&&(s.getNormal(Fg,_),Fg.dot(cs.direction)>=0)))for(let A=0;A<3;++A){const S=s.sharedVertexMap[_*3+A];b.has(S)||(b.add(S),y.push(S),o.add(S))}switch(c){case"x":Dl.center.x*=-1,cs.direction.x*=-1;break;case"y":Dl.center.y*=-1,cs.direction.y*=-1;break;case"z":Dl.center.z*=-1,cs.direction.z*=-1;break;default:{a.push({center:m.point,triangles:v,indices:y});return}}const x=s.intersectSphere(Dl),w=[];b.clear();for(let _ of x)if(!(r&&(s.getNormal(Fg,_),Fg.dot(cs.direction)>=0)))for(let A=0;A<3;++A){const S=s.sharedVertexMap[_*3+A];b.has(S)||(b.add(S),w.push(S),o.add(S))}a.push({center:m.point,triangles:v,indices:y,centerSym:new P().copy(Dl.center),trianglesSym:x,indicesSym:w})});const h=Array.from(o),f=new Map,d=new Float32Array(h.length*3);for(let p=0,g=h.length;p<g;++p){const m=h[p];for(let v=0;v<3;++v)d[p*3+v]=s.aPosition[m*3+v];f.set(m,p*3)}return{indices:h,offset:f,position:d,track:a}}sculptFalloff(e){return(3*e-4)*e**3+1}}u(ri,"EditorTool");h1e(ri,"EditorTool");var f1e=Object.defineProperty,d1e=u((n,e)=>f1e(n,"name",{value:e,configurable:!0}),"__name$Q");const Ng=new P,Wf=new P,DE=new P,Ib=new P,Un=new P,jf=new P,Xf=new P,LE=new P,p1e=new P,Ll=new me,kg=new P,OE=new P,Ol=new P,La=new P,qf=new P,Es=.25;class Yp extends ri{constructor(){super(...arguments);T(this,"name",Yp.name);T(this,"label","Box");T(this,"icon",a1e);T(this,"tips","Hold [Alt] to create a box");T(this,"boxEdge",new qA);T(this,"boxFace",new ti);T(this,"activeViewIndex",-1);T(this,"draggingFace",!1);T(this,"draggingFaceNodeId",0);T(this,"draggingFaceIndex",0);T(this,"draggingFaceNormal",new P);T(this,"faceNormalWorld0",new P);T(this,"position0",new P);T(this,"boxSize0",new P);T(this,"localMat0",new me);T(this,"invWorldMat0",new me);T(this,"mouse0",new P);T(this,"local0",new P);T(this,"creating",!1);T(this,"point2Set",!1);T(this,"point1",new P);T(this,"point2",new P);T(this,"normal1",new P);T(this,"normal2",new P);T(this,"boxHeight",0)}setup(t){this.boxEdge.visible=!1,t.scene.add(this.boxEdge),this.boxFace.visible=!1,t.scene.add(this.boxFace)}begin(t){this.draggingFace||(this.boxFace.visible=!1),this.creating||(this.boxEdge.visible=!1)}update(t,i){var r;const s=i.input;if(this.draggingFace){if(this.activeViewIndex!==i.index)return;if(s.pointerOver&&s.mouseLeft&&t.model.isNodeExists(this.draggingFaceNodeId,"Box")){if(LE.crossVectors(this.faceNormalWorld0,i.mouseRayN).lengthSq()<1e-6)return;No(Ng,null,this.mouse0,this.faceNormalWorld0,i.mouseRay0,i.mouseRayN),Wf.copy(Ng).applyMatrix4(this.invWorldMat0);const o=DE.subVectors(Wf,this.local0).dot(this.draggingFaceNormal);Ib.copy(this.position0),Un.copy(this.boxSize0);const a=t.model.getNode(this.draggingFaceNodeId);switch(this.draggingFaceIndex){case ti.Left:case ti.Right:{Un.x=Math.max(0,o+Un.x),s.isKeyPressed("Shift")&&(Un.x=Math.round(Un.x/Es)*Es);const l=this.draggingFaceIndex===ti.Left?1:-1;jf.set(l*this.boxSize0.x/2,0,0),Xf.set(l*Un.x/2,0,0)}break;case ti.Bottom:case ti.Top:{Un.y=Math.max(0,o+Un.y),s.isKeyPressed("Shift")&&(Un.y=Math.round(Un.y/Es)*Es);const l=this.draggingFaceIndex===ti.Bottom?1:-1;jf.set(0,l*this.boxSize0.y/2,0),Xf.set(0,l*Un.y/2,0)}break;case ti.Back:case ti.Front:{Un.z=Math.max(0,o+Un.z),s.isKeyPressed("Shift")&&(Un.z=Math.round(Un.z/Es)*Es);const l=this.draggingFaceIndex===ti.Back?1:-1;jf.set(0,0,l*this.boxSize0.z/2),Xf.set(0,0,l*Un.z/2)}break}jf.applyMatrix4(this.localMat0),Xf.applyMatrix4(this.localMat0),Ib.add(jf).sub(Xf),t.history.setValue(a,Zs,new P().copy(Un)),t.history.setValue(a,ze,new P().copy(Ib)),Un.multiplyScalar(ac(a.getWorldMatrix())),t.statusBarMessage=`${Un.x.toFixed(2)} \xD7 ${Un.y.toFixed(2)} \xD7 ${Un.z.toFixed(2)}`}else this.draggingFace=!1,this.activeViewIndex=-1,this.draggingFaceNodeId=0,t.statusBarMessage=this.tips;return}if(this.creating){if(!this.point2Set){if(this.activeViewIndex!==i.index)return;if(s.mouseRightDownThisFrame&&(this.creating=!1,t.statusBarMessage=this.tips),Gt(this.point2,i.mouseRay0,i.mouseRay1,this.point1,this.normal2)){if(this.boxEdge.setPoint2(this.point2),this.boxEdge.updateGeometry(),s.isKeyPressed("Shift")){Ol.copy(this.normal1),La.crossVectors(this.normal1,this.normal2).normalize();let l=this.boxEdge.getWidth(),c=this.boxEdge.getLength();l=Math.round(l/Es)*Es,c=Math.round(c/Es)*Es,this.point2.copy(this.point1).addScaledVector(Ol,l).addScaledVector(La,c),this.boxEdge.setPoint2(this.point2),this.boxEdge.updateGeometry()}const o=Math.abs(this.boxEdge.getWidth()).toFixed(2),a=Math.abs(this.boxEdge.getLength()).toFixed(2);t.statusBarMessage=`${o} \xD7 ${a}`}s.mouseLeft||(this.point2Set=!0);return}if(!s.pointerOver||(s.mouseRightDownThisFrame&&(this.creating=!1,this.point2Set=!1,t.statusBarMessage=this.tips),LE.crossVectors(this.normal2,i.mouseRayN).lengthSq()<1e-8))return;if(!No(Ng,null,this.point2,this.normal2,i.mouseRay0,i.mouseRayN)){this.boxHeight=DE.subVectors(Ng,this.point2).dot(this.normal2),s.isKeyPressed("Shift")&&(this.boxHeight=Math.round(this.boxHeight/Es)*Es),this.boxEdge.setHeight(this.boxHeight),this.boxEdge.updateGeometry();const o=Math.abs(this.boxEdge.getWidth()).toFixed(2),a=Math.abs(this.boxEdge.getLength()).toFixed(2),l=Math.abs(this.boxHeight).toFixed(2);t.statusBarMessage=`${o} \xD7 ${a} \xD7 ${l}`}if(s.mouseLeftDownThisFrame){this.creating=!1,this.point2Set=!1,t.statusBarMessage=this.tips;let o=null;for(let v of t.model.getSelectedNodes())if(v.isValidChild("Box")){o=v;break}o?Ll.copy(o.getWorldMatrix()).invert():Ll.identity(),Wf.copy(this.point1).applyMatrix4(Ll),kg.copy(this.point2).applyMatrix4(Ll),OE.copy(this.point2).addScaledVector(this.normal2,this.boxHeight).applyMatrix4(Ll),Ol.copy(this.normal1).transformDirection(Ll),La.copy(this.normal2).transformDirection(Ll),qf.crossVectors(Ol,La).normalize();let a=Wf.dot(Ol),l=kg.dot(Ol);a>l&&([a,l]=[l,a]);let c=Wf.dot(qf),h=kg.dot(qf);c>h&&([c,h]=[h,c]);let f=kg.dot(La),d=OE.dot(La);f>d&&([f,d]=[d,f]);const p=new ht().setFromQuaternion(Qa(new je,qf,La)),g=new P(l-a,d-f,h-c),m=new P().addScaledVector(Ol,a+g.x/2).addScaledVector(La,f+g.y/2).addScaledVector(qf,c+g.z/2);t.history.createNode({type:"Box",parentId:o?o.id:0,data:{[Zs.name]:g,[ze.name]:m,[tt.name]:p}})}return}if(s.pointerOver){for(let o of i.mousePick()){const a=o.object.userData.node;if((a==null?void 0:a.type)==="Box"){const l=(r=o.face)==null?void 0:r.normal;l&&(this.boxFace.visible=!0,this.boxFace.matrixAutoUpdate=!1,this.boxFace.matrix.copy(a.getWorldMatrix()),this.boxFace.setSize(a.value(Zs)),this.boxFace.setFaceFromNormal(l),this.boxFace.updateGeometry(),this.point1.copy(o.point),s.mouseLeftDownThisFrame&&!s.isKeyPressed("Alt")&&!a.instanceId&&(this.draggingFace=!0,this.activeViewIndex=i.index,this.draggingFaceNodeId=a.id,this.draggingFaceIndex=this.boxFace.getFace(),this.draggingFaceNormal.copy(l),this.faceNormalWorld0.copy(l).transformDirection(a.getWorldMatrix()),this.position0.copy(a.value(ze)),this.boxSize0.copy(a.value(Zs)),this.localMat0.copy(a.getLocalMatrix()),this.invWorldMat0.copy(a.getWorldMatrix()).invert(),this.mouse0.copy(o.point),this.local0.copy(this.mouse0).applyMatrix4(this.invWorldMat0)));break}}s.isKeyPressed("Alt")&&s.mouseLeftDownThisFrame&&(this.boxFace.visible?(this.creating=!0,this.boxFace.getFaceTangent(this.normal1),this.boxFace.getFaceNormal(this.normal2),this.normal1.transformDirection(this.boxFace.matrix),this.normal2.transformDirection(this.boxFace.matrix)):Gt(this.point1,i.mouseRay0,i.mouseRay1,this.point1.set(0,0,0),i.camera.perspective?p1e.set(0,1,0):i.mouseRayN)&&(i.camera.perspective?(this.normal1.set(1,0,0),this.normal2.set(0,1,0)):(this.boxFace.setFaceFromNormal(i.mouseRayN),this.boxFace.getFaceTangent(this.normal1),this.boxFace.getFaceNormal(this.normal2)),this.creating=!0),this.creating&&(s.isKeyPressed("Shift")&&Xu(this.point1,Es),this.activeViewIndex=i.index,this.boxHeight=0,this.boxEdge.setPoint1(this.point1),this.boxEdge.setPoint2(this.point1),this.boxEdge.setNormal1(this.normal1),this.boxEdge.setNormal2(this.normal2),this.boxEdge.setHeight(0),this.boxEdge.updateGeometry(),this.boxEdge.visible=!0))}}onUnselected(t){this.draggingFace=!1,this.creating=!1,this.point2Set=!1,this.boxEdge.visible=!1,this.boxFace.visible=!1}}u(Yp,"BoxTool");d1e(Yp,"BoxTool");var m1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAItJREFUSIntkskRgCAMAIljIR4taP8FaAsencSPMtGBkGD4sR8zjO6C6lwlF7wpGqDXYoFika/UPBISmkZiMrMIJzKJpCS/IxLBr4j04dR9rUUcEREAICswdJOf93P1c0yoCjzy7VhQIxWBBLoWmjnYE5juWIr2FE1uiH58DvUroLse+xmce/9dFTUXvoWCImYNNpoAAAAASUVORK5CYII=",g1e=Object.defineProperty,v1e=u((n,e)=>g1e(n,"name",{value:e,configurable:!0}),"__name$P");class Zp extends ri{constructor(){super(...arguments);T(this,"name",Zp.name);T(this,"label","Select");T(this,"icon",m1e);T(this,"enableSelectionRect",!0);T(this,"enableDefaultSelectionBehavior",!0)}}u(Zp,"CursorTool");v1e(Zp,"CursorTool");var y1e=Object.defineProperty,ZA=u((n,e)=>y1e(n,"name",{value:e,configurable:!0}),"__name$O");function c_(n,e,t){return n[e]=t.x,n[e+1]=t.y,n[e+2]=t.z,e+3}u(c_,"vertex");ZA(c_,"vertex");function Is(n,e,t,i){return e=c_(n,e,t),c_(n,e,i)}u(Is,"line");ZA(Is,"line");const Oa=new P,uu=new P,Fl=new P,hu=new P,Yf=new P,Zf=new P,Kf=new P,Qf=new P;class KA extends Tr{constructor(){const t=new Je,i=new Array(12*2*3).fill(0);t.setAttribute("position",new Ve(i,3));const s=new Bi({toneMapped:!1,color:16777215,transparent:!0,opacity:.25});super(t,s);T(this,"box",new un);this.type="AabbEdge"}setBox(t){if(this.box.equals(t))return;this.box.copy(t);const i=t.max.x-t.min.x,s=t.max.y-t.min.y,r=t.max.z-t.min.z;Oa.copy(t.min),uu.copy(Oa),uu.x+=i,Fl.copy(Oa),Fl.x+=i,Fl.z+=r,hu.copy(Oa),hu.z+=r,Yf.copy(Oa),Yf.y+=s,Zf.copy(uu),Zf.y+=s,Kf.copy(Fl),Kf.y+=s,Qf.copy(hu),Qf.y+=s;const o=this.geometry.attributes.position,a=o.array;let l=0;l=Is(a,l,Oa,uu),l=Is(a,l,uu,Fl),l=Is(a,l,Fl,hu),l=Is(a,l,hu,Oa),l=Is(a,l,Oa,Yf),l=Is(a,l,uu,Zf),l=Is(a,l,Fl,Kf),l=Is(a,l,hu,Qf),l=Is(a,l,Yf,Zf),l=Is(a,l,Zf,Kf),l=Is(a,l,Kf,Qf),Is(a,l,Qf,Yf),o.needsUpdate=!0}}u(KA,"AabbEdge");ZA(KA,"AabbEdge");var b1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJNJREFUSIntVMsOwCAIo8v+/5e7kwkzgIJmO2w9+YBWiyLyYzdIMhN/VIlnhTBLDACaVM8BDHlCcj1viOI0XGWS1CezSPr96ZtkCxnlnVWCLb5740ycK6KL6SXpfav4Ip1FVe8tjmbhTaAtrggNa/NYDbx1z2svL/VMK0/znZ/skVZ6UWjRqGMud1OLbPT5tgl9BxdXU+tyUEB2ugAAAABJRU5ErkJggg==",x1e=Object.defineProperty,QA=u((n,e)=>x1e(n,"name",{value:e,configurable:!0}),"__name$N");function JA(...n){if(!n.length)return null;if(n.length===1)return n[0];const e=new Set;let t=n[0];for(;t;)e.add(t),t=t.parent;let i=n[1];for(;i;){if(e.has(i))return JA(i,...n.slice(2));i=i.parent}return null}u(JA,"getCommonParent");QA(JA,"getCommonParent");const _1e=function(){const n=new un,e=new me;return QA(u(function t(i,s,r){s.updateWorldMatrix(!1,!1);const o=s.geometry;o&&(o.boundingBox||o.computeBoundingBox(),n.copy(o.boundingBox),e.multiplyMatrices(r,s.matrixWorld),n.applyMatrix4(e),i.union(n));for(let a of s.children)a.visible&&t(i,a,r)},"expandBoxByVisibleObjects2"),"expandBoxByVisibleObjects")}(),zg=new un,Fa=new me,Jf=new me,Db=new me,Jn=new P,Lb=new je,Nl=new P,Li=new P,FE=new me,NE=new me,ed=new P,Bg=new P;class eM extends ri{constructor(){super(...arguments);T(this,"label","Transform");T(this,"icon",b1e);T(this,"nodes",[]);T(this,"detMats",new Map);T(this,"geom3Init",new Map);T(this,"boundingBox",new KA)}setup(t){t.scene.add(this.boundingBox),this.boundingBox.visible=!1}begin(t){const i=t.readonlyRef().model;this.nodes=i.getTopmostSelectedNodes().filter(r=>r.visible&&r.has(Me));const s=this.nodes.map(r=>r.value(Me)).filter(r=>!!r);if(s.length){this.boundingBox.visible=!0,zg.makeEmpty();const r=JA(...s);r?(r.updateWorldMatrix(!1,!1),Fa.copy(r.matrixWorld),Jf.copy(r.matrixWorld).invert()):(Fa.identity(),Jf.identity());for(let o of s)_1e(zg,o,Jf);this.boundingBox.setBox(zg),Fa.decompose(this.boundingBox.position,this.boundingBox.quaternion,this.boundingBox.scale),this.boundingBox.quaternion.normalize(),zg.applyMatrix4(Fa).getSize(Bg),t.statusBarMessage=`${Bg.x.toFixed(2)} \xD7 ${Bg.y.toFixed(2)} \xD7 ${Bg.z.toFixed(2)}`}else this.boundingBox.visible=!1,t.statusBarMessage="";this.enableSelectionRect=!0}update(t,i){var r,o,a,l;const s=i.gizmo;if(s.orientation=t.options.useLocalSpaceForTransformControl?"local":"world",i.gizmo.visible=!0,i.gizmoEnabled=this.boundingBox.visible,i.gizmoEnabled&&(this.boundingBox.updateMatrixWorld(),s.dragging||(this.boundingBox.box.getCenter(Jn).applyMatrix4(this.boundingBox.matrixWorld),s.setTargetTransform(Jn,this.boundingBox.quaternion,Nl.set(1,1,1))),i.gizmo.enableTranslate=!0,i.gizmo.enableRotate=!0,i.gizmo.enableScale=!0,s.update(i.camera,i.raycaster,i.input,i.mouseRay0,i.mouseRay1,i.mouseRayN)),s.dragging)if(this.enableSelectionRect=!1,s.dragStart){Fa.compose(s.position0,s.rotation0,s.scale0),Jf.copy(Fa).invert(),this.detMats.clear(),this.geom3Init.clear();for(let c of this.nodes){const h=new me().multiplyMatrices(Jf,c.getWorldMatrix());switch(this.detMats.set(c.id,h),c.type){case"CsgCuboid":this.geom3Init.set(c.id,{[Ks.name]:c.cloneValue(Ks),[Et.name]:c.cloneValue(Et)});break;case"CsgEllipsoid":this.geom3Init.set(c.id,{[xr.name]:c.cloneValue(xr),[Et.name]:c.cloneValue(Et)});break;case"CsgCylinder":this.geom3Init.set(c.id,{[ln.name]:c.cloneValue(ln),[Et.name]:c.cloneValue(Et),[ds.name]:c.cloneValue(ds)});break;case"CsgCylinderElliptic":this.geom3Init.set(c.id,{[ln.name]:c.cloneValue(ln),[Et.name]:c.cloneValue(Et)});break}}}else{FE.compose(s.position0,s.rotation0,s.scale0),Fa.compose(s.position1,s.rotation1,s.scale1);for(let c of this.nodes){const h=this.detMats.get(c.id);if(!h)continue;Db.copy(c.getParentWorldMatrix()).invert().multiply(Fa).multiply(h),Db.decompose(Jn,Lb,Nl),c.has(ze)&&t.history.setValue(c,ze,new P().copy(Jn)),c.has(tt)&&t.history.setValue(c,tt,new ht().setFromQuaternion(Lb));let f=!1;if(s.mode==="scale"){const d=this.geom3Init.get(c.id);if(d&&Math.abs(Lb.length()-1)<1e-8){const p=d[Et.name];switch(Li.copy(Nl).divide(p),c.type){case"CsgCuboid":{const g=new P().copy(d[Ks.name]);g.multiply(Li),t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,Ks,g),f=!0}break;case"CsgEllipsoid":{const g=new P().copy(d[xr.name]);g.multiply(Li),t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,xr,g),f=!0}break;case"CsgCylinder":if(Math.abs(Li.x-1)<1e-7&&Math.abs(Li.y-1)<1e-7&&Math.abs(Li.z-1)>1e-7){let g=d[ln.name];g*=Li.z,t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ln,g),t.history.setValue(c,Et,new P().copy(p)),f=!0}else if(Math.abs(Li.x-1)>1e-7&&Math.abs(Li.y-Li.x)<1e-7&&Math.abs(Li.z-1)<1e-7){let g=d[ds.name];g*=Li.x,t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ds,g),t.history.setValue(c,Et,new P().copy(p)),f=!0}else t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ln,d[ln.name]),t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ds,d[ds.name]);break;case"CsgCylinderElliptic":if(Math.abs(Li.x-1)<1e-7&&Math.abs(Li.y-1)<1e-7&&Math.abs(Li.z-1)>1e-7){let g=d[ln.name];g*=Li.z,t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ln,g),t.history.setValue(c,Et,new P().copy(p)),f=!0}else t.history.setValue(c.instanceId?t.model.getNode(c.instanceId):c,ln,d[ln.name]);break}}}if(!f)if(c.has(Wt)){NE.copy(c.getParentWorldMatrix()).invert().multiply(FE).multiply(h),PD(ed,NE);const d=(Nl.x/ed.x||1)*(Nl.y/ed.y||1)*(Nl.z/ed.z||1)*ed.x;t.history.setValue(c,Wt,d)}else c.has(Et)&&t.history.setValue(c,Et,new P().copy(Nl));if(c.has(Ge)){const d=c.get(Ge);f?(d.useTempMat=!0,d.tempMat.copy(Db)):d.useTempMat=!1;let p=c;for(;p&&(p.parent&&p.parent.has(Ge));)p=p.parent;t.delayThrottle(`#${p.id}-update-csg`,50)}}}else if(t.selectionRectSetThisFrame&&t.selectionRectViewIndex===i.index){const c=t.readonlyRef().selectionRect;if(Math.abs(c.x0-c.x1)<1e-6&&Math.abs(c.y0-c.y1)<1e-6){const h=i.raycaster.intersectObjects(t.readonlyRef().scene.children.filter(v=>!!v.userData.node));let f=!1,d=null;for(let v of h)if((r=v.object.userData.node)!=null&&r.visible){const y=v.object.userData.node;if(!t.options.allowSelectingInvisibleObjectByClicking&&y.has(Ge)&&((o=y.parent)==null?void 0:o.has(Ge)))continue;if(d||(d=y),!f&&t.model.selected.includes(y.id)){f=!0;break}}const p=new Set;for(let v of this.nodes)if(v.type==="CsgBezierControlPoint")for(let y of v.parent.children)p.add(y);let g=1/0;const m=i.camera.get();for(let v of p)dh(Jn,v.getWorldMatrix()),Jn.project(m),!(Jn.z>g)&&(Jn.x+=1,Jn.y+=1,Jn.x*=i.width/2,Jn.y*=i.height/2,Math.sqrt((i.mouseScr.x-Jn.x)**2+(i.mouseScr.y-Jn.y)**2)<=24/2&&(g=Jn.z,d=v));f||(i.input.isKeyPressed("Control")||(t.model.selected.length=0),d&&t.model.addSelection(d.id))}else{const h=new Set;for(let f of this.nodes)if(f.type==="CsgBezierControlPoint")for(let d of f.parent.children)h.add(d);if(h.size){const f=i.camera.get();i.input.isKeyPressed("Control")||(t.model.selected.length=0);const d=Math.min(c.x0,c.x1),p=Math.min(c.y0,c.y1),g=Math.max(c.x0,c.x1),m=Math.max(c.y0,c.y1);for(let v of h)dh(Jn,v.getWorldMatrix()),Jn.project(f),Jn.x>=d&&Jn.x<=g&&Jn.y>=p&&Jn.y<=m&&t.model.selected.push(v.id)}else{const f=c.select(i.camera.get(),t.readonlyRef().scene.children.filter(d=>!!d.userData.node));i.input.isKeyPressed("Control")||(t.model.selected.length=0);for(let d of f)if((a=d.userData.node)!=null&&a.visible){const p=d.userData.node;if(!t.options.allowSelectingInvisibleObjectByClicking&&p.has(Ge)&&((l=p.parent)==null?void 0:l.has(Ge)))continue;t.model.addSelection(p.id)}}}}}end(t){var s;const i=new Set;for(let r of this.nodes)if(r.type==="CsgBezierControlPoint")for(let o of r.parent.children)i.add(o);else{if(!r.has(Ge))continue;const o=r.get(Ge);let a=r,l=!1;if(o.useTempMat)l=!0;else for(;a&&a.has(Ge);){if(a.has(Mi)&&((s=a==null?void 0:a.parent)==null?void 0:s.has(Ge))&&a.value(Mi)==="negative"){l=!0;break}a=a.parent}l&&i.add(r)}for(let r of i){const o=r.get(Me);if(!o.value)continue;const a=r.get(Ge),l=a.placeholder;l&&(l.parent||t.scene.add(l),l.visible=!0,l.matrixAutoUpdate=!1,a.useTempMat?l.matrix.multiplyMatrices(r.getParentWorldMatrix(),a.tempMat):l.matrix.copy(o.value.matrixWorld))}}afterRender(t){for(let i of this.nodes)if(i.type==="CsgBezierControlPoint")for(let s of i.parent.children){const r=s.get(Ge);r.placeholder&&(r.placeholder.visible=!1)}else if(i.has(Ge)){const s=i.get(Ge);s.placeholder&&(s.placeholder.visible=!1)}}onUnselected(t){this.boundingBox.visible=!1;for(let i of t.views)i.gizmoEnabled=!1,i.gizmo.visible=!1,i.gizmo.dragging=!1;t.selectionRect.hide(),this.nodes=[],this.detMats.clear(),this.geom3Init.clear()}}u(eM,"GizmoTool");QA(eM,"GizmoTool");var w1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHJJREFUSIntk0sOwCAIRB3vf2e6aqJN+AnEJjpLJfNQhtaudgvcBRHRVAiwtW59zbmzNPMIpGuwaOcioERaxymzyJ6DyygN4IGMYXAHw7ITo7nUmBnCQUOxliDSC8x7AABaurQak5b/+ZeQUsALKQWcoQdg9q9krk0nEQAAAABJRU5ErkJggg==",A1e=Object.defineProperty,M1e=u((n,e)=>A1e(n,"name",{value:e,configurable:!0}),"__name$M");const Ob=new P,Ug=new P,$g=new P,kl=new P,Vg=new me,fu=new me,Hg=new me,du=new P,fr=new je,Fb=new je,S1e=new je,kE=new je,Gg=new P,zE=new P,Wg=new P,BE=new P,UE=new P,Nb=new P,jg=new je,$E=new P;class tM extends ri{constructor(){super(...arguments);T(this,"label","IK Bind");T(this,"icon",w1e);T(this,"activeView",-1);T(this,"ikChains",[]);T(this,"node");T(this,"rotate",!1);T(this,"mouse0",new P);T(this,"nodeInvMat",new me);T(this,"chainInvMat",new me);T(this,"chainPosition0",new P);T(this,"nodeStart0",new P);T(this,"nodeEnd0",new P);T(this,"nodeRotation0",new je);T(this,"nodeLocalMat0",new Map);T(this,"objWorldMat0",new Map)}begin(t){this.cleanup(t);const i=new Set;for(let s of t.model.getSelectedNodes())s.type==="IKChain"?i.add(s):s.type==="IKNode"&&s.parent&&i.add(s.parent);this.ikChains=Array.from(i);for(let s of this.ikChains)for(let r=0,o=s.children.length;r<o;++r){const l=s.children[r].get(At);l.boneMesh&&(l.boneMesh.visible=!0),l.hingeIndicator&&(l.hingeIndicator.visible=l.hingeEnabled),r===0&&l.moveHandler&&(l.moveHandler.visible=!0),l.rotateHandler&&(l.rotateHandler.visible=!0)}}update(t,i){const s=i.input;if(s.mouseLeft){if(s.mouseLeftDownThisFrame){if(s.pointerOver){let r=1/0,o=null,a=null;for(let l of this.ikChains)for(let c of l.children){const h=c.get(At);h.updateHandlersHoverState(c,i),h.moveHandlerHovered&&h.moveHandlerZ<r&&(r=h.moveHandlerZ,o=c,a=h),h.rotateHandlerHovered&&h.rotateHandlerZ<r&&(r=h.rotateHandlerZ,o=c,a=h)}if(o&&a){this.node=o,this.rotate=a.rotateHandlerHovered,this.activeView=i.index;const l=o.parent,c=l.getWorldMatrix();this.mouse0.copy(this.rotate?a.end:a.start).applyMatrix4(c),Gt(this.mouse0,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),this.nodeInvMat.copy(c).invert(),this.chainInvMat.copy(l.getParentWorldMatrix()).invert(),this.nodeStart0.copy(a.start),this.nodeEnd0.copy(a.end),this.nodeRotation0.copy(a.quaternion),this.chainPosition0.copy(l.value(ze)),this.nodeLocalMat0.clear(),this.objWorldMat0.clear();for(let h of l.children){this.nodeLocalMat0.set(h.id,new me().copy(h.getLocalMatrix()));for(let f of h.children)this.objWorldMat0.set(f.id,new me().copy(f.getWorldMatrix()))}t.model.addSelection(this.node.id)}else{let l;for(let c of i.mousePick()){for(l=c.object.userData.node;l&&!l.has(At);)l=l.parent||void 0;if(l){this.mouse0.copy(c.point);break}}if(!l){t.model.selected=[];return}t.model.selected=[l.id]}}}else if(this.activeView===i.index&&this.node&&!this.node.deleted){const r=this.node.parent;if(Gt(Ob,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),this.rotate){Ug.copy(this.mouse0).applyMatrix4(this.nodeInvMat),$g.copy(Ob).applyMatrix4(this.nodeInvMat),kl.subVectors($g,Ug),zE.subVectors(this.nodeEnd0,this.nodeStart0).normalize(),Wg.copy(this.nodeEnd0).add(kl).sub(this.nodeStart0);let o=Wg.length();Wg.normalize(),Fb.setFromUnitVectors(zE,Wg),BE.set(0,0,1).applyQuaternion(this.nodeRotation0).applyQuaternion(Fb),UE.set(0,1,0).applyQuaternion(this.nodeRotation0).applyQuaternion(Fb),Qa(fr,BE,UE),jg.copy(fr);const a=r.children.indexOf(this.node);if(a>0){const c=r.children[a-1];kE.copy(c.get(At).quaternion).invert(),fr.multiplyQuaternions(kE,fr)}let l=t.history.setValue(this.node,Sn,new ht().setFromQuaternion(fr));if(t.options.allowModifyingBoneLengthWhenBindingIk&&(l=t.history.setValue(this.node,Ji,o)||l),l&&t.options.keepInternalTransformWhenBindingIk){let c=r.children.indexOf(this.node);if(c<0)return;Nb.copy(this.node.get(At).start),$E.set(1,1,1);const h=r.getWorldMatrix();for(let f=r.children.length;c<f;++c){const d=r.children[c];fu.compose(Nb,jg,$E),fu.multiplyMatrices(h,fu).invert();for(let g of d.children){const m=this.objWorldMat0.get(g.id);!m||(Hg.multiplyMatrices(fu,m),Hg.decompose(du,fr,Gg),g.has(ze)&&t.history.setValue(g,ze,new P().copy(du)),g.has(tt)&&t.history.setValue(g,tt,new ht().setFromQuaternion(fr)))}const p=c+1;if(p<f){kl.set(o,0,0).applyQuaternion(jg),Nb.add(kl);const g=r.children[p];jg.multiply(S1e.setFromEuler(g.value(Sn))),o=g.value(Ji)}}}}else if(Ug.copy(this.mouse0).applyMatrix4(this.chainInvMat),$g.copy(Ob).applyMatrix4(this.chainInvMat),kl.subVectors($g,Ug),t.history.setValue(r,ze,new P().copy(this.chainPosition0).add(kl))&&t.options.keepInternalTransformWhenBindingIk){du.copy(this.chainPosition0).add(kl),fr.setFromEuler(r.value(tt)),Gg.setScalar(r.value(Wt)),Vg.compose(du,fr,Gg),Vg.multiplyMatrices(r.getParentWorldMatrix(),Vg);for(let a of r.children){const l=this.nodeLocalMat0.get(a.id);if(!!l){fu.multiplyMatrices(Vg,l).invert();for(let c of a.children){const h=this.objWorldMat0.get(c.id);!h||(Hg.multiplyMatrices(fu,h),Hg.decompose(du,fr,Gg),c.has(ze)&&t.history.setValue(c,ze,new P().copy(du)),c.has(tt)&&t.history.setValue(c,tt,new ht().setFromQuaternion(fr)))}}}}}}else this.activeView===i.index&&(this.activeView=-1,this.node=void 0)}onUnselected(t){this.cleanup(t)}cleanup(t){for(let i of this.ikChains)if(!i.deleted)for(let s of i.children){if(s.deleted)continue;s.get(At).resetHandlers(t)}this.ikChains.length=0}}u(tM,"IkBindTool");M1e(tM,"IkBindTool");var T1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHJJREFUSIntktsOwCAIQ+3+/5/xyWRbVrATNVl23kRCubSUn92AfZiZXRIBmitzL85iacVHRI5IbLRzV0Chu5Eokd1HmvbNHVj8cUUAkOYaD6VbaYJGxiShi7at6/yWXdQj4gmmiExd2zKR6cdf4q7vUwFJaZOIR/7h8gAAAABJRU5ErkJggg==",C1e=Object.defineProperty,E1e=u((n,e)=>C1e(n,"name",{value:e,configurable:!0}),"__name$L");const us=new P,VE=new me;class nM extends ri{constructor(){super(...arguments);T(this,"label","Stretch Joint");T(this,"icon",T1e);T(this,"node",null);T(this,"dragging",!1);T(this,"draggedPrevFrame",!1);T(this,"length0",0);T(this,"childrenPosition0",new Map);T(this,"scale",new P)}begin(t){this.cleanup(t),this.node=null;for(let s of t.model.getSelectedNodes())if(!s.instanceId){this.node=s;break}for(;this.node&&!(this.node.type==="IKNode"&&!this.node.instanceId);)this.node=this.node.parent;if(!this.node)return;const i=this.node.parent;for(let s=0,r=i.children.length;s<r;++s){const a=i.children[s].get(At);a.boneMesh&&(a.boneMesh.visible=!0)}if(!this.dragging){this.length0=this.node.value(Ji),this.childrenPosition0.clear();for(let s of this.node.children)s.has(ze)&&this.childrenPosition0.set(s.id,new P().copy(s.value(ze)))}this.draggedPrevFrame=this.dragging,this.dragging=!1}update(t,i){if(this.node&&(i.gizmoEnabled=!0,i.gizmo.visible=!0,i.gizmo.orientation="local",i.gizmo.enableTranslate=!1,i.gizmo.enableRotate=!1,i.gizmo.enableScale=!0,i.gizmo.dragging||(i.gizmo.setTargetTransformFromMatrix(this.node.getWorldMatrix()),i.gizmo.scale0.set(1,1,1)),i.gizmo.update(i.camera,i.raycaster,i.input,i.mouseRay0,i.mouseRay1,i.mouseRayN),i.gizmo.dragging)){this.dragging=!0,this.scale.copy(i.gizmo.scale1),this.scale.x=Math.max(this.scale.x,0),t.history.setValue(this.node,Ji,this.length0*this.scale.x);for(let r of this.childrenPosition0){const o=t.model.getNode(r[0]),a=r[1],l=new P().copy(a);l.x*=this.scale.x,t.history.setValue(o,ze,l)}for(let r of this.node.children)r.type==="Clay"&&t.model.setValue(r,Qo,new P().copy(this.scale));return}const s=i.input;if(s.pointerOver&&s.mouseLeftDownThisFrame)for(let r of i.mousePick()){const o=r.object.userData.node;if(o&&!o.instanceId){t.model.selected=[o.id];break}}}end(t){if(this.draggedPrevFrame&&!this.dragging&&this.node){const i=this.scale,s=this.length0,r=i.x*s,o=r-s,a=t.options.keepBothEndsOfClayNodesWhenStretching;let l=!1;for(let c of this.node.children)if(c.type==="Clay"){l=!0;const h=c.getLocalMatrix();VE.copy(h).invert();const f=c.cloneValue(Fn);for(let d=0,p=f.length;d<p;d+=3)us.fromArray(f,d),us.applyMatrix4(h),i.x>1&&a?us.x>0&&us.x<r?us.x*=i.x:us.x>=r&&(us.x+=o):us.x*=i.x,us.y*=i.y,us.z*=i.z,us.applyMatrix4(VE),f[d]=us.x,f[d+1]=us.y,f[d+2]=us.z;t.history.setValue(c,Fn,f)}if(l){const c=[];c.push({node:this.node,componentClass:Ji});for(let h of this.childrenPosition0){const f=t.model.getNode(h[0]);c.push({node:f,componentClass:ze})}t.history.mergeLastRecord(c)}}}onUnselected(t){for(let i of t.views)i.gizmoEnabled=!1,i.gizmo.visible=!1,i.gizmo.dragging=!1;this.cleanup(t),this.node=null,this.dragging=!1,this.draggedPrevFrame=!1,this.scale.setScalar(1),this.childrenPosition0.clear()}cleanup(t){if(this.node){for(let s of this.node.children)s.type==="Clay"&&t.model.setValue(s,Qo,new P(1,1,1));const i=this.node.parent;for(let s=0,r=i.children.length;s<r;++s)i.children[s].get(At).resetHandlers(t)}}}u(nM,"IkJointStretchTool");E1e(nM,"IkJointStretchTool");var P1e=Object.defineProperty,R1e=u((n,e)=>P1e(n,"name",{value:e,configurable:!0}),"__name$K");class iM{constructor(){T(this,"length",0);T(this,"localRotation",new je);T(this,"start",new P);T(this,"end",new P);T(this,"rotation",new je);T(this,"hingeEnabled",!1);T(this,"hingeAxis",new P(1,0,0));T(this,"lowerAngle",-Math.PI);T(this,"upperAngle",+Math.PI)}}u(iM,"CcdJoint");R1e(iM,"CcdJoint");var I1e=Object.defineProperty,D1e=u((n,e)=>I1e(n,"name",{value:e,configurable:!0}),"__name$J");const kb=new P,HE=new P,GE=new P,td=new je,WE=new P,jE=new P,Xg=new je,qg=new P;class sM{constructor(){T(this,"joints",[]);T(this,"iterLimit",20);T(this,"precision",1e-4)}resize(e){this.joints.length=e;for(let t=0;t<e;++t)this.joints[t]||(this.joints[t]=new iM)}resolve(e){const t=this.joints.length;if(!t)return;for(let s=0;s<t;++s){const r=this.joints[s];if(s>0){const o=this.joints[s-1];r.rotation.multiplyQuaternions(o.rotation,r.localRotation),r.start.copy(o.end)}else r.rotation.copy(r.localRotation),r.start.set(0,0,0);r.end.set(r.length,0,0).applyQuaternion(r.rotation).add(r.start)}const i=this.joints[t-1];kb.copy(i.end);for(let s=0;s<this.iterLimit;++s){for(let r=t-1;r>=0;--r){const o=this.joints[r];if(HE.subVectors(i.end,o.start).normalize(),GE.subVectors(e,o.start).normalize(),td.setFromUnitVectors(HE,GE),WE.set(0,0,1).applyQuaternion(o.rotation).applyQuaternion(td),jE.set(0,1,0).applyQuaternion(o.rotation).applyQuaternion(td),Qa(o.localRotation,WE,jE),r>0){const a=this.joints[r-1];Xg.copy(a.rotation).invert(),o.localRotation.multiplyQuaternions(Xg,o.localRotation)}if(o.hingeEnabled){Xg.copy(o.localRotation).invert(),qg.copy(o.hingeAxis).applyQuaternion(Xg),td.setFromUnitVectors(o.hingeAxis,qg),o.localRotation.multiply(td).normalize();let a=Go(qg,o.localRotation);const l=Math.sign(qg.dot(o.hingeAxis));a=ow(a*l,o.lowerAngle,o.upperAngle),o.localRotation.setFromAxisAngle(o.hingeAxis,a)}for(let a=r;a<t;++a){const l=this.joints[a];if(a>0){const c=this.joints[a-1];l.rotation.multiplyQuaternions(c.rotation,l.localRotation),l.start.copy(c.end)}else l.rotation.copy(l.localRotation),l.start.set(0,0,0);l.end.set(l.length,0,0).applyQuaternion(l.rotation).add(l.start)}}if(i.end.distanceToSquared(kb)<=this.precision||i.end.distanceToSquared(e)<=this.precision)break;kb.copy(i.end)}}}u(sM,"CcdChain");D1e(sM,"CcdChain");var L1e=Object.defineProperty,oa=u((n,e)=>L1e(n,"name",{value:e,configurable:!0}),"__name$I");class rM{constructor(e){T(this,"node");T(this,"length",0);T(this,"localRotation",new je);T(this,"localRotation0",new je);T(this,"hingeEnabled",!1);T(this,"hingeAxis",new P(1,0,0));T(this,"lowerAngle",-Math.PI);T(this,"upperAngle",+Math.PI);T(this,"localMat",new me);T(this,"worldMat",new me);T(this,"hasLockEndChild",!1);T(this,"children",[]);T(this,"parent",null);T(this,"start",new P);T(this,"end",new P);T(this,"rotation",new je);this.node=e}}u(rM,"VirtualIkNode");oa(rM,"VirtualIkNode");class oM{constructor(){T(this,"localMat",new me);T(this,"worldMat",new me);T(this,"hasLockEndChild",!1);T(this,"children",[]);T(this,"parent",null)}}u(oM,"VirtualContainer");oa(oM,"VirtualContainer");class bv{constructor(){T(this,"children",[]);T(this,"localMat",new me);T(this,"worldMat",new me);T(this,"hasLockEndChild",!1);T(this,"lockEnd",!1);T(this,"endWorld",new P);T(this,"parent",null)}}u(bv,"VirtualIkChain");oa(bv,"VirtualIkChain");function aM(n){const e=[];let t=!1;for(let i of n.children){const s=aM(i);s&&(e.push(s),(s.hasLockEndChild||s.lockEnd)&&(t=!0))}switch(n.type){case"Container":{const i=new oM;i.localMat.copy(n.getLocalMatrix()),i.worldMat.copy(n.getWorldMatrix()),i.hasLockEndChild=t,i.children=e;for(let s of i.children)s.parent=i;return i}case"IKChain":{const i=new bv;if(i.localMat.copy(n.getLocalMatrix()),i.worldMat.copy(n.getWorldMatrix()),i.lockEnd=n.value(dp),i.hasLockEndChild=t,i.children=e,i.lockEnd&&n.children.length){const s=n.children[n.children.length-1];i.endWorld.copy(s.get(At).end),i.endWorld.applyMatrix4(i.worldMat)}for(let s of i.children)s.parent=i;return i}case"IKNode":{const i=new rM(n);switch(i.localMat.copy(n.getLocalMatrix()),i.worldMat.copy(n.getWorldMatrix()),i.length=n.value(Ji),i.localRotation.setFromEuler(n.value(Sn)),i.localRotation0.copy(i.localRotation),n.value(gs)){case"horizontal":i.hingeEnabled=!0,i.hingeAxis.set(0,1,0);break;case"vertical":i.hingeEnabled=!0,i.hingeAxis.set(0,0,1);break;default:i.hingeEnabled=!1;break}const s=n.value(Ja);if(i.lowerAngle=s[0]/180*Math.PI,i.upperAngle=s[1]/180*Math.PI,n.instanceId&&n.has(jn)){const r=n.value(jn);switch(n.value(gs)){case"horizontal":r.z>1e-6&&([i.lowerAngle,i.upperAngle]=[-i.upperAngle,-i.lowerAngle]);break;case"vertical":r.y>1e-6&&([i.lowerAngle,i.upperAngle]=[-i.upperAngle,-i.lowerAngle]);break}}i.hasLockEndChild=t,i.children=e;for(let r of i.children)r.parent=i;return i}}return null}u(aM,"createVirtualNode");oa(aM,"createVirtualNode");function gN(n){return aM(n)}u(gN,"saveIkChainState");oa(gN,"saveIkChainState");const Yg=new sM,O1e=new P(1,1,1);function lM(n,e,t,i){Yg.resize(t+1);for(let s=0;s<=t;++s){const r=Yg.joints[s],o=e.children[s];r.length=o.length,r.localRotation.copy(o.localRotation),r.hingeEnabled=o.hingeEnabled,r.hingeAxis.copy(o.hingeAxis),r.lowerAngle=o.lowerAngle,r.upperAngle=o.upperAngle}Yg.resolve(i);for(let s=0;s<=t;++s){const r=Yg.joints[s],o=e.children[s];o.localRotation.copy(r.localRotation),n.history.setValue(o.node,Sn,new ht().setFromQuaternion(o.localRotation))}cM(e)}u(lM,"resolveIkChain");oa(lM,"resolveIkChain");function cM(n){for(let e=0,t=n.children.length;e<t;++e){const i=n.children[e];if(e===0)i.rotation.copy(i.localRotation),i.start.set(0,0,0);else{const s=n.children[e-1];i.rotation.multiplyQuaternions(s.rotation,i.localRotation),i.start.copy(s.end)}i.end.set(i.length,0,0).applyQuaternion(i.rotation).add(i.start),i.localMat.compose(i.start,i.rotation,O1e)}}u(cM,"updateIkChainLocalMatrices");oa(cM,"updateIkChainLocalMatrices");const XE=new me,qE=new P;function l1(n,e){if((e.hasLockEndChild||e.lockEnd)&&e.parent&&e.worldMat.multiplyMatrices(e.parent.worldMat,e.localMat),e.lockEnd){const t=e;XE.copy(t.worldMat).invert(),qE.copy(t.endWorld).applyMatrix4(XE),lM(n,t,t.children.length-1,qE)}if(e.hasLockEndChild)for(let t of e.children)l1(n,t)}u(l1,"resolveLockedEnds");oa(l1,"resolveLockedEnds");function uM(n){if(n instanceof bv)for(let e of n.children)e.localRotation.copy(e.localRotation0);if(n.hasLockEndChild)for(let e of n.children)uM(e)}u(uM,"resetIkChains");oa(uM,"resetIkChains");var F1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHlJREFUSIntU0EOwDAIqvv/n9m1MzjRNlmylCNSsFHHOPgaxkgAeIjMqK4Fbx5x28xXQ643w8xU0YQBGQCgPBulY6+bOeVH6RyYOau1Qjwf/aQVUlnfckjVqLTSHZO5VlrTbRetmEYzajWhDpzx8iXOj9kFZ/WDH+MGbSHHUbX+Pw0AAAAASUVORK5CYII=",N1e=Object.defineProperty,k1e=u((n,e)=>N1e(n,"name",{value:e,configurable:!0}),"__name$H");const Mo=new P,So=new P,pu=new P,mu=new P,YE=new P,nd=new P,zl=new je,Zg=new je,ZE=new P,KE=new P,Bl=new P,zb=new P,QE=new je,JE=new P;class hM extends ri{constructor(){super(...arguments);T(this,"label","Move IK Chain");T(this,"icon",F1e);T(this,"activeView",-1);T(this,"ikChains",[]);T(this,"node");T(this,"action","swing");T(this,"mouse0",new P);T(this,"origin",new P);T(this,"boneAxis",new P);T(this,"invMat",new me);T(this,"nodeEnd0",new P);T(this,"rotation0",new je);T(this,"position0",new P);T(this,"chain0",null)}begin(t){this.cleanup(t);const i=new Set;for(let s of t.model.getSelectedNodes())s.type==="IKChain"?i.add(s):s.type==="IKNode"&&s.parent&&i.add(s.parent);this.ikChains=Array.from(i);for(let s of this.ikChains)for(let r=0,o=s.children.length;r<o;++r){const a=s.children[r],l=a.get(At);r===0&&l.moveHandler&&(l.moveHandler.visible=s.value(_h)),l.rotateHandler&&(l.rotateHandler.visible=a.value(wh))}}update(t,i){const s=i.input;if(s.mouseLeft){if(s.mouseLeftDownThisFrame){if(s.pointerOver){let r=1/0,o=null,a=null,l=!1;for(let c of this.ikChains)for(let h of c.children){const f=h.get(At);f.updateHandlersHoverState(h,i),f.moveHandlerHovered&&f.moveHandlerZ<r&&(r=f.moveHandlerZ,o=h,a=f,l=!1),f.rotateHandlerHovered&&f.rotateHandlerZ<r&&(r=f.rotateHandlerZ,o=h,a=f,l=!0)}if(o&&a){this.node=o,this.action=l?"swing":"move",this.activeView=i.index;const c=o.parent,h=c.getWorldMatrix();l?this.mouse0.copy(a.end).applyMatrix4(h):(this.position0.copy(c.value(ze)),dh(this.mouse0,c.getWorldMatrix())),Gt(this.mouse0,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),l?(this.invMat.copy(h).invert(),this.nodeEnd0.copy(a.end)):this.invMat.copy(c.getParentWorldMatrix()).invert(),t.model.addSelection(this.node.id)}else{let c;for(let d of i.mousePickVisible()){for(c=d.object.userData.node;c&&!c.has(At);)c=c.parent||void 0;if(c){this.mouse0.copy(d.point);break}}if(!c){t.model.selected=[];return}if(t.model.selected=[c.id],c.value(gs)!=="none")return;this.node=c,this.action="twist",this.activeView=i.index;const h=c.getParentWorldMatrix();this.invMat.copy(h).invert(),So.copy(this.mouse0).applyMatrix4(this.invMat);const f=c.get(At);this.boneAxis.subVectors(f.end,f.start).normalize(),ID(this.origin,f.start,this.boneAxis,So),this.boneAxis.transformDirection(h),this.rotation0.copy(f.quaternion),this.origin.distanceTo(So)<1e-8?this.node=void 0:this.origin.applyMatrix4(h)}this.node&&(this.chain0=gN(this.node.parent))}}else if(this.activeView===i.index&&this.node&&!this.node.deleted&&this.chain0){let r=!1;if(this.action==="move"){Gt(Mo,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),So.copy(this.mouse0).applyMatrix4(this.invMat),pu.copy(Mo).applyMatrix4(this.invMat),mu.subVectors(pu,So);const o=this.node.parent,a=new P().addVectors(this.position0,mu);r=t.history.setValue(o,ze,a),zl.setFromEuler(o.value(tt)),JE.setScalar(o.value(Wt)),this.chain0.localMat.compose(a,zl,JE),this.chain0.worldMat.multiplyMatrices(o.getParentWorldMatrix(),this.chain0.localMat)}else if(this.action==="swing"){if(Gt(Mo,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),So.copy(this.mouse0).applyMatrix4(this.invMat),pu.copy(Mo).applyMatrix4(this.invMat),mu.subVectors(pu,So),mu.lengthSq()<1e-6)return;nd.copy(this.nodeEnd0).add(mu),this.mouse0.copy(Mo),this.nodeEnd0.copy(nd);const o=this.chain0.children.findIndex(a=>a.node.id===this.node.id);lM(t,this.chain0,o,nd),r=!0}else{if(Math.acos(Math.abs(this.boneAxis.dot(i.mouseRayN)))*180/Math.PI>45){if(!Gt(Mo,i.mouseRay0,i.mouseRay1,this.origin,i.mouseRayN))return;Bl.crossVectors(this.boneAxis,i.mouseRayN).normalize();const c=this.mouse0.distanceTo(this.origin),h=.4,f=-mu.subVectors(Mo,this.mouse0).dot(Bl)/c*Math.PI/2*h;Bl.copy(this.boneAxis).transformDirection(this.invMat),Zg.setFromAxisAngle(Bl,f)}else{if(!Gt(Mo,i.mouseRay0,i.mouseRay1,this.origin,this.boneAxis))return;So.copy(this.mouse0).applyMatrix4(this.invMat),pu.copy(Mo).applyMatrix4(this.invMat),zb.copy(this.origin).applyMatrix4(this.invMat),YE.subVectors(So,zb).normalize(),nd.subVectors(pu,zb).normalize(),Bl.copy(this.boneAxis).transformDirection(this.invMat);const c=ql(Bl,YE,nd);Zg.setFromAxisAngle(Bl,c)}ZE.set(0,0,1).applyQuaternion(this.rotation0).applyQuaternion(Zg),KE.set(0,1,0).applyQuaternion(this.rotation0).applyQuaternion(Zg),Qa(zl,ZE,KE);const o=this.node.parent,a=o.children.indexOf(this.node);if(a>0){const c=o.children[a-1];QE.copy(c.get(At).quaternion).invert(),zl.multiplyQuaternions(QE,zl)}r=t.history.setValue(this.node,Sn,new ht().setFromQuaternion(zl)),this.chain0.children.find(c=>c.node.id===this.node.id).localRotation.copy(zl),cM(this.chain0)}if(r){for(let o of this.chain0.children)uM(o);if(this.node.id===this.chain0.children[this.chain0.children.length-1].node.id)for(let o of this.chain0.children)l1(t,o);else l1(t,this.chain0)}}}else this.activeView===i.index&&(this.activeView=-1,this.node=void 0)}onUnselected(t){this.cleanup(t)}cleanup(t){for(let i of this.ikChains)if(!i.deleted)for(let s of i.children){if(s.deleted)continue;s.get(At).resetHandlers(t)}this.ikChains.length=0}}u(hM,"IkMoveTool");k1e(hM,"IkMoveTool");var z1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHhJREFUSIntk0sOgDAIRDve/864ra0DJUM1Mc4SKI9Pae3X2wJzmJldAgEam9aYnNnKkiuQI4KplbuALYoqZn7r1NunDgBAGcvyb/Mq9eyp4rKQO7+7ZHVcIaAKsqQRUn2Q00MGlLtliSqu3oWwQ5Mg25f/yO/6vk5YzaN81PvS3QAAAABJRU5ErkJggg==",B1e=Object.defineProperty,U1e=u((n,e)=>B1e(n,"name",{value:e,configurable:!0}),"__name$G");const Na=new P,To=new P,gu=new P,id=new P,Kg=new P,Qg=new P,ka=new je,Ul=new je,eP=new P,tP=new P,$l=new P,Bb=new P,Jg=new je,e0=new P,vu=new P;class fM extends ri{constructor(){super(...arguments);T(this,"label","Move Single Joint (Ignore IK)");T(this,"icon",z1e);T(this,"activeView",-1);T(this,"ikChains",[]);T(this,"node");T(this,"action","swing");T(this,"mouse0",new P);T(this,"origin",new P);T(this,"boneAxis",new P);T(this,"invMat",new me);T(this,"nodeStart0",new P);T(this,"nodeEnd0",new P);T(this,"rotation0",new je);T(this,"position0",new P)}begin(t){this.cleanup(t);const i=new Set;for(let s of t.model.getSelectedNodes())s.type==="IKChain"?i.add(s):s.type==="IKNode"&&s.parent&&i.add(s.parent);this.ikChains=Array.from(i);for(let s of this.ikChains)for(let r=0,o=s.children.length;r<o;++r){const a=s.children[r],l=a.get(At);r===0&&l.moveHandler&&(l.moveHandler.visible=s.value(_h)),l.rotateHandler&&(l.rotateHandler.visible=a.value(wh))}}update(t,i){const s=i.input;if(s.mouseLeft){if(s.mouseLeftDownThisFrame){if(s.pointerOver){let r=1/0,o=null,a=null,l=!1;for(let c of this.ikChains)for(let h of c.children){const f=h.get(At);f.updateHandlersHoverState(h,i),f.moveHandlerHovered&&f.moveHandlerZ<r&&(r=f.moveHandlerZ,o=h,a=f,l=!1),f.rotateHandlerHovered&&f.rotateHandlerZ<r&&(r=f.rotateHandlerZ,o=h,a=f,l=!0)}if(o&&a){this.node=o,this.action=l?"swing":"move",this.activeView=i.index;const c=o.parent,h=c.getWorldMatrix();l?this.mouse0.copy(a.end).applyMatrix4(h):(this.position0.copy(c.value(ze)),dh(this.mouse0,c.getWorldMatrix())),Gt(this.mouse0,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),l?(this.invMat.copy(h).invert(),this.nodeStart0.copy(a.start),this.nodeEnd0.copy(a.end),this.rotation0.copy(a.quaternion)):this.invMat.copy(c.getParentWorldMatrix()).invert(),t.model.addSelection(this.node.id)}else{let c;for(let d of i.mousePickVisible()){for(c=d.object.userData.node;c&&!c.has(At);)c=c.parent||void 0;if(c){this.mouse0.copy(d.point);break}}if(!c){t.model.selected=[];return}if(t.model.selected=[c.id],c.value(gs)!=="none")return;this.node=c,this.action="twist",this.activeView=i.index;const h=c.getParentWorldMatrix();this.invMat.copy(h).invert(),To.copy(this.mouse0).applyMatrix4(this.invMat);const f=c.get(At);this.boneAxis.subVectors(f.end,f.start).normalize(),ID(this.origin,f.start,this.boneAxis,To),this.boneAxis.transformDirection(h),this.rotation0.copy(f.quaternion),this.origin.distanceTo(To)<1e-8?this.node=void 0:this.origin.applyMatrix4(h)}}}else if(this.activeView===i.index&&this.node&&!this.node.deleted)if(this.action==="move"){Gt(Na,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),To.copy(this.mouse0).applyMatrix4(this.invMat),gu.copy(Na).applyMatrix4(this.invMat),id.subVectors(gu,To);const r=this.node.parent;t.history.setValue(r,ze,new P().addVectors(this.position0,id))}else{if(this.action==="swing")Gt(Na,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN),To.copy(this.mouse0).applyMatrix4(this.invMat),gu.copy(Na).applyMatrix4(this.invMat),id.subVectors(gu,To),Kg.subVectors(this.nodeEnd0,this.nodeStart0).normalize(),Qg.subVectors(this.nodeEnd0,this.nodeStart0).add(id).normalize(),Ul.setFromUnitVectors(Kg,Qg);else if(Math.acos(Math.abs(this.boneAxis.dot(i.mouseRayN)))*180/Math.PI>45){if(!Gt(Na,i.mouseRay0,i.mouseRay1,this.origin,i.mouseRayN))return;$l.crossVectors(this.boneAxis,i.mouseRayN).normalize();const l=this.mouse0.distanceTo(this.origin),c=.4,h=-id.subVectors(Na,this.mouse0).dot($l)/l*Math.PI/2*c;$l.copy(this.boneAxis).transformDirection(this.invMat),Ul.setFromAxisAngle($l,h)}else{if(!Gt(Na,i.mouseRay0,i.mouseRay1,this.origin,this.boneAxis))return;To.copy(this.mouse0).applyMatrix4(this.invMat),gu.copy(Na).applyMatrix4(this.invMat),Bb.copy(this.origin).applyMatrix4(this.invMat),Kg.subVectors(To,Bb).normalize(),Qg.subVectors(gu,Bb).normalize(),$l.copy(this.boneAxis).transformDirection(this.invMat);const l=ql($l,Kg,Qg);Ul.setFromAxisAngle($l,l)}eP.set(0,0,1).applyQuaternion(this.rotation0).applyQuaternion(Ul),tP.set(0,1,0).applyQuaternion(this.rotation0).applyQuaternion(Ul),Qa(ka,eP,tP);const r=this.node.parent,o=r.children.indexOf(this.node);if(o>0){const l=r.children[o-1];Jg.copy(l.get(At).quaternion).invert(),ka.multiplyQuaternions(Jg,ka)}let a=!1;switch(this.node.value(gs)){case"horizontal":vu.set(0,1,0),a=!0;break;case"vertical":vu.set(0,0,1),a=!0;break}if(a){Jg.copy(ka).invert(),e0.copy(vu).applyQuaternion(Jg),Ul.setFromUnitVectors(vu,e0),ka.multiply(Ul).normalize();let l=Go(e0,ka);const c=Math.sign(e0.dot(vu)),h=this.node.value(Ja);let f=h[0],d=h[1];if(this.node.instanceId&&this.node.has(jn)){const p=this.node.value(jn);switch(this.node.value(gs)){case"horizontal":p.z>1e-6&&([f,d]=[-d,-f]);break;case"vertical":p.y>1e-6&&([f,d]=[-d,-f]);break}}l=ow(l*c,f/180*Math.PI,d/180*Math.PI),ka.setFromAxisAngle(vu,l)}t.history.setValue(this.node,Sn,new ht().setFromQuaternion(ka))}}else this.activeView===i.index&&(this.activeView=-1,this.node=void 0)}onUnselected(t){this.cleanup(t)}cleanup(t){for(let i of this.ikChains)if(!i.deleted)for(let s of i.children){if(s.deleted)continue;s.get(At).resetHandlers(t)}this.ikChains.length=0}}u(fM,"IkRotateTool");U1e(fM,"IkRotateTool");var $1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHdJREFUSIntVEEOwCAIs2b///J2GQkh6VZQD1vsxaClIAFa2/gdzhtmH6qTtwGA8QAg8uVsnu7NTolLxM+K+zJlEpLInvPG79GRdcgUjGTPfKU5iCJ2Kr9NBZhSvlRHCD6dPSxFZdCWBCmLewF12TFIXaGu640SLqrDp4K4/n+JAAAAAElFTkSuQmCC",V1e=Object.defineProperty,H1e=u((n,e)=>V1e(n,"name",{value:e,configurable:!0}),"__name$F");const nP=new P;class dM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Brush");T(this,"icon",$1e);T(this,"sculpt",!0);T(this,"hasDirection",!0);T(this,"optionsProps",["brushRadius","brushStrength","brushDirection","frontFacesOnly"])}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=t.options.enablePressure?1:s.pressure,c=this.brushStrength*this.brushDirection*l*.01,h=new P,f=new P,d=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly);for(let p of d.track)this.stroke(p.indices,c,a.getAverageNormal(f,p.triangles),a.getAverageCenter(h,p.triangles),t.sculptLocalRadius,d.offset,d.position),t.sculptSym&&this.stroke(p.indicesSym,c,a.getAverageNormal(f,p.trianglesSym),a.getAverageCenter(h,p.trianglesSym),t.sculptLocalRadius,d.offset,d.position);t.history.updateVertices(r,Fn,d.indices,d.position)}stroke(t,i,s,r,o,a,l){r.addScaledVector(s,-o*Math.sign(i)*.5);for(let c of t)this.strokeVertex(s,r,o,i,l,a.get(c))}strokeVertex(t,i,s,r,o,a){nP.fromArray(o,a);const l=nP.distanceTo(i)/s;if(l>=1)return;const c=this.sculptFalloff(l)*r;o[a]+=t.x*c,o[a+1]+=t.y*c,o[a+2]+=t.z*c}}u(dM,"SculptBrushTool");H1e(dM,"SculptBrushTool");var G1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHJJREFUSIntlMEKgDAMQ1Px/39ZLwoSZk2j87K9S2G0SQehwORvtoNu4tda3irbzhK/E+R3W7zSN4i4OsA9sklXcaWZk9NKErNWzc8aEaHMyQaq4CPOHclmlnfrmFR+YV9OJ7KWiXLsMqRksNhniZoAwA6iu8NUWhw/8AAAAABJRU5ErkJggg==",W1e=Object.defineProperty,j1e=u((n,e)=>W1e(n,"name",{value:e,configurable:!0}),"__name$E");const t0=new P,n0=new P;class pM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Crease");T(this,"icon",G1e);T(this,"sculpt",!0);T(this,"hasDirection",!0);T(this,"brushStrength",.25);T(this,"brushStepSpacingRadiusRatio",.1);T(this,"optionsProps",["brushRadius","brushStrength","brushDirection","frontFacesOnly"])}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=t.options.enablePressure?1:s.pressure,c=this.brushStrength*this.brushDirection*l*.1,h=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly),f=new P;for(let d of h.track)this.stroke(d.indices,c,a.getAverageNormal(f,d.triangles),d.center,t.sculptLocalRadius,h.offset,h.position),t.sculptSym&&this.stroke(d.indicesSym,c,a.getAverageNormal(f,d.trianglesSym),d.centerSym,t.sculptLocalRadius,h.offset,h.position);t.history.updateVertices(r,Fn,h.indices,h.position)}stroke(t,i,s,r,o,a,l){for(let c of t)this.strokeVertex(s,r,o,i,l,a.get(c))}strokeVertex(t,i,s,r,o,a){t0.fromArray(o,a);const l=t0.distanceTo(i)/s;if(l>=1)return;const c=this.sculptFalloff(l),h=c**5*r*-.01;o[a]+=t.x*h,o[a+1]+=t.y*h,o[a+2]+=t.z*h,t0.fromArray(o,a),n0.subVectors(i,t0);const f=c*r*.1;o[a]+=n0.x*f,o[a+1]+=n0.y*f,o[a+2]+=n0.z*f}}u(pM,"SculptCreaseTool");j1e(pM,"SculptCreaseTool");var X1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHdJREFUSIntlMEOwCAIQ2H//8/stMQZcC1gdrE3I7w2RBE5+ltaaTYze8FUczwbNJ5no9kQBkfJSyarQg+M9sJwNAB3Kd/pywZsCBr+1KVM2GdGj4h+xxL/iTaDyGiLiaerA5JaEdvgTGN5nKtlh8Kh/d2294883Y/A1zVqqAZoAAAAAElFTkSuQmCC",q1e=Object.defineProperty,Y1e=u((n,e)=>q1e(n,"name",{value:e,configurable:!0}),"__name$D");const iP=new P,Ub=new P,sd=new P,i0=new P;class mM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Drag");T(this,"icon",X1e);T(this,"sculpt",!0);T(this,"brushRadius",100);T(this,"brushStrength",1);T(this,"optionsProps",["brushRadius","brushStrength","frontFacesOnly"]);T(this,"nodeId",0);T(this,"stroke0");T(this,"mouse0",new P);T(this,"local0",new P);T(this,"invMat",new me)}begin(t){t.sculptActiveView===-1&&(this.nodeId=0,this.stroke0=void 0)}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly);if(l.track.length&&(this.nodeId=r.id,this.stroke0=l,this.mouse0.copy(this.stroke0.track[0].center).applyMatrix4(r.getWorldMatrix()),this.local0.copy(this.stroke0.track[0].center),this.invMat.copy(r.getWorldMatrix()).invert()),this.nodeId!==r.id||!this.stroke0||!this.stroke0.track.length){this.nodeId=0,this.stroke0=void 0;return}if(!Gt(iP,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN))return;Ub.copy(iP).applyMatrix4(this.invMat).sub(this.local0);const c=new Float32Array(this.stroke0.position);if(t.sculptSym)switch(sd.copy(Ub),r.value(Ui)){case"x":sd.x*=-1;break;case"y":sd.y*=-1;break;case"z":sd.z*=-1;break}const h=t.options.enablePressure?1:s.pressure;this.stroke(this.stroke0.indices,this.brushStrength*h,t.sculptSym,Ub,sd,this.stroke0.track[0].center,this.stroke0.track[0].centerSym,t.sculptLocalRadius,this.stroke0.offset,c),t.history.updateVertices(r,Fn,this.stroke0.indices,c)}stroke(t,i,s,r,o,a,l,c,h,f){for(let d of t)this.strokeVertex(s,r,o,a,l,c,i,f,h.get(d))}strokeVertex(t,i,s,r,o,a,l,c,h){if(i0.fromArray(c,h),t){const f=i0.distanceTo(r)/a,d=i0.distanceTo(o)/a;if(f>=1){if(d>=1)return;const p=this.sculptFalloff(d)*l;c[h]+=s.x*p,c[h+1]+=s.y*p,c[h+2]+=s.z*p}else if(d>=1){const p=this.sculptFalloff(f)*l;c[h]+=i.x*p,c[h+1]+=i.y*p,c[h+2]+=i.z*p}else{const p=1-f+(1-d),g=this.sculptFalloff(f)*l*(1-f)/p,m=this.sculptFalloff(d)*l*(1-d)/p;c[h]+=i.x*g+s.x*m,c[h+1]+=i.y*g+s.y*m,c[h+2]+=i.z*g+s.z*m}}else{const f=i0.distanceTo(r)/a;if(f>=1)return;const d=this.sculptFalloff(f)*l;c[h]+=i.x*d,c[h+1]+=i.y*d,c[h+2]+=i.z*d}}}u(mM,"SculptDragTool");Y1e(mM,"SculptDragTool");var Z1e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAIVJREFUSIntVUEOgCAMo8T/f1kvmujMRjvYSXtCmKVjHbT2owL7iXJiZpPOEl9jAMjJc4itytG3xRaRL1VryZX1KP5Vg1LlIzVRnGfdboMy6mnrqs3j9cV9znURAznbFe1vs3jUAAAym0g2nQUlUskifazMj9M185pHeQ8om1my0qvkezgA21OnjKJcGJgAAAAASUVORK5CYII=",K1e=Object.defineProperty,Q1e=u((n,e)=>K1e(n,"name",{value:e,configurable:!0}),"__name$C");const $b=new P,J1e=new P;class gM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Flatten");T(this,"icon",Z1e);T(this,"sculpt",!0);T(this,"brushStrength",.2);T(this,"hasDirection",!0);T(this,"hasThirdDirection",!0);T(this,"brushDirection",0);T(this,"optionsProps",["brushRadius","brushStrength","brushDirection","frontFacesOnly"])}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=new P,c=new P,h=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly),f=t.options.enablePressure?1:s.pressure;for(let d of h.track)this.stroke(d.indices,this.brushStrength*f,a.getAverageNormal(c,d.triangles),a.getAverageCenter(l,d.triangles),d.center,t.sculptLocalRadius,h.offset,h.position),t.sculptSym&&this.stroke(d.indicesSym,this.brushStrength*f,a.getAverageNormal(c,d.trianglesSym),a.getAverageCenter(l,d.trianglesSym),d.centerSym,t.sculptLocalRadius,h.offset,h.position);t.history.updateVertices(r,Fn,h.indices,h.position)}stroke(t,i,s,r,o,a,l,c){for(let h of t)this.strokeVertex(s,r,o,a,i,c,l.get(h))}strokeVertex(t,i,s,r,o,a,l){$b.fromArray(a,l);const c=$b.distanceTo(s)/r;if(c>=1)return;const h=J1e.subVectors(i,$b).dot(t);if(this.brushDirection===-Math.sign(h))return;const f=this.sculptFalloff(c)*o*h;a[l]+=t.x*f,a[l+1]+=t.y*f,a[l+2]+=t.z*f}}u(gM,"SculptFlattenTool");Q1e(gM,"SculptFlattenTool");var eve="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHNJREFUSIntVEEOgDAIW43//zJeXKJkakujB7MegbaMMFqb+D3AFEVEnEgARrljnELsuIrn3KiW7prNUyZSJyrfFc8aiytWdn5FQzVgtmhVBDMAQPoHzohobsXkjvPtFnUoryiPlSHaa/107BgN+1xP2NgAXJmHlymbSbgAAAAASUVORK5CYII=",tve=Object.defineProperty,nve=u((n,e)=>tve(n,"name",{value:e,configurable:!0}),"__name$B");const Vb=new P,Hb=new Set,yu=new P,sP=new P,rP=new P;class vM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Inflate");T(this,"icon",eve);T(this,"sculpt",!0);T(this,"brushStrength",.2);T(this,"optionsProps",["brushRadius","brushStrength","frontFacesOnly"])}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=t.options.enablePressure?1:s.pressure,c=this.brushStrength*l*.01,h=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly);for(let f of h.track)this.stroke(a,f.indices,c,f.center,t.sculptLocalRadius,h.offset,h.position),t.sculptSym&&this.stroke(a,f.indicesSym,c,f.centerSym,t.sculptLocalRadius,h.offset,h.position);t.history.updateVertices(r,Fn,h.indices,h.position)}stroke(t,i,s,r,o,a,l){for(let c of i)this.strokeVertex(t,c,r,o,s,l,a.get(c))}strokeVertex(t,i,s,r,o,a,l){Vb.fromArray(a,l);const c=Vb.distanceTo(s)/r;if(c>=1)return;yu.set(0,0,0);let h=t.getVertexTriangleIndex(t.edgeNeighborMap[i]);const f=h;let d=50;Hb.clear();do{Hb.add(h),t.getNormal(sP,h),t.getTriangleCenter(rP,h),yu.addScaledVector(sP,Vb.distanceTo(rP));const g=h;for(let m=0;m<3;++m){const v=h*3+m;if(t.holes[v])continue;const y=t.getVertexTriangleIndex(t.edgeNeighborMap[v]);if(h===y||Hb.has(y))continue;let b=!1;for(let x=0;x<3;++x)if(t.sharedVertexMap[y*3+x]===i){b=!0;break}if(b){h=y;break}}if(g===h)break;if(d--<=0){console.warn("Loop limit reached");break}}while(f!==h);yu.normalize();const p=this.sculptFalloff(c)*o;a[l]+=yu.x*p,a[l+1]+=yu.y*p,a[l+2]+=yu.z*p}}u(vM,"SculptInflateTool");nve(vM,"SculptInflateTool");var ive="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHpJREFUSIntVUkKwDAI1NL/f3l6aS6hLhMNFNq5heAsUYzIDxEBAOtOO8lVtcwXisw4WYJWl7jhCUZn0w0APLn1nmOGmTYiYRLQ5GzNwZKVsOreGoYWAapuVcBDWw+2pnjPFA0wKZb7liksD4W37LLkqdU7k237WL6JC85mj5JuLIckAAAAAElFTkSuQmCC",sve=Object.defineProperty,rve=u((n,e)=>sve(n,"name",{value:e,configurable:!0}),"__name$A");const oP=new P,Gb=new P,rd=new P,s0=new P;class yM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Move");T(this,"icon",ive);T(this,"sculpt",!0);T(this,"brushStrength",1);T(this,"optionsProps",["brushRadius","brushStrength","frontFacesOnly"]);T(this,"nodeId",0);T(this,"stroke0");T(this,"mouse0",new P);T(this,"local0",new P);T(this,"invMat",new me)}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh;if(t.sculptStartThisFrame){if(this.nodeId=r.id,this.stroke0=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly),!this.stroke0.track.length){this.nodeId=0,this.stroke0=void 0;return}this.mouse0.copy(this.stroke0.track[0].center).applyMatrix4(r.getWorldMatrix()),this.local0.copy(this.stroke0.track[0].center),this.invMat.copy(r.getWorldMatrix()).invert();return}else if(this.nodeId!==r.id){this.nodeId=0,this.stroke0=void 0;return}if(!this.stroke0||!this.stroke0.track.length||!Gt(oP,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN))return;Gb.copy(oP).applyMatrix4(this.invMat).sub(this.local0);const l=new Float32Array(this.stroke0.position);if(t.sculptSym)switch(rd.copy(Gb),r.value(Ui)){case"x":rd.x*=-1;break;case"y":rd.y*=-1;break;case"z":rd.z*=-1;break}const c=t.options.enablePressure?1:s.pressure;this.stroke(this.stroke0.indices,this.brushStrength*c,t.sculptSym,Gb,rd,this.stroke0.track[0].center,this.stroke0.track[0].centerSym,t.sculptLocalRadius,this.stroke0.offset,l),t.history.updateVertices(r,Fn,this.stroke0.indices,l)}stroke(t,i,s,r,o,a,l,c,h,f){for(let d of t)this.strokeVertex(s,r,o,a,l,c,i,f,h.get(d))}strokeVertex(t,i,s,r,o,a,l,c,h){if(s0.fromArray(c,h),t){const f=s0.distanceTo(r)/a,d=s0.distanceTo(o)/a;if(f>=1){if(d>=1)return;const p=this.sculptFalloff(d)*l;c[h]+=s.x*p,c[h+1]+=s.y*p,c[h+2]+=s.z*p}else if(d>=1){const p=this.sculptFalloff(f)*l;c[h]+=i.x*p,c[h+1]+=i.y*p,c[h+2]+=i.z*p}else{const p=1-f+(1-d),g=this.sculptFalloff(f)*l*(1-f)/p,m=this.sculptFalloff(d)*l*(1-d)/p;c[h]+=i.x*g+s.x*m,c[h+1]+=i.y*g+s.y*m,c[h+2]+=i.z*g+s.z*m}}else{const f=s0.distanceTo(r)/a;if(f>=1)return;const d=this.sculptFalloff(f)*l;c[h]+=i.x*d,c[h+1]+=i.y*d,c[h+2]+=i.z*d}}}u(yM,"SculptMoveTool");rve(yM,"SculptMoveTool");var ove="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAIFJREFUSIntVMsOwCAIo/v/f2YnE8MQqMHsYi9GbcsrQeTib6BCUlX9CIGSNjX2zLO/snknLxSx9y3z1UkH8YgVs1KAmcT21mpdfdYGJrEwwBFz1tS2oVT17jCplkZz8BJg55UaVngzHvsAAEPQstBW6MheJFnXs3hUYw2PVnnRgheBggsc8NK3TAAAAABJRU5ErkJggg==",ave=Object.defineProperty,lve=u((n,e)=>ave(n,"name",{value:e,configurable:!0}),"__name$z");const aP=new P,Gs=new P,od=new P,r0=new sl,lP=new me;class bM extends ri{constructor(){super(...arguments);T(this,"label","Paint");T(this,"icon",ove);T(this,"tips","Press [P] to pick color");T(this,"sculpt",!0);T(this,"brushRadius",25);T(this,"brushStrength",1);T(this,"hasHardness",!0);T(this,"hasColor",!0);T(this,"frontFacesOnly",!0);T(this,"optionsProps",["brushRadius","brushStrength","brushHardness","frontFacesOnly"])}update(t,i){if(!t.sculptNodeId)return;const s=i.input;if(s.pointerOver&&s.isKeyPressed("p")){const d=t.model.getNode(t.sculptNodeId),g=d.get(Me).mesh;lP.copy(d.getWorldMatrix()).invert(),r0.origin.copy(i.mouseRay0),r0.direction.copy(i.mouseRayN),r0.applyMatrix4(lP);const m=g.raycast(r0,!0)[0];if(m){const v=m.triangleIndex;Gs.set(0,0,0),Gs.add(od.fromArray(g.aColor,v*9)),Gs.add(od.fromArray(g.aColor,v*9+3)),Gs.add(od.fromArray(g.aColor,v*9+6)),Gs.divideScalar(3),t.options.paintColor=[Gs.x,Gs.y,Gs.z]}return}if(t=t.readonlyRef(),!t.sculptMoved||i.index!==t.sculptActiveView||!s.mouseLeft)return;const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=t.options.enablePressure?1:s.pressure,c=this.brushStrength*l,h=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly),f=new Float32Array(h.position);for(let d=0,p=h.indices.length;d<p;++d){const g=h.indices[d];for(let m=0;m<3;++m)f[d*3+m]=a.aColor[g*3+m]}od.set(t.options.paintColor[0],t.options.paintColor[1],t.options.paintColor[2]);for(let d of h.track)this.stroke(d.indices,c,d.center,t.sculptLocalRadius,h.offset,h.position,f),t.sculptSym&&this.stroke(d.indicesSym,c,d.centerSym,t.sculptLocalRadius,h.offset,h.position,f);t.history.updateVertices(r,Pr,h.indices,f)}stroke(t,i,s,r,o,a,l){for(let c of t)this.strokeVertex(s,r,i,a,l,o.get(c))}strokeVertex(t,i,s,r,o,a){aP.fromArray(r,a);const l=aP.distanceTo(t)/i;if(l>=1)return;const h=Math.pow(1-l,2*(1-this.brushHardness))*s;Gs.fromArray(o,a).lerp(od,h),o[a]=Gs.x,o[a+1]=Gs.y,o[a+2]=Gs.z}}u(bM,"SculptPaintTool");lve(bM,"SculptPaintTool");var cve="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAIJJREFUSIntVUEOwCAIk2X//zI7kbiFxpbhzZ4US2tEcYyDBUxNcHd/CZjJGrR4xAItwplgjGWT1c4yYdqEISLOHL8RISvenFguLrOrmLNcepG9LZDDFqhsolyz0hFVHgt6E20GyGiLSYarQ6TUIraJK4m/jxMVTmnPVD/5irV+MgcPCvzbPZirI9cAAAAASUVORK5CYII=",uve=Object.defineProperty,hve=u((n,e)=>uve(n,"name",{value:e,configurable:!0}),"__name$y");const Wb=new P,o0=new P;class xM extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Pinch");T(this,"icon",cve);T(this,"sculpt",!0);T(this,"hasDirection",!0);T(this,"optionsProps",["brushRadius","brushStrength","brushDirection","frontFacesOnly"])}update(t,i){if(t=t.readonlyRef(),!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView)return;const s=i.input;if(!s.mouseLeft)return;if(s.isKeyPressed("Shift"))return t.sculptSmoothTool.doStroke(t,i);const r=t.model.getNode(t.sculptNodeId),a=r.get(Me).mesh,l=t.options.enablePressure?1:s.pressure,c=this.brushStrength*this.brushDirection*l*.1,h=this.sculptPickStrokeVertices(t,r,i,a,this.frontFacesOnly);for(let f of h.track)this.stroke(f.indices,c,f.center,t.sculptLocalRadius,h.offset,h.position),t.sculptSym&&this.stroke(f.indicesSym,c,f.centerSym,t.sculptLocalRadius,h.offset,h.position);t.history.updateVertices(r,Fn,h.indices,h.position)}stroke(t,i,s,r,o,a){for(let l of t)this.strokeVertex(s,r,i,a,o.get(l))}strokeVertex(t,i,s,r,o){Wb.fromArray(r,o);const a=Wb.distanceTo(t)/i;if(a>=1)return;o0.subVectors(t,Wb);const l=this.sculptFalloff(a)*s;r[o]+=o0.x*l,r[o+1]+=o0.y*l,r[o+2]+=o0.z*l}}u(xM,"SculptPinchTool");hve(xM,"SculptPinchTool");var fve="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHxJREFUSIntVMsOgDAIG8b//2W8zGRBgcrD03pcoAVWGGNDgJn5V5GjW+xEgmTbRESogBl4E0tC+R4q4MtnrbE80Ubu5mfJwwLWGNLkGvGao83+4Q7PAVoR5c5BUbbJcHGRLqyc9lv0iugulIukTaF5G7o3E9DZzZzrDRcXkCuzdkeSNcIAAAAASUVORK5CYII=",dve=Object.defineProperty,pve=u((n,e)=>dve(n,"name",{value:e,configurable:!0}),"__name$x");const bu=new P,ad=new P,jb=new Set;class _M extends ri{constructor(){super(...arguments);T(this,"label","Sculpt Smooth (Shift)");T(this,"icon",fve);T(this,"sculpt",!0);T(this,"brushStrength",1);T(this,"optionsProps",["brushRadius","brushStrength","frontFacesOnly"])}update(t,i){t=t.readonlyRef(),!(!t.sculptMoved||!t.sculptNodeId||i.index!==t.sculptActiveView||!i.input.mouseLeft)&&this.doStroke(t,i)}doStroke(t,i){const s=t.model.getNode(t.sculptNodeId),o=s.get(Me).mesh,a=this.sculptPickStrokeVertices(t,s,i,o,this.frontFacesOnly),l=t.options.enablePressure?1:i.input.pressure;for(let c of a.track)this.stroke(o,c.indices,this.brushStrength*l,c.center,t.sculptLocalRadius,a.offset,a.position),t.sculptSym&&this.stroke(o,c.indicesSym,this.brushStrength*l,c.centerSym,t.sculptLocalRadius,a.offset,a.position);t.history.updateVertices(s,Fn,a.indices,a.position)}stroke(t,i,s,r,o,a,l){for(let c of i)this.strokeVertex(t,c,r,o,s,l,a.get(c))}strokeVertex(t,i,s,r,o,a,l){bu.fromArray(a,l);const c=bu.distanceTo(s)/r;if(c>=1)return;let h=t.getVertexTriangleIndex(t.edgeNeighborMap[i]);const f=h;let d=0,p=0,g=0,m=0,v=50;jb.clear();do{jb.add(h);for(let x=0;x<3;++x){const w=t.sharedVertexMap[h*3+x];if(w!==i){t.getVertex(ad,w);const _=ad.distanceTo(bu);d+=ad.x*_,p+=ad.y*_,g+=ad.z*_,m+=_}}const b=h;for(let x=0;x<3;++x){const w=h*3+x;if(t.holes[w])continue;const _=t.getVertexTriangleIndex(t.edgeNeighborMap[w]);if(h===_||jb.has(_))continue;let A=!1;for(let S=0;S<3;++S)if(t.sharedVertexMap[_*3+S]===i){A=!0;break}if(A){h=_;break}}if(b===h)break;if(v--<=0){console.warn("Loop limit reached");break}}while(f!==h);if(m=1/m,!isFinite(m))return;d*=m,p*=m,g*=m;const y=this.sculptFalloff(c)*o;a[l]+=(d-bu.x)*y,a[l+1]+=(p-bu.y)*y,a[l+2]+=(g-bu.z)*y}}u(_M,"SculptSmoothTool");pve(_M,"SculptSmoothTool");var mve=Object.defineProperty,gve=u((n,e)=>mve(n,"name",{value:e,configurable:!0}),"__name$w");const DM=class extends ri{constructor(){super(...arguments);T(this,"icon","");T(this,"label","");T(this,"sep",!0)}};let Vo=DM;u(Vo,"ToolSeperator"),T(Vo,"instance",new DM);gve(Vo,"ToolSeperator");var vve="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGRJREFUSIntlMESABAIROX//znXGKJajBl7JG8LldLXbZG2ycxcBROp8Sa18NEaDA4zWQFYTHIoG49Ws3NfleXgdpPQgx8zQf8qFwDSgLNq3uhyCdo6q0bAnkF4/EoodJx/wVQASvh7kexwAhUAAAAASUVORK5CYII=",yve=Object.defineProperty,bve=u((n,e)=>yve(n,"name",{value:e,configurable:!0}),"__name$v");const Ws=new P,cP=new P,Co=new P,uP=new je,hP=new P(1,0,0),xu=new me,fP=.003,dP=.003,pP=5,Xb=.05;class wM extends ri{constructor(){super(...arguments);T(this,"label","Tube");T(this,"icon",vve);T(this,"tips","Hold [Alt] to create/insert a tube node. Resize tube node with mouse wheel.");T(this,"enableDefaultDeleteShortcut",!1);T(this,"enableSelectionRect",!0);T(this,"enableDefaultSelectionBehavior",!1);T(this,"nodes",[]);T(this,"enableDeleteThisFrame",!0);T(this,"dragging",!1);T(this,"draggingActiveViewIndex",-1);T(this,"mouse0",new P);T(this,"circle",new er(new yv,new Bi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0,color:16711935})));T(this,"line1",new er(new Je().setFromPoints([new P(0,0,0),new P(1,0,0)]),this.circle.material.clone()));T(this,"line2",new er(this.line1.geometry.clone(),this.line1.material.clone()));T(this,"creating",!1);T(this,"radius",.1);T(this,"lastNodeId",0)}setup(t){this.circle.visible=!1,t.scene.add(this.circle),this.line1.visible=!1,t.scene.add(this.line1),this.line2.visible=!1,t.scene.add(this.line2)}begin(t){t=t.readonlyRef();for(let i of this.nodes){if(i.deleted)continue;const s=i.get(dt);s.group&&(s.group.visible=!1),t.model.selected.includes(i.id)?s.selected=s.selected.filter(r=>r<s.value.length):s.selected.length=0}this.enableDefaultDeleteShortcut=!0,this.enableDeleteThisFrame=!0,this.nodes=t.model.getSelectedNodes().filter(i=>i.has(dt)&&!i.instanceId);for(let i of this.nodes){const s=i.get(dt);s.group&&(s.group.visible=!0),s.hovered=-1,s.selected.length&&(this.enableDefaultDeleteShortcut=!1),i.id===this.lastNodeId&&s.value.length&&(s.selected=[0],this.lastNodeId=0)}this.enableSelectionRect=!0,this.creating||(this.circle.visible=!1,this.line1.visible=!1,this.line2.visible=!1,this.lastNodeId=0)}update(t,i){const s=i.input;if(s.isKeyPressed("Delete")&&this.enableDeleteThisFrame){this.enableDeleteThisFrame=!1;for(let r of this.nodes){const o=r.get(dt);if(o.selected.length){const a=o.clone().filter((l,c)=>!o.selected.includes(c));o.selected.length=0,a.length===0?t.history.removeNode(r.id):t.history.setValue(r,dt,a)}}return}if(this.dragging&&i.index===this.draggingActiveViewIndex)if(this.enableSelectionRect=!1,s.mouseLeft){if(Gt(cP,i.mouseRay0,i.mouseRay1,this.mouse0,i.mouseRayN)){Co.subVectors(cP,this.mouse0);let r=!0;for(let o of this.nodes){const a=o.get(dt);if(a.draggingStartNodeIndex>=0){r=a.selected.includes(a.draggingStartNodeIndex);break}}for(let o of this.nodes){const a=o.get(dt);if(a.selected.length||a.draggingStartNodeIndex>=0){const l=a.clone(a.draggingStartValue);if(r)for(let c of a.selected)l[c].position.applyMatrix4(a.draggingStartMatrix).add(Co).applyMatrix4(a.draggingStartInvMatrix),s.isKeyPressed("Shift")&&Xu(l[c].position,Xb);a.draggingStartNodeIndex>=0&&!r&&(l[a.draggingStartNodeIndex].position.applyMatrix4(a.draggingStartMatrix).add(Co).applyMatrix4(a.draggingStartInvMatrix),s.isKeyPressed("Shift")&&Xu(l[a.draggingStartNodeIndex].position,Xb)),t.history.setValue(o,dt,l)}}if(!r)for(let o of this.nodes){const a=o.get(dt);a.draggingStartNodeIndex>=0?a.selected=[a.draggingStartNodeIndex]:a.selected=[]}}}else{this.dragging=!1,this.draggingActiveViewIndex=-1;for(let r of this.nodes){const o=r.get(dt);o.draggingStartNodeIndex=-1}}if(s.pointerOver&&!(this.dragging||this.creating)){let r=!1;for(let o of this.nodes){const a=o.get(dt),l=i.raycaster.intersectObjects(a.pickers);if(l.length){const c=l[0].object.userData.index;if(a.hovered=c==null?-1:c,s.mouseLeftDownThisFrame)this.dragging=!0,this.draggingActiveViewIndex=i.index,this.mouse0.copy(l[0].point),a.draggingStartNodeIndex=a.hovered;else if(s.wheelDetY)for(let h of l){const f=h.object.userData.index;if(f!=null&&a.selected.includes(f)){r=!0;break}}}else a.hovered=-1}if(this.dragging&&i.index===this.draggingActiveViewIndex)for(let o of this.nodes){const a=o.get(dt);(a.selected.length||a.draggingStartNodeIndex>=0)&&(a.draggingStartMatrix=new me().copy(o.getWorldMatrix()),a.draggingStartInvMatrix=new me().copy(o.getWorldMatrix()).invert(),a.draggingStartValue=a.clone())}if(r){t.disableCameraDraggingThisFrame=!0;for(let o of this.nodes){const a=o.get(dt);if(a.selected.length){const l=a.clone();for(let c of a.selected)l[c].radius=Math.max(fP,Math.min(pP,l[c].radius-s.wheelDetY*dP));t.history.setValue(o,dt,l)}}}if(!this.dragging&&!this.creating&&s.isKeyPressed("Alt")){this.creating=!0;for(let o of this.nodes){const a=o.get(dt);if(a.selected.length){this.radius=a.value[a.selected[0]].radius,this.radius*=ac(o.getWorldMatrix());break}}}}if(this.creating)if(s.isKeyPressed("Alt")){if(this.enableSelectionRect=!1,s.pointerOver){let r=null,o=null,a=-1;for(let l of this.nodes){const c=l.get(dt);if(c.selected.length){r=l,o=c,a=c.selected[0];break}}if(r)Ws.copy(o.value[a].position).applyMatrix4(r.getWorldMatrix());else for(let l of t.readonlyRef().model.getSelectedNodes())if(l.isValidChild("Tube")){Ws.setFromMatrixPosition(l.getWorldMatrix());break}if(Gt(this.circle.position,i.mouseRay0,i.mouseRay1,Ws,i.mouseRayN),s.isKeyPressed("Shift")&&Xu(this.circle.position,Xb),s.wheelDetY&&(this.radius=Math.min(pP,Math.max(fP,-s.wheelDetY*dP+this.radius)),t.disableCameraDraggingThisFrame=!0),this.circle.scale.setScalar(this.radius),this.circle.visible=!0,this.line1.visible=!1,this.line2.visible=!1,r&&(this.line1.position.copy(o.value[a].position).applyMatrix4(r.getWorldMatrix()),Co.subVectors(this.circle.position,this.line1.position),this.line1.scale.setScalar(Co.length()),this.line1.quaternion.setFromUnitVectors(hP,Co.normalize()),this.line1.visible=!0,a<o.value.length-1&&(this.line2.position.copy(o.value[a+1].position).applyMatrix4(r.getWorldMatrix()),Co.subVectors(this.circle.position,this.line2.position),this.line2.scale.setScalar(Co.length()),this.line2.quaternion.setFromUnitVectors(hP,Co.normalize()),this.line2.visible=!0,o.lines[a].visible=!1,t.nextFrameEnd(()=>{const l=o==null?void 0:o.lines[a];l&&(l.visible=!0)}))),s.mouseLeftDownThisFrame){Ws.copy(this.circle.position);let l=this.radius;if(!r&&this.nodes.length&&this.nodes[0].value(dt).length===0&&(r=this.nodes[0]),r){xu.copy(r.getWorldMatrix()).invert(),Ws.applyMatrix4(xu),l*=ac(xu);let c;o?(c=o.clone(),c.splice(a+1,0,{position:new P().copy(Ws),radius:l}),o.selected=[a+1]):(c=[{position:new P().copy(Ws),radius:l}],this.lastNodeId=r.id),t.history.setValue(r,dt,c)}else{let c=null;if(this.nodes.length)c=this.nodes[0].parent;else for(let f of t.model.getSelectedNodes())if(f.isValidChild("Tube")){c=f;break}if(c&&(xu.copy(c.getWorldMatrix()).invert(),Ws.applyMatrix4(xu),l*=ac(xu)),!c){for(let f of t.model.getSelectedNodes())if(f.isValidChild("Shape")){c=f;break}t.model.selected=[],this.lastNodeId=t.history.createNode({type:"Shape",parentId:c?c.id:0,data:{},children:[{type:"Tube",data:{[dt.name]:[{radius:l,position:new P().copy(Ws)}]}}]})+1}else t.model.selected=[],this.lastNodeId=t.history.createNode({type:"Tube",parentId:c?c.id:0,data:{[dt.name]:[{radius:l,position:new P().copy(Ws)}]}})}this.creating=!1}}}else this.creating=!1;if(t.selectionRectSetThisFrame&&t.selectionRectViewIndex===i.index)if(t.selectionStart.equals(t.selectionEnd)){let r=!1;for(let o of this.nodes){const a=o.get(dt);a.selected.length&&(r=!0),a.selected.includes(a.hovered)?s.isKeyPressed("Control")&&(a.selected=a.selected.filter(l=>l!==a.hovered),r=!0):(s.isKeyPressed("Control")||(a.selected.length=0),a.hovered>=0&&(a.addSelection(a.hovered),r=!0))}if(!r){const o=i.mousePick("Shape");let a=null;for(let l of o){const c=o[0].object.userData.node;if(c){a=c;break}}a?t.model.selected=a.children.map(l=>l.id):t.model.selected=[]}}else{const r=i.camera.get();for(let o of this.nodes){const a=o.get(dt);s.isKeyPressed("Control")||(a.selected.length=0);for(let l of a.pickers)if(Ws.setFromMatrixPosition(l.matrixWorld).project(r),RD(Ws,t.selectionStart,t.selectionEnd)){const c=l.userData.index;c!=null&&a.addSelection(c)}}}}end(t){for(let i of this.nodes)i.get(dt).updateColor()}beforeRender(t,i){for(let s of this.nodes){const r=s.get(dt);ED(uP,s.getWorldMatrix()).invert();for(let o of r.circles)o.quaternion.copy(uP).multiply(i.camera.get().quaternion)}this.circle.visible&&this.circle.quaternion.copy(i.camera.get().quaternion)}onUnselected(t){this.dragging=!1,this.creating=!1,this.lastNodeId=0,this.circle.visible=!1,this.line1.visible=!1,this.line2.visible=!1;for(let i of this.nodes){if(i.deleted)continue;const s=i.get(dt);s.group&&(s.group.visible=!1),s.selected.length=0}this.nodes.length=0}}u(wM,"TubeTool");bve(wM,"TubeTool");var xve=Object.defineProperty,_ve=u((n,e)=>xve(n,"name",{value:e,configurable:!0}),"__name$u");const qb=new Dp,_u=new P,wu=new P,dr=new P,Eo=new P,Br=new P,Po=new P,Ro=new P,ld=new P,cd=new P,ud=new P,a0=new P,hd=new P,fd=new P,dd=new P,mP=new me,wve=new je,Ave=new P;class AM{constructor(){T(this,"dom");T(this,"parent");T(this,"x0",0);T(this,"y0",0);T(this,"x1",0);T(this,"y1",0);const e=this.dom=document.createElement("div");e.style.pointerEvents="none",e.style.position="absolute",e.style.zIndex="20",e.style.border="dashed 1px #fff",e.style.background="rgba(255, 255, 255, .1)",e.style.boxSizing="border-box"}attach(e){this.parent=e,e.appendChild(this.dom)}detach(){this.parent=void 0,this.dom.remove()}show(){this.dom.style.display="block"}hide(){this.dom.style.display="none"}setPoint1(e,t){this.x0=e,this.y0=t}setPoint2(e,t){if(this.x1=e,this.y1=t,!this.parent)return;const i=(this.x0+1)/2,s=(this.x1+1)/2,r=(this.y0+1)/2,o=(this.y1+1)/2,a=this.parent.getBoundingClientRect(),l=Math.round(a.width*Math.max(Math.min(i,s),0)),c=Math.round(a.width*Math.min(1-Math.max(i,s),1)),h=Math.round(a.height*Math.max(1-Math.max(r,o),0)),f=Math.round(a.height*Math.min(r,o,1));this.dom.style.left=`${l}px`,this.dom.style.right=`${c}px`,this.dom.style.top=`${h}px`,this.dom.style.bottom=`${f}px`,i!==s||r!==o?this.show():this.hide()}select(e,t){let i=this.x0,s=this.y0,r=this.x1,o=this.y1;i===r&&(r+=Number.EPSILON),s===o&&(o+=Number.EPSILON);const a=0,l=1,c=Number.MAX_VALUE;if(e.updateProjectionMatrix(),e.updateMatrixWorld(),e.isPerspectiveCamera){wu.set(i,s,a),wu.x=Math.min(i,r),wu.y=Math.max(s,o),r=Math.max(i,r),o=Math.min(s,o),dr.setFromMatrixPosition(e.matrixWorld),Eo.copy(wu),Br.set(r,wu.y,0),Po.set(r,o,l),Ro.set(wu.x,o,0),Eo.unproject(e),Br.unproject(e),Po.unproject(e),Ro.unproject(e),hd.copy(Eo).sub(dr),fd.copy(Br).sub(dr),dd.copy(Po).sub(dr),hd.normalize(),fd.normalize(),dd.normalize(),hd.multiplyScalar(c),fd.multiplyScalar(c),dd.multiplyScalar(c),hd.add(dr),fd.add(dr),dd.add(dr);const d=qb.planes;d[0].setFromCoplanarPoints(dr,Eo,Br),d[1].setFromCoplanarPoints(dr,Br,Po),d[2].setFromCoplanarPoints(Po,Ro,dr),d[3].setFromCoplanarPoints(Ro,Eo,dr),d[4].setFromCoplanarPoints(Br,Po,Ro),d[5].setFromCoplanarPoints(dd,fd,hd),d[5].normal.multiplyScalar(-1)}else if(e.isOrthographicCamera){const d=Math.min(i,r),p=Math.max(s,o),g=Math.max(i,r),m=Math.min(s,o);Eo.set(d,p,-1),Br.set(g,p,-1),Po.set(g,m,-1),Ro.set(d,m,-1),ld.set(d,p,1),cd.set(g,p,1),ud.set(g,m,1),a0.set(d,m,1),Eo.unproject(e),Br.unproject(e),Po.unproject(e),Ro.unproject(e),ld.unproject(e),cd.unproject(e),ud.unproject(e),a0.unproject(e);const v=qb.planes;v[0].setFromCoplanarPoints(Eo,ld,cd),v[1].setFromCoplanarPoints(Br,cd,ud),v[2].setFromCoplanarPoints(ud,a0,Ro),v[3].setFromCoplanarPoints(a0,ld,Eo),v[4].setFromCoplanarPoints(Br,Po,Ro),v[5].setFromCoplanarPoints(ud,cd,ld),v[5].normal.multiplyScalar(-1)}const h=[],f={};for(let d of t)this.searchChildInFrustum(h,f,qb,d);return h}searchChildInFrustum(e,t,i,s){if(s.isMesh||s.isLine||s.isPoints)if(s.isInstancedMesh){const r=s;t[r.uuid]=[];for(let o=0;o<r.count;o++)r.getMatrixAt(o,mP),mP.decompose(_u,wve,Ave),_u.applyMatrix4(r.matrixWorld),i.containsPoint(_u)&&t[r.uuid].push(o)}else{const r=s;r.geometry.boundingSphere===null&&r.geometry.computeBoundingSphere(),_u.copy(r.geometry.boundingSphere.center),_u.applyMatrix4(s.matrixWorld),i.containsPoint(_u)&&e.push(s)}if(s.children.length>0)for(let r=0;r<s.children.length;r++)this.searchChildInFrustum(e,t,i,s.children[r])}}u(AM,"SelectionRect");_ve(AM,"SelectionRect");var Mve=Object.defineProperty,Sve=u((n,e)=>Mve(n,"name",{value:e,configurable:!0}),"__name$t");class Kp{constructor(e,t,i,s,r){T(this,"systems",[new eA,new VA([new RA,new DA,new dA,new PA,new sA,new zA,new $A,new cA,new OA,new uA,new hA,new FA,new UA,new BA,new IA,new LA,new kA]),new HA,new jA,new tA,new nA,new iA,new GA,new WA,new Dw,new Iw]);T(this,"sculptSmoothTool",new _M);T(this,"tools",[new Zp,new eM,Vo.instance,new fM,new hM,Vo.instance,new tM,new nM,Vo.instance,new Yp,new wM,Vo.instance,new dM,new vM,new pM,new xM,new gM,new yM,new mM,this.sculptSmoothTool,new bM]);T(this,"sculptNodeId",0);T(this,"sculptActiveView",-1);T(this,"sculptSym",!1);T(this,"sculptLocalRadius",0);T(this,"sculptMoved",!1);T(this,"sculptStartThisFrame",!1);T(this,"sculptAccWalkedPixels",0);T(this,"sculptX0",0);T(this,"sculptY0",0);T(this,"sculptX1",0);T(this,"sculptY1",0);T(this,"canvas");T(this,"renderer");T(this,"composer");T(this,"renderPass");T(this,"outlinePass");T(this,"ptMaterial");T(this,"ptRenderer");T(this,"ptGenerator");T(this,"fsQuad");T(this,"bvhDirty",!0);T(this,"transformDirty",!0);T(this,"scene",new sp);T(this,"views");T(this,"mainViewIndex");T(this,"disableCameraDraggingThisFrame",!1);T(this,"selectionRect",new AM);T(this,"selectionRectDragging",!1);T(this,"selectionRectViewIndex",-1);T(this,"selectionRectSetThisFrame",!1);T(this,"selectionStart",new Ie);T(this,"selectionEnd",new Ie);T(this,"model",new kp);T(this,"history",new Rw(this.model));T(this,"fps",0);T(this,"detSec",0);T(this,"lastTimestamp",0);T(this,"statusBarMessage","");T(this,"tool",this.tools[0]);T(this,"nextFrameCallbacks",[]);T(this,"throttleTasks",new Map);T(this,"options",new sw);this.history.setup(),this.canvas=e,this.renderer=new SI({canvas:e}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=YR,this.mainViewIndex=1,this.views=[new Nu(this,0,t,-Math.PI/2,-Math.PI/2,!1),new Nu(this,1,i,-Math.PI/8,-Math.PI/4,!0),new Nu(this,2,s,0,-Math.PI/2,!1),new Nu(this,3,r,0,0,!1)],this.composer=new SD(this.renderer),this.renderPass=new CD(this.scene,this.views[this.mainViewIndex].camera.get()),this.composer.addPass(this.renderPass),this.outlinePass=new Zr(new Ie,this.scene,this.renderPass.camera),this.outlinePass.visibleEdgeColor.setHex(15964205),this.composer.addPass(this.outlinePass),this.ptMaterial=new AD,this.ptRenderer=new nD(this.renderer),this.ptRenderer.camera=this.views[this.mainViewIndex].camera.get(),this.ptRenderer.material=this.ptMaterial,this.ptGenerator=new cD([]),this.fsQuad=new TD(new xi({map:this.ptRenderer.target.texture,blending:ZR}));for(let o of this.systems)o.setup(this);for(let o of this.tools)o.setup(this)}dispose(){this.history.unload();for(let e of this.views)e.dispose();for(let e of this.systems)e.dispose();for(let e of this.tools)e.dispose();this.renderer.dispose()}update(){const e=Date.now();this.detSec=(e-this.lastTimestamp)/1e3,this.fps=Math.floor(1/this.detSec),this.lastTimestamp=e,this.options.shadingMode==="path-tracing"&&(this.options.quadView=!1);for(let t=0;t<this.views.length;++t){const i=this.views[t];if(i.enabled=t===this.mainViewIndex||this.options.quadView,t===this.mainViewIndex){const s=i.camera;s.perspective=this.model.cameraPerspective&&(Math.abs(s.alpha%(Math.PI/2))>1e-8||Math.abs(s.beta%(Math.PI/2))>1e-8),s.perspectiveCamera.fov=this.model.cameraFov}}for(let t of this.views)t=it(t),t.enabled&&t.update();for(let t of this.systems)t.update(this);for(let t of this.views)t=it(t),t.input.update()}reset(){this.views[this.mainViewIndex].camera.alpha=-Math.PI/8,this.views[this.mainViewIndex].camera.beta=-Math.PI/4;for(let e of this.views)e.camera.target.set(0,0,0),e.zoomLevel=0;this.model.reset(),this.history.clear()}readonlyRef(){return it(this)}nextFrameEnd(e){this.nextFrameCallbacks.push(e)}throttle(e,t,i,s=!1){const r=this.throttleTasks.get(e);r?(s||(r.time=Date.now()+t),r.callback=i):s?(i(),this.throttleTasks.set(e,{time:Date.now()+t,callback:()=>{}})):this.throttleTasks.set(e,{time:Date.now()+t,callback:i})}delayThrottle(e,t){const i=this.throttleTasks.get(e);i&&(i.time=Date.now()+t)}load(e){this.reset();for(let t=0;t<4;++t){const i=e.views[t],s=this.views[t];s.zoomLevel=i.zoomLevel,s.camera.alpha=i.alpha,s.camera.beta=i.beta,s.camera.target.set(...i.target),t===this.mainViewIndex&&(s.camera.perspective=i.perspective,s.camera.perspectiveCamera.fov=i.fov,this.model.cameraPerspective=i.perspective,this.model.cameraFov=i.fov)}this.model.cameras=e.cameras;for(let t of e.nodes){const i=this.model.createNode(t.id,t.type,t.parentId?this.model.getNode(t.parentId):null,null,t.data,t.instanceId);i.expanded=t.expanded}}}u(Kp,"EditorContext");Sve(Kp,"EditorContext");var Tve=Object.defineProperty,Cve=u((n,e)=>Tve(n,"name",{value:e,configurable:!0}),"__name$s"),Eve=zt({props:{editorContext:{type:Kp,required:!0}},emits:["setData"],setup(n,e){const t=st(function(){return n.editorContext.model.selected.join(",")}),i=st(function(){const r=n.editorContext.model.getSelectedNodes();if(!r.length)return[];const o=[],a=new Set;let l=r[0];const c=ii(l.type);for(let h of c.components)is(h.name).inputComponent&&a.add(h.name);for(let h=1,f=r.length;h<f;++h){let d=r[h];const p=ii(d.type),g=new Set;for(let m of p.components)is(m.name).inputComponent&&g.add(m.name);for(let m of a)g.has(m)||a.delete(m)}for(let h of a){const f=is(h);let d;l.instanceId&&!f.instanceable?d=n.editorContext.model.getNode(l.instanceId).value(f.constructor):d=l.value(f.constructor),o.push({name:h,componentClass:f.constructor,label:f.label||h,inlineLabel:f.inlineLabel||!1,inputComponent:f.inputComponent,inputComponentProps:f.inputComponentProps,value:d})}return o});function s(r,o){e.emit("setData",n.editorContext.model.getSelectedNodes().map(a=>({node:a,type:r,value:o})))}return u(s,"onInput"),Cve(s,"onInput"),{key:t,properties:i,onInput:s}}});function Pve(n,e,t,i,s,r){return Te(),Be("div",{class:"properties",key:n.key},[(Te(!0),Be(kt,null,Ga(n.properties,o=>(Te(),Be("div",{class:Mn(["property",{inline:o.inlineLabel}])},[ue("label",null,On(o.label),1),(Te(),cn(fz(o.inputComponent),IR({class:"value",value:o.value,onInput:a=>n.onInput(o.componentClass,a)},o.inputComponentProps),null,16,["value","onInput"]))],2))),256))])}u(Pve,"_sfc_render$b");var Rve=jt(Eve,[["render",Pve]]),Ive=Object.defineProperty,Dve=u((n,e)=>Ive(n,"name",{value:e,configurable:!0}),"__name$r");class MM{constructor(){T(this,"parent");T(this,"subMenu")}}u(MM,"PopupMenuItemContext");Dve(MM,"PopupMenuItemContext");var Lve=Object.defineProperty,gP=u((n,e)=>Lve(n,"name",{value:e,configurable:!0}),"__name$q"),Ove=zt({props:{title:String,icon:String,hotkey:String,disabled:Boolean,sep:Boolean,popup:Boolean,checked:Boolean},emits:["click"],setup(n,e){const t=He(),i=st(function(){return!!e.slots.default}),s=new MM;Gu("popupMenuItemContext",s),s.parent=zi("popupMenuContext",null)||void 0;function r(){var a;(a=s.parent)==null||a.handleMenuItemMouseOver(s,t.value)}u(r,"onMouseOver"),gP(r,"onMouseOver");function o(a){var l;n.disabled||n.sep||i.value||((l=s.parent)==null||l.hideAll(),e.emit("click",a))}return u(o,"onClick"),gP(o,"onClick"),{menuItem:t,hasChild:i,onMouseOver:r,onClick:o}}});const Fve=["src"],Nve={class:"title"},kve={key:0,class:"hotkey"};function zve(n,e,t,i,s,r){return Te(),Be("div",{class:Mn(["popup-menu-item",{"has-child":n.hasChild,disabled:n.disabled,sep:n.sep,popup:n.popup}]),ref:"menuItem",onMouseover:e[0]||(e[0]=Hn((...o)=>n.onMouseOver&&n.onMouseOver(...o),["stop"])),onClick:e[1]||(e[1]=(...o)=>n.onClick&&n.onClick(...o))},[n.sep?nt("",!0):(Te(),Be(kt,{key:0},[ue("div",{class:Mn(["icon",{checked:n.checked,img:!!n.icon}])},[n.icon&&!n.checked?(Te(),Be("img",{key:0,src:n.icon,alt:""},null,8,Fve)):nt("",!0)],2),ue("div",Nve,On(n.title),1),n.hotkey?(Te(),Be("div",kve,On(n.hotkey),1)):nt("",!0),Kd(n.$slots,"default",{},void 0,!0)],64))],34)}u(zve,"_sfc_render$a");var vN=jt(Ove,[["render",zve],["__scopeId","data-v-4eb751b0"]]),Bve=Object.defineProperty,pr=u((n,e)=>Bve(n,"name",{value:e,configurable:!0}),"__name$p"),Uve=zt({name:"model-tree-node",props:{model:{type:kp,required:!0},node:{type:lc,required:!0},depth:{type:Number,required:!0},draggingNode:lc,dragOverNode:lc,dropPosition:String},emits:["setValue","setSelection","dragStart","dragOver","contextmenu","rangeSelect"],setup(n,e){const t=He(),i=st(function(){const x=n.node;return(x.has(Dt)?x.value(Dt):"")||`${ii(x.type).label} #${x.id}`}),s=st(function(){return ii(n.node.type).icon}),r=st(function(){return n.node.has(ft)}),o=st(function(){return r.value&&n.node.value(ft)});function a(x,w,_){e.emit("setValue",x,w,_)}u(a,"onSetValue"),pr(a,"onSetValue");function l(){a(n.node,ft,!o.value)}u(l,"toggleVisible"),pr(l,"toggleVisible");function c(){n.node.expanded=!n.node.expanded}u(c,"toggleExpanded"),pr(c,"toggleExpanded");function h(x){e.emit("setSelection",x)}u(h,"onSetSelection"),pr(h,"onSetSelection");function f(x){const w=n.node.id;if(x.ctrlKey){const _=n.model.selected;_.includes(w)?e.emit("setSelection",_.filter(A=>A!==w)):e.emit("setSelection",[..._,w])}else x.shiftKey?b(w):e.emit("setSelection",[w])}u(f,"onNodeClick"),pr(f,"onNodeClick");function d(x){if(!x.shiftKey){if(!n.model.selected.includes(n.node.id)){if(x.ctrlKey)return;e.emit("setSelection",[n.node.id])}g(n.node)}}u(d,"onMouseDown"),pr(d,"onMouseDown");function p(x){if(n.draggingNode&&t.value){const w=t.value.getBoundingClientRect(),_=x.clientY-w.top,A=6;let S=_<=A?"before":_>=w.height-A?"after":"atLast";S==="after"&&n.node.children.length&&n.node.expanded&&(S="atFirst"),e.emit("dragOver",n.node,S)}}u(p,"onMouseMove"),pr(p,"onMouseMove");function g(x){e.emit("dragStart",x)}u(g,"onDragStart"),pr(g,"onDragStart");function m(x,w){e.emit("dragOver",x,w)}u(m,"onDragOver"),pr(m,"onDragOver");const v=st(function(){const x=n.node,w=n.draggingNode===x,_=n.dragOverNode===x,A=n.dropPosition;return{selected:n.model.selected.includes(x.id),dragging:w,"drag-over-before":_&&A==="before","drag-over-inside":_&&(A==="atFirst"||A==="atLast"),"drag-over-after":_&&A==="after",instance:!!x.instanceId}});function y(x,w){e.emit("contextmenu",x,w)}u(y,"onContextMenu"),pr(y,"onContextMenu");function b(x){e.emit("rangeSelect",x)}return u(b,"onRangeSelect"),pr(b,"onRangeSelect"),{dom:t,name:i,icon:s,hasVisible:r,visible:o,onSetValue:a,toggleVisible:l,toggleExpanded:c,onSetSelection:h,onNodeClick:f,onMouseDown:d,onMouseMove:p,onDragStart:g,onDragOver:m,classnames:v,onContextMenu:y,onRangeSelect:b}}});const $ve={class:"visibility"},Vve={class:"expand"},Hve=["src"],Gve={class:"node-name"};function Wve(n,e,t,i,s,r){const o=xn("model-tree-node",!0);return Te(),Be(kt,null,[ue("div",{class:Mn(["model-tree-node",n.classnames]),onMousedown:e[3]||(e[3]=Hn((...a)=>n.onMouseDown&&n.onMouseDown(...a),["left"])),onMousemove:e[4]||(e[4]=(...a)=>n.onMouseMove&&n.onMouseMove(...a)),onContextmenu:e[5]||(e[5]=Hn(a=>n.onContextMenu(n.node,a),["prevent"])),ref:"dom"},[ue("div",$ve,[n.hasVisible?(Te(),Be("div",{key:0,class:Mn(["icon",[n.visible?"visible":"invisible"]]),onClick:e[0]||(e[0]=Hn((...a)=>n.toggleVisible&&n.toggleVisible(...a),["stop"]))},null,2)):nt("",!0)]),ue("div",{class:"name",style:ci({"padding-left":`${n.depth*16+2}px`}),onClick:e[2]||(e[2]=(...a)=>n.onNodeClick&&n.onNodeClick(...a))},[ue("div",Vve,[n.node.children.length?(Te(),Be("div",{key:0,class:Mn(["icon",[n.node.expanded?"collapse":"expand"]]),onClick:e[1]||(e[1]=Hn((...a)=>n.toggleExpanded&&n.toggleExpanded(...a),["stop"]))},null,2)):nt("",!0)]),ue("img",{class:"node-icon",src:n.icon,alt:""},null,8,Hve),ue("span",Gve,On(n.name),1)],4)],34),n.node.expanded?(Te(!0),Be(kt,{key:0},Ga(n.node.children,a=>(Te(),cn(o,{key:a.id,model:n.model,node:a,depth:n.depth+1,onSetValue:n.onSetValue,onSetSelection:n.onSetSelection,onRangeSelect:n.onRangeSelect,"dragging-node":n.draggingNode,"drag-over-node":n.dragOverNode,"drop-position":n.dropPosition,onDragStart:n.onDragStart,onDragOver:n.onDragOver,onContextmenu:n.onContextMenu},null,8,["model","node","depth","onSetValue","onSetSelection","onRangeSelect","dragging-node","drag-over-node","drop-position","onDragStart","onDragOver","onContextmenu"]))),128)):nt("",!0)],64)}u(Wve,"_sfc_render$9");var jve=jt(Uve,[["render",Wve],["__scopeId","data-v-6a76ea03"]]),Xve=Object.defineProperty,yi=u((n,e)=>Xve(n,"name",{value:e,configurable:!0}),"__name$o"),qve=zt({components:{PopupMenu:vw,PopupMenuItem:vN,ModelTreeNode:jve},props:{model:{type:kp,required:!0}},emits:["setValue","moveNode","select","focus","cut","copy","paste","delete","convertToClay","applyTransformation","createInstance","flip","copyPose","pastePose"],setup(n,e){const t=He();function i(k,G,X){e.emit("setValue",k,G,X)}u(i,"onSetValue"),yi(i,"onSetValue");let s=!1;const r=He(),o=He(),a=He("");function l(k){r.value=k,o.value=void 0;const G=yi(function(){r.value!==o.value&&r.value&&o.value&&e.emit("moveNode",o.value,a.value),r.value=void 0,o.value=void 0,document.removeEventListener("mouseup",G)},"onMouseUp");document.addEventListener("mouseup",G)}u(l,"onDragStart"),yi(l,"onDragStart");function c(k,G){k!==o.value&&(s=!0),o.value=k,a.value=G}u(c,"onDragOver"),yi(c,"onDragOver");function h(k){if(s){s=!1;return}e.emit("select",k)}u(h,"onSetSelection"),yi(h,"onSetSelection");function f(k){const G=it(n.model),X=new Set(G.selected);if(!X.size){h([k]);return}const te=[];let j=!1,ie=!1;G.forEach(K=>{if(j&&ie)return!1;!ie&&X.has(K.id)&&(ie=!0),K.id===k&&(j=!0),(ie||j)&&te.push(K.id)}),h(te)}u(f,"onRangeSelect"),yi(f,"onRangeSelect");const d=He();function p(k,G){d.value=k,t.value.show(G.target,{x:G.clientX,y:G.clientY})}u(p,"onContextMenu"),yi(p,"onContextMenu");function g(){e.emit("focus",d.value)}u(g,"onFocus"),yi(g,"onFocus");function m(){e.emit("cut")}u(m,"onCut"),yi(m,"onCut");function v(){e.emit("copy")}u(v,"onCopy"),yi(v,"onCopy");function y(){e.emit("paste",d.value)}u(y,"onPaste"),yi(y,"onPaste");function b(){e.emit("delete")}u(b,"onDelete"),yi(b,"onDelete");const x=st(function(){const k=d.value;return k?ii(k.type).mesh:!1});function w(){e.emit("convertToClay",d.value)}u(w,"onConvertToClay"),yi(w,"onConvertToClay");const _=st(function(){const k=d.value;return k?!k.instanceId&&k.type==="Clay":!1});function A(){e.emit("applyTransformation",d.value)}u(A,"onApplyTransformation"),yi(A,"onApplyTransformation");const S=st(function(){const k=d.value;if(!k)return!1;const G=ii(k.type);return!!G.instanceable&&!G.unique}),M=st(function(){const k=d.value;return k?!k.has(jn):!1});function C(k){e.emit("createInstance",d.value,k)}u(C,"onCreateInstance"),yi(C,"onCreateInstance");const I=st(function(){const k=d.value;return k?["Container","IKChain","IKNode"].includes(k.type):!1});function F(k){e.emit("flip",d.value,k)}u(F,"onFlip"),yi(F,"onFlip");const O=st(function(){const k=d.value;return k?["IKChain"].includes(k.type):!1});function N(){e.emit("copyPose",d.value)}u(N,"onCopyPose"),yi(N,"onCopyPose");function E(){e.emit("pastePose",d.value)}return u(E,"onPastePose"),yi(E,"onPastePose"),{contextMenu:t,onSetValue:i,onSetSelection:h,draggingNode:r,dragOverNode:o,dropPosition:a,onDragStart:l,onDragOver:c,onRangeSelect:f,onContextMenu:p,contextMenuNode:d,onFocus:g,onCut:m,onCopy:v,onPaste:y,onDelete:b,canConvertToClay:x,onConvertToClay:w,canApplyTransformation:_,onApplyTransformation:A,canCreateInstance:S,canCreateMirrorInstance:M,onCreateInstance:C,canFlip:I,onFlip:F,hasPose:O,onCopyPose:N,onPastePose:E}}});function Yve(n,e,t,i,s,r){const o=xn("model-tree-node"),a=xn("popup-menu-item"),l=xn("popup-menu");return Te(),Be("div",{class:"model-tree",onClick:e[6]||(e[6]=Hn(c=>n.onSetSelection([]),["left","self"])),onContextmenu:e[7]||(e[7]=Hn(c=>n.onContextMenu(void 0,c),["self","prevent"]))},[(Te(!0),Be(kt,null,Ga(n.model.nodes,c=>(Te(),cn(o,{key:c.id,model:n.model,node:c,depth:0,onSetValue:n.onSetValue,onSetSelection:n.onSetSelection,"dragging-node":n.draggingNode,"drag-over-node":n.dragOverNode,"drop-position":n.dropPosition,onDragStart:n.onDragStart,onDragOver:n.onDragOver,onContextmenu:n.onContextMenu,onRangeSelect:n.onRangeSelect},null,8,["model","node","onSetValue","onSetSelection","dragging-node","drag-over-node","drop-position","onDragStart","onDragOver","onContextmenu","onRangeSelect"]))),128)),Pe(l,{ref:"contextMenu"},{default:dn(()=>[Pe(a,{title:"Focus",onClick:n.onFocus,disabled:!n.contextMenuNode},null,8,["onClick","disabled"]),n.canFlip?(Te(),Be(kt,{key:0},[Pe(a,{title:"Flip",onClick:e[0]||(e[0]=c=>n.onFlip("flip"))}),Pe(a,{title:"Flip Left to Right",onClick:e[1]||(e[1]=c=>n.onFlip("left-to-right"))}),Pe(a,{title:"Flip Right to Left",onClick:e[2]||(e[2]=c=>n.onFlip("right-to-left"))})],64)):nt("",!0),n.canConvertToClay||n.canApplyTransformation||n.canCreateInstance?(Te(),Be(kt,{key:1},[Pe(a,{sep:""}),n.canConvertToClay?(Te(),cn(a,{key:0,title:"Convert to Clay",onClick:n.onConvertToClay},null,8,["onClick"])):nt("",!0),n.canApplyTransformation?(Te(),cn(a,{key:1,title:"Apply Transformation",onClick:n.onApplyTransformation},null,8,["onClick"])):nt("",!0),n.canCreateInstance?(Te(),Be(kt,{key:2},[Pe(a,{title:"Create Shadow Node",onClick:e[3]||(e[3]=c=>n.onCreateInstance("none"))}),n.canCreateMirrorInstance?(Te(),Be(kt,{key:0},[Pe(a,{title:"Create Mirror Shadow Node",onClick:e[4]||(e[4]=c=>n.onCreateInstance("z"))}),Pe(a,{title:"Create Vertical Mirror Shadow Node",onClick:e[5]||(e[5]=c=>n.onCreateInstance("y"))})],64)):nt("",!0)],64)):nt("",!0)],64)):nt("",!0),n.hasPose?(Te(),Be(kt,{key:2},[Pe(a,{sep:""}),Pe(a,{title:"Copy Pose",onClick:n.onCopyPose},null,8,["onClick"]),Pe(a,{title:"Paste Pose",onClick:n.onPastePose},null,8,["onClick"])],64)):nt("",!0),Pe(a,{sep:""}),Pe(a,{title:"Cut",hotkey:"Ctrl+X",onClick:n.onCut,disabled:!n.model.selected.length},null,8,["onClick","disabled"]),Pe(a,{title:"Copy",hotkey:"Ctrl+C",onClick:n.onCopy,disabled:!n.model.selected.length},null,8,["onClick","disabled"]),Pe(a,{title:"Paste",hotkey:"Ctrl+V",onClick:n.onPaste},null,8,["onClick"]),Pe(a,{title:"Delete",hotkey:"Delete",onClick:n.onDelete,disabled:!n.model.selected.length},null,8,["onClick","disabled"])]),_:1},512)],32)}u(Yve,"_sfc_render$8");var Zve=jt(qve,[["render",Yve],["__scopeId","data-v-5aa4f4ef"]]),Kve=Object.defineProperty,vP=u((n,e)=>Kve(n,"name",{value:e,configurable:!0}),"__name$n"),Qve=zt({props:{modal:Boolean,title:String,width:String,height:String,closable:Boolean,visible:Boolean,x:Number,y:Number},emits:["update:visible","update:x","update:y","close"],setup(n,e){const t=He(),i=He(0),s=He(0),r=st(function(){const l={};return l.left=Math.round(i.value)+"px",l.top=Math.round(s.value)+"px",n.width&&(l.width=n.width),n.height&&(l.height=n.height),l});ts([()=>n.x,()=>n.y],function([l,c]){l!=null&&c!=null&&(i.value=l,s.value=c)},{immediate:!0}),ts(()=>n.visible,async function(l){if(l&&(n.x==null||n.y==null)&&(i.value=0,s.value=0,await qs(),t.value)){const c=document.body.getBoundingClientRect(),h=t.value.getBoundingClientRect();i.value=(c.width-h.width)/2,s.value=(c.height-h.height)/2}},{immediate:!0});function o(){e.emit("update:visible",!1),e.emit("close")}u(o,"close"),vP(o,"close");function a(l){const c=l.clientX,h=l.clientY,f=i.value,d=s.value;dc(l,p=>{if(t.value){const g=p.clientX-c,m=p.clientY-h,v=document.body.getBoundingClientRect(),y=t.value.getBoundingClientRect();i.value=Math.max(0,Math.min(v.width-y.width,f+g)),s.value=Math.max(0,Math.min(v.height-y.height,d+m)),e.emit("update:x",i.value),e.emit("update:y",s.value)}})}return u(a,"onTitleMouseDown"),vP(a,"onTitleMouseDown"),{dialog:t,style:r,close:o,onTitleMouseDown:a}}});const Jve={class:"popup-dialog__title-text"},eye={class:"popup-dialog__body"},tye={key:0,class:"popup-dialog__buttons"};function nye(n,e,t,i,s,r){return Te(),cn(C_,{to:"body"},[ue("div",{class:Mn(["popup-dialog__mask",{modal:n.modal,visible:n.visible}])},[ue("div",{class:"popup-dialog",style:ci(n.style),ref:"dialog"},[ue("div",{class:"popup-dialog__title",onPointerdown:e[2]||(e[2]=(...o)=>n.onTitleMouseDown&&n.onTitleMouseDown(...o))},[ue("div",Jve,On(n.title),1),n.closable?(Te(),Be("button",{key:0,class:"popup-dialog__btn-close",onMousedown:e[0]||(e[0]=Hn(()=>{},["stop"])),onClick:e[1]||(e[1]=(...o)=>n.close&&n.close(...o))},null,32)):nt("",!0)],32),ue("div",eye,[Kd(n.$slots,"default",{},void 0,!0)]),n.$slots.buttons?(Te(),Be("div",tye,[Kd(n.$slots,"buttons",{},void 0,!0)])):nt("",!0)],4)],2)])}u(nye,"_sfc_render$7");var xv=jt(Qve,[["render",nye],["__scopeId","data-v-4be1c5cb"]]),iye=Object.defineProperty,sye=u((n,e)=>iye(n,"name",{value:e,configurable:!0}),"__name$m"),rye=zt({props:{alpha:Number,beta:Number},emits:["setView"],setup(n,e){const t=st(function(){const s=(n.alpha||0)/Math.PI*180,r=-(n.beta||0)/Math.PI*180-90;return{transform:`rotateX(${s}deg) rotateY(${r}deg)`}});function i(s){e.emit("setView",s)}return u(i,"setView"),sye(i,"setView"),{cubeStyle:t,setView:i}}});function oye(n,e,t,i,s,r){return Te(),Be("div",{class:"view-rotation-handler",onContextmenu:e[6]||(e[6]=Hn(()=>{},["prevent"]))},[ue("div",{class:"cube",style:ci(n.cubeStyle)},[ue("div",{class:"face front",onClick:e[0]||(e[0]=o=>n.setView("front"))},"+Z"),ue("div",{class:"face back",onClick:e[1]||(e[1]=o=>n.setView("back"))},"-Z"),ue("div",{class:"face top",onClick:e[2]||(e[2]=o=>n.setView("top"))},"+Y"),ue("div",{class:"face bottom",onClick:e[3]||(e[3]=o=>n.setView("bottom"))},"-Y"),ue("div",{class:"face right",onClick:e[4]||(e[4]=o=>n.setView("right"))},"+X"),ue("div",{class:"face left",onClick:e[5]||(e[5]=o=>n.setView("left"))},"-X")],4)],32)}u(oye,"_sfc_render$6");var aye=jt(rye,[["render",oye],["__scopeId","data-v-308c1057"]]),lye=Object.defineProperty,yP=u((n,e)=>lye(n,"name",{value:e,configurable:!0}),"__name$l"),cye=zt({components:{ViewRotationHandler:aye},props:{editorContext:Kp,quadView:Boolean,mainView:Number},emits:["mounted","beforeUnmount","setView"],setup(n,e){const t=He(),i=He(),s=He(),r=He(),o=He(),a=He(),l=He(),c=He(),h=He(),f=He();let d;ts(()=>n.quadView,function(){p()}),x1(function(){p(),d=setInterval(p,50),e.emit("mounted",i.value,l.value,c.value,h.value,f.value)}),il(function(){clearInterval(d),e.emit("beforeUnmount")});function p(){const m=t.value.getBoundingClientRect(),v=i.value;(v.width!==m.width||v.height!==m.height)&&(v.width=m.width,v.height=m.height)}u(p,"resize"),yP(p,"resize");function g(m){e.emit("setView",m)}return u(g,"setView"),yP(g,"setView"),{wrapper:t,canvas:i,view1:s,view2:r,view3:o,view4:a,view1Control:l,view2Control:c,view3Control:h,view4Control:f,setView:g}}});const uye={ref:"canvas"},hye={class:"view v1",ref:"view1",tabindex:"0"},fye={class:"control",ref:"view1Control"},dye={class:"view v2",ref:"view2",tabindex:"0"},pye={class:"control",ref:"view2Control"},mye={class:"view v3",ref:"view3",tabindex:"0"},gye={class:"control",ref:"view3Control"},vye={class:"view v4",ref:"view4",tabindex:"0"},yye={class:"control",ref:"view4Control"};function bye(n,e,t,i,s,r){const o=xn("view-rotation-handler");return Te(),Be("div",{class:Mn(["canvas-wrapper",{"quad-view":n.quadView}]),ref:"wrapper"},[ue("canvas",uye,null,512),Iu(ue("div",hye,[ue("div",fye,null,512),n.editorContext?(Te(),cn(o,{key:0,alpha:n.editorContext.views[0].camera.alpha,beta:n.editorContext.views[0].camera.beta,onSetView:n.setView},null,8,["alpha","beta","onSetView"])):nt("",!0)],512),[[rm,n.quadView||n.mainView===0]]),Iu(ue("div",dye,[ue("div",pye,null,512),n.editorContext?(Te(),cn(o,{key:0,alpha:n.editorContext.views[1].camera.alpha,beta:n.editorContext.views[1].camera.beta,onSetView:n.setView},null,8,["alpha","beta","onSetView"])):nt("",!0)],512),[[rm,n.quadView||n.mainView===1]]),Iu(ue("div",mye,[ue("div",gye,null,512),n.editorContext?(Te(),cn(o,{key:0,alpha:n.editorContext.views[2].camera.alpha,beta:n.editorContext.views[2].camera.beta,onSetView:n.setView},null,8,["alpha","beta","onSetView"])):nt("",!0)],512),[[rm,n.quadView||n.mainView===2]]),Iu(ue("div",vye,[ue("div",yye,null,512),n.editorContext?(Te(),cn(o,{key:0,alpha:n.editorContext.views[3].camera.alpha,beta:n.editorContext.views[3].camera.beta,onSetView:n.setView},null,8,["alpha","beta","onSetView"])):nt("",!0)],512),[[rm,n.quadView||n.mainView===3]])],2)}u(bye,"_sfc_render$5");var xye=jt(cye,[["render",bye],["__scopeId","data-v-5bd07d3d"]]),_ye=Object.defineProperty,wye=u((n,e)=>_ye(n,"name",{value:e,configurable:!0}),"__name$k"),Aye=zt({props:{width:{type:Number,default:250},minWidth:{type:Number,default:50},maxWidth:{type:Number,default:500},direction:{type:String,default:"left"}},setup(n,e){function t(i){if(i.button!==0)return;const s=n.width,r=i.clientX;dc(i,function(o){const a=(o.clientX-r)*(n.direction==="left"?-1:1),l=Math.min(Math.max(s+a,n.minWidth),n.maxWidth);e.emit("update:width",l)})}return u(t,"onResize"),wye(t,"onResize"),{onResize:t}}});const Mye={class:"side-panel-content"};function Sye(n,e,t,i,s,r){return Te(),Be("div",{class:"side-panel",style:ci({width:`${n.width}px`})},[ue("div",Mye,[Kd(n.$slots,"default",{},void 0,!0)]),n.direction==="left"?(Te(),Be("div",{key:0,class:"resizer-handler left",onPointerdown:e[0]||(e[0]=(...o)=>n.onResize&&n.onResize(...o))},null,32)):nt("",!0),n.direction==="right"?(Te(),Be("div",{key:1,class:"resizer-handler right",onPointerdown:e[1]||(e[1]=(...o)=>n.onResize&&n.onResize(...o))},null,32)):nt("",!0)],4)}u(Sye,"_sfc_render$4");var Tye=jt(Aye,[["render",Sye],["__scopeId","data-v-64397c11"]]),Cye=Object.defineProperty,Eye=u((n,e)=>Cye(n,"name",{value:e,configurable:!0}),"__name$j");function _v(n,e){const t=NR(n);e&&e(t);const i=document.createElement("div");return document.body.appendChild(i),t.mount(i),function(){t.unmount(),i.remove()}}u(_v,"createComponentInstance");Eye(_v,"createComponentInstance");var Pye=Object.defineProperty,Rye=u((n,e)=>Pye(n,"name",{value:e,configurable:!0}),"__name$i"),Iye=zt({components:{PopupDialog:xv},setup(){const n=He(!1),e=He(""),t=zi("context",null);t&&(n.value=t.visible,e.value=t.content),ts(n,s=>{s||t==null||t.onCloseCallback()});function i(){n.value=!1}return u(i,"ok"),Rye(i,"ok"),{visible:n,content:e,ok:i}}});const Dye={style:{"white-space":"pre-wrap"}};function Lye(n,e,t,i,s,r){const o=xn("popup-dialog");return Te(),cn(o,{modal:"",title:"Message",closable:"",visible:n.visible,"onUpdate:visible":e[1]||(e[1]=a=>n.visible=a)},{buttons:dn(()=>[ue("button",{onClick:e[0]||(e[0]=(...a)=>n.ok&&n.ok(...a))},"Ok")]),default:dn(()=>[ue("div",Dye,On(n.content),1)]),_:1},8,["visible"])}u(Lye,"_sfc_render$3");var Oye=jt(Iye,[["render",Lye]]),Fye=Object.defineProperty,bP=u((n,e)=>Fye(n,"name",{value:e,configurable:!0}),"__name$h"),Nye=zt({components:{PopupDialog:xv},setup(){const n=He(!1),e=He("");let t=!1;const i=zi("context",null);i&&(n.value=i.visible,e.value=i.content),ts(n,o=>{o||i==null||i.onCloseCallback(t)});function s(){t=!0,n.value=!1}u(s,"yes"),bP(s,"yes");function r(){n.value=!1}return u(r,"no"),bP(r,"no"),{visible:n,content:e,yes:s,no:r}}});const kye={style:{"white-space":"pre-wrap"}};function zye(n,e,t,i,s,r){const o=xn("popup-dialog");return Te(),cn(o,{modal:"",title:"Confirm",closable:"",visible:n.visible,"onUpdate:visible":e[2]||(e[2]=a=>n.visible=a)},{buttons:dn(()=>[ue("button",{onClick:e[0]||(e[0]=(...a)=>n.yes&&n.yes(...a))},"Yes"),ue("button",{onClick:e[1]||(e[1]=(...a)=>n.no&&n.no(...a))},"No")]),default:dn(()=>[ue("div",kye,On(n.content),1)]),_:1},8,["visible"])}u(zye,"_sfc_render$2");var Bye=jt(Nye,[["render",zye]]),Uye=Object.defineProperty,xP=u((n,e)=>Uye(n,"name",{value:e,configurable:!0}),"__name$g"),$ye=zt({components:{PopupDialog:xv},setup(){const n=He(!1),e=He(""),t=He(),i=He(null);let s=!1;const r=zi("context",null);r&&(n.value=r.visible,e.value=r.title,i.value=r.value),ts(n,async l=>{var c,h;l?(await qs(),(c=t.value)==null||c.focus(),(h=t.value)==null||h.select()):r==null||r.onCloseCallback(s?i.value:null)},{immediate:!0});function o(){s=!0,n.value=!1}u(o,"ok"),xP(o,"ok");function a(){s=!1,n.value=!1}return u(a,"cancel"),xP(a,"cancel"),{visible:n,title:e,input:t,value:i,ok:o,cancel:a}}});function Vye(n,e,t,i,s,r){const o=xn("popup-dialog");return Te(),cn(o,{modal:"",title:n.title,closable:"",visible:n.visible,"onUpdate:visible":e[3]||(e[3]=a=>n.visible=a)},{buttons:dn(()=>[ue("button",{onClick:e[1]||(e[1]=(...a)=>n.ok&&n.ok(...a))},"Ok"),ue("button",{onClick:e[2]||(e[2]=(...a)=>n.cancel&&n.cancel(...a))},"Cancel")]),default:dn(()=>[Iu(ue("input",{type:"text","onUpdate:modelValue":e[0]||(e[0]=a=>n.value=a),style:{width:"100%"},ref:"input"},null,512),[[FR,n.value]])]),_:1},8,["title","visible"])}u(Vye,"_sfc_render$1");var Hye=jt($ye,[["render",Vye]]),Gye=Object.defineProperty,tf=u((n,e)=>Gye(n,"name",{value:e,configurable:!0}),"__name$f");class SM{constructor(e,t,i){T(this,"visible");T(this,"content");T(this,"onCloseCallback");this.visible=e,this.content=t,this.onCloseCallback=i}}u(SM,"AlertDialogContext");tf(SM,"AlertDialogContext");function jd(n){let e;return new Promise(function(t){const i=new SM(!0,n,function(){e(),t()});e=_v(Oye,s=>{s.provide("context",i)})})}u(jd,"showAlertDialog");tf(jd,"showAlertDialog");class TM{constructor(e,t,i){T(this,"visible");T(this,"content");T(this,"onCloseCallback");this.visible=e,this.content=t,this.onCloseCallback=i}}u(TM,"ConfirmDialogContext");tf(TM,"ConfirmDialogContext");function yN(n){let e;return new Promise(function(t){const i=new TM(!0,n,function(s){e(),t(s)});e=_v(Bye,s=>{s.provide("context",i)})})}u(yN,"showConfirmDialog");tf(yN,"showConfirmDialog");class CM{constructor(e,t,i,s){T(this,"visible");T(this,"title");T(this,"value");T(this,"onCloseCallback");this.visible=e,this.title=t,this.value=i,this.onCloseCallback=s}}u(CM,"PromptDialogContext");tf(CM,"PromptDialogContext");function Wye(n,e){let t;return new Promise(function(i){const s=new CM(!0,n,e==null?null:e,function(r){t(),i(r)});t=_v(Hye,r=>{r.provide("context",s)})})}u(Wye,"showPromptDialog");tf(Wye,"showPromptDialog");var jye=Object.defineProperty,Ep=u((n,e)=>jye(n,"name",{value:e,configurable:!0}),"__name$e");async function bN(n,e){const t=await EM(n,e);if(t){for(let i of t)n.history.removeNode(i.id);return!0}return!1}u(bN,"cutModelSelected");Ep(bN,"cutModelSelected");async function EM(n,e){var s;if(((s=e==null?void 0:e.target)==null?void 0:s.tagName)==="INPUT")return;const t=n.model.getTopmostSelectedNodes(),i=[];for(let r of t)i.push(await r.toJson());return await navigator.clipboard.writeText(JSON.stringify(i)),t}u(EM,"copyModelSelected");Ep(EM,"copyModelSelected");async function xN(n,e){var t;if(e&&"target"in e&&((t=e.target)==null?void 0:t.tagName)==="INPUT")return!1;try{let i=u(function(f){f=f.filter(d=>d.instanceId?a.isNodeExists(d.instanceId)?d.type===d.type:!1:!0);for(let d of f)d.children&&(d.children=i(d.children));return f},"filterInvalidInstancedNodes");Ep(i,"filterInvalidInstancedNodes");const s=(await navigator.clipboard.read())[0];for(let f of s.types)if(f.startsWith("image/")){const d=await s.getType(f),p=await up(d);return n.history.createNode({type:"Image",data:{[io.name]:p}}),!0}let r=JSON.parse(await navigator.clipboard.readText());if(!Array.isArray(r))return!1;async function o(f){for(let d of f){for(let p in d.data){const g=is(p);let m=d.data[p];g.dataType===De.BYTES&&(m=new Uint8Array(await uw(m))),g.deserialize&&(m=g.deserialize(m)),d.data[p]=m}d.children&&await o(d.children),d.selected=!1}}u(o,"convertJsonToRealDataType"),Ep(o,"convertJsonToRealDataType"),await o(r);const a=n.model;let l=e instanceof lc?e:void 0;l||a.forEach(f=>{if(a.selected.includes(f.id))return l=f,!1}),r=i(r);let c=!1;const h=n.history;for(let f of r)if(f.selected=!0,l){if(l.isValidChild(f.type)){const d={...f};d.parentId=l.id,h.createNode(d),c=!0}}else if(ii(f.type).canBeRoot){const p={...f};p.parentId=void 0,h.createNode(p),c=!0}return c&&(a.selected=[]),!0}catch(i){return console.error(i),!1}}u(xN,"pastedModelNodes");Ep(xN,"pastedModelNodes");var Xye=Object.defineProperty,qye=u((n,e)=>Xye(n,"name",{value:e,configurable:!0}),"__name$d");const _P=new P,Yb=new je,wP=new P,AP=new me,l0=new me;function _N(n,e){e=it(e);const t=e.parent;if(!e.has(Me))return;const i=e.value(Me);if(!i)return;AP.copy(e.getParentWorldMatrix()).invert();const s=[i],r=[];for(;s.length;){const o=s.pop();if(!o)break;const a=o.userData.node;a&&a.id!==e.id||!o.visible||(o.isMesh&&r.push(o),s.push(...o.children))}for(let o of r){const a=o.geometry,l=[];let c=null;if(a.index){const d=a.getAttribute("position");if((d==null?void 0:d.itemSize)!==3)continue;const p=a.index.array,g=d.array;for(let v=0,y=p.length;v<y;++v){const x=p[v]*3;l.push(g[x],g[x+1],g[x+2])}const m=a.getAttribute("color");if(m){const v=m.array;c=[];for(let y=0,b=p.length,x=m.itemSize;y<b;++y){const _=p[y]*x;c.push(v[_],v[_+1],v[_+2])}}}else{const d=a.getAttribute("position");if((d==null?void 0:d.itemSize)!==3)continue;const p=d.array;for(let m=0,v=p.length;m<v;m+=3)l.push(p[m],p[m+1],p[m+2]);const g=a.getAttribute("color");if(g){c=[];const m=g.array;for(let v=0,y=m.length,b=g.itemSize;v<y;v+=b)c.push(m[v],m[v+1],m[v+2])}}if(!l.length)continue;const h={};h[Fn.name]=new Float32Array(l),c&&(h[Pr.name]=new Float32Array(c));const f=[Dt,Vn,Xi,In,Rn,Ft,Pn,nn,Ui];for(let d of f)e.has(d)&&(h[d.name]=e.cloneValue(d));o.updateWorldMatrix(!0,!1),l0.copy(o.matrixWorld),l0.multiplyMatrices(AP,l0),l0.decompose(_P,Yb,wP),Yb.identity(),h[ze.name]=new P().copy(_P),h[tt.name]=new ht().setFromQuaternion(Yb),h[Wt.name]=wP.x,n.history.createNode({type:"Clay",parentId:t==null?void 0:t.id,data:h})}n.history.removeNode(e.id)}u(_N,"convertModelNodeToClay");qye(_N,"convertModelNodeToClay");var Yye=Object.defineProperty,wv=u((n,e)=>Yye(n,"name",{value:e,configurable:!0}),"__name$c");async function wN(n){function e(t){const i={type:t.type,children:[]};if(t.has(Sn)){const s=t.value(Sn);i.euler={x:s.x,y:s.y,z:s.z}}return i.children=t.children.map(e),i}u(e,"getPoseJson"),wv(e,"getPoseJson"),await navigator.clipboard.writeText(JSON.stringify(e(n)))}u(wN,"copyPose");wv(wN,"copyPose");async function AN(n,e){try{let t=u(function(s,r){if(r.type===s.type&&(r.euler&&s.has(Sn)&&n.history.setValue(s,Sn,new ht(r.euler.x,r.euler.y,r.euler.z)),s.children.length===r.children.length))for(let o=0,a=s.children.length;o<a;++o)t(s.children[o],r.children[o])},"applyPose");wv(t,"applyPose");let i=JSON.parse(await navigator.clipboard.readText());if(!("type"in i))return;t(e,i)}catch(t){console.error(t)}}u(AN,"pastePose");wv(AN,"pastePose");var Zye=Object.defineProperty,MN=u((n,e)=>Zye(n,"name",{value:e,configurable:!0}),"__name$b");function SN(n,e,t){var v;e=it(e);const i=new me,s=new me,r=new P,o=new P,a=new P;if(t!=="none"){switch(i.copy(e.getParentWorldMatrix()),s.copy(i).invert(),t){case"x":r.set(1,0,0);break;case"y":r.set(0,1,0);break;case"z":r.set(0,0,1);break}o.copy(r).transformDirection(i),a.applyMatrix4(i)}const l=new P,c=new je,h=new P,f=new me,d=new P,p=new je;function g(y,b,x,w,_){const A={type:y.type,instanceId:y.instanceId||y.id};A.data=y.getComponentData(!0);let S;if(t!=="none"){if(b=b,x=x,w=w,y.instanceId&&y.has(jn)&&Ir(y.value(jn),r)?delete A.data[jn.name]:A.data[jn.name]=new P().copy(r),l.set(0,0,0),c.set(0,0,0,1),h.set(1,1,1),y.has(ze)){const M=A.data[ze.name];M.applyMatrix4(b),M.sub(a),M.reflect(o),M.add(a),M.applyMatrix4(w),l.copy(M)}if(y.has(tt)){const M=A.data[tt.name];c.setFromEuler(M);const C=Go(d,c);d.applyMatrix4(b),d.sub(a),d.reflect(o),d.add(a),d.applyMatrix4(w),d.normalize(),c.setFromAxisAngle(d,-C),M.setFromQuaternion(c)}if(y.has(At)){if(t==="x")throw new Error("Flipping on x axis will broke the ik chain");const M=y.get(At);l.copy(M.start),l.applyMatrix4(b),l.sub(a),l.reflect(o),l.add(a),l.applyMatrix4(w);let C=Go(d,M.quaternion);d.applyMatrix4(b),d.sub(a),d.reflect(o),d.add(a),d.applyMatrix4(w),d.normalize(),c.setFromAxisAngle(d,-C);const I=A.data[Sn.name];_?(p.multiplyQuaternions(_,c),I.setFromQuaternion(p)):I.setFromQuaternion(c)}y.has(Wt)&&h.setScalar(y.value(Wt)),f.compose(l,c,h),x=new me().multiplyMatrices(x,f),w=new me().copy(x).invert(),b=y.getWorldMatrix(),S=new je().copy(c).invert()}if(A.children=[],!ii(y.type).preventCreatingInstanceChild){let M;for(let C of y.children){const I=g(C,b,x,w,M);M=I.invQuat1,A.children.push(I.creationInfo)}}return A.expanded=y.expanded,A.selected=!1,{creationInfo:A,invQuat1:S}}u(g,"makeNewNode"),MN(g,"makeNewNode");const m=g(e,i,i,s).creationInfo;m.parentId=(v=e.parent)==null?void 0:v.id,m.selected=!0,n.model.selected=[],n.history.createNode(m)}u(SN,"createInstanceNode");MN(SN,"createInstanceNode");class Av{constructor(){this.pluginCallbacks=[],this.register(function(e){return new EN(e)}),this.register(function(e){return new PN(e)}),this.register(function(e){return new RN(e)}),this.register(function(e){return new LN(e)}),this.register(function(e){return new ON(e)}),this.register(function(e){return new IN(e)}),this.register(function(e){return new DN(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,s){const r=new CN,o=[];for(let a=0,l=this.pluginCallbacks.length;a<l;a++)o.push(this.pluginCallbacks[a](r));r.setPlugins(o),r.write(e,t,s).catch(i)}parseAsync(e,t){const i=this;return new Promise(function(s,r){i.parse(e,s,r,t)})}}u(Av,"GLTFExporter");const Jt={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},Fs={};Fs[Yt]=Jt.NEAREST;Fs[V0]=Jt.NEAREST_MIPMAP_NEAREST;Fs[H0]=Jt.NEAREST_MIPMAP_LINEAR;Fs[Zt]=Jt.LINEAR;Fs[D_]=Jt.LINEAR_MIPMAP_NEAREST;Fs[Mc]=Jt.LINEAR_MIPMAP_LINEAR;Fs[Wn]=Jt.CLAMP_TO_EDGE;Fs[Qi]=Jt.REPEAT;Fs[tp]=Jt.MIRRORED_REPEAT;const MP={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},SP=12,Kye=1179937895,Qye=2,TP=8,Jye=1313821514,ebe=5130562;function Id(n,e){return n.length===e.length&&n.every(function(t,i){return t===e[i]})}u(Id,"equalArray");function tbe(n){return new TextEncoder().encode(n).buffer}u(tbe,"stringToArrayBuffer");function nbe(n){return Id(n.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}u(nbe,"isIdentityMatrix");function ibe(n,e,t){const i={min:new Array(n.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(n.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let r=0;r<n.itemSize;r++){let o;n.itemSize>4?o=n.array[s*n.itemSize+r]:r===0?o=n.getX(s):r===1?o=n.getY(s):r===2?o=n.getZ(s):r===3&&(o=n.getW(s)),i.min[r]=Math.min(i.min[r],o),i.max[r]=Math.max(i.max[r],o)}return i}u(ibe,"getMinMax");function TN(n){return Math.ceil(n/4)*4}u(TN,"getPaddedBufferSize");function Zb(n,e=0){const t=TN(n.byteLength);if(t!==n.byteLength){const i=new Uint8Array(t);if(i.set(new Uint8Array(n)),e!==0)for(let s=n.byteLength;s<t;s++)i[s]=e;return i.buffer}return n}u(Zb,"getPaddedArrayBuffer");function CP(){return typeof document=="undefined"&&typeof OffscreenCanvas!="undefined"?new OffscreenCanvas(1,1):document.createElement("canvas")}u(CP,"getCanvas");function EP(n,e){if(n.toBlob!==void 0)return new Promise(i=>n.toBlob(i,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),n.convertToBlob({type:e,quality:t})}u(EP,"getToBlobPromise");class CN{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,i){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},i),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const s=this,r=s.buffers,o=s.json;i=s.options;const a=s.extensionsUsed,l=new Blob(r,{type:"application/octet-stream"}),c=Object.keys(a);if(c.length>0&&(o.extensionsUsed=c),o.buffers&&o.buffers.length>0&&(o.buffers[0].byteLength=l.size),i.binary===!0){const h=new FileReader;h.readAsArrayBuffer(l),h.onloadend=function(){const f=Zb(h.result),d=new DataView(new ArrayBuffer(TP));d.setUint32(0,f.byteLength,!0),d.setUint32(4,ebe,!0);const p=Zb(tbe(JSON.stringify(o)),32),g=new DataView(new ArrayBuffer(TP));g.setUint32(0,p.byteLength,!0),g.setUint32(4,Jye,!0);const m=new ArrayBuffer(SP),v=new DataView(m);v.setUint32(0,Kye,!0),v.setUint32(4,Qye,!0);const y=SP+g.byteLength+p.byteLength+d.byteLength+f.byteLength;v.setUint32(8,y,!0);const b=new Blob([m,g,p,d,f],{type:"application/octet-stream"}),x=new FileReader;x.readAsArrayBuffer(b),x.onloadend=function(){t(x.result)}}}else if(o.buffers&&o.buffers.length>0){const h=new FileReader;h.readAsDataURL(l),h.onloadend=function(){const f=h.result;o.buffers[0].uri=f,t(o)}}else t(o)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const i=this.options,s=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(i.includeCustomExtensions&&r.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const o in r.gltfExtensions)t.extensions[o]=r.gltfExtensions[o],s[o]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const i=new P;for(let s=0,r=e.count;s<r;s++)if(Math.abs(i.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const i=e.clone(),s=new P;for(let r=0,o=i.count;r<o;r++)s.fromBufferAttribute(i,r),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),i.setXYZ(r,s.x,s.y,s.z);return t.attributesNormalized.set(e,i),i}applyTextureTransform(e,t){let i=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),i=!0),t.rotation!==0&&(s.rotation=t.rotation,i=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),i=!0),i&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function i(p){return p.encoding===Lt?u(function(m){return m<.04045?m*.0773993808:Math.pow(m*.9478672986+.0521327014,2.4)},"SRGBToLinear"):u(function(m){return m},"LinearToLinear")}u(i,"getEncodingConversion"),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const s=e==null?void 0:e.image,r=t==null?void 0:t.image,o=Math.max((s==null?void 0:s.width)||0,(r==null?void 0:r.width)||0),a=Math.max((s==null?void 0:s.height)||0,(r==null?void 0:r.height)||0),l=CP();l.width=o,l.height=a;const c=l.getContext("2d");c.fillStyle="#00ffff",c.fillRect(0,0,o,a);const h=c.getImageData(0,0,o,a);if(s){c.drawImage(s,0,0,o,a);const p=i(e),g=c.getImageData(0,0,o,a).data;for(let m=2;m<g.length;m+=4)h.data[m]=p(g[m]/256)*256}if(r){c.drawImage(r,0,0,o,a);const p=i(t),g=c.getImageData(0,0,o,a).data;for(let m=1;m<g.length;m+=4)h.data[m]=p(g[m]/256)*256}c.putImageData(h,0,0);const d=(e||t).clone();return d.source=new Rp(l),d.encoding=Xo,d}processBuffer(e){const t=this.json,i=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),i.push(e),0}processBufferView(e,t,i,s,r){const o=this.json;o.bufferViews||(o.bufferViews=[]);let a;t===Jt.UNSIGNED_BYTE?a=1:t===Jt.UNSIGNED_SHORT?a=2:a=4;const l=TN(s*e.itemSize*a),c=new DataView(new ArrayBuffer(l));let h=0;for(let p=i;p<i+s;p++)for(let g=0;g<e.itemSize;g++){let m;e.itemSize>4?m=e.array[p*e.itemSize+g]:g===0?m=e.getX(p):g===1?m=e.getY(p):g===2?m=e.getZ(p):g===3&&(m=e.getW(p)),t===Jt.FLOAT?c.setFloat32(h,m,!0):t===Jt.UNSIGNED_INT?c.setUint32(h,m,!0):t===Jt.UNSIGNED_SHORT?c.setUint16(h,m,!0):t===Jt.UNSIGNED_BYTE&&c.setUint8(h,m),h+=a}const f={buffer:this.processBuffer(c.buffer),byteOffset:this.byteOffset,byteLength:l};return r!==void 0&&(f.target=r),r===Jt.ARRAY_BUFFER&&(f.byteStride=e.itemSize*a),this.byteOffset+=l,o.bufferViews.push(f),{id:o.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,i=t.json;return i.bufferViews||(i.bufferViews=[]),new Promise(function(s){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const o=Zb(r.result),a={buffer:t.processBuffer(o),byteOffset:t.byteOffset,byteLength:o.byteLength};t.byteOffset+=o.byteLength,s(i.bufferViews.push(a)-1)}})}processAccessor(e,t,i,s){const r=this.json,o={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=Jt.FLOAT;else if(e.array.constructor===Uint32Array)a=Jt.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)a=Jt.UNSIGNED_SHORT;else if(e.array.constructor===Uint8Array)a=Jt.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");if(i===void 0&&(i=0),s===void 0&&(s=e.count),s===0)return null;const l=ibe(e,i,s);let c;t!==void 0&&(c=e===t.index?Jt.ELEMENT_ARRAY_BUFFER:Jt.ARRAY_BUFFER);const h=this.processBufferView(e,a,i,s,c),f={bufferView:h.id,byteOffset:h.byteOffset,componentType:a,count:s,max:l.max,min:l.min,type:o[e.itemSize]};return e.normalized===!0&&(f.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(f)-1}processImage(e,t,i,s="image/png"){const r=this,o=r.cache,a=r.json,l=r.options,c=r.pending;o.images.has(e)||o.images.set(e,{});const h=o.images.get(e),f=s+":flipY/"+i.toString();if(h[f]!==void 0)return h[f];a.images||(a.images=[]);const d={mimeType:s},p=CP();p.width=Math.min(e.width,l.maxTextureSize),p.height=Math.min(e.height,l.maxTextureSize);const g=p.getContext("2d");if(i===!0&&(g.translate(0,p.height),g.scale(1,-1)),e.data!==void 0){t!==rn&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>l.maxTextureSize||e.height>l.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const v=new Uint8ClampedArray(e.height*e.width*4);for(let y=0;y<v.length;y+=4)v[y+0]=e.data[y+0],v[y+1]=e.data[y+1],v[y+2]=e.data[y+2],v[y+3]=e.data[y+3];g.putImageData(new ImageData(v,e.width,e.height),0,0)}else g.drawImage(e,0,0,p.width,p.height);l.binary===!0?c.push(EP(p,s).then(v=>r.processBufferViewImage(v)).then(v=>{d.bufferView=v})):p.toDataURL!==void 0?d.uri=p.toDataURL(s):c.push(EP(p,s).then(v=>new FileReader().readAsDataURL(v)).then(v=>{d.uri=v}));const m=a.images.push(d)-1;return h[f]=m,m}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const i={magFilter:Fs[e.magFilter],minFilter:Fs[e.minFilter],wrapS:Fs[e.wrapS],wrapT:Fs[e.wrapT]};return t.samplers.push(i)-1}processTexture(e){const t=this.cache,i=this.json;if(t.textures.has(e))return t.textures.get(e);i.textures||(i.textures=[]);let s=e.userData.mimeType;s==="image/webp"&&(s="image/png");const r={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,s)};e.name&&(r.name=e.name),this._invokeAll(function(a){a.writeTexture&&a.writeTexture(e,r)});const o=i.textures.push(r)-1;return t.textures.set(e,o),o}processMaterial(e){const t=this.cache,i=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;i.materials||(i.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(Id(r,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=.5,s.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const a=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),l={index:this.processTexture(a)};this.applyTextureTransform(l,a),s.pbrMetallicRoughness.metallicRoughnessTexture=l}if(e.map){const a={index:this.processTexture(e.map)};this.applyTextureTransform(a,e.map),s.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive.clone().multiplyScalar(e.emissiveIntensity),l=Math.max(a.r,a.g,a.b);if(l>1&&(a.multiplyScalar(1/l),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),l>0&&(s.emissiveFactor=a.toArray()),e.emissiveMap){const c={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(c,e.emissiveMap),s.emissiveTexture=c}}if(e.normalMap){const a={index:this.processTexture(e.normalMap)};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),s.normalTexture=a}if(e.aoMap){const a={index:this.processTexture(e.aoMap),texCoord:1};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),s.occlusionTexture=a}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===Ki&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),this._invokeAll(function(a){a.writeMaterial&&a.writeMaterial(e,s)});const o=i.materials.push(s)-1;return t.materials.set(e,o),o}processMesh(e){const t=this.cache,i=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let x=0,w=e.material.length;x<w;x++)s.push(e.material[x].uuid);else s.push(e.material.uuid);const r=s.join(":");if(t.meshes.has(r))return t.meshes.get(r);const o=e.geometry;let a;e.isLineSegments?a=Jt.LINES:e.isLineLoop?a=Jt.LINE_LOOP:e.isLine?a=Jt.LINE_STRIP:e.isPoints?a=Jt.POINTS:a=e.material.wireframe?Jt.LINES:Jt.TRIANGLES;const l={},c={},h=[],f=[],d={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=o.getAttribute("normal");p!==void 0&&!this.isNormalizedNormalAttribute(p)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),o.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let g=null;for(let x in o.attributes){if(x.slice(0,5)==="morph")continue;const w=o.attributes[x];if(x=d[x]||x.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x)||(x="_"+x),t.attributes.has(this.getUID(w))){c[x]=t.attributes.get(this.getUID(w));continue}g=null;const A=w.array;x==="JOINTS_0"&&!(A instanceof Uint16Array)&&!(A instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),g=new Rt(new Uint16Array(A),w.itemSize,w.normalized));const S=this.processAccessor(g||w,o);S!==null&&(c[x]=S,t.attributes.set(this.getUID(w),S))}if(p!==void 0&&o.setAttribute("normal",p),Object.keys(c).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const x=[],w=[],_={};if(e.morphTargetDictionary!==void 0)for(const A in e.morphTargetDictionary)_[e.morphTargetDictionary[A]]=A;for(let A=0;A<e.morphTargetInfluences.length;++A){const S={};let M=!1;for(const C in o.morphAttributes){if(C!=="position"&&C!=="normal"){M||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),M=!0);continue}const I=o.morphAttributes[C][A],F=C.toUpperCase(),O=o.attributes[C];if(t.attributes.has(this.getUID(I,!0))){S[F]=t.attributes.get(this.getUID(I,!0));continue}const N=I.clone();if(!o.morphTargetsRelative)for(let E=0,k=I.count;E<k;E++)N.setXYZ(E,I.getX(E)-O.getX(E),I.getY(E)-O.getY(E),I.getZ(E)-O.getZ(E));S[F]=this.processAccessor(N,o),t.attributes.set(this.getUID(O,!0),S[F])}f.push(S),x.push(e.morphTargetInfluences[A]),e.morphTargetDictionary!==void 0&&w.push(_[A])}l.weights=x,w.length>0&&(l.extras={},l.extras.targetNames=w)}const m=Array.isArray(e.material);if(m&&o.groups.length===0)return null;const v=m?e.material:[e.material],y=m?o.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let x=0,w=y.length;x<w;x++){const _={mode:a,attributes:c};if(this.serializeUserData(o,_),f.length>0&&(_.targets=f),o.index!==null){let S=this.getUID(o.index);(y[x].start!==void 0||y[x].count!==void 0)&&(S+=":"+y[x].start+":"+y[x].count),t.attributes.has(S)?_.indices=t.attributes.get(S):(_.indices=this.processAccessor(o.index,o,y[x].start,y[x].count),t.attributes.set(S,_.indices)),_.indices===null&&delete _.indices}const A=this.processMaterial(v[y[x].materialIndex]);A!==null&&(_.material=A),h.push(_)}l.primitives=h,i.meshes||(i.meshes=[]),this._invokeAll(function(x){x.writeMesh&&x.writeMesh(e,l)});const b=i.meshes.push(l)-1;return t.meshes.set(r,b),b}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const i=e.isOrthographicCamera,s={type:i?"orthographic":"perspective"};return i?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:Yi.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const i=this.json,s=this.nodeMap;i.animations||(i.animations=[]),e=Av.Utils.mergeMorphTargetTracks(e.clone(),t);const r=e.tracks,o=[],a=[];for(let l=0;l<r.length;++l){const c=r[l],h=_t.parseTrackName(c.name);let f=_t.findNode(t,h.nodeName);const d=MP[h.propertyName];if(h.objectName==="bones"&&(f.isSkinnedMesh===!0?f=f.skeleton.getBoneByName(h.objectIndex):f=void 0),!f||!d)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',c.name),null;const p=1;let g=c.values.length/c.times.length;d===MP.morphTargetInfluences&&(g/=f.morphTargetInfluences.length);let m;c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(m="CUBICSPLINE",g/=3):c.getInterpolation()===sh?m="STEP":m="LINEAR",a.push({input:this.processAccessor(new Rt(c.times,p)),output:this.processAccessor(new Rt(c.values,g)),interpolation:m}),o.push({sampler:a.length-1,target:{node:s.get(f),path:d}})}return i.animations.push({name:e.name||"clip_"+i.animations.length,samplers:a,channels:o}),i.animations.length-1}processSkin(e){const t=this.json,i=this.nodeMap,s=t.nodes[i.get(e)],r=e.skeleton;if(r===void 0)return null;const o=e.skeleton.bones[0];if(o===void 0)return null;const a=[],l=new Float32Array(r.bones.length*16),c=new me;for(let f=0;f<r.bones.length;++f)a.push(i.get(r.bones[f])),c.copy(r.boneInverses[f]),c.multiply(e.bindMatrix).toArray(l,f*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new Rt(l,16)),joints:a,skeleton:i.get(o)}),s.skin=t.skins.length-1}processNode(e){const t=this.json,i=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(i.trs){const a=e.quaternion.toArray(),l=e.position.toArray(),c=e.scale.toArray();Id(a,[0,0,0,1])||(r.rotation=a),Id(l,[0,0,0])||(r.translation=l),Id(c,[1,1,1])||(r.scale=c)}else e.matrixAutoUpdate&&e.updateMatrix(),nbe(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const a=this.processMesh(e);a!==null&&(r.mesh=a)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let l=0,c=e.children.length;l<c;l++){const h=e.children[l];if(h.visible||i.onlyVisible===!1){const f=this.processNode(h);f!==null&&a.push(f)}}a.length>0&&(r.children=a)}this._invokeAll(function(a){a.writeNode&&a.writeNode(e,r)});const o=t.nodes.push(r)-1;return s.set(e,o),o}processScene(e){const t=this.json,i=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const r=[];for(let o=0,a=e.children.length;o<a;o++){const l=e.children[o];if(l.visible||i.onlyVisible===!1){const c=this.processNode(l);c!==null&&r.push(c)}}r.length>0&&(s.nodes=r),this.serializeUserData(e,s)}processObjects(e){const t=new sp;t.name="AuxScene";for(let i=0;i<e.length;i++)t.children.push(e[i]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(s){s.beforeParse&&s.beforeParse(e)});const i=[];for(let s=0;s<e.length;s++)e[s]instanceof sp?this.processScene(e[s]):i.push(e[s]);i.length>0&&this.processObjects(i);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll(function(s){s.afterParse&&s.afterParse(e)})}_invokeAll(e){for(let t=0,i=this.plugins.length;t<i;t++)e(this.plugins[t])}}u(CN,"GLTFWriter");class EN{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const i=this.writer,s=i.json,r=i.extensionsUsed,o={};e.name&&(o.name=e.name),o.color=e.color.toArray(),o.intensity=e.intensity,e.isDirectionalLight?o.type="directional":e.isPointLight?(o.type="point",e.distance>0&&(o.range=e.distance)):e.isSpotLight&&(o.type="spot",e.distance>0&&(o.range=e.distance),o.spot={},o.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,o.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},r[this.name]=!0);const a=s.extensions[this.name].lights;a.push(o),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}u(EN,"GLTFLightExtension");class PN{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}u(PN,"GLTFMaterialsUnlitExtension");class RN{constructor(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,t){if(!e.isGLTFSpecularGlossinessMaterial)return;const i=this.writer,s=i.extensionsUsed,r={};t.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);const o=[1,1,1];if(e.specular.toArray(o,0),r.specularFactor=o,r.glossinessFactor=e.glossiness,t.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=t.pbrMetallicRoughness.baseColorTexture),e.specularMap){const a={index:i.processTexture(e.specularMap)};i.applyTextureTransform(a,e.specularMap),r.specularGlossinessTexture=a}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}u(RN,"GLTFMaterialsPBRSpecularGlossiness");class IN{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const i=this.writer,s=i.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const o={index:i.processTexture(e.clearcoatMap)};i.applyTextureTransform(o,e.clearcoatMap),r.clearcoatTexture=o}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const o={index:i.processTexture(e.clearcoatRoughnessMap)};i.applyTextureTransform(o,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=o}if(e.clearcoatNormalMap){const o={index:i.processTexture(e.clearcoatNormalMap)};i.applyTextureTransform(o,e.clearcoatNormalMap),r.clearcoatNormalTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}u(IN,"GLTFMaterialsClearcoatExtension");class DN{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const i=this.writer,s=i.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const o={index:i.processTexture(e.iridescenceMap)};i.applyTextureTransform(o,e.iridescenceMap),r.iridescenceTexture=o}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const o={index:i.processTexture(e.iridescenceThicknessMap)};i.applyTextureTransform(o,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}u(DN,"GLTFMaterialsIridescenceExtension");class LN{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,s=i.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const o={index:i.processTexture(e.transmissionMap)};i.applyTextureTransform(o,e.transmissionMap),r.transmissionTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}u(LN,"GLTFMaterialsTransmissionExtension");class ON{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,s=i.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const o={index:i.processTexture(e.thicknessMap)};i.applyTextureTransform(o,e.thicknessMap),r.thicknessTexture=o}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}u(ON,"GLTFMaterialsVolumeExtension");Av.Utils={insertKeyframe:function(n,e){const i=n.getValueSize(),s=new n.TimeBufferType(n.times.length+1),r=new n.ValueBufferType(n.values.length+i),o=n.createInterpolant(new n.ValueBufferType(i));let a;if(n.times.length===0){s[0]=e;for(let l=0;l<i;l++)r[l]=0;a=0}else if(e<n.times[0]){if(Math.abs(n.times[0]-e)<.001)return 0;s[0]=e,s.set(n.times,1),r.set(o.evaluate(e),0),r.set(n.values,i),a=0}else if(e>n.times[n.times.length-1]){if(Math.abs(n.times[n.times.length-1]-e)<.001)return n.times.length-1;s[s.length-1]=e,s.set(n.times,0),r.set(n.values,0),r.set(o.evaluate(e),n.values.length),a=s.length-1}else for(let l=0;l<n.times.length;l++){if(Math.abs(n.times[l]-e)<.001)return l;if(n.times[l]<e&&n.times[l+1]>e){s.set(n.times.slice(0,l+1),0),s[l+1]=e,s.set(n.times.slice(l+1),l+2),r.set(n.values.slice(0,(l+1)*i),0),r.set(o.evaluate(e),(l+1)*i),r.set(n.values.slice((l+1)*i),(l+2)*i),a=l+1;break}}return n.times=s,n.values=r,a},mergeMorphTargetTracks:function(n,e){const t=[],i={},s=n.tracks;for(let r=0;r<s.length;++r){let o=s[r];const a=_t.parseTrackName(o.name),l=_t.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(o);continue}if(o.createInterpolant!==o.InterpolantFactoryMethodDiscrete&&o.createInterpolant!==o.InterpolantFactoryMethodLinear){if(o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),o=o.clone(),o.setInterpolation(uc)}const c=l.morphTargetInfluences.length,h=l.morphTargetDictionary[a.propertyIndex];if(h===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let f;if(i[l.uuid]===void 0){f=o.clone();const p=new f.ValueBufferType(c*f.times.length);for(let g=0;g<f.times.length;g++)p[g*c+h]=f.values[g];f.name=(a.nodeName||"")+".morphTargetInfluences",f.values=p,i[l.uuid]=f,t.push(f);continue}const d=o.createInterpolant(new o.ValueBufferType(1));f=i[l.uuid];for(let p=0;p<f.times.length;p++)f.values[p*c+h]=d.evaluate(f.times[p]);for(let p=0;p<o.times.length;p++){const g=this.insertKeyframe(f,o.times[p]);f.values[g*c+h]=o.values[p]}}return n.tracks=t,n}};class FN{parse(e){let t="",i=0,s=0,r=0;const o=new P,a=new Ce,l=new P,c=new Ie,h=[];function f(g){let m=0,v=0,y=0;const b=g.geometry,x=new ki,w=b.getAttribute("position"),_=b.getAttribute("normal"),A=b.getAttribute("uv"),S=b.getIndex();if(t+="o "+g.name+`
`,g.material&&g.material.name&&(t+="usemtl "+g.material.name+`
`),w!==void 0)for(let M=0,C=w.count;M<C;M++,m++)o.fromBufferAttribute(w,M),o.applyMatrix4(g.matrixWorld),t+="v "+o.x+" "+o.y+" "+o.z+`
`;if(A!==void 0)for(let M=0,C=A.count;M<C;M++,y++)c.fromBufferAttribute(A,M),t+="vt "+c.x+" "+c.y+`
`;if(_!==void 0){x.getNormalMatrix(g.matrixWorld);for(let M=0,C=_.count;M<C;M++,v++)l.fromBufferAttribute(_,M),l.applyMatrix3(x).normalize(),t+="vn "+l.x+" "+l.y+" "+l.z+`
`}if(S!==null)for(let M=0,C=S.count;M<C;M+=3){for(let I=0;I<3;I++){const F=S.getX(M+I)+1;h[I]=i+F+(_||A?"/"+(A?s+F:"")+(_?"/"+(r+F):""):"")}t+="f "+h.join(" ")+`
`}else for(let M=0,C=w.count;M<C;M+=3){for(let I=0;I<3;I++){const F=M+I+1;h[I]=i+F+(_||A?"/"+(A?s+F:"")+(_?"/"+(r+F):""):"")}t+="f "+h.join(" ")+`
`}i+=m,s+=y,r+=v}u(f,"parseMesh");function d(g){let m=0;const v=g.geometry,y=g.type,b=v.getAttribute("position");if(t+="o "+g.name+`
`,b!==void 0)for(let x=0,w=b.count;x<w;x++,m++)o.fromBufferAttribute(b,x),o.applyMatrix4(g.matrixWorld),t+="v "+o.x+" "+o.y+" "+o.z+`
`;if(y==="Line"){t+="l ";for(let x=1,w=b.count;x<=w;x++)t+=i+x+" ";t+=`
`}if(y==="LineSegments")for(let x=1,w=x+1,_=b.count;x<_;x+=2,w=x+1)t+="l "+(i+x)+" "+(i+w)+`
`;i+=m}u(d,"parseLine");function p(g){let m=0;const v=g.geometry,y=v.getAttribute("position"),b=v.getAttribute("color");if(t+="o "+g.name+`
`,y!==void 0){for(let x=0,w=y.count;x<w;x++,m++)o.fromBufferAttribute(y,x),o.applyMatrix4(g.matrixWorld),t+="v "+o.x+" "+o.y+" "+o.z,b!==void 0&&(a.fromBufferAttribute(b,x).convertLinearToSRGB(),t+=" "+a.r+" "+a.g+" "+a.b),t+=`
`;t+="p ";for(let x=1,w=y.count;x<=w;x++)t+=i+x+" ";t+=`
`}i+=m}return u(p,"parsePoints"),e.traverse(function(g){g.isMesh===!0&&f(g),g.isLine===!0&&d(g),g.isPoints===!0&&p(g)}),t}}u(FN,"OBJExporter");var sbe=Object.defineProperty,I0=u((n,e)=>sbe(n,"name",{value:e,configurable:!0}),"__name$a");async function NN(n,e,t){function i(){const r=new sp;r.traverse=function(o){a(r);function a(l){for(let c of l.children)c.visible&&(o(c),a(c))}u(a,"traverseVisible"),I0(a,"traverseVisible")};for(let o of n.readonlyRef().model.nodes)if(o.has(Me)){const a=o.value(Me);a&&r.children.push(a)}return r}u(i,"getExportScene"),I0(i,"getExportScene");async function s(r){try{n.statusBarMessage="Exporting...",e.value=!0,await qs(),await r(async function(){n.statusBarMessage="Writing files...",await qs()}),n.statusBarMessage="File exported."}catch(o){console.error(o),n.statusBarMessage="Failed to export."}finally{e.value=!1}}switch(u(s,"process"),I0(s,"process"),t){case"obj":try{const r=await showSaveFilePicker({types:[{accept:{"application/object":[".obj"]}}]});await s(async function(o){const a=i(),l=new FN().parse(a);await o();const c=await r.createWritable({keepExistingData:!1});await c.write(l),await c.close()})}catch{return}break;case"glb":try{const r=await showSaveFilePicker({types:[{accept:{"application/object":[".glb"]}}]});await s(async function(o){const a=i(),c=await new Av().parseAsync(a,{onlyVisible:!0,binary:!0});await o();const h=await r.createWritable({keepExistingData:!1});await h.write(c),await h.close()})}catch{return}break;default:return}}u(NN,"exportModel");I0(NN,"exportModel");var rbe=Object.defineProperty,D0=u((n,e)=>rbe(n,"name",{value:e,configurable:!0}),"__name$9");const bn=new P,Io=new je,c0=new P(1,0,0),pd=new P(0,1,0),PP=new P(0,0,1);function kN(n,e,t){e=it(e);let i;if(e.type==="IKNode"){const a=e.parent,l=a.children.findIndex(c=>c.id===e.id);if(l){const h=a.children[l-1].get(At);i=new je().copy(h.quaternion).invert()}}s(e,new P,new P(0,0,1),new me,new me,new me,i);function s(a,l,c,h,f,d,p){const g=a.getLocalMatrix(),m=new P,v=new je,y=new P;if(!(a.has(Qt)&&a.value(Qt))){g.decompose(m,v,y);const x=new me().multiplyMatrices(h,g);if(t==="flip"){const M=Go(bn,v);bn.applyMatrix4(h),bn.sub(l),bn.reflect(c),bn.add(l),bn.applyMatrix4(d),bn.normalize(),v.setFromAxisAngle(bn,-M),m.applyMatrix4(h),m.sub(l),m.reflect(c),m.add(l),m.applyMatrix4(d)}else c0.set(1,0,0).applyQuaternion(v),pd.set(0,1,0).applyQuaternion(v),c0.z=0,c0.normalize(),pd.z=0,pd.normalize(),PP.crossVectors(c0,pd).normalize(),Qa(v,PP,pd),m.z=0;a.has(tt)&&n.history.setValue(a,tt,new ht().setFromQuaternion(v)),a.has(Sn)&&(p?Io.multiplyQuaternions(p,v):Io.copy(v),n.history.setValue(a,Sn,new ht().setFromQuaternion(Io)));const w=new me().compose(m,v,y);w.multiplyMatrices(f,w);const _=new me().copy(w).invert(),A=new Set;let S;for(let M of a.children){if(A.has(M.id))continue;A.add(M.id);const C=o(M,a);if(C){A.add(C.id);let I=M,F=C;M.has(ze)&&M.value(ze).z>0&&(F=M,I=C),r(l,c,I,h,f,d,S,F,h,f,d,S)}else{const{rotation:I}=s(M,l,c,x,w,_,S);S=new je().copy(I).invert()}}}return{rotation:v}}u(s,"processMiddleNode"),D0(s,"processMiddleNode");function r(a,l,c,h,f,d,p,g,m,v,y,b){const x=c.getLocalMatrix(),w=new P,_=new je,A=new P;x.decompose(w,_,A);const S=new me().multiplyMatrices(h,x),M=g.getLocalMatrix(),C=new P,I=new je,F=new P;M.decompose(C,I,F);const O=new me().multiplyMatrices(m,M);if(!(e.has(Qt)&&e.value(Qt))){if(t==="flip"||t==="left-to-right"){const ie=Go(bn,_);bn.applyMatrix4(h),bn.sub(a),bn.reflect(l),bn.add(a),bn.applyMatrix4(d),bn.normalize(),_.setFromAxisAngle(bn,-ie),w.applyMatrix4(h),w.sub(a),w.reflect(l),w.add(a),w.applyMatrix4(d),g.has(tt)&&n.history.setValue(g,tt,new ht().setFromQuaternion(_)),g.has(Sn)&&(p?Io.multiplyQuaternions(p,_):Io.copy(_),n.history.setValue(g,Sn,new ht().setFromQuaternion(Io)))}if(t==="flip"||t==="right-to-left"){const ie=Go(bn,I);bn.applyMatrix4(m),bn.sub(a),bn.reflect(l),bn.add(a),bn.applyMatrix4(y),bn.normalize(),I.setFromAxisAngle(bn,-ie),C.applyMatrix4(m),C.sub(a),C.reflect(l),C.add(a),C.applyMatrix4(y),c.has(tt)&&n.history.setValue(c,tt,new ht().setFromQuaternion(I)),c.has(Sn)&&(b?Io.multiplyQuaternions(b,I):Io.copy(I),n.history.setValue(c,Sn,new ht().setFromQuaternion(Io)))}const E=new me().compose(w,_,A);E.multiplyMatrices(f,E);const k=new me().copy(E).invert(),G=new me().compose(C,I,F);G.multiplyMatrices(v,G);const X=new me().copy(G).invert();let te,j;for(let ie of c.children){const K=o(ie,g);if(K){const{rotationLeft:$,rotationRight:le}=r(a,l,ie,S,E,k,te,K,O,G,X,j);te=new je().copy($).invert(),j=new je().copy(le).invert()}}}return{rotationLeft:_,rotationRight:I}}u(r,"processMirrorNode"),D0(r,"processMirrorNode");function o(a,l){var f;if(a.type==="IKNode"&&((f=a.parent)==null?void 0:f.id)===l.id)return null;const c=a.has(ze)?a.value(ze):null;if(a.has(jn)){for(let d of l.children)if(a.id!==d.id&&a.type===d.type&&(a.instanceId===d.id||a.instanceId===d.instanceId)&&(!c||h(c,d.value(ze))))return d}else for(let d of l.children)if(a.id!==d.id&&a.type===d.type&&d.has(jn)&&(d.instanceId===a.id||d.instanceId===a.instanceId)&&(!c||h(c,d.value(ze))))return d;return null;function h(d,p){return Math.abs(d.x-p.x)<1e-8&&Math.abs(d.y-p.y)<1e-8&&Math.abs(d.z+p.z)<1e-8}}u(o,"findMirrorNode"),D0(o,"findMirrorNode")}u(kN,"flipNode");D0(kN,"flipNode");var obe=Object.defineProperty,abe=u((n,e)=>obe(n,"name",{value:e,configurable:!0}),"__name$8");const zN=2016834916,BN=2,u0=new DataView(new ArrayBuffer(8));class PM{constructor(){T(this,"buffer",new Uint8Array(64));T(this,"size",0)}expandCapacity(e){const t=e+this.size;if(this.buffer.length<t){const i=new Uint8Array(Math.pow(2,Math.ceil(Math.log2(t))));for(let s=0,r=this.size;s<r;++s)i[s]=this.buffer[s];this.buffer=i}}writeUint32(e){this.expandCapacity(4),u0.setUint32(0,e);for(let t=0;t<4;++t)this.buffer[this.size+t]=u0.getUint8(t);this.size+=4}writeFloat64(e){this.expandCapacity(8),u0.setFloat64(0,e);for(let t=0;t<8;++t)this.buffer[this.size+t]=u0.getUint8(t);this.size+=8}writeBoolean(e){this.writeUint32(e?1:0)}writeString(e){const i=new TextEncoder().encode(e);this.writeUint32(i.length),this.expandCapacity(i.length);for(let s=0,r=i.length;s<r;++s)this.buffer[this.size+s]=i[s];this.size+=i.length}writeBytes(e){this.writeUint32(e.length),this.expandCapacity(e.length);for(let t=0,i=e.length;t<i;++t)this.buffer[this.size+t]=e[t];this.size+=e.length}writeNumberArray(e){this.writeUint32(e.length);for(let t of e)this.writeFloat64(t)}write(e){e=e.readonlyRef(),this.writeUint32(zN),this.writeUint32(BN);for(let i of e.views)this.writeFloat64(i.zoomLevel),this.writeFloat64(i.camera.alpha),this.writeFloat64(i.camera.beta),this.writeFloat64(i.camera.target.x),this.writeFloat64(i.camera.target.y),this.writeFloat64(i.camera.target.z),this.writeBoolean(i.index===e.mainViewIndex?e.model.cameraPerspective:i.camera.perspective),this.writeFloat64(i.camera.perspectiveCamera.fov);const t=e.model;this.writeUint32(t.cameras.length);for(let i of t.cameras)this.writeString(i.name),this.writeFloat64(i.zoomLevel),this.writeFloat64(i.alpha),this.writeFloat64(i.beta),this.writeFloat64(i.target[0]),this.writeFloat64(i.target[1]),this.writeFloat64(i.target[2]),this.writeBoolean(i.perspective),this.writeFloat64(i.fov);return e.model.forEach(i=>{var r;this.writeUint32(i.id),this.writeString(i.type),this.writeBoolean(i.expanded),this.writeUint32(((r=i.parent)==null?void 0:r.id)||0),this.writeUint32(i.instanceId);const s=[];for(let o in i.components){const a=i.components[o],l=is(o);if(l.storable){if(i.instanceId&&!l.instanceable)continue;const c=l.serialize?l.serialize(a.value):a.value;c!=null&&s.push([l.dataType,o,c])}}this.writeUint32(s.length);for(let o of s){const a=o[0],l=o[1],c=o[2];switch(this.writeUint32(a),this.writeString(l.substring(1)),a){case De.NUMBER:this.writeFloat64(c);break;case De.STRING:this.writeString(c);break;case De.BOOLEAN:this.writeBoolean(c);break;case De.NUMBER_ARRAY:this.writeNumberArray(c);break;case De.BYTES:this.writeBytes(c);break;default:throw new Error(`Unimplemented data type of component [${l}]`)}}}),this}getBytes(){return this.buffer.subarray(0,this.size)}}u(PM,"ProjectWriter");abe(PM,"ProjectWriter");var lbe=Object.defineProperty,cbe=u((n,e)=>lbe(n,"name",{value:e,configurable:!0}),"__name$7");const h0=new DataView(new ArrayBuffer(8));class Mv{constructor(e){T(this,"buffer");T(this,"index",0);this.buffer=e}end(){return this.index>=this.buffer.length}readUint32(){for(let t=0;t<4;++t)h0.setUint8(t,this.buffer[this.index+t]);const e=h0.getUint32(0);return this.index+=4,e}readFloat64(){for(let t=0;t<8;++t)h0.setUint8(t,this.buffer[this.index+t]);const e=h0.getFloat64(0);return this.index+=8,e}readBoolean(){return!!this.readUint32()}readString(){const e=new TextDecoder,t=this.readUint32(),i=this.buffer.subarray(this.index,this.index+t),s=e.decode(i);return this.index+=t,s}readBytes(){const e=this.readUint32(),t=this.buffer.subarray(this.index,this.index+e);return this.index+=e,t}readNumberArray(){const e=this.readUint32(),t=[];for(let i=0;i<e;++i)t.push(this.readFloat64());return t}read(){if(this.readUint32()!==zN)throw new Error("Failed to read magic header");const t=this.readUint32();if(t>BN)throw new Error("Unknown file version");const i={views:[],cameras:[],nodes:[]};for(let s=0;s<4;++s){const r=this.readFloat64(),o=this.readFloat64(),a=this.readFloat64(),l=this.readFloat64(),c=this.readFloat64(),h=this.readFloat64();let f=s===1,d=45;t>=2&&(f=this.readBoolean(),d=this.readFloat64()),i.views.push({zoomLevel:r,alpha:o,beta:a,target:[l,c,h],perspective:f,fov:d})}if(t>=2){const s=this.readUint32();for(let r=0;r<s;++r){const o=this.readString(),a=this.readFloat64(),l=this.readFloat64(),c=this.readFloat64(),h=this.readFloat64(),f=this.readFloat64(),d=this.readFloat64(),p=this.readBoolean(),g=this.readFloat64();i.cameras.push({name:o,zoomLevel:a,alpha:l,beta:c,target:[h,f,d],perspective:p,fov:g})}}for(;!this.end();){const s=this.readUint32(),r=this.readString(),o=this.readBoolean(),a=this.readUint32(),l=this.readUint32(),c=this.readUint32(),h={};for(let f=0;f<c;++f){const d=this.readUint32(),p="C"+this.readString();let g;switch(d){case De.NUMBER:g=this.readFloat64();break;case De.STRING:g=this.readString();break;case De.BOOLEAN:g=this.readBoolean();break;case De.NUMBER_ARRAY:g=this.readNumberArray();break;case De.BYTES:g=this.readBytes();break;default:throw new Error(`Unimplemented data type [${d}]`)}if(LD(p)){const m=is(p);m.deserialize&&(g=m.deserialize(g)),h[p]=g}}i.nodes.push({id:s,type:r,expanded:o,parentId:a,instanceId:l,data:h})}return i}}u(Mv,"ProjectReader");cbe(Mv,"ProjectReader");var ube=Object.defineProperty,hbe=u((n,e)=>ube(n,"name",{value:e,configurable:!0}),"__name$6");async function UN(n,e,t,i){let s=null;const r=[t,{description:"Wavefront",accept:{"application/object":[".obj"]}},{description:"FBX",accept:{"application/fbx":[".fbx"]}},{description:"Image",accept:{"image/png":[".png"],"image/jpeg":[".jpg",".jpeg",".jfif",".pjpeg",".pjp"],"image/bmp":[".bmp"],"image/webp":[".webp"]}}];try{[s]=await showOpenFilePicker({types:[{description:"All Supported",accept:r.reduce((o,a)=>Object.assign(o,a.accept),{})},...r],multiple:!1})}catch{return}try{n.statusBarMessage="Loading...",e.value=!0,await qs();const o=await s.getFile(),a=o.name.substring(o.name.lastIndexOf(".")).toLowerCase();switch(a){case i:{const l=new Mv(new Uint8Array(await o.arrayBuffer())).read(),c={};let h=n.history.getNextNodeId()+1;for(let p of l.nodes)c[p.id]=h++;const f={};for(let p of l.nodes)f[p.id]={originId:p.id,type:p.type,data:p.data,expanded:p.expanded,instanceId:p.instanceId?c[p.instanceId]:0};const d=[];for(let p of l.nodes)if(p.parentId){const g=f[p.parentId];g.children=g.children||[],g.children.push(f[p.id])}else d.push(f[p.id]);for(let p of d)n.history.createNode(p)}break;case".obj":{const l=await o.text();n.history.createNode({type:"ObjModel",data:{[Zo.name]:l,[tr.name]:!0}})}break;case".fbx":{const l=await o.arrayBuffer(),c=await up(new Blob([l]));n.history.createNode({type:"FbxModel",data:{[Yo.name]:c,[tr.name]:!0}})}break;case".jpg":case".jpeg":case".jfif":case".pjpeg":case".pjp":case".png":case".apng":case".gif":case".avif":case".webp":case".bmp":{const l=await o.arrayBuffer(),c=await up(new Blob([l]));n.history.createNode({type:"Image",data:{[io.name]:c}})}break;default:await jd(`Unsupported file format ${a}`)}focus(),n.statusBarMessage=""}catch(o){console.error(o),n.statusBarMessage="Failed to import file: "+o}finally{e.value=!1}}u(UN,"importModel");hbe(UN,"importModel");var fbe=Object.defineProperty,dbe=u((n,e)=>fbe(n,"name",{value:e,configurable:!0}),"__name$5");const md=new P,f0=new P,d0=new P,RP=new P,IP=new P,DP=new P,p0=new P,Kb=new P,Qb=new P,LP=new P,m0=new P,OP=new P,Jb=new P,ex=new P(1,0,0);function $N(n,e,t,i,s=.005){const r=Math.max(i.max.x-i.min.x,i.max.y-i.min.y,i.max.z-i.min.z),o=r/(Math.ceil(r/s)+.5),a=1/o,l=n.length/9,c=i.min.x-o,h=i.min.y-o,f=i.min.z-o,d=i.max.x+o,p=i.max.y+o,g=i.max.z+o,m=Math.floor(c*a),v=Math.floor(h*a),y=Math.floor(f*a),b=Math.ceil(d*a),x=Math.ceil(p*a),w=Math.ceil(g*a),_=b-m,A=x-v,S=w-y,M=_*A*S,C=new Float32Array(M),I=new Float32Array(M*3);for(let $=0;$<M;++$)C[$]=o;const F=new Qr(M),O=new Qr(M*3);for(let $=0;$<l;++$){const le=t[$*6]-o,ae=t[$*6+1]-o,J=t[$*6+2]-o,ne=t[$*6+3]+o,ve=t[$*6+4]+o,he=t[$*6+5]+o,_e=Math.floor(le*a),we=Math.floor(ae*a),Se=Math.floor(J*a),V=Math.ceil(ne*a),Y=Math.ceil(ve*a),R=Math.ceil(he*a),ee=V-_e,Q=Y-we,U=R-Se;md.fromArray(n,$*9),f0.fromArray(n,$*9+3),d0.fromArray(n,$*9+6),RP.fromArray(e,$*9),IP.fromArray(e,$*9+3),DP.fromArray(e,$*9+6),p0.addVectors(RP,IP).add(DP).multiplyScalar(1/3),Kb.subVectors(f0,md),Qb.subVectors(d0,md),LP.subVectors(d0,f0);for(let z=0;z<ee;++z){const W=z+_e-m,re=c+W*o;for(let B=0;B<Q;++B){const D=B+we-v,L=h+D*o;for(let H=0;H<U;++H){const q=H+Se-y,se=f+q*o,de=W*A*S+D*S+q;m0.set(re,L,se),VW(OP,m0,md,f0,d0,Kb,Qb,LP),Jb.subVectors(OP,m0);const ge=Jb.length();if(!(ge>o)){F.set(de),ge<=C[de]&&(C[de]=ge,I[de*3]=p0.x,I[de*3+1]=p0.y,I[de*3+2]=p0.z);for(let ye=0;ye<3;++ye){const pe=Jb.getComponent(ye);if(pe<0||pe>o)continue;const Ne=de*3+ye;if(O.get(Ne))continue;ex.set(0,0,0),ex.setComponent(ye,1);const Ye=HW(m0,ex,md,Kb,Qb);Ye<0||Ye>o||O.set(Ne)}}}}}}const N=new Qr(C.length),E=[0],k=A*S,G=S,X=1,te=[-k,+k,-G,+G,-X,+X],j=[0,0,1,1,2,2];for(;E.length;){const $=E.pop();if($==null)break;if(F.get($)){let le=!1;for(let ae=0;ae<6;++ae){const J=te[ae],ne=$+J;ne<0||ne>=M||N.get(ne)||!F.get(ne)||(O.get((J>0?$:ne)*3+j[ae])?le=!0:(N.set(ne),E.push(ne)))}le&&N.set($)}else{N.set($);for(let le=0;le<6;++le){const ae=$+te[le];ae<0||ae>=M||N.get(ae)||(N.set(ae),E.push(ae))}}}for(let $=0;$<M;++$)N.get($)||(C[$]=-C[$]);const ie=[],K=[];for(let $=0;$<_-1;++$){const le=c+$*o;for(let ae=0;ae<A-1;++ae){const J=h+ae*o;for(let ne=0;ne<S-1;++ne){const ve=f+ne*o;aA(ie,null,K,le,J,ve,o,C,I,$*A*S+ae*S+ne,($+1)*A*S+ae*S+ne,($+1)*A*S+ae*S+(ne+1),$*A*S+ae*S+(ne+1),$*A*S+(ae+1)*S+ne,($+1)*A*S+(ae+1)*S+ne,($+1)*A*S+(ae+1)*S+(ne+1),$*A*S+(ae+1)*S+(ne+1))}}}return{position:new Float32Array(ie),color:new Float32Array(K)}}u($N,"voxelizeRemesh");dbe($N,"voxelizeRemesh");var pbe=Object.defineProperty,mbe=u((n,e)=>pbe(n,"name",{value:e,configurable:!0}),"__name$4");async function VN(n,e,t,i){const s=await fetch(n);if(!s.body)throw new Error("Failed to get response body");const r=s.body.getReader();i||(i=Number.parseInt(s.headers.get("Content-Length")||"0"));let o=0;const a=[];for(;;){const{done:h,value:f}=await r.read();if(h||!f)break;if(a.push(f),o+=f.length,e(o,i),t!=null&&t.value)return await r.cancel(),r.releaseLock(),null}const l=new Uint8Array(o);let c=0;for(let h of a)l.set(h,c),c+=h.length;return l}u(VN,"progressiveDownload");mbe(VN,"progressiveDownload");var gbe=Object.defineProperty,vbe=u((n,e)=>gbe(n,"name",{value:e,configurable:!0}),"__name$3");class RM{constructor(e){T(this,"running",!1);T(this,"keepLoop",!1);T(this,"lastTimestamp",0);T(this,"onUpdate");this.onUpdate=e}start(){this.running||(this.running=!0,this.keepLoop=!0,this.lastTimestamp=new Date().valueOf(),requestAnimationFrame(()=>this.loop()))}stop(){this.keepLoop=!1}loop(){const e=new Date().valueOf();try{this.keepLoop&&this.onUpdate(Math.max(e-this.lastTimestamp,1)/1e3)}catch(t){throw this.running=!1,this.keepLoop=!1,t}this.lastTimestamp=e,this.keepLoop?requestAnimationFrame(()=>this.loop()):this.running=!1}}u(RM,"RenderLoop");vbe(RM,"RenderLoop");var ybe=Object.defineProperty,bbe=u((n,e)=>ybe(n,"name",{value:e,configurable:!0}),"__name$2");const xbe="gYxItIxQuvELUDHlN23TLnKHSMC47FjIJmWce1uK",_be=`https://sketchfab.com/oauth2/authorize/?response_type=token&client_id=${xbe}`,tx="sketchfab-token",HN=Ho({token:{accessToken:"",expires:0},user:{displayName:"",username:""},loadLocalStorage(){const n=localStorage.getItem(tx);if(!n)return;const e=JSON.parse(n);if(e.expires>Date.now())try{this.getUser(),this.token=e}catch(t){console.error(t)}},login(){window.location.replace(_be)},logout(){this.token={accessToken:"",expires:0},localStorage.removeItem(tx)},parseRouterPath(n){n=n||"",n.startsWith("/")&&(n=n.substring(1));const e=n.split("&"),t={accessToken:"",expires:0};for(let i of e){const s=i.split("=");if(s.length<2)continue;const r=s[0],o=s[1];switch(r){case"access_token":t.accessToken=o;break;case"expires_in":t.expires=Number.parseInt(o)*1e3+Date.now();break}}t.accessToken&&t.accessToken!==this.token.accessToken&&(this.token=t,localStorage.setItem(tx,JSON.stringify(t)),this.getUser())},async fetch(n,e="get"){return fetch(n,{method:e,headers:{Authorization:`Bearer ${this.token.accessToken}`},mode:"cors"})},async getUser(){const n=await this.fetch("https://api.sketchfab.com/v3/me");this.user=await n.json()},async getModelDownloadUrl(n){var r,o,a,l;const e=new URL(n).pathname.split("-"),t=e[e.length-1];if(!t)return;const i=await(await this.fetch(`https://api.sketchfab.com/v3/models/${t}/download`)).json(),s=await(await this.fetch(`https://api.sketchfab.com/v3/models/${t}`)).json();return{download:i,info:{name:s==null?void 0:s.name,url:s==null?void 0:s.viewerUrl,license:{name:(r=s==null?void 0:s.license)==null?void 0:r.label,url:(o=s==null?void 0:s.license)==null?void 0:o.url},user:{name:(a=s==null?void 0:s.user)==null?void 0:a.displayName,url:(l=s==null?void 0:s.user)==null?void 0:l.profileUrl}}}}});HN.loadLocalStorage();function GN(){return HN}u(GN,"useSketchfabClient");bbe(GN,"useSketchfabClient");var wbe=Object.defineProperty,WN=u((n,e)=>wbe(n,"name",{value:e,configurable:!0}),"__name$1");function jN(n,e=300){let t=Date.now(),i=0;function s(){const r=Date.now();i+=r-t,t=r;const o=Math.min(1,i/e);n(o),o<1&&requestAnimationFrame(s)}u(s,"step"),WN(s,"step"),s()}u(jN,"createTransitionAnimation");WN(jN,"createTransitionAnimation");var Abe=Object.defineProperty,gt=u((n,e)=>Abe(n,"name",{value:e,configurable:!0}),"__name");const L0=".doll",nx={description:"Figure Doll Model",accept:{"application/figure-doll-editor":[L0]}},FP="figure-doll-editor-options";var Mbe=zt({components:{ColorPicker:KI,FullscreenLoading:QH,InputBoolean:sa,InputNumber:si,LabelRange:vG,ModelNodeProperties:Rve,ModelTree:Zve,PopupDialog:xv,PopupMenu:vw,PopupMenuItem:vN,QuadView:xye,SidePanel:Tye},setup(){const n=DB(),e=GN(),t=He(),i=He(),s=new RM(function(){var B;(B=i.value)==null||B.update()}),r=He({showTools:!0,showModelTree:!0,showProperties:!0,showStatusBar:!0,modelTreePanelWidth:200,modelNodePropertiesPanelWidth:200,colorPanelX:250,colorPanelY:50}),o=He(!1),a=He(null);let l=null;const c=st(function(){var D;const B=(D=i.value)==null?void 0:D.model;return B?B.selected.length===0?oO.filter(L=>!L.canBeRoot||!L.showInList?!1:L.unique?!B.nodes.find(H=>H.type===L.name):!0):B.selected.length>1?[]:bw(B.getSelectedNodes()[0]).filter(L=>L.showInList):[]}),h=st(function(){var D;const B=(D=i.value)==null?void 0:D.model;return B?B.getSelectedNodes().filter(L=>!ii(L.type).fixed).length:!1});ts([a,()=>{var B,D;return(D=(B=i.value)==null?void 0:B.history)==null?void 0:D.dirty}],function([B,D]){B&&B.endsWith(L0)&&(B=B.substring(0,B.length-L0.length)),document.title=(B||"Untitled")+(D?"*":"")+" - Figure Doll Editor"},{immediate:!0}),ts([r,()=>{var B;return(B=i.value)==null?void 0:B.options}],function(){var B;localStorage.setItem(FP,JSON.stringify({ui:r.value,options:(B=i.value)==null?void 0:B.options}))},{deep:!0}),x1(async function(){"showOpenFilePicker"in window||await jd(`This application is only available in Chrome or Edge.
Cannot open or save files in the current browser.`),e.parseRouterPath(n.currentRoute.value.fullPath),n.currentRoute.value.fullPath.length>1&&await n.push("/")});function f(){var B;(B=t.value)==null||B.focus()}u(f,"focus"),gt(f,"focus");function d(B,D,L,H,q){i.value=new Kp(B,D,L,H,q);try{const se=localStorage.getItem(FP);if(se){const de=JSON.parse(se);if("ui"in de&&Object.assign(r.value,de.ui),"options"in de){Object.assign(i.value.options,de.options);for(let ge in i.value.options.tools){const ye=i.value.options.tools[ge],pe=i.value.tools.find(Ne=>Ne.constructor.name===ge);if(pe)for(let Ne in ye)pe[Ne]=ye[Ne]}}}}catch(se){console.error(se)}s.start(),window.ctx=i.value.readonlyRef()}u(d,"onCanvasMounted"),gt(d,"onCanvasMounted");function p(){var B;(B=i.value)==null||B.dispose(),i.value=void 0}u(p,"onBeforeCanvasUnmount"),gt(p,"onBeforeCanvasUnmount");function g(B){var D;((D=B==null?void 0:B.target)==null?void 0:D.tagName)!=="INPUT"&&(i.value.history.undo(),f())}u(g,"onUndo"),gt(g,"onUndo");function m(B){var D;((D=B==null?void 0:B.target)==null?void 0:D.tagName)!=="INPUT"&&(i.value.history.redo(),f())}u(m,"onRedo"),gt(m,"onRedo");async function v(){return i.value.history.dirty?await yN(`Unsaved changes will be lost.
Are you sure you want to continue?`):!0}u(v,"historyConfirm"),gt(v,"historyConfirm");async function y(){await v()&&(a.value=null,l=null,i.value.reset(),f(),i.value.statusBarMessage="")}u(y,"onNew"),gt(y,"onNew");async function b(){try{[l]=await showOpenFilePicker({types:[nx],multiple:!1})}catch{return}if(await v())try{i.value.statusBarMessage="Loading...",o.value=!0,await qs();const B=await l.getFile();a.value=B.name;const D=new Mv(new Uint8Array(await B.arrayBuffer())).read();i.value.load(D),f(),i.value.statusBarMessage=""}catch(B){console.error(B),i.value.statusBarMessage="Failed to open file."}finally{o.value=!1}}u(b,"onOpen"),gt(b,"onOpen");async function x(){await UN(i.value,o,nx,L0)}u(x,"onImport"),gt(x,"onImport");async function w(B){await NN(i.value,o,B)}u(w,"onExport"),gt(w,"onExport");async function _(B){B!=null&&B.shiftKey?await A():(l?await S():await A(),f())}u(_,"onSave"),gt(_,"onSave");async function A(){try{l=await showSaveFilePicker({types:[nx],suggestedName:a.value||void 0})}catch{return}const B=await l.getFile();a.value=B.name,await S(),f()}u(A,"onSaveAs"),gt(A,"onSaveAs");async function S(){if(!!l)try{i.value.statusBarMessage="Saving...",o.value=!0,await qs();const B=await l.createWritable({keepExistingData:!1}),D=new PM().write(i.value).getBytes();i.value.statusBarMessage="Writing files...",await qs(),await B.write(D),await B.close(),i.value.history.save(),i.value.statusBarMessage="File saved."}catch{i.value.statusBarMessage="Failed to save file."}finally{o.value=!1}}u(S,"saveFile"),gt(S,"saveFile");function M(B){const D=i.value,H=D.views[D.mainViewIndex].camera;let q=H.alpha,se=H.beta;switch(B){case"front":q=0,se=-Math.PI/2,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=0,se=+Math.PI/2);break;case"back":q=0,se=+Math.PI/2,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=0,se=-Math.PI/2);break;case"top":q=-Math.PI/2,se=-Math.PI/2,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=+Math.PI/2,se=-Math.PI/2);break;case"bottom":q=+Math.PI/2,se=-Math.PI/2,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=-Math.PI/2,se=-Math.PI/2);break;case"right":q=0,se=0,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=0,se=Math.PI);break;case"left":q=0,se=Math.PI,Math.abs(q-H.alpha)<1e-8&&Math.abs(se-H.beta)<1e-8&&(q=0,se=0);break}const de=q-H.alpha,ge=se-H.beta;jN(function(ye){H.alpha=q-de*(1-ye),H.beta=se-ge*(1-ye)},100)}u(M,"onSetView"),gt(M,"onSetView");function C(B,D,L){i.value.history.setValue(B,D,L)}u(C,"onSetValue"),gt(C,"onSetValue");function I(B,D){B=it(B);const L=i.value;let q=it(L.model).getSelectedNodes();const se=D==="before"||D==="after"?B.parent:B;q=q.filter(ge=>{let ye=!0,pe=ge.parent;for(;ye&&pe;){if(!pe.expanded){ye=!1;break}pe=pe.parent}return!ye||ge.parent&&q.includes(ge.parent)?!1:!ii(ge.type).fixed});for(let ge of q)if(!de(se,ge))return;for(let ge of q){const ye=L.options.keepTransformUnchangedWhileMoving;D==="before"||D==="after"?L.history.moveNode(ge,se,B,D==="after",ye):L.history.moveNode(ge,se,null,D==="atLast",ye)}function de(ge,ye){const pe=ii(ye.type);if(!ge)return pe.canBeRoot;if(!ge.isValidChild(ye.type))return!1;for(;ge;ge=ge.parent)if(ge.id===ye.id)return!1;return!0}u(de,"isValidChild"),gt(de,"isValidChild")}u(I,"onMoveNode"),gt(I,"onMoveNode");function F(B){const D=i.value.model,L=D.selected[0];D.selected=[];const H={type:B,parentId:L},q=ii(B);q.defaultData&&(H.data=q.defaultData),q.defaultChildren&&(H.children=q.defaultChildren),i.value.history.createNode(H),f()}u(F,"onAddNode"),gt(F,"onAddNode");function O(B){var H;if((B==null?void 0:B.key)==="Backspace"||((H=B==null?void 0:B.target)==null?void 0:H.tagName)==="INPUT"||!i.value.tool.enableDefaultDeleteShortcut&&(B==null?void 0:B.key)==="Delete")return;const L=i.value.model.getTopmostSelectedNodes();for(let q of L)ii(q.type).fixed||i.value.history.removeNode(q.id);f()}u(O,"onDelete"),gt(O,"onDelete");function N(B){i.value.nextFrameEnd(function(){i.value.model.selected=B})}u(N,"onSelect"),gt(N,"onSelect");function E(B){const D=new Set;for(let L of B){let H=L.node;H.instanceId&&(is(L.type.name).instanceable||(H=i.value.model.getNode(H.instanceId)));const q=`${H.id}#${L.type.name}`;D.has(q)||(D.add(q),i.value.history.setValue(H,L.type,L.value))}}u(E,"onSetNodesProperties"),gt(E,"onSetNodesProperties");function k(B){if(!B)return;const D=new P;if(dh(D,B.getWorldMatrix()),B.has(Me)){const L=B.value(Me);if(L){const H=L.geometry;H&&(H.boundingSphere||H.computeBoundingSphere(),D.copy(H.boundingSphere.center),D.applyMatrix4(B.getWorldMatrix()))}}for(let L of i.value.views)L.camera.target.copy(D)}u(k,"onFocus"),gt(k,"onFocus");async function G(B){await bN(i.value,B)&&f()}u(G,"onCut"),gt(G,"onCut");async function X(B){await EM(i.value,B)&&f()}u(X,"onCopy"),gt(X,"onCopy");async function te(B){await xN(i.value,B)&&f()}u(te,"onPaste"),gt(te,"onPaste");function j(B){_N(i.value,B)}u(j,"onConvertToClay"),gt(j,"onConvertToClay");function ie(B){B=it(B);const D=i.value,L=B.getLocalMatrix(),H=B.cloneValue(Fn),q=new P;for(let se=0,de=H.length;se<de;se+=3)q.fromArray(H,se),q.applyMatrix4(L),H[se]=q.x,H[se+1]=q.y,H[se+2]=q.z;D.history.setValue(B,Fn,H),D.history.setValue(B,ze,new P),D.history.setValue(B,tt,new ht),D.history.setValue(B,Wt,1)}u(ie,"onApplyTransformation"),gt(ie,"onApplyTransformation");const K=st(function(){const B=i.value;if(!B)return!1;const D=B.model.selected[0];return D?B.model.getNode(D).type==="Clay":!1});async function $(){var se;const B=(se=i.value)==null?void 0:se.readonlyRef();if(!B)return;const D=B.model.selected[0];if(!D)return;const L=B.model.getNode(D),q=L.get(Me).mesh;if(!!q)try{o.value=!0,await qs(),await new Promise(function(ge){setTimeout(ge,50)});const de=$N(q.aPosition,q.aColor,q.triBox,q.octree.box,B.options.remeshVoxelSize);B.history.enableMerge=!1,B.history.setValue(L,Fn,de.position,"remesh-position"),B.history.setValue(L,Pr,de.color,"remesh-color")}finally{o.value=!1}}u($,"onRemesh"),gt($,"onRemesh");function le(B,D){SN(i.value,B,D)}u(le,"onCreateInstance"),gt(le,"onCreateInstance");function ae(B,D){kN(i.value,B,D)}u(ae,"onFlip"),gt(ae,"onFlip");function J(B){return wN(B)}u(J,"onCopyPose"),gt(J,"onCopyPose");function ne(B){return AN(i.value,B)}u(ne,"onPastePose"),gt(ne,"onPastePose");function ve(B){const D=i.value,L=D.model,H=D.views[D.mainViewIndex];H.zoomLevel=B.zoomLevel,H.camera.alpha=B.alpha,H.camera.beta=B.beta,H.camera.target.set(B.target[0],B.target[1],B.target[2]),L.cameraPerspective=B.perspective,L.cameraFov=B.fov}u(ve,"onLoadCamera"),gt(ve,"onLoadCamera");function he(B){i.value.model.cameras.splice(B,1),i.value.history.dirty=!0}u(he,"onDeleteCamera"),gt(he,"onDeleteCamera");function _e(){const B=i.value,D=B.model,L=B.views[B.mainViewIndex];D.cameras.push({name:new Date().toISOString().replace("T"," ").replace(/\.[0-9]+Z/,""),zoomLevel:L.zoomLevel,alpha:L.camera.alpha,beta:L.camera.beta,target:[L.camera.target.x,L.camera.target.y,L.camera.target.z],perspective:D.cameraPerspective,fov:D.cameraFov}),B.history.dirty=!0}u(_e,"onSaveCamera"),gt(_e,"onSaveCamera");const we=He("");async function Se(){await v()&&e.login()}u(Se,"onSketchfabLogin"),gt(Se,"onSketchfabLogin");function V(){e.logout()}u(V,"onSketchfabLogout"),gt(V,"onSketchfabLogout");const Y=He(!1),R=He(""),ee=He(""),Q=He(!1),U=He(0);async function z(){var B;if(!!we.value)try{i.value.statusBarMessage="Fetching model download url...",o.value=!0;const{info:D,download:L}=await e.getModelDownloadUrl(we.value);if((B=L.gltf)!=null&&B.url){we.value="",i.value.statusBarMessage="Downloading model...",o.value=!1,Y.value=!0,Q.value=!1,U.value=0,R.value="0.0MB",ee.value=(L.gltf.size/1024/1024).toFixed(1)+"MB";const H=await VN(L.gltf.url,(q,se)=>{U.value=Math.round(q/se*100),R.value=(q/1024/1024).toFixed(1)+"MB"},Q,L.gltf.size);if(!H){i.value.statusBarMessage="Download canceled.";return}i.value.history.createNode({type:"ImportModel",data:{[Dt.name]:D.name,[hp.name]:D,[Ko.name]:H}}),i.value.statusBarMessage="Model imported."}else i.value.statusBarMessage="Failed to download model.",L.detail?await jd("Could not download model: "+L.detail):await jd("Failed to get model download url.")}catch{i.value.statusBarMessage="Failed to import model."}finally{o.value=!1,Y.value=!1}}u(z,"onSketchfabImportModel"),gt(z,"onSketchfabImportModel");function W(){window.open("https://github.com/x6ud/figure-doll-editor/issues")}u(W,"onOpenFeedback"),gt(W,"onOpenFeedback");function re(){window.open("https://github.com/x6ud/figure-doll-editor#download-models")}return u(re,"onOpenTutorial"),gt(re,"onOpenTutorial"),{dom:t,sketchfabClient:e,editorCtx:i,fullscreenLoading:o,uiOptions:r,validChildNodeDefs:c,canDelete:h,canRemesh:K,sketchfabModelUrl:we,downloadProgressDialog:Y,downloadProgressText:R,downloadTotalText:ee,downloadCancelFlag:Q,downloadProgressPercent:U,onCanvasMounted:d,onBeforeCanvasUnmount:p,onUndo:g,onRedo:m,onNew:y,onOpen:b,onImport:x,onExport:w,onSave:_,onSaveAs:A,onSetView:M,onSetValue:C,onMoveNode:I,onAddNode:F,onDelete:O,onSelect:N,onSetNodesProperties:E,onFocus:k,onCut:G,onCopy:X,onPaste:te,onConvertToClay:j,onApplyTransformation:ie,onRemesh:$,onCreateInstance:le,onFlip:ae,onCopyPose:J,onPastePose:ne,onLoadCamera:ve,onDeleteCamera:he,onSaveCamera:_e,onSketchfabLogin:Se,onSketchfabLogout:V,onSketchfabImportModel:z,onOpenFeedback:W,onOpenTutorial:re}}}),Sbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAAG3RFWHRTb2Z0d2FyZQBDZWxzeXMgU3R1ZGlvIFRvb2zBp+F8AAAPYElEQVR42u1be1RU1ff/nLkz4Ixo4AM1FTF8P6CwfKJo9FIyAzEUtbQkDTMrM7Ny3XXTwge4VktSVrpKMzHSJMon6nKVpqQpShhCKC41zRe+ZgCZuXf//vh9z133ztwZEOlbra9nrVlc7p17ztmfs/c+n733GUZE+F9u7B4A9wC4B8A9AP7qJkkSAUBoaCjMZjMAQFGU/58AY7q/AGAymeBwOFBZWQmHw4G5c+eyfyUAXPAOHTogICAAsiwjMTGRAUBubi6NGjXKQ7CcnBwqLCxE9+7dUVxcrHsmiiL7VwAwf/58uv/++9GqVSvIsgxFUVBYWOghwO7du2nfvn0AgKioKDidTvz888/q97799lsSBAEjR45kmZmZdPHixQYHoUEBWLRoEYWFhcFsNsPf3x8AIAgCTCYTBEFQPyaTCXl5eYiJiUFUVBTbv38/DRw40Ktg27dvJ7vdjuPHj8NisUAQBMyZM4f9YwD4/PPPyWw2w2w2o7S0FP3794efnx+GDRvGuBm4t+HDh8NisYCIwBiDy+UCEUFRFPWv9kNEkGUZjz/+OAOApUuX0ptvvsn+VgCWL19OZrMZL7/8siqoKIps586dZLPZsGvXLoiiyCRJIq66x44dIwAgIgiCACJCeHg4KywsJMYYevfuzbT+g7fHHnsMu3btQr9+/VSzOn36NARBQEpKCvuvA5CZmUkmk0kVngs6ePBg7N27FyNGjMAjjzzCAODXX38lPk54eDgDgJKSEuratSsDgBMnTlC3bt0YABw/fpwYY+jRo4dOe3h/2nvh4eFQFAUVFRVITk5m/zUAFi9eTK1bt0Z5ebnufnR0NIYOHcokSaL4+Hj1/qZNmzyc1++//06dO3dmAFBWVkadOnXSrfxzzz0Hxhg4MMeOHaOIiAidNvHr7OxsIiI4nU5MnDiR/aUALFiwgNq0aYOAgACcOHFC3Z727t1LgwcPVoXnDq9r1666SQPA6dOnKTQ0lGm3y0mTJmH16tUeQJWWlhIAyLIMl8sFp9MJp9OJmpoa1NTU4Pbt26ipqcGzzz7L1q9fT+PGjfvrAOCrExISgsDAQMTFxTEA+Omnn2jQoEE6O+YqfurUKXrggQfUSZ07d47atWunU2VRFBm/7z5meXk5cUfYuXNnDzC1c+vduzcqKiowZcoU1uAAaCccGhqKFi1aIDY2lh04cIAGDBjACgsLidu3Vq0lSaKXXnoJXOjk5GSsXLnSY6X//PNPat26tXrv/PnzJMsy2rdvb9in+/tbt26lQ4cOAQCCg4PxyiuvsAYHQBRF9uWXX9KECRPYzp07qWnTpujXrx/j9qn9PldzDtzUqVMhCIJKe7XUt3nz5gwArly5QnwLbNWqlaEAZWVltG7dOkNSFRMTo/qGoKAgvPbaa6xBANAinpWVRe3atcOQIUNYQUEBMcbw4IMPegx09uxZ+uyzz1QVv3r1KjVv3pxVVFRQs2bNdPY/Y8YM9T0+n4yMDK/zGT9+PNxB4D5I22/jxo3x1ltvsQYDIDs7mxITE1l+fj75+fkhMjKSeTMVruocAK3gN27coPvuu8/j3evXr1NgYKBOGzgowcHBOr/BQeDtqaeewvbt2z3m7u/vj3feeYfdFQCpqak0d+5ctmHDBhozZgw7fPgw9enThxkJzlfl4sWL1KpVK9VetcIBwK1bt6hJkyYeE3O/rzUhbh6rVq2CKIpMu30WFBTQQw89pOtvxYoVZLfbUV1djXnz5rF6A5Cenk4dO3ZEfHw8O3jwIFksFnDq+/XXX3tEapIk0fTp09GiRQsGADdv3qSmTZt6TKCyspJsNpvuvsPhoMaNGzN3QN3Ni4PhdDqRlZWF0aNHo1evXmzPnj3kcDhgt9sxduxYlp6eTna73WsQVScAli1bRu3atUObNm3Qv39/da/v3bs3O3nyJIWFhTF3c9GqvLfVBoDq6mpq1KiR6rxmz56NJUuWeJ2w+w5w8uRJ4nGC3W6Hu2ZmZGTQ1atX6w/AypUrKTk5meXm5lJwcDDy8vIgiiL77bffqEePHoyvSPv27XXbE1d5u91O6enpPsPY27dv08KFCyGKItMCUhsA586dI5fLhdDQUFZSUkJfffWVhzZ++umndOHChfoDsGbNGmrWrBmCgoIQFRWldqLl8nwfFwQBLVu21Km9w+GgtLQ0jwm4EyGn00kWi4VxQPz9/b1qQEpKCmRZhpY3aGMKLUhr1qyh06dP1x+A9evXU9u2bTFkyBCPDrj6awe8du0aBQUFMbvdTiaTCTabzYO/e7Ntl8tFZrOZ1dTUkJ+fn8fzGzdukKIoCAoKMhSmuLiYunfvrhuna9euGDt2rFcGWSsA27ZtI6vViqFDhxrS1I4dO3p0fuvWLRIEAYwxWK1WD9rrazyXy0VEBK4NAFBVVUWKooA7R199HD9+nHr27Mk0gRjFx8fXD4DNmzeT1WoFZ1hG7cyZMxQSEuLxvKqqijjjM5lMKvszSoJ+8MEHunfff/99EJG67WnNoTYAioqKqFevXgwAtmzZQrGxsT53FJ8A5OXl0YEDB7yunCRJNGXKFLRt29bDvt9++20sXrwYc+fORWpqqs+VJ80kuOD8mmeDFi5cWOegLS4uDjk5ORg4cCD279/vM6nqE4Dt27eTv78/fvzxR0MnJooiu3DhArVp08bDvqurq2nRokUQRZG5XC5ijEEQhDpHabIsE/8+B1RRFDUbJMuyGkMYtaNHj9KNGzcQHR3N0tLSyOFw3DkAW7ZsIavVCn9/f5jNZvTr148ZqeHFixcpMzNTN4AWAP59RVHIZDLVCQRFUWj+/Pm6lTMaV5ZlNVcgyzK0zLCqqgrnz59HQkJC/XzA999/T0eOHMGwYcPU4Oe7776Du0dPSUlRtz9u/4sXL/Zgh//5nw/oc6+fN28e3MEyEsLdvouLi8nlcqmAPPzww8yX7/AKQE5ODsXFxTFJkigmJga7d+8GACQkJGDjxo26lbly5Qpx2lsHAFRzdwdBK4yRtvhygNpnRUVF5HK5UFNTg759+9bPCW7cuJG0qnPgwAHKy8sDACQlJUEQBGgzPVrqa8TxvUxeBcHouRaE2rw/zxW4XC41j5ifn0+culssFrz77rt1B4CHvtqM7/Dhw9G3b1+mDUp4xoYTICPhaxHAq0m4O0JvAJw9e5ZkWYY2ASOKolpwSU9Pp1mzZt0ZE8zKyqKkpCQdALGxsapNGaWyrl+/ThaLBY0bN64VAAO19DCJ2gC4dOkSybIMvgsZjbd37146evQoZsyYcWcArF27liZOnOhR2XnmmWfgHndfuXKFtOWvgIAArxPyZY+cD7D/sCROjd0BuH79OimKAm1myZtfiI6ORklJCaZOnVp3AFavXk2TJk3y2NslSaJRo0YZpsB4AMQYg1Ho661E5t5EUWR85XmAxIW32+1ERGjSpAmra39RUVE4c+YMJk+efHcaoF09ngtwF/D111+HyWRSqa87BXanwwYagAULFgAA3nvvPSiKgtTUVMyZMweKomDJkiV3VCqXJIkGDBiAy5cvY/z48XcGQGZmJgUFBcFsNqOoqEhHaCRJooSEBPCgwyjt5XA4CIDqD3ypvrvdczqsjQe0DJDv8S6XC0a1BO2ctm3bRna7HWPGjLkzAD755BOaPn06W7duHTVt2hQjR47UsSltQkSbBVq2bJluhSorKwmAunp1re/zPt0TJO7OsLy8nHi1yP1TU1MDp9MJRVHw9NNP3xkAH3/8Mc2cOZPx3WDHjh2Un5+vY4GJiYnIzs5WtUObBzQKjnhoXBsI2u944xS+wOTv79ixg1wuF2JjY+uXFeYJRZ5U2LNnDwmCoCZH3NNQly5douDgYK87QFVVFQGA1WplvqpPWpBnzZpluKv4osbR0dGQZRn79u1Dz549kZCQUD8AFi1aRNXV1RBFUU2JS5JETz75pJocHTduHLp06cKMyltGE+WJTyLS8QVvwrzxxhswyigbvZefn0+yLGPQoEHqWN26dVPPJd0xAB999BE5nU51Rb755hviDvHw4cO0efNmlRp37tyZ/fHHH+SeGzACgF/zbW3p0qVew233eoJRKygoIFmWsWXLFo/4o1OnTl53gFoBMLI1nmLiNXuTyYRGjRohKysLL774oq6Y6WtltbvKzZs3iYigrRYZpdfd+0hISICiKNi0aZPh9qjlM/WuDC1YsIAEQVDP6kmSRBERETh27JguBOXFEm3dv64hLG/Xrl0jRVGQkZGhPrt8+TItX75cN6ekpCQoiqKePdAKrx1v1apVVFupvM61QZvNhtmzZ6tn/I4ePaoToKysTJcD5EB4iwF8tZSUFHChp02bplaKy8vLiYjUKNSbafHrzMxMmjZt2t0DwDsNDAzEzJkzmSRJFBkZiZEjR+oEGzt2rFoCt1gsHmzQqDRuxAaJCCaTSb3mJKhDhw668R599FHdKZHbt2/rrokIr776asMAwAdt2bIlLl++DADo06ePjmBoU9JlZWVERMjKyjIkQL5OeoiiyM6fP09aAHiWR0tyeIrOvb8VK1aQLMu1Cl+vM0KSJFHbtm0hCAImT57MeOqZJyK1gZIkSZSUlKSupLaS5Ms5au+dOnWK1q5d62HfRvNq3749ZFnG1atXfZbE7woAPpjFYkFISAgmTJjAtm7dSiNGjGCHDh2irVu3eiQxud0nJiaCiKCt3nhLePJWWlpK69ev9xkErVu3jmRZxvPPP18npnnXAPAJ+/n5ISwsDAEBARgxYoSagfHm5fn9hIQENcjh54q8OUsedLmDCQA9evSAoig4ceJErRrS4ADwSfr7+6NLly6wWq2w2WyIjo5mdeHq/HrUqFFQFAWRkZGGJTRuVlrhcnNziR/Ads8l3KkMDXJWeOHChcQYQ0REBARB0FVj6tpiY2OhKIou5wgABw8epG3btoGHtoqiIDY2lnGafjfCNxgAfFWtVivCw8N9JkGMaoP8dCkAPPHEE+oBacYYoqKi2K5du0hRFFy6dAnV1dWoqqpCRUXFXQne4ABoQQgJCUFJSQkiIyN1J75Hjx5tuAv88MMPutogbyaTCbIso7KyEr/88gtqyyn+7QBoD1W88MILHpmgDRs2kBYQbZBi5AQjIyNx5MgRiKLIPvzwQ3K5XP/sH0xoW0ZGBjkcDmjt1N1hffHFF8RZ3rlz53QrHBYWhpMnT8Jms0GW5Trv6/8YAAAgLS2NjGze6J7NZlM1Q5Zl+Pn5weFwoCF+FPG3AfBvaPcAuAfAPQD+twH4PyYSYSaTaCiyAAAAAElFTkSuQmCC",Tbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAZNJREFUOI3Fk79rU1EUxz/nvgZiqkMRgkKGDMlQCDRgXbpZgrSIQ5ZM/gHB3exFcLB0kQ6OLkIgW6wubdA2mTIEApVAoWPgpQ/E16bxx+u7xyHk0Te1kMEDl8s5XD7fc773XpgzRFXnAph5O5gbIMCLTCazk0wmbwUbj8cT13UPgS1VPQV43+v19DYxGo3U8zxtt9uay+V+AMsGEBGZ4v8GcHwK/hiCKzg+Af8iUi8Wi5N0Ov21Xq/TaDSWROTNQqy/tx/g+wnccWBpEUYu3EvCzmtIpQA8a+26iHyp1Wqb+Xz+SRzgDcG5hCCEMw9MCJMLOPdngMg7x3FIJBIJA2j0FjbWwEzA/ALzB+QKVh/Bg4cwPXhfRPaq1eqG7/sMBoOjhRhg8ylc/oRPzWm+UoTqy0i20+ncdRznmeu6lMtl31r7CmC32+3G7f68p7r7TjUIYuVSqWSz2ewZ8BHIz4S3W63WjVc4HA5VRPZVletLgMeFQuFbpVJJGWNms0a7tZYwDGk2m7/7/f5zVT2IufnfP9M/jW8Tm1+fCIsAAAAASUVORK5CYII=",Cbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAFBJREFUOI1jYBgF6OA/FFBsCDJNH0P+owGyDaGKS3BppqohuAxjwmUgIyMjIy4+0QYhA0YoICmqsXkNH5skw8gyBJ8GQobgDEB0jYQCe/ABAKCQl4Lg46L9AAAAAElFTkSuQmCC",Ebe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAFRJREFUOI3lkjsOACAIQ8V4/yvXCUIMH4kbdqWUl5Qx2oq8AQCky0Syv6IQbaweEZNn9uZkmSIxJQBo4pkiXqpxkFl/JK+QMhE3df5YuX4r5InoI21GkSwM7aEiTgAAAABJRU5ErkJggg==",Pbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAC5JREFUOI1jYBgFwxT8////PyE1TNSyjGoGMeKSwOcdRkZGnPrwgqEZRqOAjgAAfNwMAvOaLCwAAAAASUVORK5CYII=",Rbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAADBJREFUOI1jYBgFgwf8hwKKDcHGJtsQYgxjIsuWkWUQXkCVWEM2gGJDRgEDAwMDAwA87SfhU+Y3UgAAAABJRU5ErkJggg==",Ibe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAACJJREFUOI1jYBgFo2AQAUZcEv////+PUxMjI059o2AUUAIA4coEAgSS2PIAAAAASUVORK5CYII=",Dbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAEVJREFUOI1jYBi2gBGf5P////+jKGZkxKseqwHohuATJ8oVxKphIsp0UgHRzsailmouGnwGYYDBFWvINpKaIGmbRYYHAAC8Mj/Vvda64QAAAABJRU5ErkJggg==",Lbe="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAGFJREFUOI3dk0EOwCAIBMH0/19er4ILKqaHlqOsw6hR5LelWRMATFg1zNOGB0ybCLBVICwzgaplQCubzOodox2Ta1AGESHPz+7JQwDArz2V6VtGoxUziQYffZHQpnCCD1UHNO0sGtTVHO8AAAAASUVORK5CYII=";const rs=u(n=>(tl("data-v-6e1f6f19"),n=n(),nl(),n),"_withScopeId"),Obe={class:"toolbar"},Fbe={class:"properties"},Nbe={class:"cols",style:{"align-items":"center","margin-bottom":"8px"}},kbe={class:"cols",style:{"align-items":"center"}},zbe=rs(()=>ue("div",{class:"fill"},null,-1)),Bbe={style:{"margin-right":"4px"}},Ube={class:"properties"},$be={class:"cols",style:{"align-items":"center","margin-bottom":"8px"}},Vbe=rs(()=>ue("div",{style:{"margin-right":"4px"}},"FOV",-1)),Hbe={class:"camera-list"},Gbe={class:"item"},Wbe=["onClick"],jbe=["onClick"],Xbe=rs(()=>ue("div",{class:"properties cols"},[ue("div",null,[ue("img",{src:Sbe,alt:""})]),ue("div",{style:{padding:"4px 6px 4px 8px"}},[ue("div",{style:{"margin-bottom":"6px"}},[ue("span",{style:{"font-size":"16px","font-weight":"bold"}}," Figure Doll Editor "),Bo(" Ver 20230309 ")]),ue("div",{style:{"margin-bottom":"6px"}},"Author: x6udpngx"),ue("div",{style:{"margin-bottom":"6px"}},[ue("a",{href:"https://github.com/x6ud/figure-doll-editor",target:"_blank"}," Source ")]),ue("div",null,[ue("a",{href:"https://ko-fi.com/x6udpngx",target:"_blank"},[ue("img",{src:Tbe,alt:"",style:{"vertical-align":"text-bottom"}}),Bo(" Support Me on Ko-fi ")])])])],-1)),qbe=rs(()=>ue("div",{class:"separator"},null,-1)),Ybe=rs(()=>ue("img",{src:Cbe,alt:""},null,-1)),Zbe=[Ybe],Kbe=rs(()=>ue("img",{src:Ebe,alt:""},null,-1)),Qbe=[Kbe],Jbe={key:1,class:"button-group cols",style:{"margin-right":"6px"},title:"Direction"},exe=rs(()=>ue("img",{src:Pbe,alt:""},null,-1)),txe=[exe],nxe=rs(()=>ue("img",{src:Rbe,alt:""},null,-1)),ixe=[nxe],sxe=rs(()=>ue("img",{src:Ibe,alt:""},null,-1)),rxe=[sxe],oxe={class:"properties"},axe={class:"property inline"},lxe=rs(()=>ue("label",null,"Voxel size",-1)),cxe=rs(()=>ue("span",null,"\xA0m",-1)),uxe=rs(()=>ue("div",{class:"fill"},null,-1)),hxe={class:"button-group cols"},fxe=rs(()=>ue("img",{src:Dbe,alt:""},null,-1)),dxe=[fxe],pxe=rs(()=>ue("img",{src:Lbe,alt:""},null,-1)),mxe=[pxe],gxe={class:"cols fill"},vxe={key:0,class:"tools scrollable"},yxe={class:"scroll"},bxe={key:0},xxe={key:0},_xe=["title","onClick"],wxe=["src"],Axe={key:0,class:"rows",style:{width:"100%",height:"100%"}},Mxe=["disabled"],Sxe={key:0,class:"status-bar cols"},Txe=rs(()=>ue("div",{class:"fill"},null,-1)),Cxe={class:"cols",style:{"align-items":"center"}},Exe={class:"progress-bar",style:{width:"260px","margin-right":"4px"}},Pxe={class:"text"};function Rxe(n,e,t,i,s,r){var b,x,w;const o=xn("popup-menu-item"),a=xn("popup-menu"),l=xn("input-number"),c=xn("input-boolean"),h=xn("label-range"),f=xn("model-tree"),d=xn("side-panel"),p=xn("model-node-properties"),g=xn("quad-view"),m=xn("color-picker"),v=xn("popup-dialog"),y=xn("fullscreen-loading");return Te(),Be(kt,null,[ue("div",{class:"container rows",tabindex:"0",onKeydown:[e[43]||(e[43]=Dn(Hn((..._)=>n.onUndo&&n.onUndo(..._),["ctrl"]),["z"])),e[44]||(e[44]=Dn(Hn((..._)=>n.onRedo&&n.onRedo(..._),["ctrl"]),["y"])),e[45]||(e[45]=Dn(Hn((..._)=>n.onOpen&&n.onOpen(..._),["ctrl","prevent"]),["o"])),e[46]||(e[46]=Dn(Hn((..._)=>n.onSave&&n.onSave(..._),["ctrl","prevent"]),["s"])),e[47]||(e[47]=Dn(Hn((..._)=>n.onCut&&n.onCut(..._),["ctrl"]),["x"])),e[48]||(e[48]=Dn(Hn((..._)=>n.onCopy&&n.onCopy(..._),["ctrl"]),["c"])),e[49]||(e[49]=Dn(Hn((..._)=>n.onPaste&&n.onPaste(..._),["ctrl"]),["v"])),e[50]||(e[50]=Dn((..._)=>n.onDelete&&n.onDelete(..._),["delete"]))],onContextmenu:e[51]||(e[51]=Hn(()=>{},["prevent"])),ref:"dom"},[ue("div",Obe,[n.editorCtx?(Te(),Be(kt,{key:0},[Pe(a,{title:"File"},{default:dn(()=>[Pe(o,{title:"New",onClick:n.onNew},null,8,["onClick"]),Pe(o,{title:"Open",popup:"",hotkey:"Ctrl+O",onClick:n.onOpen},null,8,["onClick"]),Pe(o,{sep:""}),Pe(o,{title:"Save",hotkey:"Ctrl+S",onClick:n.onSave},null,8,["onClick"]),Pe(o,{title:"Save As",popup:"",hotkey:"Shirt+Ctrl+S",onClick:n.onSaveAs},null,8,["onClick"]),Pe(o,{sep:""}),Pe(o,{title:"Import",popup:"",onClick:n.onImport},null,8,["onClick"]),Pe(o,{title:"Export"},{default:dn(()=>[Pe(a,null,{default:dn(()=>[Pe(o,{title:"glTF 2.0 Binary (.glb)",popup:"",onClick:e[0]||(e[0]=_=>n.onExport("glb"))}),Pe(o,{title:"Wavefront (.obj)",popup:"",onClick:e[1]||(e[1]=_=>n.onExport("obj"))})]),_:1})]),_:1})]),_:1}),Pe(a,{title:"Edit"},{default:dn(()=>[Pe(o,{title:"Undo",hotkey:"Ctrl+Z",onClick:n.onUndo},null,8,["onClick"]),Pe(o,{title:"Redo",hotkey:"Ctrl+Y",onClick:n.onRedo},null,8,["onClick"]),Pe(o,{sep:""}),Pe(o,{title:"Cut",hotkey:"Ctrl+X",onClick:n.onCut},null,8,["onClick"]),Pe(o,{title:"Copy",hotkey:"Ctrl+C",onClick:n.onCopy},null,8,["onClick"]),Pe(o,{title:"Paste",hotkey:"Ctrl+V",onClick:n.onPaste},null,8,["onClick"]),Pe(o,{title:"Delete",hotkey:"Delete",onClick:n.onDelete},null,8,["onClick"]),Pe(o,{sep:""}),Pe(o,{title:"Moving Nodes: Keep World Position Unchanged",onClick:e[2]||(e[2]=_=>n.editorCtx.options.keepTransformUnchangedWhileMoving=!n.editorCtx.options.keepTransformUnchangedWhileMoving),checked:n.editorCtx.options.keepTransformUnchangedWhileMoving},null,8,["checked"]),Pe(o,{sep:""}),Pe(o,{title:"Selecting: Allow Clicking Negative Objects",onClick:e[3]||(e[3]=_=>n.editorCtx.options.allowSelectingInvisibleObjectByClicking=!n.editorCtx.options.allowSelectingInvisibleObjectByClicking),checked:n.editorCtx.options.allowSelectingInvisibleObjectByClicking},null,8,["checked"]),Pe(o,{sep:""}),Pe(o,{title:"Transform: Use Local Space for Controls",onClick:e[4]||(e[4]=_=>n.editorCtx.options.useLocalSpaceForTransformControl=!n.editorCtx.options.useLocalSpaceForTransformControl),checked:n.editorCtx.options.useLocalSpaceForTransformControl},null,8,["checked"]),Pe(o,{sep:""}),Pe(o,{title:"IK Binding: Allow Modification of Joint Length",onClick:e[5]||(e[5]=_=>n.editorCtx.options.allowModifyingBoneLengthWhenBindingIk=!n.editorCtx.options.allowModifyingBoneLengthWhenBindingIk),checked:n.editorCtx.options.allowModifyingBoneLengthWhenBindingIk},null,8,["checked"]),Pe(o,{title:"IK Binding: Keep Internal Object Position Unchanged",onClick:e[6]||(e[6]=_=>n.editorCtx.options.keepInternalTransformWhenBindingIk=!n.editorCtx.options.keepInternalTransformWhenBindingIk),checked:n.editorCtx.options.keepInternalTransformWhenBindingIk},null,8,["checked"]),Pe(o,{sep:""}),Pe(o,{title:"Stretching Joints: Keep Both Ends of Clay Nodes Unchanged",onClick:e[7]||(e[7]=_=>n.editorCtx.options.keepBothEndsOfClayNodesWhenStretching=!n.editorCtx.options.keepBothEndsOfClayNodesWhenStretching),checked:n.editorCtx.options.keepBothEndsOfClayNodesWhenStretching},null,8,["checked"])]),_:1}),Pe(a,{title:"View"},{default:dn(()=>[Pe(o,{title:"Window"},{default:dn(()=>[Pe(a,null,{default:dn(()=>[Pe(o,{title:"Tools",checked:n.uiOptions.showTools,onClick:e[8]||(e[8]=_=>n.uiOptions.showTools=!n.uiOptions.showTools)},null,8,["checked"]),Pe(o,{title:"Nodes Panel",checked:n.uiOptions.showModelTree,onClick:e[9]||(e[9]=_=>n.uiOptions.showModelTree=!n.uiOptions.showModelTree)},null,8,["checked"]),Pe(o,{title:"Properties Panel",checked:n.uiOptions.showProperties,onClick:e[10]||(e[10]=_=>n.uiOptions.showProperties=!n.uiOptions.showProperties)},null,8,["checked"]),Pe(o,{title:"Status Bar",checked:n.uiOptions.showStatusBar,onClick:e[11]||(e[11]=_=>n.uiOptions.showStatusBar=!n.uiOptions.showStatusBar)},null,8,["checked"])]),_:1})]),_:1}),Pe(o,{sep:""}),Pe(o,{title:"Quad Views",checked:n.editorCtx.options.quadView,disabled:n.editorCtx.options.shadingMode==="path-tracing",onClick:e[12]||(e[12]=_=>n.editorCtx.options.quadView=!n.editorCtx.options.quadView)},null,8,["checked","disabled"]),Pe(o,{title:"Outline Selected",checked:n.editorCtx.options.outlineSelected,onClick:e[13]||(e[13]=_=>n.editorCtx.options.outlineSelected=!n.editorCtx.options.outlineSelected)},null,8,["checked"]),Pe(o,{sep:""}),Pe(o,{title:"Grids",checked:n.editorCtx.options.showGrids,onClick:e[14]||(e[14]=_=>n.editorCtx.options.showGrids=!n.editorCtx.options.showGrids)},null,8,["checked"]),Pe(o,{title:"Light Indicators",checked:n.editorCtx.options.showLightHelpers,onClick:e[15]||(e[15]=_=>n.editorCtx.options.showLightHelpers=!n.editorCtx.options.showLightHelpers)},null,8,["checked"]),Pe(o,{title:"IK Joint Indicators",checked:n.editorCtx.options.showIkBones,onClick:e[16]||(e[16]=_=>n.editorCtx.options.showIkBones=!n.editorCtx.options.showIkBones)},null,8,["checked"])]),_:1}),Pe(a,{title:"Sketchfab","dynamic-size":""},{default:dn(()=>[ue("div",Fbe,[n.sketchfabClient.token.accessToken?(Te(),Be(kt,{key:0},[ue("div",Nbe,[Iu(ue("input",{type:"text",placeholder:"Sketchfab Model URL",style:{"margin-right":"4px",width:"260px"},"onUpdate:modelValue":e[17]||(e[17]=_=>n.sketchfabModelUrl=_),onKeydown:e[18]||(e[18]=Dn((..._)=>n.onSketchfabImportModel&&n.onSketchfabImportModel(..._),["enter"]))},null,544),[[FR,n.sketchfabModelUrl]]),ue("button",{class:"normal-button",style:{"font-size":"8px",padding:"2px 6px"},onClick:e[19]||(e[19]=(..._)=>n.onSketchfabImportModel&&n.onSketchfabImportModel(..._))}," Import ")]),ue("div",kbe,[zbe,ue("div",Bbe,On(n.sketchfabClient.user.displayName),1),ue("button",{class:"normal-button",onClick:e[20]||(e[20]=(..._)=>n.onSketchfabLogout&&n.onSketchfabLogout(..._)),style:{"font-size":"8px",padding:"2px 6px"}}," Logout ")])],64)):(Te(),Be("button",{key:1,class:"normal-button",onClick:e[21]||(e[21]=(..._)=>n.onSketchfabLogin&&n.onSketchfabLogin(..._))}," Sketchfab Login "))])]),_:1}),Pe(a,{title:"Camera","dynamic-size":""},{default:dn(()=>[ue("div",Ube,[ue("div",$be,[Vbe,Pe(l,{style:{width:"4em","margin-right":"8px"},min:4,max:90,value:n.editorCtx.model.cameraFov,onInput:e[22]||(e[22]=_=>n.editorCtx.model.cameraFov=_)},null,8,["value"]),Pe(c,{label:"Orthographic",value:!n.editorCtx.model.cameraPerspective,onInput:e[23]||(e[23]=_=>n.editorCtx.model.cameraPerspective=!_)},null,8,["value"])]),ue("div",Hbe,[(Te(!0),Be(kt,null,Ga(n.editorCtx.model.cameras,(_,A)=>(Te(),Be("div",Gbe,[ue("div",{class:"name normal-button",onClick:S=>n.onLoadCamera(_)},On(_.name),9,Wbe),ue("button",{class:"icon-button",onClick:S=>n.onDeleteCamera(A)},"\xD7",8,jbe)]))),256))]),ue("button",{class:"normal-button",style:{width:"100%","margin-top":"4px"},onClick:e[24]||(e[24]=(..._)=>n.onSaveCamera&&n.onSaveCamera(..._))}," Save Current ")])]),_:1}),Pe(a,{title:"About","dynamic-size":""},{default:dn(()=>[Xbe]),_:1}),ue("button",{class:"popup-menu-trigger",onClick:e[25]||(e[25]=(..._)=>n.onOpenFeedback&&n.onOpenFeedback(..._)),style:{cursor:"pointer"}}," Feedback "),ue("button",{class:"popup-menu-trigger",onClick:e[26]||(e[26]=(..._)=>n.onOpenTutorial&&n.onOpenTutorial(..._)),style:{cursor:"pointer"}}," Tutorial "),n.editorCtx.tool.sculpt?(Te(),Be(kt,{key:0},[qbe,Pe(h,{style:{"margin-right":"6px"},value:n.editorCtx.tool.brushRadius,"onUpdate:value":e[27]||(e[27]=_=>n.editorCtx.tool.brushRadius=_),label:"Radius",min:1,max:200,step:1,"fraction-digits":0},null,8,["value"]),n.editorCtx.tool.hasHardness?(Te(),cn(h,{key:0,style:{"margin-right":"6px"},value:n.editorCtx.tool.brushHardness,"onUpdate:value":e[28]||(e[28]=_=>n.editorCtx.tool.brushHardness=_),label:"Hardness",min:.01,max:1,step:.01,"fraction-digits":2},null,8,["value","min","step"])):nt("",!0),Pe(h,{style:{"margin-right":"2px"},value:n.editorCtx.tool.brushStrength,"onUpdate:value":e[29]||(e[29]=_=>n.editorCtx.tool.brushStrength=_),label:"Strength",min:.01,max:1,step:.01,"fraction-digits":2},null,8,["value","min","step"]),ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.options.enablePressure}]),title:"Enable Tablet Pressure Sensitivity",style:{"margin-right":"6px",padding:"0"},onClick:e[30]||(e[30]=_=>n.editorCtx.options.enablePressure=!n.editorCtx.options.enablePressure)},Zbe,2),ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.tool.frontFacesOnly}]),title:"Front Faces Only",style:{"margin-right":"6px",padding:"0"},onClick:e[31]||(e[31]=_=>n.editorCtx.tool.frontFacesOnly=!n.editorCtx.tool.frontFacesOnly)},Qbe,2),n.editorCtx.tool.hasDirection?(Te(),Be("div",Jbe,[ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.tool.brushDirection===1}]),style:{padding:"0"},onClick:e[32]||(e[32]=_=>n.editorCtx.tool.brushDirection=1)},txe,2),n.editorCtx.tool.hasThirdDirection?(Te(),Be("button",{key:0,class:Mn(["normal-button toggle-button",{active:n.editorCtx.tool.brushDirection===0}]),style:{padding:"0"},onClick:e[33]||(e[33]=_=>n.editorCtx.tool.brushDirection=0)},ixe,2)):nt("",!0),ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.tool.brushDirection===-1}]),style:{padding:"0"},onClick:e[34]||(e[34]=_=>n.editorCtx.tool.brushDirection=-1)},rxe,2)])):nt("",!0),n.canRemesh?(Te(),cn(a,{key:2,title:"Remesh","class-name":"normal-button dropdown"},{default:dn(()=>[ue("div",oxe,[ue("div",axe,[lxe,Pe(l,{class:"value",style:{width:"6em"},min:1e-4,max:1,value:n.editorCtx.options.remeshVoxelSize,onInput:e[35]||(e[35]=_=>n.editorCtx.options.remeshVoxelSize=_)},null,8,["min","value"]),cxe]),ue("button",{class:"normal-button",style:{width:"100%"},onClick:e[36]||(e[36]=(..._)=>n.onRemesh&&n.onRemesh(..._))}," Remesh ")])]),_:1})):nt("",!0)],64)):nt("",!0),uxe,ue("div",hxe,[ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.options.shadingMode==="solid"}]),title:"No Shadow",style:{padding:"0"},onClick:e[37]||(e[37]=_=>n.editorCtx.options.shadingMode="solid")},dxe,2),ue("button",{class:Mn(["normal-button toggle-button",{active:n.editorCtx.options.shadingMode==="rendered"}]),title:"Basic Shading",style:{padding:"0"},onClick:e[38]||(e[38]=_=>n.editorCtx.options.shadingMode="rendered")},mxe,2)])],64)):nt("",!0)]),ue("div",gxe,[n.uiOptions.showTools?(Te(),Be("div",vxe,[ue("div",yxe,[n.editorCtx?(Te(),Be("div",bxe,[(Te(!0),Be(kt,null,Ga(n.editorCtx.tools,_=>(Te(),Be(kt,null,[_.sep?(Te(),Be("hr",xxe)):nt("",!0),_.sep?nt("",!0):(Te(),Be("button",{key:1,class:Mn(["tool icon-button toggle-button",{active:n.editorCtx.tool===_}]),title:_.label,onClick:A=>n.editorCtx.tool=_},[ue("img",{src:_.icon,alt:""},null,8,wxe)],10,_xe))],64))),256))])):nt("",!0)])])):nt("",!0),n.uiOptions.showModelTree?(Te(),cn(d,{key:1,direction:"right",width:n.uiOptions.modelTreePanelWidth,"onUpdate:width":e[41]||(e[41]=_=>n.uiOptions.modelTreePanelWidth=_),style:{"border-left":"none"}},{default:dn(()=>[n.editorCtx?(Te(),Be("div",Axe,[ue("div",{class:"toolbar",onClick:e[40]||(e[40]=Hn(_=>n.onSelect([]),["self"]))},[Pe(a,{title:"Add",disabled:!n.validChildNodeDefs.length},{default:dn(()=>[(Te(!0),Be(kt,null,Ga(n.validChildNodeDefs,_=>(Te(),cn(o,{key:_.name,title:_.label,icon:_.icon,onClick:A=>n.onAddNode(_.name)},null,8,["title","icon","onClick"]))),128))]),_:1},8,["disabled"]),ue("button",{disabled:!n.canDelete,onClick:e[39]||(e[39]=(..._)=>n.onDelete&&n.onDelete(..._))}," Delete ",8,Mxe)]),Pe(f,{class:"fill",model:n.editorCtx.model,onSelect:n.onSelect,onSetValue:n.onSetValue,onMoveNode:n.onMoveNode,onFocus:n.onFocus,onCut:n.onCut,onCopy:n.onCopy,onPaste:n.onPaste,onDelete:n.onDelete,onConvertToClay:n.onConvertToClay,onApplyTransformation:n.onApplyTransformation,onCreateInstance:n.onCreateInstance,onFlip:n.onFlip,onCopyPose:n.onCopyPose,onPastePose:n.onPastePose},null,8,["model","onSelect","onSetValue","onMoveNode","onFocus","onCut","onCopy","onPaste","onDelete","onConvertToClay","onApplyTransformation","onCreateInstance","onFlip","onCopyPose","onPastePose"])])):nt("",!0)]),_:1},8,["width"])):nt("",!0),n.uiOptions.showProperties?(Te(),cn(d,{key:2,direction:"right",width:n.uiOptions.modelNodePropertiesPanelWidth,"onUpdate:width":e[42]||(e[42]=_=>n.uiOptions.modelNodePropertiesPanelWidth=_),style:{"border-left":"none"}},{default:dn(()=>[n.editorCtx?(Te(),cn(p,{key:0,"editor-context":n.editorCtx,onSetData:n.onSetNodesProperties},null,8,["editor-context","onSetData"])):nt("",!0)]),_:1},8,["width"])):nt("",!0),Pe(g,{class:"fill","editor-context":n.editorCtx,"quad-view":(x=(b=n.editorCtx)==null?void 0:b.options)==null?void 0:x.quadView,"main-view":(w=n.editorCtx)==null?void 0:w.mainViewIndex,onMounted:n.onCanvasMounted,onBeforeUnmount:n.onBeforeCanvasUnmount,onSetView:n.onSetView},null,8,["editor-context","quad-view","main-view","onMounted","onBeforeUnmount","onSetView"])]),n.uiOptions.showStatusBar&&n.editorCtx?(Te(),Be("div",Sxe,[ue("div",null,On(n.editorCtx.statusBarMessage),1),Txe,ue("div",null,"FPS: "+On(n.editorCtx.fps),1)])):nt("",!0)],544),n.editorCtx?(Te(),cn(v,{key:0,title:"Color",visible:n.editorCtx.tool.hasColor,x:n.uiOptions.colorPanelX,"onUpdate:x":e[53]||(e[53]=_=>n.uiOptions.colorPanelX=_),y:n.uiOptions.colorPanelY,"onUpdate:y":e[54]||(e[54]=_=>n.uiOptions.colorPanelY=_)},{default:dn(()=>[Pe(m,{value:n.editorCtx.options.paintColor,"onUpdate:value":e[52]||(e[52]=_=>n.editorCtx.options.paintColor=_),"color-box":""},null,8,["value"])]),_:1},8,["visible","x","y"])):nt("",!0),n.downloadProgressDialog?(Te(),cn(v,{key:1,visible:n.downloadProgressDialog,modal:"",title:"Downloading"},{default:dn(()=>[ue("div",Cxe,[ue("div",Exe,[ue("div",{class:"progress",style:ci({width:`${n.downloadProgressPercent}%`})},null,4),ue("div",Pxe,On(n.downloadProgressText)+" / "+On(n.downloadTotalText),1)]),ue("button",{class:"normal-button",onClick:e[55]||(e[55]=_=>n.downloadCancelFlag=!0)},"Cancel")])]),_:1},8,["visible"])):nt("",!0),n.fullscreenLoading?(Te(),cn(y,{key:2})):nt("",!0)],64)}u(Rxe,"_sfc_render");var Ixe=jt(Mbe,[["render",Rxe],["__scopeId","data-v-6e1f6f19"]]);const Dxe=RB({history:j5(),routes:[{path:"/:pathMatch(.*)",component:Ixe}]}),IM=NR(S5),XN=new P_;IM.config.errorHandler=function(n,e,t){XN.dispatch(n)};IM.provide("errorSignal",XN);IM.use(Dxe).mount("#app");
//# sourceMappingURL=index.28368cbe.js.map
